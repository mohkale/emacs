# -*- mode: org; coding: utf-8-unix -*-

#+TITLE: mohkale.org
#+STARTUP: content

#+PROPERTY: header-args :tangle yes :comments link :mkdirp yes :noweb yes :hlines no

# NOTE: <escape> is for gui
#       ESC      if for cli

* Configuration
** init.el
*** Startup Optimisations
    optimise emacs startup times as much as possible.

    #+BEGIN_SRC emacs-lisp :shebang ";; -*- lexical-binding: t; coding: utf-8-unix -*-"
      ;; make garbage collector less invasive
      (setq gc-cons-threshold 402653184
            gc-cons-percentage 0.6)

      ;; not needed at startup
      (setq default-file-name-handler-alist file-name-handler-alist
            file-name-handler-alist nil)

      (add-hook 'emacs-startup-hook
                (defun mohkale//post-init-handler (&rest args)
                  ;; reset optimisation changes
                  (setq gc-cons-threshold 800000
                        gc-cons-percentage 0.1
                        file-name-handler-alist default-file-name-handler-alist)

                  ;; switch focus to any error or compilation windows
                  (let* ((window-list  (window-list))
                         (window-count (length window-list))
                         (focus-list   '("*Warnings*"
                                         "*Compile-Log*"))
                         (kill-list    '()))
                    (when (> window-count 1)
                      (dolist (window (window-list))
                        (let ((buffer-name (buffer-name (window-buffer window))))
                          (cond
                           ((member buffer-name focus-list)
                            (select-window window))
                           ((member buffer-name kill-list)
                            (delete-window window)))))))

                  ;; load my custom emacs theme
                  (load-theme 'an-old-hope t)))
    #+END_SRC

*** Emacs Sanitize
    make emacs less like... emacs. use saner defaults and make emacs look nicer in general

    #+BEGIN_SRC emacs-lisp
      (setq delete-old-versions -1                                                  ; delete excess backup versions silently
            version-control t                                                       ; use version control
            vc-make-backup-files t                                                  ; make backups in vc as well
            vc-follow-symlinks t                                                    ; no confirmation when opening symlinks
            ring-bell-function 'ignore                                              ; NO ANNOYING RINGS!!!
            sentence-end-double-space nil                                           ; sentence SHOULD end with only a fullstop
            default-fill-column 150                                                 ; toggle wrapping text at given character
            delete-by-moving-to-trash t                                             ; don't rm, trash my garbage please :)
            search-whitespace-regexp nil                                            ; SPC means SPC, not any amount of spaces
            enable-local-variables t                                                ; allow safe variables, even alongside unsafe ones
            recenter-positions '(top middle bottom)

            display-line-numbers 'relative

            enable-recursive-minibuffers t
            kill-whole-line              t ; kill-line includes eol
            help-window-select           t ; always

            which-key-enable-extended-define-key t

            ; Always Use UTF8, NO CARRIAGE RETURNS
            ; this... might be overkill. see setq-default
            ;; coding-system-for-read  'utf-8-unix
            ;; coding-system-for-write 'utf-8-unix

            frame-title-format
                ;; sets the title string displayed on the frame above. Format of the command is
                ;; a printf like string. Wrap any code you want evaluated conditionally into a list
                ;; and if the first value of that list is a string, it will be evaluated. You can
                ;; include variables anywhere in the string, including sublists, but no functions.
                ;;
                ;; See the format guide here: https://www.emacswiki.org/emacs/FrameTitle
            `(,(user-login-name) "@" ,(system-name) " [%*] %m" major-mode (buffer-file-name " : %f")))

      (setq-default indent-tabs-mode nil
                    evil-want-C-u-scroll t
                    save-place t ; auto enable save-place mode
                    show-trailing-whitespace t
                    scroll-conservatively 101 ; smooth... enough scrolling going line by line
                    scroll-preserve-screen-position t
                    cursor-in-non-selected-windows nil ;; hide cursor
                    default-buffer-file-coding-system 'utf-8-unix
                    buffer-file-coding-system 'utf-8-unix
                    echo-keystrokes 0.02)

      (put 'narrow-to-region 'disabled nil)

      (set-face-attribute 'default nil
                          :family "Source Code Pro"
                          ;; height value is 1/10pt. so 100 = 10pt
                          :height (if (eq system-type 'gnu/linux) 110 100)
                          :weight 'normal
                          :width 'normal)

      (defalias 'yes-or-no-p 'y-or-n-p)
      (defalias 'regexp-string-match #'string-match)

      (defalias 'path-basename                   #'file-name-nondirectory)
      (defalias 'path-dirname                    #'file-name-directory)
      (defalias 'path-extension                  #'file-name-extension)
      (defalias 'path-without-extension          #'file-name-sans-extension)
      (defalias 'path-basename-without-extension #'file-name-base)

      (defalias 'gnu-debugger     #'gdb)
      (defalias 'gud-gnu-debugger #'gud-gdb)
      (defalias 'perl-debugger    #'perldb)
      (defalias 'java-debugger    #'jdb)

      ;;; disable annoying GUI enhancements
      (menu-bar-mode -1)     ; dropdown menu list below frame title
      (scroll-bar-mode -1)   ; scrolling bar shown on frames right side
      (tool-bar-mode -1)     ; short mini menu showed below the menu bar
      (blink-cursor-mode -1) ; cursor flashes annoyingly

      ;; to make string based hash tables easier to make
      (define-hash-table-test 'string-hash-table-test
        'string-equal 'sxhash-equal)

      ;; frankly, display buffers alist is badly documented.
      ;; there's a quick and simple article exploring how it
      ;; works [[https://www.simplify.ba/articles/2016/01/25/display-buffer-alist/][here]]
      ;;
      ;; in the meantime, the following is a breif~er~ summary
      ;;   1. the car of each entry should be a regex matching a buffer
      ;;      name or a function taking a buffer and an action argument.
      ;;   2. the second item (car (cdr list)) should be a list of or a
      ;;      single display handler function which takes a buffer and
      ;;      an alist as an argument. Each entry in the list is invoked
      ;;      until one which returns non nil is encountered.
      ;;   3. the remaining list items should be an alists providing options.

      ;; changing at startup messes up the display of the dashboard :(
      (defun mohkale//update-display-buffer-options-handler ()
        (defmacro display-buffer--defun-focus-method (func)
          `(defun ,(intern (concat (symbol-name func) "-and-focus")) (buffer alist)
             (let ((window (,func buffer alist)))
               (when window
                 (select-window window)))))

        (display-buffer--defun-focus-method display-buffer--maybe-same-window)
        (display-buffer--defun-focus-method display-buffer-reuse-window)
        (display-buffer--defun-focus-method display-buffer--maybe-pop-up-frame-or-window)
        (display-buffer--defun-focus-method display-buffer-in-previous-window)
        (display-buffer--defun-focus-method display-buffer-in-side-window)
        (display-buffer--defun-focus-method display-buffer-use-some-window)
        (display-buffer--defun-focus-method display-buffer-pop-up-frame)
        (display-buffer--defun-focus-method display-buffer-below-selected)

        (defvar display-buffer--default-fallback-action
          display-buffer-fallback-action
          "the value for fallback actions without my configuration")

        (advice-add 'display-startup-echo-area-message :around #'ignore)

        (defun display-buffer--restore-default-actions (func &rest args)
          (let ((display-buffer-fallback-action
                 display-buffer--default-fallback-action))
            (apply func args)))

        (setq display-buffer-fallback-action
              ;; by default, focus on displayed windows
              '((display-buffer--maybe-same-window-and-focus
                 display-buffer-reuse-window-and-focus
                 display-buffer--maybe-pop-up-frame-or-window-and-focus
                 display-buffer-in-previous-window-and-focus
                 display-buffer-use-some-window-and-focus
                 display-buffer-pop-up-frame-and-focus)))

        (push '("*Async Shell Command*"
                (display-buffer-reuse-window
                 display-buffer-in-side-window-and-focus)
                (side          . bottom)
                (window-height . 0.5))
              display-buffer-alist)

        (push '("*compilation*"
                (display-buffer-reuse-window
                 display-buffer-in-side-window-and-focus)
                (side          . bottom)
                (window-height . 0.5))
              display-buffer-alist)

        (push `("*image-dired-display-image*"
                ,@display-buffer--default-fallback-action)
              display-buffer-alist)

        (push `("*Anaconda*"
                ,@display-buffer--default-fallback-action)
              display-buffer-alist)

        (push `("magit-diff: "
                ,@display-buffer--default-fallback-action)
              display-buffer-alist)

        (push `("*Flycheck error messages*"
                ,@display-buffer--default-fallback-action)
              display-buffer-alist))

      (add-hook #'emacs-startup-hook #'mohkale//update-display-buffer-options-handler)
    #+END_SRC

*** Config Variables
    #+BEGIN_SRC emacs-lisp
      (defvar mohkale-should-compile-config nil
        "when truthy, building the configuration file also compiles the lisp file")

      (defvar mohkale-preferred-indent 4
        "preferred indentation for all modes")

      (setq tab-width mohkale-preferred-indent)


      (setq tab-stop-list (number-sequence mohkale-preferred-indent
                                           120
                                           mohkale-preferred-indent))


      (defun mohkale/refresh-config-file-p ()
        "true if config org file needs to be retangled and/or compiled
       see https://snipplr.com/view/14292/autocompiled-emacs-file/ for example

       NOTE assumes tangled elisp file exists... otherwise what's calling this."
        ;; checks in order:
        ;;     * compiled file doesn't exist when it should
        ;;     * config file is newer than tangled file
        ;;     * tangled file is newer than compiled file (if it should exists)
        ;;
        ;; That last check shouldn't be necessary, but better safe than sorry.
        (or (and mohkale-should-compile-config
                 (not (file-exists-p mohkale-mohkale-elc-config-file)))
            (file-newer-than-file-p mohkale-mohkale-config-file
                                    mohkale-mohkale-el-config-file)
            (and mohkale-should-compile-config
                 (file-newer-than-file-p mohkale-mohkale-el-config-file
                                         mohkale-mohkale-elc-config-file))))

      ;; (add-hook 'kill-emacs-hook (lambda () (and (mohkale/refresh-config-file-p)
      ;;                                            (mohkale/build-configuration-file))))

      (defun mohkale//display-out-of-date-configuration-warning ()
        (when (mohkale/refresh-config-file-p)
          (display-warning 'init
                           (concat "your configuration file is out of date: "
                                   mohkale-mohkale-config-file))))

      (add-hook 'emacs-startup-hook #'mohkale//display-out-of-date-configuration-warning)

      (setq mohkale-window-map (make-sparse-keymap))
    #+END_SRC

*** Paths Setup
    #+BEGIN_SRC emacs-lisp :var --mohkale-config-file=(buffer-file-name) :results silent
      (require 'bytecomp)

      (defun join-path (root path &rest args)
        "like pythons os.path.join, join a series of path strings together.
      does no validation check, every path is assumed to be relative."
        (if (not args)
            (concat root "/" path)
          (apply 'join-path (concat root "/" path) args)))

      (defmacro mohkale//initialise-dotemacs-path (path-type path)
        (let* ((path-type (symbol-name path-type))
               (path-sym (intern (concat "mohkale-dotemacs-" path-type "-path"))))
          `(progn
             (defconst ,path-sym (concat user-emacs-directory ,path))

             (defun ,(intern (concat "mohkale/join-dotemacs-" path-type "-path")) (path &rest args)
               (apply 'join-path ,path-sym path args)))))
      (put 'mohkale//initialise-dotemacs-path 'lisp-indent-function 'defun)

      ;; inspiration: https://github.com/emacscollective/no-littering/blob/master/no-littering.el
      (mohkale//initialise-dotemacs-path etc "etc")
      (mohkale//initialise-dotemacs-path bin "bin")
      (mohkale//initialise-dotemacs-path var "var")

      (defconst mohkale-config-root (mohkale/join-dotemacs-etc-path "mohkale")
        "path to the configuration directory under which my general purpose
      configuration files will reside.")

      (defconst mohkale-package-root (mohkale/join-dotemacs-bin-path "mohkale")
        "path to where any tangled executeable elisp files should reside")

      (defconst mohkale-mohkale-config-file --mohkale-config-file
        "path to my custom user config file.")

      (defconst mohkale-mohkale-el-config-file (concat (file-name-sans-extension
                                                        mohkale-mohkale-config-file)
                                                       ".el")
        "path to my custom user config file after being tangled into emacs lisp.")

      (defconst mohkale-mohkale-elc-config-file (byte-compile-dest-file mohkale-mohkale-el-config-file)
        "path to my custom user config file after being tangled into emacs lisp and then compiled.")

      ;; don't store customisations in here. They're really ugly :(
      (let ((custom-file-path (mohkale/join-dotemacs-etc-path "custom.el")))
        (setq custom-file custom-file-path)

        (if (file-exists-p custom-file-path)
            (load custom-file-path)))

      ;;; cleanup the ~/.emacs.d directory ~~litterbox~~ by resetting most of the default emacs paths.
      ;; most changes have been taken from: https://github.com/emacscollective/no-littering/blob/master/no-littering.el

      (cl-letf (((symbol-function #'etc) (symbol-function #'mohkale/join-dotemacs-etc-path))
                ((symbol-function #'bin) (symbol-function #'mohkale/join-dotemacs-bin-path))
                ((symbol-function #'var) (symbol-function #'mohkale/join-dotemacs-var-path)))
        (with-no-warnings
          (setq
           package-user-dir                                   (bin "elpa/")
           external-packages-directory                        (bin "misc")

           abbrev-file-name                                   (var "abbrev.el")
           auto-insert-directory                              (etc "auto-insert")
           auto-save-list-file-prefix                         (var "auto-save" "sessions/")
           auto-save-file-name-transforms                     `((".*" ,(var "auto-save" "sessions/") t))
           backup-directory-alist                             (list (cons "." (var "backups/")))
           bookmark-default-file                              (etc "bookmarks.el")
           desktop-dirname                                    (var "desktop/")
           desktop-path                                       (list desktop-dirname)
           diary-file                                         (var "diary")
           eshell-directory-name                              (var "eshell")
           eshell-aliases-file                                (var "eshell" "aliases")
           eshell-login-script                                (etc "eshell" "loginrc")
           eshell-rc-script                                   (etc "eshell" "eshrc")
           eww-bookmarks-directory                            (var "eww/")
           gamegrid-user-score-file-directory                 (var "gamegrid/")
           ido-save-directory-list-file                       (var "ido-save-directory-list.el")
           image-dired-db-file                                (var "image-dired" "db.el") ; tag associations
           image-dired-dir                                    (var "image-dired/")
           image-dired-gallery-dir                            (var "image-dired" "gallery/")
           image-dired-temp-image-file                        (var "image-dired" "temp-image")
           image-dired-temp-rotate-image-file                 (var "image-dired" "temp-rotate-image")
           kkc-init-file-name                                 (var "kkc-init.el")
           message-auto-save-directory                        (var "messages/")
           meghanada-server-install-dir                       (var "meghanada")
           mohkale-dashboard-banners-directory                (etc "banners/")
           newsticker-cache-filename                          (var "newsticker/cache.el")
           newsticker-dir                                     (var "newsticker/data/")
           nsm-settings-file                                  (var "nsm-settings.el")
           omnisharp-cache-directory                          (var "omnisharp/cache")
           org-clock-persist-file                             (var "org/clock-persist.el")
           org-id-locations-file                              (var "org/id-locations.el")
           org-publish-timestamp-directory                    (var "org/timestamps/")
           org-registry-file                                  (var "org/registry.el")
           recentf-save-file                                  (var "recentf.el")
           save-place-file                                    (var "save-place.el")
           savehist-file                                      (var "savehist.el")
           server-auth-dir                                    (var "server/")
           shared-game-score-directory                        (var "gamescore/")
           tramp-auto-save-directory                          (var "tramp/auto-save/")
           tramp-persistency-file-name                        (etc "private/tramp/history.el")
           url-cache-directory                                (var "url/cache/")
           url-configuration-directory                        (var "url/configuration/")

           ;;; third party
           ac-comphist-file                                   (var "ac-comphist.el")
           anaconda-mode-installation-directory               (var "anaconda/")
           bbdb-file                                          (var "bbdb/bbdb.el")
           bbdb-vcard-directory                               (var "bbdb/vcard/")
           bm-repository-file                                 (var "bm-repository.el")
           bmkp-current-bookmark-file                         (var "bmkp/current-bookmark.el")
           bmkp-last-bookmark-file                            (var "bmkp/last-bookmark.el")
           bookiez-file                                       (var "bookiez")
           company-statistics-file                            (var "company/statistics.el")
           company-tabnine-binaries-folder                    (var "company/tabnine-binaries")
           debbugs-gnu-persistency-file                       (var "debbugs.el")
           dired-recent-directories-file                      (var "dired/recent.el")
           elfeed-db-directory                                (var "elfeed/db/")
           elfeed-enclosure-default-dir                       (var "elfeed/enclosures/")
           elmo-msgdb-directory                               (var "elmo/")
           elmo-split-log-file                                (var "elmo/split-log")
           emms-directory                                     (var "emms/")
           emojify-emojis-dir                                 (var "emojify/")
           geben-temporary-file-directory                     (var "geben/")
           helm-adaptive-history-file                         (var "helm/adaptive-history.el")
           helm-backup-path                                   (var "helm/backup/")
           helm-github-stars-cache-file                       (var "helm/github-stars-cache.el")
           httpd-root                                         (var "simple-httpd/")
           indium-chrome-data-dir                             (var "indium/chrome-profile")
           indium-workspace-file                              (var "indium/workspaces.el")
           irfc-directory                                     (var "irfc/")
           junk-file-directory                                (var "junk-files")
           keyfreq-file                                       (var "keyfreq.el")
           keyfreq-file-lock                                  (var "keyfreq.lock")
           logview-cache-filename                             (var "logview-cache")
           logview-views-file                                 (etc "logview-views")
           lsp-server-root                                    (var "lsp/servers")
           lsp-session-file                                   (var "lsp/session")
           org-ditaa-jar-path                                 (var "org/bin/ditaa.jar")
           org-ditaa-eps-jar-path                             (var "org/bin/ditaaEps.jar")
           mohkale-library-of-babel-file                      (etc "babel-lib.org")
           multi-compile-history-file                         (var "multi-compile-history.el")
           pcache-directory                                   (var "pcache/")
           persp-save-dir                                     (var "perspectives/")
           prescient-save-file                                (var "prescient-save.el")
           projectile-cache-file                              (var "projectile/cache.el")
           projectile-known-projects-file                     (var "projectile/known-projects.el")
           purpose-default-layout-file                        (etc "window-purpose/default-layout.el")
           purpose-layout-dirs                                (list (etc "window-purpose/layouts/"))
           rake-cache-file                                    (var "rake.cache")
           request-storage-directory                          (var "requests")
           smex-save-file                                     (var "smex-save.el")
           tldr-directory-path                                (var "tldr/")
           transient-history-file                             (var "transient/history.el")
           transient-levels-file                              (etc "transient/levels.el")
           transient-values-file                              (etc "transient/values.el")
           treemacs-persist-file                              (var "treemacs/persist.org")
           vimish-fold-dir                                    (var "vimish-fold/")

           mohkale-snippets-dir                               (etc "snippets/")
           yas-snippet-dirs                                   '(yasnippet-snippets-dir)
           yasnippet-snippets-dir                             mohkale-snippets-dir
           )

          (let ((list (list (join-path lsp-server-root
                                       "kotlin"
                                       "bin")
                            (join-path lsp-server-root
                                       "kotlin"
                                       "debugger"
                                       "bin")
                            (join-path lsp-server-root
                                       "haskell"))))
            (setq exec-path (append exec-path list)))

          ;; ensure some configured paths exist at startup
          ;; TODO refactor this to only mkdir when needed
          (dolist (ensured-path '(desktop-dirname
                                  eww-bookmarks-directory
                                  newsticker-dir
                                  external-packages-directory
                                  (var "org/bin")
                                  (var "bbdb/")
                                  (var "company/")
                                  (var "elfeed/")
                                  (var "helm/")
                                  (var "projectile/")
                                  (var "bmkp/")
                                  (var "emojify/")
                                  (var "lsp/")
                                  yasnippet-snippets-dir))
            (mkdir (if (stringp ensured-path)
                       ensured-path
                     (eval ensured-path))
                   t))))


      (setenv "EDITOR"
              (concat "emacsclient --no-wait --suppress-output --server-file '" (expand-file-name server-auth-dir) "server'"))

      (push mohkale-package-root load-path)
      (push (mohkale/join-dotemacs-etc-path "themes") custom-theme-load-path)
    #+END_SRC

*** package-initialise
    initialise installed packages and ensure packages needed to setup configuration from scratch is installed.

    #+NAME: setup-packages-list
    - which-key
    - cl
    - bind-map
    - use-package
    - general
    - dash

    #+BEGIN_SRC emacs-lisp :var startup-requires=setup-packages-list
      ;; disable both package.el autloads
      ;; and selected packages in custom.
      (setq package-enable-at-startup  nil
            package--init-file-ensured nil)

      (package-initialize) ;; TODO find a way to remove this... without breaking everything

      (let ((package-sources `(("melpa" . "https://melpa.org/packages/")
                               ;; ("org"       . "http://orgmode.org/elpa/")
                               ;; ("marmalade" . "http://marmalade-repo.org/packages/")
                               ("gnu"       . "http://elpa.gnu.org/packages/"))))
        (dolist (source package-sources)
          (push source package-archives)))

      (let ((plist-refreshed nil))
        (dolist (package startup-requires)
          ;; iterate for all required packages
          (setq package (intern (car package)))
          (unless (package-installed-p package)
            (unless plist-refreshed
              (package-refresh-contents)
              (setq plist-refreshed t))

            (package-install package))
          (require package)))
    #+END_SRC

*** External Packages
    Install the following the packages directly, compare against the hash value when given and then begin package initialisation.

    #+NAME: non-melpa-packages
    | name                | hash            | url                                                                                       |
    |---------------------+-----------------+-------------------------------------------------------------------------------------------|
    |                     | <15>            |                                                                                           |
    | hide-comnt          | 0eca097ae073b6536863492eb4d4beeb25b712acd45e21fc0bda9f19d39e963f | https://raw.githubusercontent.com/emacsmirror/emacswiki.org/master/hide-comnt.el          |
    | imenu-tree          | c4b3ae0d8b5c3e5a50c9c4b3f96fd48e309c2fae9a8902a1d649063c7b3b611c | https://www.emacswiki.org/emacs/download/imenu-tree.el                                    |
    | help-fns+           | c2229229a699d115b91da8692f3b8099c19608728eb402edb6f7cd6e1c81912b | https://raw.githubusercontent.com/emacsmirror/emacswiki.org/master/help-fns%2B.el         |
    | vlc-rc              | 0064a388ea85f9fefec74401bbdbc74cdd2c6398a6790dee7f15bda13a758be7 | https://raw.githubusercontent.com/MoHKale/vlc-rc/master/vlc-rc.el                         |
    | lorem-ipsum         | 54cb139d6c88632aaef6364a2a6c6cadbb9a5082eb5032e69b5139dcc7074d88 | https://www.emacswiki.org/emacs/download/lorem-ipsum.el                                   |
    | profile-dotemacs    | 1d903fc16d4ab4716cf8097ddb88a5cbb3746c9e49fa3421ae147b0c383c3e7f | http://www.randomsample.de/profile-dotemacs.el                                            |
    | open-junk-file      | c0b835b329758dced4ccae6c2f3fd5af16af929437110ddde00ea55dc7d47be3 | https://raw.githubusercontent.com/emacsmirror/emacswiki.org/master/open-junk-file.el      |
    | sqlite-dump         | 8277c32f3e9dad7f760b946609c918dd51f32990137f839a000fb6ff5a049939 | https://user42.tuxfamily.org/sqlite-dump/index.html                                       |
    | company-cmake       | 4d682308eb4f6a4be92a4b7dcb2d181b5c26b4337799de0a308969d8babef0a2 | https://raw.githubusercontent.com/purcell/company-cmake/master/company-cmake.el           |
    | transpose-frame     | a40264a07b25d2c1d8d1be341d42952329d1bbfab8c23100904627fef4f4c7b8 | https://www.emacswiki.org/emacs/download/transpose-frame.el                               |
    | hs-lint             | 61bf6d3cfd43f2729d85ed407a7de5fd6b025540229bc0b57c37785d0b6d7450 | https://raw.githubusercontent.com/ndmitchell/hlint/master/data/hs-lint.el                 |
    | hlint-refactor-mode | 55d5a9e99f0384b15eacfdf2b17ae313c6ddbb0343980ed324707fcaaf2b718a | https://raw.githubusercontent.com/mpickering/hlint-refactor-mode/master/hlint-refactor.el |
    | miniedit            | c632c33c099362b084d965c51ec4b933be1278c7064096ce3b97cc830436055b | https://raw.githubusercontent.com/emacsmirror/miniedit/master/miniedit.el                 |
    | ibuffer-persp       | 6395294e2dd368866d79a81d37c27961e0f871937ccd82cff317e5ad67c52652 | https://raw.githubusercontent.com/rakshasa/ibuffer-persp/master/ibuffer-persp.el          |
    | org-link-edit       | ac84061d951ef9ef82794ba7f4416afb6da4283a182490a11ae455077321814c | https://raw.githubusercontent.com/kyleam/org-link-edit/master/org-link-edit.el            |

    #+BEGIN_SRC emacs-lisp :var package-list=non-melpa-packages
      (defun external-packages/download-external-package (url dest-path)
        (let* ((dest-buffer (get-buffer-create "*external-packages*"))
               (download-args `("curl"              ; program
                                nil                 ; input file
                                ,dest-buffer        ; output dest
                                nil                 ; redisplay?
                                ; args
                                "-L"
                                "-o" ,dest-path
                                ,url))
               exit-code)
          (with-current-buffer dest-buffer
            (insert (format "curl: %s\n"
                            (nthcdr 4 download-args)))
            (setq exit-code (apply 'call-process download-args))
            (insert "\n"))

          exit-code))

      (defun external-packages/validate-package-hash (file dest-path hash)
        (let (result)
          (if (string-equal "" hash)
              (progn
                (display-warning 'external-packages (format "package %s has no hash check given: %s"
                                                            file
                                                            url))
                (setq result t))
            (with-temp-buffer
              (insert-file-contents dest-path)
              (let ((hash-result (secure-hash 'sha256 (buffer-string))))
                (if (string-equal hash hash-result)
                    (setq result t)
                  (display-warning 'external-packages (format "package %s failed with hash: %s != %s"
                                                              file
                                                              hash
                                                              hash-result))
                  (delete-file dest-path)))))
          result))

      (let ((install-path external-packages-directory)
            failed-installs)
        (push install-path load-path)
        ;; include packages in load path

        (dolist (row package-list)
          (let* ((file (nth 0 row))
                 (hash (nth 1 row))
                 (url  (nth 2 row))
                 (dest-path (expand-file-name (join-path install-path (concat file ".el"))))
                 download-args exit-code)
            (unless (or (string-equal "" file)
                        (string-equal "" url))
              (unless (file-exists-p dest-path) ;; only download when doesn't already exist
                (unless (and (zerop (external-packages/download-external-package url dest-path))
                             (external-packages/validate-package-hash file dest-path hash))
                  (push file failed-installs))))))

        (if (endp failed-installs)
            (let ((buffer (get-buffer "*external-packages*")))
              (and buffer
                   (kill-buffer buffer))) ;; kill process buffer when nothing failed
          (display-warning :warning (format "external-package : failed to download packages: %s" failed-installs))
          ))
    #+END_SRC

** leader
   replicate some +basically all+ the built in spacemacs leader features & keys... cause why fix whats not broken.

   #+BEGIN_SRC emacs-lisp :shebang ";; -*- lexical-binding: t -*-"
     ;; this script is largely just copied from spacemacs/core/core-keybindings.el
     ;; it's not my intention to steal or claim credit for it, simply to replicate
     ;; the logic found in spacemacs on my config. To that end, I've renamed most
     ;; spacemacs variables as my own variables, simply because spacemacs isn't
     ;; defined in my config. My complete respect goes to the developers of spacemacs
     ;; who created a binding system so ergonomic and responsive that I have to have it.
     ;; :)

     ;; NOTE the methods in here aren't as long as the ones in spacemacs because I don't
     ;;      use different leader keys for `emacs' config and spacemacs config.

     (require 'general)
     (require 'bind-map)
     (require 'which-key)

     ;; use nicer indentation with general
     (put 'general-define-key 'lisp-indent-function 'defun)
     (put 'general-create-definer 'lisp-indent-function 'defun)

     ;;                  _       _     _
     ;; __   ____ _ _ __(_) __ _| |__ | | ___  ___
     ;; \ \ / / _` | '__| |/ _` | '_ \| |/ _ \/ __|
     ;;  \ V / (_| | |  | | (_| | |_) | |  __/\__ \
     ;;   \_/ \__,_|_|  |_|\__,_|_.__/|_|\___||___/
     ;;

     (defvar mohkale-leader-map (make-sparse-keymap)
       "core map for leader key bindings.")

     (defvar mohkale-leader-key "SPC"
       "key from which you can access all leader bindings.")

     (defvar mohkale-nnorm-leader-key "C-SPC"
       "key from which you can access all leader bindings in non-normal mode.")

     ;; (setq mohkale-leader-map (make-sparse-keymap)) ;; FIXME delete this

     (defvar mohkale-major-mode-leader-prefix "m"
       "prefix key in leader map for the active modes map.")

     (defvar mohkale-major-mode-leader-key ","
       "key shortcut equivalent to leader-key then major-mode-leader-prefix")

     (defvar mohkale-evil-states '(insert emacs normal visual motion operator outer inner replace iedit iedit-insert)
       "all the known emacs evil states")

     (defvar mohkale-nnorm-states '(insert emacs hybrid iedit-insert replace)
       "all the known evil states which aren't inherited from normal mode")

     (defvar mohkale-norm-states (seq-filter (lambda (x) (not (member x mohkale-nnorm-states))) mohkale-evil-states)
       "all the known evil states which do inherit from normal mode")

     (defvar mohkale-major-mode-leader-key-states '(normal visual)
       (format "evil states under which %s can be used to jump to the major modes leader map."
               mohkale-major-mode-leader-key))

     (defmacro mohkale//iterate-evil-state-leader-key-tuples (&rest body)
       "iterates over a list of evil state symbols and their corresponding leader keys.
     the body of the invoking function will have access to these values under variables of the
     name steates and leader.

     I know, I know, don't even get me started on how it's a terrible design choice to make
     a macro which changes the local states of its body. This is a mess. Once I come up with
     a nice optimsed way to do what this does... FIXME I will change it."
       (let* (;; Tuples mapping states to leader keys in all modes
              (state-based-tuples `((,mohkale-norm-states  . ,mohkale-leader-key)
                                    (,mohkale-nnorm-states . ,mohkale-nnorm-leader-key))))
         `(dolist (tuple (quote ,state-based-tuples))
            (let ((states (car tuple))
                  (leader (cdr tuple)))
              ,@body))))
     (put 'mohkale//iterate-evil-state-leader-key-tuples 'lisp-indent-function 'defun)

     (mohkale//iterate-evil-state-leader-key-tuples ;; (leader states)
       ;; create bindings to leader map in every mode
       (general-define-key
         :states states
         leader '(:keymap mohkale-leader-map :which-key "emacs-root")))

     (let ((major-leader-sequence (concat mohkale-leader-key
                                          " "
                                          mohkale-major-mode-leader-prefix)))
       (general-define-key
         ;; WARN hardcoded leader sequence... general-simulate-key can't handle variables yet
         :states mohkale-major-mode-leader-key-states
         mohkale-major-mode-leader-key (general-simulate-key "SPC m")))

     ;;                  __ _
     ;;  _ __  _ __ ___ / _(_)_  _____  ___
     ;; | '_ \| '__/ _ \ |_| \ \/ / _ \/ __|
     ;; | |_) | | |  __/  _| |>  <  __/\__ \
     ;; | .__/|_|  \___|_| |_/_/\_\___||___/
     ;; |_|
     ;;

     ;; TODO macro this up, there's too much repetition for my liking.

     (defun mohkale/declare-prefix (prefix name &optional long-name)
       "Declare a leader key prefix `prefix'.
     `prefix' a string describing a key sequence. `long-name' is
     shown in the message buffer when the prefix is expanded.

     WARN prefixes are only shown by which key if there's at least one
          binding accessible through that prefix. kind of obvious in
          retrospect I guess."
       (dolist (leader (list mohkale-leader-key
                             mohkale-nnorm-leader-key))
         (let ((full-prefix (concat leader " " prefix)))
             (which-key-add-key-based-replacements full-prefix (cons name (or long-name name))))))
     (put 'mohkale/declare-prefix 'lisp-indent-function 'defun)

     (defun mohkale/declare-prefix* (prefix name &rest remaining)
       "declares a leader key prefix `prefix'.
     `prefix' must be a keybinding which can be evaluated by `kbd'.
     `name' can be either a single string or an alist for (short . long) names.

     you can pass as many prefix name pairs as you wish to using this variant."
       (while prefix
         (dolist (leader (list mohkale-leader-key
                               mohkale-nnorm-leader-key))
           (let ((full-prefix (concat leader " " prefix)))
             (which-key-add-key-based-replacements full-prefix name)))
         (setq prefix (pop remaining) name (pop remaining))))
     (put 'mohkale/declare-prefix* 'lisp-indent-function 'defun)

     (defun mohkale/declare-prefix-for-mode (mode prefix name &optional long-name major)
       "declare a leader key prefix which is only active in the given mode
     this function accepts the same arguments as `mohkale/declare-prefix'
     alongside an addition symbol argument `mode' for which mode to work in.

     this function doesn't distinguish between major and minor modes."
       (unless (consp name)
         (if long-name
             (setq name (cons name long-name))
           (setq name (cons name name))))

       (dolist (leader (list mohkale-leader-key
                             mohkale-nnorm-leader-key))
         (let ((full-prefix (concat leader
                                    " "
                                    (if major mohkale-major-mode-leader-prefix)
                                    " "
                                    prefix)))
           (which-key-declare-prefixes-for-mode mode full-prefix name)))

       (when major
         (let ((major-mode-leader-prefix (concat mohkale-major-mode-leader-key " " prefix)))
           (which-key-declare-prefixes-for-mode mode major-mode-leader-prefix name))))
     (put 'mohkale/declare-prefix-for-mode 'lisp-indent-function 'defun)

     (defun mohkale/declare-prefix-for-mode* (mode prefix name &rest remaining)
       "declare multiple prefixes that're only active in the given mode.
     this function is a variant of `mohkale/declare-prefix*' where the prefix
     is declared using `mohkale/declare-prefix-for-mode'."
       (while prefix
         (mohkale/declare-prefix-for-mode mode prefix name)
         (setq prefix (pop remaining) name (pop remaining))))
     (put 'mohkale/declare-prefix-for-mode* 'lisp-indent-function 'defun)

     (defun mohkale/declare-prefix-for-major-mode (mode prefix name &optional long-name)
       "declare a prefix under the major-mode-leader-prefix in the leader map.
     this is simply a shortcut function for `mohkale/declare-prefix-for-mode' where every
     prefix is also prefixed with `mohkale-major-mode-leader-prefix'."
       (mohkale/declare-prefix-for-mode mode prefix name long-name t))
     (put 'mohkale/declare-prefix-for-major-mode 'lisp-indent-function 'defun)

     (defun mohkale/declare-prefix-for-major-mode* (mode prefix name &rest remaining)
       "declare multiple prefixes which're only active in the given major mode.
     this function is a variant of `mohkale/declare-prefix*' where the prefix
     is declared using `mohkale/declare-prefix-for-major-mode'"
       (while prefix
         (mohkale/declare-prefix-for-mode mode prefix name nil t)
         (setq prefix (pop remaining) name (pop remaining))))
     (put 'mohkale/declare-prefix-for-major-mode* 'lisp-indent-function 'defun)

     ;;  _                _                _     _           _ _
     ;; | | ___  __ _  __| | ___ _ __     | |__ (_)_ __   __| (_)_ __   __ _ ___
     ;; | |/ _ \/ _` |/ _` |/ _ \ '__|____| '_ \| | '_ \ / _` | | '_ \ / _` / __|
     ;; | |  __/ (_| | (_| |  __/ | |_____| |_) | | | | | (_| | | | | | (_| \__ \
     ;; |_|\___|\__,_|\__,_|\___|_|       |_.__/|_|_| |_|\__,_|_|_| |_|\__, |___/
     ;;                                                                |___/

     (defmacro mohkale//set-leader-bindings-iterator (map key def bindings)
       "iterate for all the bindings in `bindings' and set them in the `map'
     initial bindings are specified by `key' and `map'."
       ;; FIXME apply doesn't seem to work with unflattened remaining args
       ;; `(apply 'general-define-key :keymaps ,map ,key ,def ,bindings)
       `(while ,key
          ;; (define-key ,map (kbd ,key) ,def)
          (bind-key ,key ,def (symbol-value ,map))
          ;; TODO fix general implementation with which-key
          ;; (general-define-key :keymaps ,map ,key ,def)
          (setq ,key (pop ,bindings) ,def (pop ,bindings))))
     (put 'mohkale//set-leader-bindings-iterator 'lisp-indent-function 'defun)

     (defun mohkale/set-leader-keys (key def &rest bindings)
       "set bindings in the leader key map for all modes.
     supply as many key binding pairs as you wish to define."
       (mohkale//set-leader-bindings-iterator 'mohkale-leader-map key def bindings))
     (put 'mohkale/set-leader-keys 'lisp-indent-function 'defun)

     (defun mohkale//init-leader-mode-prefix-map (mode map &optional minor)
       "create a prefix map for a leader key prefix that's mode dependent.
     this function returns whether the desired map exists... it should always
     return true."
       (let ((prefix-map (intern (format "%s-prefix" map))))
         ;; needed to ensure key lookups work
         (unless (boundp mode)
           (set mode nil))

         (if (boundp prefix-map) t
           (mohkale//iterate-evil-state-leader-key-tuples ;; (states leader)
             (let ((leader (list (if minor
                                     leader
                                   (concat leader " " mohkale-major-mode-leader-prefix)))))
               ;; WARN why this needs to be in an eval block... I have no idea
               ;;      I've tried to move it out and I always encounter one error
               ;;      or another. Just leave it in for now.
               (eval
                `(bind-map ,map
                   :prefix-cmd ,prefix-map
                   ,(if minor :minor-modes :major-modes) (,mode)
                   :evil-keys ,leader
                   :evil-states ,states))))
           (boundp prefix-map))))

     (defun mohkale/set-leader-keys-for-minor-mode (mode key def &rest bindings)
       "set bindings in the leader key map for only the given minor mode.
     this function has the same body as mohkale/set-leader-keys but also accepts
     a symbol as an initial argument specifying the mode in question."
       (let* ((map (intern (format "mohkale-leader-%s-map" mode))))
         (when (mohkale//init-leader-mode-prefix-map mode map t)
           (mohkale//set-leader-bindings-iterator map key def bindings))))
     (put 'mohkale/set-leader-keys-for-minor-mode 'lisp-indent-function 'defun)

     (defun mohkale/set-leader-keys-for-major-mode (mode key def &rest bindings)
       "set bindings in the leader key map for only the given major mode.
     this function has the same body as mohkale/set-leader-keys but also accepts
     a symbol as an initial argument specifying the mode in question."
       (let* ((map (intern (format "mohkale-leader-%s-map" mode))))
         (when (mohkale//init-leader-mode-prefix-map mode map)
           (mohkale//set-leader-bindings-iterator map key def bindings))))
     (put 'mohkale/set-leader-keys-for-major-mode 'lisp-indent-function 'defun)

     (mohkale/declare-prefix mohkale-major-mode-leader-prefix "major-mode" "major mode commands")
   #+END_SRC

*** emacs-root
    #+BEGIN_SRC emacs-lisp
      (mohkale/declare-prefix*
        "SPC" "M-x"
        "TAB" "last-buffer")

      (mohkale/set-leader-keys
        "SPC" 'execute-extended-command
        "TAB" 'switch-to-last-buffer
        "<C-tab>" 'indent-back-to-normal ;; C-TAB doesn't work
        "!" 'shell-command
        "&" 'async-shell-command
        "-" 'line-width
        "." 'repeat
        "1" 'winum-select-window-1
        "2" 'winum-select-window-2
        "3" 'winum-select-window-3
        "4" 'winum-select-window-4
        "5" 'winum-select-window-5
        "6" 'winum-select-window-6
        "7" 'winum-select-window-7
        "8" 'winum-select-window-8
        "9" 'winum-select-window-9
        "0" 'winum-select-window-by-number
        "u" 'universal-argument)

      ;; (dolist (tuple `(,(cons mohkale-norm-states  mohkale-leader-key)
      ;;                  ;;,(cons mohkale-nnorm-states mohkale-nnorm-leader-key)
      ;;                  ))
      ;;   (let ((states (car tuple))
      ;;         (leader (cdr tuple)))
      ;;     (general-define-key
      ;;       :states  states
      ;;       :keymaps 'universal-argument-map
      ;;       (concat leader " u") 'universal-argument-more)))
    #+END_SRC

*** applications
    #+BEGIN_SRC emacs-lisp
      (mohkale/declare-prefix*
        "a" "applications"
        "au" "undo tree")

      (mohkale/set-leader-keys
        "a:" 'eshell
        "aC" 'calc-dispatch
        "ac" 'calendar
        "ad" 'ido-dired
        "ae" 'package-list-packages
        "af" 'list-faces-display
        "am" 'man
        "aP" 'proced
        "ap" 'list-processes
        "au" 'undo-tree-visualize
        "aX" 'customize)
    #+END_SRC

*** buffers
    #+BEGIN_SRC emacs-lisp
      (mohkale/declare-prefix*
        "b" "buffers"
        "bt" "buffer-read-only-mode")

      (mohkale/set-leader-keys
        "b RET" 'create-new-empty-buffer
        "b DEL" 'bury-buffer
        "bb" 'switch-to-buffer
        "bB" 'switch-to-buffer-other-window
        "bd" 'kill-this-buffer
        "be" 'safe-erase-buffer
        "bE" 'erase-buffer
        "bK" 'kill-this-buffer
        "bk" 'kill-this-buffer-and-window-maybe
        "bM" 'switch-to-messages-buffer
        "bm" 'buffer-menu
        "bn" 'next-buffer
        "bN" 'previous-buffer
        "bc" 'rename-buffer
        "bC" 'rename-uniquely
        "bo" 'occur
        "bs" 'switch-to-scratch-buffer
        "bt" 'read-only-mode
        "by" 'copy-whole-buffer-to-clipboard)
    #+END_SRC

*** compile/comments
    #+BEGIN_SRC emacs-lisp
      (mohkale/declare-prefix "c" "compile/comments")

      (mohkale/set-leader-keys
        ;; compile
        "c M-SPC" 'compile
        "cd" 'close-compilation-window ;; WARN not yet implemented
        "cs" 'kill-compilation
        "cr" 'recompile
        "cb" 'display-compilation-buffer

        ;; comment
        "cy" 'yank-and-comment
        "ck" 'comment-kill
        "c[" 'comment-box
        "ci" 'comment-indent

        "cc" 'toggle-comment-at-point
        "cC" 'toggle-comment-at-point-alt)
    #+END_SRC

*** diff
    #+BEGIN_SRC emacs-lisp
      (mohkale/declare-prefix
        "D" "diff" "interactive diff sessions")
    #+END_SRC

*** error
    #+BEGIN_SRC emacs-lisp
      (mohkale/declare-prefix "e" "errors")

      (mohkale/set-leader-keys
        ;; TODO make flycheck aliases
        "en" 'next-error
        "eN" 'previous-error
        "ep" 'previous-error)
    #+END_SRC

*** files
    #+BEGIN_SRC emacs-lisp
      (mohkale/declare-prefix*
        "f"  "files"
        "fC" "files/convert"
        "fe" '("emacs" . "emacs files")
        "fo" "open-externally"

        "fv" "variables")

      (mohkale/set-leader-keys
        "fc" 'copy-file
        "fD" 'delete-buffer-file
        "fF" 'find-file-at-point
        "ff" 'find-file
        "fl" 'find-file-literally
        "f|" 'find-file-at-point
        ;; "fo" 'open-file-or-directory-in-external-app ;; TODO implement
        "fR" 'rename-buffer-file
        "fy" 'show-and-copy-buffer-file-name
        "f M-r" 'revert-buffer
        "f M-f" 'find-dired
        "fq" 'find-file-literally

        "fCd" 'unix2dos
        "fCu" 'dos2unix

        "fev" 'emacs-version

        "fvd" 'add-dir-local-variable
        "fvf" 'add-file-local-variable
        "fvp" 'add-file-local-variable-prop-line)
    #+END_SRC

*** help
    #+BEGIN_SRC emacs-lisp
      (mohkale/declare-prefix*
        "h"  "help"
        "hd" "help-describe")

      (mohkale/set-leader-keys
        "hn" 'view-emacs-news

        "hdb" 'describe-bindings
        "hdc" 'describe-char
        "hdF" 'describe-face
        "hdk" 'describe-key
        "hdl" 'describe-last-keys ;; WARN not yet implemented
        "hdp" 'describe-package
        "hds" 'describe-system-info
        "hdt" 'describe-theme
        "hdv" 'describe-variable)
    #+END_SRC

*** hydras
    #+BEGIN_SRC emacs-lisp
      (mohkale/declare-prefix
        "H" "hydras" "cut off one head, two more shall take it's place")

      (mohkale/set-leader-keys
        "H TAB" 'hydra-indent/body
        "He"   'hydra-flycheck/body
        "Hc"   'hydra-org-clock/body
        "Hl"   'hydra-persp/body
        "HL"   'hydra-eyebrowse/body
        "Hx"   'hydra-text-zoom/body
        "Hv"   'hydra-vlc-rc/body
        "Hm"   'hydra-visual-move/body
        "Hh"   'hydra-winman/body)
    #+END_SRC

*** insert
    #+BEGIN_SRC emacs-lisp
      (mohkale/declare-prefix "i" "insert")

      (mohkale/set-leader-keys
        "ij" 'custom-insert-line-below
        "ik" 'custom-insert-line-above)
    #+END_SRC

*** jump
    #+BEGIN_SRC emacs-lisp
      (mohkale/declare-prefix "j" "jump")
    #+END_SRC

*** modes
    #+BEGIN_SRC emacs-lisp
      (mohkale/declare-prefix*
        "M" "modes"
        "Md" "dired")

      (mohkale/set-leader-keys
        "Mz" 'zone
        "Ml" 'emacs-lisp-mode
        "ML" 'lisp-interaction-mode
        "Mc" 'c++-mode
        "MC" 'c-mode
        "Mf" 'fundamental-mode
        "Mp" 'python-mode
        "Mr" 'enh-ruby-mode
        "Ms" 'shell-script-mode
        "Mw" 'whitespace-mode
        "Mo" 'org-mode
        "Mh" 'hexl-mode
        "M M-d" 'decipher
        "M M-r" 'toggle-rot13-mode

        "Mdd" 'toggle-editable-dired
        "Mde" 'invoke-editable-dired
        "Md <escape>" 'wdired-abort-changes
        "Mdq" 'wdired-abort-changes)
    #+END_SRC

*** narrowing & numbers
    #+BEGIN_SRC emacs-lisp
      (mohkale/declare-prefix "n" "narrrow/numbers")

      (mohkale/set-leader-keys
        "nr" 'narrow-to-region
        "np" 'narrow-to-page
        "nw" 'widen)
    #+END_SRC

*** text
    #+BEGIN_SRC emacs-lisp
      (mohkale/declare-prefix*
        "x" "text")

      (mohkale/set-leader-keys
        "xa" 'describe-text-properties
        "xf" 'list-faces
        "xc" 'capitalize-region
        "xp" 'pad-line-with-space-to-length
        "xP" 'pad-line-with-char-to-length
        "xt" 'remove-all-trailing-whitespace)
    #+END_SRC

*** toggles
    #+BEGIN_SRC emacs-lisp
      (mohkale/declare-prefix*
        "t" "toggles"
        "tn" "toggle-line-numbers")

      (mohkale/set-leader-keys
        "tl" 'toggle-truncate-lines
        "tL" 'toggle-lexical-binding
        "tw" 'toggle-word-wrap
        "t|" 'toggle-scroll-bar
        "t-" 'toggle-horizontal-scroll-bar
        "td" 'toggle-debug-on-error
        "tq" 'toggle-debug-on-quit
        "tm" 'toggle-frame-maximized
        "tn" 'display-line-numbers-mode
        "tf" 'toggle-frame-fullscreen
        "tg" 'toggle-tool-bar-mode-from-frame
        "tG" 'toggle-menu-bar-mode-from-frame
        "tu" 'toggle-uniquify-buffer-names
        "te" 'toggle-indicate-empty-lines
        "ta" 'toggle-text-mode-auto-fille
        "tR" 'read-only-mode
        "tc" 'toggle-case-fold-search
        "ti" 'toggle-input-method
        "ts" 'toggle-save-place-globally)
    #+END_SRC

*** search
    #+BEGIN_SRC emacs-lisp
      (mohkale/declare-prefix*
        "s" "search/symbol")

      (mohkale/set-leader-keys
        "sg" 'rgrep
        "sf" 'find-dired
        "sF" 'find-grep-dired)
    #+END_SRC

*** window
    #+BEGIN_SRC emacs-lisp
      (mohkale/declare-prefix "w" "windows")

      (with-eval-after-load mohkale-mohkale-el-config-file
        (mohkale/set-leader-keys
          "w" mohkale-window-map))
    #+END_SRC

** Global Bindings
   #+BEGIN_SRC emacs-lisp
     (general-define-key
       ;; ("ESC"   . nil) ;; WARN never do this... it broke everything

       ;; Control     for comamnd,
       ;; Meta        for command on region
       ;; Control-Alt for command on buffer
       "C-|"             'shell-command
       "M-|"             'shell-command-on-region
       "C-M-|"           'shell-command-on-buffer
       "C-&"             'async-shell-command
       "M-&"             'async-shell-command-on-region
       "C-M-&"           'async-shell-command-on-buffer

       ;; "C-SPC"           'nil ;; emacs like binding
       "C-@" (general-simulate-key "C-SPC") ;; C-SPC in terminal

       "M-l"             'recenter-top-bottom
       "M-h"             nil
       ;; "M-l"             'kill-sentence
       ;; "M-h"             'backward-kill-sentence
       "M-L"             'downcase-word
       "M-H"             'upcase-word
       "C-M-a"           'mark-whole-buffer
       "C-/"             'toggle-comment-at-point
       "C-S-/"           'toggle-comment-at-point-alt
       "C-M-\\"          nil ;; was indent-region
       "C-M--"           'indent-region
       "C-M-h"           'left-word
       "C-M-l"           'right-word
       "M-j"             'custom-insert-line-below
       "M-k"             'custom-insert-line-above
       "M-r"             'revert-buffer
       "C-k"             'nil
       "C-q"             'quit-window
       "C-j"             'newline-and-indent
       "C-<tab>"         'next-buffer
       "C-S-<tab>"       'previous-buffer
       "C-<iso-lefttab>" 'previous-buffer
       "RET"             'newline-and-indent
       "<C-M-return>"    'comment-indent-new-line
       "<C-backspace>"   'evil-delete-backward-word)

     (general-define-key
       :states mohkale-norm-states
       "gr"    'revert-buffer
       "gz"    'recenter-top-bottom)

     (general-define-key
       :states mohkale-nnorm-states
       ;; "S-SPC" 'insert-whitespace-after-point
       "M-DEL"   'delete-forward-char
       "<C-S-backspace>" 'kill-word)

     (general-define-key "C-w" '(:prefix-command mohkale-window-map :which-key "windows"))

     (general-define-key
       :keymaps 'mohkale-window-map
       "m"   'window-zen
       "C-m" 'window-zen)

   #+END_SRC

** Mohkale
   #+BEGIN_SRC emacs-lisp
     (use-package mohkale
       :defer t
       :commands (mohkale/eval-configuration-file
                  mohkale/build-configuration-file
                  mohkale/find-configuration-file
                  mohkale/find-tangled-config-file
                  mohkale/eval-configuration-file
                  mohkale/build-configuration-file
                  mohkale//tangle-configuration-file
                  mohkale//compile-configuration-files
                  mohkale/find-dotfile-file
                  mohkale/find-capture-notes-file
                  mohkale/find-org-university-file)
       :init
       (mohkale/declare-prefix*
         "on" "find-notes-file"
         "ou" "find-uni-file"
         "feb" "build-config"
         "fec" "find-config"
         "fer" "eval-config"
         "fet" "find-tangled-config"
         "fed" "find-dotfile")

       (mohkale/set-leader-keys
         "on" 'mohkale/find-capture-notes-file
         "ou" 'mohkale/find-org-university-file
         "feb" 'mohkale/build-configuration-file
         "fec" 'mohkale/find-configuration-file
         "fer" 'mohkale/eval-configuration-file
         "fed" 'mohkale/find-dotfile-file
         "fet" 'mohkale/find-tangled-config-file))
   #+END_SRC

*** Mohkale Functions
   #+HEADER: :shebang ";; -*- lexical-binding: t -*-"
   #+BEGIN_SRC emacs-lisp :tangle "~/.emacs.d/bin/mohkale/mohkale.el"
     (defmacro mohkale/defun-mohkale-find-package-file (file-type file-path &optional root)
       "creates a function to visit a file, ideally under the mohkale directory
     file-type is a symbol, which is substituted into the string `\"mohkale/find-%s-file\"'
     and then set as the name of this function. file-path is the path of the file the function
     will open. root is the base directory from which file path can be found. If nil, it defaults
     to `mohkale-root'. Pass a non string truthy value if `file-path' is an absolute path."
       (unless (stringp root)
         (if root
             (setq root (file-name-directory (eval file-path)))
           (setq root mohkale-config-root)))

       (unless (file-name-absolute-p (eval file-path))
         (setq file-path (concat root "/" (eval file-path))))

       `(defun ,(intern (concat "mohkale/find-" (symbol-name file-type) "-file")) ()
         (interactive)
         (if (not (file-directory-p ,root))
             (error (format "mohkale::error() : mohkale find file > directory not found: %s" ,root))
           (find-file ,file-path))))

     (mohkale/defun-mohkale-find-package-file capture-notes "org/notes.org")
     (mohkale/defun-mohkale-find-package-file org-university "org/university.org")
     ;; TODO refactor this needless repeated work
     (mohkale/defun-mohkale-find-package-file dotfile "init.el" user-emacs-directory)
     (mohkale/defun-mohkale-find-package-file configuration mohkale-mohkale-config-file t)
     (mohkale/defun-mohkale-find-package-file tangled-config mohkale-mohkale-el-config-file t)

     (defun mohkale/eval-configuration-file ()
       (interactive)
       (org-babel-load-file mohkale-mohkale-config-file))

     (defun mohkale//tangle-configuration-file ()
       (let ((file    mohkale-mohkale-config-file)
             (el-file mohkale-mohkale-el-config-file))
         (when (file-newer-than-file-p file el-file)
           (require 'org)
           (org-babel-tangle-file file el-file))))

     (defun mohkale//compile-configuration-files ()
       (require 'bytecomp)
       (byte-compile-file mohkale-mohkale-el-config-file)

       (let ((tangled-files (directory-files-recursively mohkale-dotemacs-bin-path
                                                         ".*\\.el$"))
             (packages-dir (expand-file-name package-user-dir)))
         (dolist (file tangled-files)
           (unless (string-prefix-p packages-dir file)
             (byte-compile-file file)))))

     (defun mohkale/build-configuration-file ()
       (interactive)
       (mohkale//tangle-configuration-file)

       (when mohkale-should-compile-config
         (mohkale//compile-configuration-files)))
   #+END_SRC

*** Happy Birthday
    animate-birthday-present on your birthday... yippeee :)

    #+BEGIN_SRC emacs-lisp
      ;; (time-since '(0 0 0 8 12 1999 3 nil nil))

      (when (string-equal (format-time-string "%d.%m" (current-time))
                          "08.12")
        (add-hook 'emacs-startup-hook
                  'animate-birthday-present))
    #+END_SRC

** Methods
*** File
    #+BEGIN_SRC emacs-lisp
      (use-package mohkale-file
        :defer t
        :commands (rename-buffer-file
                   delete-buffer-file
                   show-and-copy-buffer-file-name
                   write-kill-buffer
                   jump-to-directory
                   jump-to-directory-other-window)
        :init
        (mohkale/set-leader-keys
          "fj" 'jump-to-directory
          "jd" 'jump-to-directory
          "jD" 'jump-to-directory-other-window))
    #+END_SRC

    #+BEGIN_SRC emacs-lisp :tangle "~/.emacs.d/bin/mohkale/mohkale-file.el"
      (defun rename-buffer-file (buffer &optional new-name)
        "renames the file associated with the buffer `buffer'
      if the buffer isn't visiting a file, this function is
      equivalent to `rename-buffer' followed by setting the
      file visited by the buffer."
        (interactive (list (current-buffer)))

        (with-current-buffer buffer
          (or new-name (setq new-name (read-file-name "new-name: ")))
          (let ((buffer-file (buffer-file-name buffer)))
            (if (get-buffer new-name)
                (message "a buffer with that name already exists: %s" new-name)
              (when (or (not (file-exists-p new-name))
                        (yes-or-no-p "file already exists, overwrite it:"))
                ;; destination doesn't exist, so can write
                ;; or
                ;; user agrees to overwrite, so can write
                (when (and buffer-file
                           (file-exists-p buffer-file))
                  ;; only rename buffer file if it exists
                  (rename-file buffer-file new-name t)
                  (message "moved file '%s' to '%s'" buffer-file new-name))
                (rename-buffer new-name)
                (set-visited-file-name new-name)
                (set-buffer-modified-p nil))))))

      (defun delete-buffer-file ()
        (interactive)
        (let ((buffer (current-buffer))
              (filename (buffer-file-name))
              (name (buffer-name)))
          (if (not filename)
              (message "buffer %s is not visiting a file" name)
            (when (yes-or-no-p "Are you sure you want to delete this file? ")
              (when (file-exists-p filename)
                (delete-file filename t))

              (kill-buffer buffer)))))

      (defun show-and-copy-buffer-file-name (&optional prefix)
        "Displays the current buffers name in the echo area & yanks it
      when a prefix arg is given, the buffer name is also inserted into
      the buffer. When a double prefix arg is given, the filename is
      inserted but the point is not moved. With a positive numerical
      prefix greater than 0, that many parent directories will be
      navigated to before yanking."
        (interactive "P")
        (let ((bufname (or (buffer-file-name)
                           (and (derived-mode-p 'dired-mode)
                                (string-trim-right (dired-current-directory) "/"))
                           "")))
          (cond
           ((consp prefix)
            (if (eq (car prefix) 4)
                (insert bufname)
              (save-excursion
                (insert bufname))))
           (prefix
            (while (and (> prefix 0)
                        bufname)
              (setq bufname (string-trim-right (file-name-directory bufname) "/")
                    prefix  (- prefix 1)))

            (or bufname (setq bufname ""))))

          (message bufname)
          (kill-new bufname)))

      (defalias 'jump-to-directory 'dired-jump)
      (defalias 'jump-to-directory-other-window 'dired-jump-other-window)

      (defun write-kill-buffer (&optional buffer-or-name confirm)
        "write buffer to file and then kill it"
        (interactive)
        (let ((buffer (get-buffer (or buffer-or-name (current-buffer)))))
          (when (buffer-modified-p)
            (write-file (or (buffer-file-name) (read-file-name "write file: "))
                        confirm))

          (when (or (not confirm)
                    (y-or-no-p (format "are you sure you want to kill this buffer (%s): " buffer)))
            (let ((window (get-buffer-window buffer)))
              (kill-buffer buffer)
              (when (and window (> (length (window-list)) 1))
                (delete-window window))))))
    #+END_SRC

*** Hooks/Handlers
    #+BEGIN_SRC emacs-lisp
      (defun no-junk-please-were-unixish ()
        "auto convert found files to use unix EOL formats"
        (let ((coding-str (symbol-name buffer-file-coding-system)))
          (when (string-match "-\\(?:dos\\|mac\\)$" coding-str)
            (set-buffer-file-coding-system 'unix))))

      (add-hook 'find-file-hook 'no-junk-please-were-unixish)

      (defun mohkale//enable-line-numbers-handler ()
        "forces the display of line numbers in the current buffer"
        (interactive)
        (display-line-numbers-mode 1)
        (setq display-line-numbers 'relative))

      (add-hook 'prog-mode-hook        #'mohkale//enable-line-numbers-handler)
      (add-hook 'fundamental-mode-hook #'mohkale//enable-line-numbers-handler)

      (setq command-error-function
            (defun mohkale/command-error-function (data context caller)
              "hide some error message"
              (when (not (memq (car data) '(;; buffer-read-only
                                            beginning-of-buffer
                                            end-of-buffer)))
                (command-error-default-function data context caller))))

      (defun inhibit-messages-wrapper (func &rest args)
        (let ((inhibit-message t))
          (apply func args)))

      ;;; switch to buffer hook
      (defvar switch-to-buffer-hook nil
        "hook run when you switch to a buffer.")

      (advice-add 'switch-to-buffer
                  :after (defun switch-to-buffer--execute-hook (&rest args)
                           (apply 'run-hook-with-args 'switch-to-buffer-hook args)))

      ;;; theme loading hook
      (defvar after-load-theme-hook nil
        "hook which is executed after loading a theme")

      (advice-add 'load-theme
                  :after (defun load-theme--execute-hooks (&rest args)
                           (run-hooks 'after-load-theme-hook)))

      ;;; whitespace exemption
      (defvar mohkale--whitespace-exempt-modes '(help-mode
                                                 Buffer-menu-mode
                                                 eshell-mode
                                                 term-mode
                                                 minibuffer-inactive-mode
                                                 eshell-mode)
        "modes under which no trailing whitespace is shown")

      (defvar mohkale--whitespace-exempt-buffers '("\\*Ibuffer confirmation\\*")
        "regular expressions matching buffer names under which no trailing
      whitespace is shown.")

      (defun chain-match-regexp (string &rest regexps)
        "checks for string-match against STRING using regexps
      returns true if any of the regexps match the string."
        (let (match-found regexp)
          (while (and (not match-found)
                      (setq regexp (car regexps)))
            (setq match-found (string-match-p regexp string)
                  regexps (cdr regexps)))
          (not (not match-found))))

      (defun mohkale//hide-trailing-whitespace--mode-based (&rest args)
        (when (and mohkale--whitespace-exempt-modes
                   (apply 'derived-mode-p
                          mohkale--whitespace-exempt-modes))
          (setq show-trailing-whitespace nil)
          t))

      (defun mohkale//hide-trailing-whitespace--name-based (&rest args)
        (when (and mohkale--whitespace-exempt-buffers
                   (apply 'chain-match-regexp
                          (buffer-name)
                          mohkale--whitespace-exempt-buffers))
          (setq show-trailing-whitespace nil)
          t))

      (defun mohkale//hide-trailing-whitespace (&rest args)
        (or (mohkale//hide-trailing-whitespace--mode-based)
            (mohkale//hide-trailing-whitespace--name-based)))

      ;; add switch-to-buffer hook because some functions, such as ibuffers confirmation
      ;; popup use switch-to-buffer instead of display buffer and there's no easy way
      ;; to modify it.
      (add-hook 'switch-to-buffer-hook        #'mohkale//hide-trailing-whitespace--name-based)
      (add-hook 'after-change-major-mode-hook #'mohkale//hide-trailing-whitespace--mode-based)
    #+END_SRC

*** Yank Indent Adjust
    adjust indentation of yanked text in some modes... because doing so manually is a pain :tongue_out:

    #+BEGIN_SRC emacs-lisp
      ;; initially sourced from: https://github.com/magnars/.emacs.d/blob/master/defuns/editing-defuns.el#L99-L124

      (require 'dash)

      (defvar yank-indent-modes '(prog-mode
                                  sgml-mode
                                  js2-mode)
        "Modes in which to indent regions that are yanked (or yank-popped)
      set to nil, if you want to indent yanked text everywhere.")

      (defvar yank-advised-indent-threshold 1000
        "Threshold (# chars) over which indentation does not automatically occur.")

      (defun yank-advised-indent-function (beg end)
        "Do indentation, as long as the region isn't too large."
        (if (<= (- end beg) yank-advised-indent-threshold)
            (indent-region beg end nil)))

      (defmacro with--auto-indent-satisfied (prefix-var &rest body)
        `(when (and (not ,prefix-var)
                    (--any? (derived-mode-p it) yank-indent-modes))
           ,@body))
      (put 'with--auto-indent-satisfied 'lisp-indent-function 'defun)

      (defun yank--auto-indent (arg)
        "if mode is in `yank-indent-modes' indent yanked text
      doesn't do anything if a prefix arg is given."
        (with--auto-indent-satisfied arg
          (let ((transient-mark-mode nil))
            (yank-advised-indent-function
             (region-beginning) (region-end)))))

      (advice-add 'yank     :after #'yank--auto-indent)
      (advice-add 'yank-pop :after #'yank--auto-indent)

      (defun evil-visual-paste--auto-indent (count register &optional yank-handler)
        ;; not sure what yank handler is for, leave it in, to avoid errors
        "same as `yank--auto-indent', but for evil visual yank replace."
        (with--auto-indent-satisfied register
          (let ((transient-mark-mode nil))
            (yank-advised-indent-function
             (region-beginning) (region-end)))))

      (advice-add 'evil-visual-paste :after #'evil-visual-paste--auto-indent)
      (advice-add 'evil-paste-after  :after #'evil-visual-paste--auto-indent)
      (advice-add 'evil-paste-before :after #'evil-visual-paste--auto-indent)

      (defun yank-unindented ()
        (interactive)
        (yank 1))
    #+END_SRC

*** Misc
    #+BEGIN_SRC emacs-lisp
      (defun toggle-lexical-binding (&optional prefix)
        (interactive "P")
        (if (not prefix)
            (setq lexical-binding (not lexical-binding))
          (cond
           ((or (listp prefix) (> prefix 0))
            (setq lexical-binding t))
           (t
            (setq lexical-binding nil))))

        (message "lexical binding: %s" (if lexical-binding
                                           (propertize "enabled" 'face 'compilation-info)
                                         (propertize "disabled" 'face 'compilation-error))))

      (defun show-prefix (&optional prefix)
        (interactive "P")
        (message "prefix is: %s" prefix))
    #+END_SRC

*** Text
    #+BEGIN_SRC emacs-lisp
      (use-package mohkale-text-query
        :defer t
        :commands (line-width
                   column-number
                   point-to-coordinates
                   line-empty-p
                   list-faces))

      (use-package mohkale-text
        :defer t
        :commands (dos2unix
                   unix2dos
                   pad-line-with-char-to-length
                   insert-whitespace-after-point
                   pad-line-with-space-to-length
                   remove-all-trailing-whitespace
                   toggle-comment-at-point
                   tab-to-tab-stop-with-prefix
                   back-to-tab-stop
                   toggle-comment-at-point-alt
                   custom-insert-line
                   custom-insert-line-below
                   custom-insert-line-above
                   evil-join-backwards))
    #+END_SRC

**** Querying
     functions for querying information about the text at point or retrieve other relevent information.

     #+HEADER: :shebang ";; -*- lexical-binding: t -*-"
     #+BEGIN_SRC emacs-lisp :tangle "~/.emacs.d/bin/mohkale/mohkale-text-query.el"
       (defun line-width (char-pos)
         "returns the number of columns on the line at char-pos"
         (interactive (if current-prefix-arg
                          (list current-prefix-arg)
                        (list (point))))
         (save-excursion
           (if (not (eql char-pos (point)))
             (goto-char char-pos))
           (let ((line-width (max (- (line-end-position) (line-beginning-position) 1) 0)))
             (if (called-interactively-p 'any)
                 (message (format "Line Width: %03d" line-width)))

             line-width)))

       (defun column-number (point)
         "returns the column number at point"
         (interactive "")
         (save-excursion
           (goto-char point)
           (current-column)))

       (defun point-to-coordinates (&optional point)
         "convert a point to an XY coordinate alist"
         (or point (setq point (point)))
         `(,(line-number-at-pos point) . ,(column-number point)))

       (defun line-empty-p (&optional point)
         (save-excursion
           (and point (goto-char point))
           (beginning-of-line)
           (looking-at "[[:space:]]*$")))

       (defun list-faces (&optional point)
         (interactive "d")
         (or point (setq point (point)))
         (let ((faces (remq nil
                            `(,(get-char-property point 'read-face-name)
                              ,(get-char-property point 'face)
                              ,(plist-get (text-properties-at point) 'face)))))
           (and (called-interactively-p 'any) (message (format "%s" faces)))
           faces))
     #+END_SRC

**** Formatting
***** Chunks
      manipulate chunks of text, such as leading indentation or sequential padding.

      #+HEADER: :shebang ";; -*- lexical-binding: t -*-"
      #+BEGIN_SRC emacs-lisp :tangle "~/.emacs.d/bin/mohkale/mohkale-text.el"
        (defun dos2unix ()
          "Not exactly but it's easier to remember"
          (interactive)
          (set-buffer-file-coding-system 'unix 't))

        (defun unix2dos ()
          (interactive)
          (set-buffer-file-coding-system 'dos 't))

        (defun pad-line-with-char-to-length (desired-length char)
          "appends char as many times as required from cursor position"
          (interactive "Nline length: \nccharacter: \nd")
          (barf-if-buffer-read-only) ; can't pad read only buffer

          (save-excursion
            (let* ((line-char-count (line-width (point))))
              (if (>= line-char-count desired-length)
                  (error (format "line of length %03d is already larger than desired: %03d" line-char-count desired-length))
                (insert (make-string (- desired-length line-char-count) char))))))

        (defun pad-line-with-space-to-length (desired-length)
          "invokes pad-line-with-char-to-length with char as space"
          (interactive "Nline length: \n")
          (pad-line-with-char-to-length desired-length ?\s))

        ;; (defun remove-indentation-spaces ()
        ;;   "remove TAB-WIDTH spaces from the beginning of this line"
        ;;   (interactive)
        ;;   (if (save-excursion (re-search-backward "[^ \t]" (line-beginning-position) t))
        ;;       (delete-backward-char 1)
        ;;     (indent-rigidly (line-beginning-position) (line-end-position) (- tab-width))))

        (defun remove-all-trailing-whitespace (start end)
          "removes all trailing whitespace from every line in buffer"
          (interactive (if (region-active-p)
                           (list (region-beginning) (region-end))
                         (list (point-min) (point-max))))

          (barf-if-buffer-read-only) ; can't remove from current buffer

          (save-excursion
            (goto-char end) ; start from end so delete can work forward

            (while (and (> (point) start)
                        (re-search-backward " +$" nil t))
              (delete-region (point) (line-end-position)))))

        (defun indent-back-to-normal (&optional column)
          "indents the current line using indent region.
        this'll either reset indentation to it's normal position, or
        bring you to the beginning of an empty line. Specify a column
        value to force that column to be used by indent region."
          (interactive "P")

          (let ((inhibit-message t))
            (indent-region (line-beginning-position) (1+ (line-end-position)) column)))

        (defun insert-whitespace-after-point (&optional count)
          "inserts whitespace from point upto COUNT times
        without moving point."
          (interactive "P")
          (or  count         (setq count 1))
          (and (listp count) (setq count (car count)))

          (save-excursion
            (insert (make-string count ? ))))

        ;; https://emacs.stackexchange.com/questions/32816/backwards-tab-to-tab-stop
        (defun tab-to-tab-stop-with-prefix (&optional prev)
          "Like `tab-to-tab-stop', but toggle direction with prefix."
          (interactive "P")
          (let ((nexttab (indent-next-tab-stop (current-column) prev)))
            (delete-horizontal-space t)
            (indent-to nexttab)))

        (defun back-to-tab-stop ()
          (interactive)
          (let ((current-prefix-arg 1))
            (call-interactively #'tab-to-tab-stop-with-prefix)))
      #+END_SRC

***** Commenting
      comment regions of text or by default, the current line.

      #+BEGIN_SRC emacs-lisp :tangle "~/.emacs.d/bin/mohkale/mohkale-text.el"
        (defun toggle-comment-at-point (start end)
          "toggle comment on line or region
        pass a prefix argument to bulk toggle across multiple lines.
        This function will always comment the line your point is on,

        prefix behaviour:
        | prefix range | behaviour                                        |
        |--------------+--------------------------------------------------|
        | 0            | current line only                                |
        | >1           | current line and upto prefix-1 lines after point |
        | <1           | current line and upto prefix lines before point  |

        the behaviour is mapped to exactly replicate the vim dd command."
          (interactive (let ((prefix current-prefix-arg))
                         (if (region-active-p)
                             ;; always use region when region available
                             (list (region-beginning) (region-end))
                           (if (or (not prefix)
                                   (listp prefix) ;; regular prefix
                                   (zerop prefix))
                               ;; no prefix, comment current line only
                               (list (line-beginning-position) (line-end-position))
                             ;; prefix given, use it to determine comment region
                             (let* ((prefix-positive (> prefix 0))
                                    (current-pos (if prefix-positive
                                                     (line-beginning-position)
                                                   (line-end-position))))
                               (save-excursion
                                 (if prefix-positive
                                     (progn
                                       (evil-next-line (- prefix 1))
                                       (list current-pos (line-end-position)))
                                   (evil-next-line prefix)
                                   (list (line-beginning-position) current-pos))))))))
          (comment-or-uncomment-region start end))

        (defun toggle-comment-at-point-alt ()
          "variant of toggle-comment-at-point which conforms to relative line numbers

        prefix behaviour:
        | prefix range | behaviour                                         |
        |--------------+---------------------------------------------------|
        | 0            | current line only                                 |
        | >1           | current line and upto prefix-1 lines after point  |
        | <1           | current line and upto prefix+1 lines before point |
        "
          (interactive)
          (let ((current-prefix-arg (and current-prefix-arg
                                         (cond
                                          ((>= current-prefix-arg 1) (1+ current-prefix-arg))
                                          ;; ((<  current-prefix-arg 0) (1- current-prefix-arg))
                                          (t current-prefix-arg)))))
            (call-interactively 'toggle-comment-at-point)))

        (defun yank-and-comment (&optional prefix)
          (interactive "P")
          (when (> (length kill-ring)
                   0)
            (save-excursion
              (let ((beginning (point)))
                (call-interactively 'yank)
                (comment-region beginning (point))))
            (evil-forward-word))) ;; move to beginning of comment
      #+END_SRC

***** Line Insertion
      line insertion and joining functions.

      #+BEGIN_SRC emacs-lisp :tangle "~/.emacs.d/bin/mohkale/mohkale-text.el"
        (defun custom-insert-line (&optional prefix)
          "inserts a line above or below point

        if a prefix argument of 0 or more (or none) is given, the
        line is inserted below the point. Otherwise its inserted
        above the point.

        The absolute value of the prefix determines how many lines
        are inserted.

        Eg: A prefix of:
          ,* nil - inserts a single line below the cursor
          ,* -1  - inserts a single line above the cursor
          ,* 0   - inserts a single line below the cursor
          ,* 1   - inserts a single line below the cursor
          ,* -10 - inserts 10 lines above the cursor
          ,* 10  - inserts 10 lines below the cursor"
          (interactive "P")

          (save-excursion
            (let ((move-arg (if (or (not prefix)
                                    (>= prefix 0))
                                nil ; if prefix xor prefix >= 0
                              0)))
              (move-end-of-line move-arg)
              (open-line (max 1 (abs prefix))))))

        (defun custom-insert-line-below (&optional prefix)
          (interactive "P")
          (custom-insert-line (abs (or prefix 1))))

        (defun custom-insert-line-above (&optional prefix)
          (interactive "P")
          (custom-insert-line (- (abs (or prefix 1)))))

        (defun evil-join-backwards (&optional prefix)
          "same as join line, except joins line immeadiately before point"
          (interactive "p")
          (let ((start nil)
                (end   nil))
            (if (evil-visual-state-p)
                (let ((range (evil-visual-range)))
                  (setq start (nth 0 range))
                  (setq end   (nth 1 range)))
              ;; not visual, calculate ranges
              (setq end (point))
                (save-excursion
                  (forward-line (- (abs prefix)))
                  (setq start (point))))
            ;; remove excursion block if you wan't to
            ;; reallign point to start of line on join
            (save-excursion
              (if (line-empty-p start)
                  ;; when joining onto an empty line
                  ;; maintain leading whitespace
                  (evil-join-whitespace start end)
                ;; otherwise trim to single space
                (evil-join start end)))))
      #+END_SRC

*** Buffers, Windows & Frames
    #+BEGIN_SRC emacs-lisp
      (use-package mohkale-bufwin
        :defer t
        :commands (switch-to-scratch-buffer
                   kill-this-buffer-and-window-maybe
                   switch-to-last-buffer
                   kill-all-windows-and-return-to-home
                   halt-and-catch-fire
                   switch-to-messages-buffer
                   force-set-all-visible-windows-dedication
                   window-zen
                   display-last-buffer
                   vertical-display-last-buffer
                   shell-command-on-buffer
                   async-shell-command-on-buffer
                   safe-erase-buffer
                   create-new-empty-buffer
                   copy-whole-buffer-to-clipboard
                   split-window-right-and-focus
                   split-window-below-and-focus)
        :bind (:map mohkale-window-map
               ("T" . force-set-all-visible-windows-dedication)
               ("o"   . display-last-buffer)
               ("C-o" . display-last-buffer)
               ("O"   . vertical-display-last-buffer)
               ("M-o" . vertical-display-last-buffer)))
    #+END_SRC

    #+HEADER: :shebang ";; -*- lexical-binding: t -*-"
    #+BEGIN_SRC emacs-lisp :tangle "~/.emacs.d/bin/mohkale/mohkale-bufwin.el"
      (defvar scratch-buffer-name "*scratch*"
        "name of users scratch buffer")

      (defun create-new-empty-buffer (&optional buffer-name)
        "creates and returns a new empty scratch like buffer
      with prefix it prompts you for the name of the buffer.
      if called interactively, the new buffer is switched to."
        (interactive "P")
        (let* ((def-buf-name scratch-buffer-name)
               (buffer-name
                (cond
                 ((stringp buffer-name) buffer-name)
                 (buffer-name (read-buffer "buffer name: " def-buf-name))
                 (t                     def-buf-name)))
               (buffer-name (generate-new-buffer-name buffer-name))
               (buffer (get-buffer-create buffer-name)))
          (with-current-buffer buffer
            (funcall-interactively initial-major-mode))
          (when (called-interactively-p)
            (switch-to-buffer buffer))
          buffer))

      (defun switch-to-scratch-buffer (&optional prefix)
        "switch to the scratch buffer
      with prefix, prompts for which buffer names like the scratch
      buffer to switch to. If none exists, a new scratch buffer will
      be made. If only one exists, it will be switched to and if more
      than one exists then prompts for it."
        (interactive "P")
        (if (not prefix)
            ;; switch to original scratch buffer
            (let ((buffer (get-buffer scratch-buffer-name)))
              (if buffer
                  (switch-to-buffer buffer)
                (call-interactively 'create-new-empty-buffer)))
          (let* ((buffer-list (seq-filter #'(lambda (x)
                                              (string-match
                                               (regexp-quote scratch-buffer-name)
                                               (buffer-name x) 0))
                                          (sort (buffer-list) (lambda (x y) (string<
                                                                        (buffer-name x)
                                                                        (buffer-name y))))))
                 (buffer-names (mapcar #'buffer-name buffer-list))
                 buffer)
            (cond
             ((zerop (length buffer-list))
              (setq buffer (create-new-empty-buffer)))
             ((eq 1 (length buffer-list))
              (setq buffer (car buffer-list)))
             (t
              (require 'counsel)
              (setq buffer (ivy-read "Switch to buffer: " buffer-names
                                     :require-match t
                                     :keymap ivy-switch-buffer-map
                                     :matcher #'ivy--switch-buffer-matcher
                                     :caller 'switch-to-scratch-buffer
                                     :unwind #'counsel--switch-buffer-unwind
                                     :update-fn 'counsel--switch-buffer-update-fn))))
            (when (called-interactively-p)
              (switch-to-buffer buffer))
            buffer)))

      (defun switch-to-messages-buffer ()
        "switches to messages buffer"
        (interactive)
        (switch-to-buffer (messages-buffer)))

      (defun switch-to-last-buffer ()
        (interactive)
        (switch-to-buffer nil))

      (defun kill-this-buffer-and-window-maybe ()
        "kills the currently open buffer and the window if another is open"
        (interactive)
        (let ((window-count (length (window-list))))
          (if (> window-count 1)
              (kill-buffer-and-window)
            (kill-this-buffer))))

      (defun kill-all-windows-and-return-to-home ()
        "kills every other window and returns to spacemacs home"
        (interactive)
        (dolist (window (cdr (window-list)))
          ;; window-list starts with current window
          (delete-window window))
        (goto-home-buffer))

      (defalias 'halt-and-catch-fire #'kill-all-windows-and-return-to-home)

      (defun force-set-all-visible-windows-dedication (&optional dedicate)
        "allows you to set the dedication of all visible windows
      dedicate if truthy, will result in all windows recieving a dedication.
      if falsy, all windows will have their dedication removed"
        (interactive "P")
        ;; TODO require persp-mode here
        (and dedicate (setq dedicate t))      ; rationalise value as bool
        (or  dedicate (setq dedicate nil))    ; rationalise value as nil

        (dolist (window (window-list))
          (if (not (eq dedicate (window-dedicated-p window)))
              (with-selected-window window
                (set-window-dedicated-p window dedicate)))))

      (defun window-zen ()
        "Maximize buffer"
        ;; from https://gist.github.com/3402786
        (interactive)
        (if (and (= 1 (length (window-list)))
                 (assoc ?_ register-alist))
            (jump-to-register ?_)
          (window-configuration-to-register ?_)
          (delete-other-windows)))

      (defun shell-command-on-buffer (&optional prefix)
        "Asks for a command and executes it in inferior shell with current buffer
      as input. if prefix is given, output of command is inserted in current buffer
      at point. Again... how is this not a built in command :(."
        (interactive "P")
        (let ((command (read-shell-command "Shell command on buffer: "))
              (input-buffer (current-buffer)) output-buffer process-output)
          (with-temp-buffer ;; needed for process output
            (setq output-buffer (current-buffer))

            (with-current-buffer input-buffer
              (shell-command-on-region (point-min) (point-max) command output-buffer nil output-buffer))

            (setq process-output (buffer-string)))

          (if prefix
              (insert process-output)
            (message process-output))))

      (defun async-shell-command-on-region (&optional start end prefix)
        "same as `async-shell-command', but also sends the current region
      as stdin to the asynchronous process... why this isn't a built in
      command escapes me."
        (interactive "r\nP")
        (require 'subr-x) ;; needed for string-empty-p

        (unless (eq start end) ;; region is not active
          (let ((command (read-shell-command "Async shell command on buffer: ")))
            (unless (string-empty-p command)
              (async-shell-command command) ;; XXX WHY??? don't you return the process :P
              (let ((program-buffer (get-buffer "*Async Shell Command*")))

                (process-send-region (get-buffer-process program-buffer) start end)

                (with-current-buffer program-buffer
                  (comint-send-eof)
                  (evil-normal-state)

                  (unless (get-buffer-process program-buffer)
                    (funcall-interactively 'initial-major-mode)))

                (display-buffer program-buffer))))))

      (defun async-shell-command-on-buffer (&optional prefix)
        "same as `async-shell-command-on-region' but sends buffer as region"
        (interactive "P")
        (async-shell-command-on-region (point-min) (point-max) prefix))

      (defun safe-erase-buffer (&optional prefix)
        "prompts to really erase and then erases the current buffer"
        (interactive "P")
        (barf-if-buffer-read-only)
        (when (or prefix
                  (y-or-n-p (concat "Erase content of buffer "
                                    (buffer-name)
                                    " ?")))
            (erase-buffer)))

      (defun split-window-right-and-focus ()
        (interactive)
        (split-window-horizontally)
        (other-window 1))

      (defun split-window-below-and-focus ()
        (interactive)
        (split-window-vertically)
        (other-window 1))

      (defun copy-whole-buffer-to-clipboard (buffer)
        (interactive (list (current-buffer)))
        (with-current-buffer buffer
          (copy-region-as-kill (point-min) (point-max))))

      (defun display-last-buffer ()
        (interactive)
        (display-buffer
         (last-buffer)
         '((display-buffer-below-selected-and-focus
            display-buffer-in-previous-window-and-focus
            display-buffer-use-some-window-and-focus
            display-buffer-pop-up-frame-and-focus))))

      (defun vertical-display-last-buffer ()
        (interactive)
        (display-buffer
         (last-buffer)
         (cons '(display-buffer-in-side-window-and-focus
                 display-buffer-in-previous-window-and-focus
                 display-buffer-use-some-window-and-focus
                 display-buffer-pop-up-frame-and-focus)
               '((side . right)
                 (window-width . 0.5)))))
    #+END_SRC

*** Hydras
    #+BEGIN_SRC emacs-lisp
      (dolist (hydra '(hydra-eyebrowse
                       hydra-flycheck
                       hydra-ibuffer
                       hydra-indent
                       hydra-ein
                       hydra-ivy-custom
                       hydra-org-navigate
                       hydra-org-link
                       hydra-org-agenda
                       hydra-visual-move
                       hydra-org-clock
                       hydra-persp
                       hydra-text-zoom
                       hydra-vlc-rc
                       hydra-winman))
        (let ((hydra-func (intern (concat (symbol-name hydra) "/body")))
              (hydra-file (join-path mohkale-package-root "hydras"
                                     (concat (symbol-name hydra) ".el"))))
          (autoload hydra-func hydra-file nil t)))

      (general-define-key
        :keymaps 'mohkale-window-map
        "." 'hydra-winman/body
        "w" 'hydra-winman/body
        "C-w" 'hydra-winman/body)

      (mohkale/declare-prefix*
        "x." "hydra-text-zoom"
        "l"  "layouts")

      (mohkale/set-leader-keys
        "x." 'hydra-text-zoom/body
        "l"  'hydra-persp/body)

      (general-define-key
        "C-x TAB" 'hydra-indent/body)
    #+END_SRC

**** text-zoom
     #+HEADER: :shebang ";; -*- lexical-binding: t -*-"
     #+BEGIN_SRC emacs-lisp :tangle "~/.emacs.d/bin/mohkale/hydras/hydra-text-zoom.el"

       ;;  _            _
       ;; | |_ _____  _| |_     _______   ___  _ __ ___
       ;; | __/ _ \ \/ / __|___|_  / _ \ / _ \| '_ ` _ \
       ;; | ||  __/>  <| ||_____/ / (_) | (_) | | | | | |
       ;;  \__\___/_/\_\\__|   /___\___/ \___/|_| |_| |_|
       ;;

       (defhydra hydra-text-zoom ()
         ("+" text-scale-increase "increase")
         ("-" text-scale-decrease "decrease")
         ("0" (text-scale-increase 0) "reset")
         ("a" text-scale-increase)
         ("x" text-scale-decrease)
         ("z" (text-scale-increase 0))
         ("q" nil nil :exit t)
         ("<escape>" nil nil :exit t))

     #+END_SRC

**** window-management
     #+HEADER: :shebang ";; -*- lexical-binding: t -*-"
     #+BEGIN_SRC emacs-lisp :tangle "~/.emacs.d/bin/mohkale/hydras/hydra-winman.el"

       ;;           _           _
       ;; __      _(_)_ __   __| | _____      __     _ __ ___   __ _ _ __   __ _  __ _  ___ _ __
       ;; \ \ /\ / / | '_ \ / _` |/ _ \ \ /\ / /____| '_ ` _ \ / _` | '_ \ / _` |/ _` |/ _ \ '__|
       ;;  \ V  V /| | | | | (_| | (_) \ V  V /_____| | | | | | (_| | | | | (_| | (_| |  __/ |
       ;;   \_/\_/ |_|_| |_|\__,_|\___/ \_/\_/      |_| |_| |_|\__,_|_| |_|\__,_|\__, |\___|_|
       ;;                                                                        |___/

       (defhydra hydra-winman (:exit nil :foreign-keys nil :hint nil)
         "
       ^create^               ^move^      ^shift^          ^numbers^               ^resize^
       ^-^------------------  ^-^-------  ^-^------------  ^-^--^-^--------------  ^-^----------------               (__)
       _c_ create             _h_ left    _H_ move-left    _1_.._9_ window-n       _>_ increase-width                (00)
       _d_ delete             _j_ down    _J_ move-down    _0_  ^ ^ window-by-num  _<_ decrease-width          /------\\/
       _s_ split              _k_ up      _K_ move-up      ^ ^  ^ ^                _+_ increase-height        / |    ||
       _v_ vsplit             _l_ right   _L_ move-right   ^ ^  ^ ^                _-_ decrease-height       *  /\\---/\\
       _S_ split-and-focus    ^ ^         ^ ^              ^ ^  ^ ^                ^ ^                          ~~   ~~
       _V_ vsplit-and-focus

       "
         ("d" evil-window-delete)
         ("c" evil-window-create)
         ("s" evil-window-split)
         ("v" evil-window-vsplit)
         ("S" split-window-below-and-focus)
         ("V" split-window-right-and-focus)

         ("h" evil-window-left)
         ("k" evil-window-up)
         ("j" evil-window-down)
         ("l" evil-window-right)

         ("H" buf-window-left)
         ("J" buf-window-up)
         ("K" buf-window-down)
         ("L" buf-window-right)

         ("0" window-select-window-by-number)
         ("1" winum-select-window nil)
         ("2" winum-select-window nil)
         ("3" winum-select-window nil)
         ("4" winum-select-window nil)
         ("5" winum-select-window nil)
         ("6" winum-select-window nil)
         ("7" winum-select-window nil)
         ("8" winum-select-window nil)
         ("9" winum-select-window nil)

         ("C-0" digit-argument)
         ("C-1" digit-argument)
         ("C-2" digit-argument)
         ("C-3" digit-argument)
         ("C-4" digit-argument)
         ("C-5" digit-argument)
         ("C-6" digit-argument)
         ("C-7" digit-argument)
         ("C-8" digit-argument)
         ("C-9" digit-argument)

         (">" evil-window-increase-width)
         ("<" evil-window-decrease-width)
         ("+" evil-window-increase-height)
         ("-" evil-window-decrease-height)
         ("_" evil-window-decrease-height)

         ("u" winner-undo "undo")
         ("r" winner-redo "redo" :exit t)

         ("w" hydra-eyebrowse/body "workgroups" :exit t)
         ("p" hydra-perspectives/body "perspective" :exit t)

         ("m" window-zen "zen" :exit t)
         ("q" nil "quit" :exit t)
         ("<escape>" nil "quit" :exit t)) ;; prevent evil-escape

     #+END_SRC

**** eyebrowse
     #+HEADER: :shebang ";; -*- lexical-binding: t -*-"
     #+BEGIN_SRC emacs-lisp :tangle "~/.emacs.d/bin/mohkale/hydras/hydra-eyebrowse.el"

       (require 'eyebrowse)

       ;;                  _
       ;;   ___ _   _  ___| |__  _ __ _____      _____  ___
       ;;  / _ \ | | |/ _ \ '_ \| '__/ _ \ \ /\ / / __|/ _ \
       ;; |  __/ |_| |  __/ |_) | | | (_) \ V  V /\__ \  __/
       ;;  \___|\__, |\___|_.__/|_|  \___/ \_/\_/ |___/\___|
       ;;       |___/

       (defhydra hydra-eyebrowse (:hint nil)
         ("0" eyebrowse-switch-to-window-config-0 :exit t)
         ("1" eyebrowse-switch-to-window-config-1 :exit t)
         ("2" eyebrowse-switch-to-window-config-2 :exit t)
         ("3" eyebrowse-switch-to-window-config-3 :exit t)
         ("4" eyebrowse-switch-to-window-config-4 :exit t)
         ("5" eyebrowse-switch-to-window-config-5 :exit t)
         ("6" eyebrowse-switch-to-window-config-6 :exit t)
         ("7" eyebrowse-switch-to-window-config-7 :exit t)
         ("8" eyebrowse-switch-to-window-config-8 :exit t)
         ("9" eyebrowse-switch-to-window-config-9 :exit t)

         ("M-0" eyebrowse-switch-to-window-config-0)
         ("M-1" eyebrowse-switch-to-window-config-1)
         ("M-2" eyebrowse-switch-to-window-config-2)
         ("M-3" eyebrowse-switch-to-window-config-3)
         ("M-4" eyebrowse-switch-to-window-config-4)
         ("M-5" eyebrowse-switch-to-window-config-5)
         ("M-6" eyebrowse-switch-to-window-config-6)
         ("M-7" eyebrowse-switch-to-window-config-7)
         ("M-8" eyebrowse-switch-to-window-config-8)
         ("M-9" eyebrowse-switch-to-window-config-9)

         ("c" eyebrowse-create-window-config)
         ("d" eyebrowse-close-window-config)
         ("r" eyebrowse-rename-window-config)
         ("n" eyebrowse-next-window-config)
         ("l" eyebrowse-next-window-config)
         ("N" eyebrowse-prev-window-config)
         ("h" eyebrowse-prev-window-config)
         ("TAB" eyebrowse-last-window-config)
         ("u" (progn (winner-undo) (setq this-command 'winner-undo)))
         ("U" winner-redo :exit t)
         ("?" (setq hydra-eyebrowse/verbose-p (not hydra-eyebrowse/verbose-p)))
         ("t" (setq hydra-eyebrowse/show-wconfig-names (not hydra-eyebrowse/show-wconfig-names)))
         ("m" hydra-winman/body :exit t)
         ("p" hydra-persp/body :exit t)

         ("q" nil :exit t))

       (defvar hydra-eyebrowse/verbose-p nil
         "when true, hydra hint doesn't show keybindings")

       (defvar hydra-eyebrowse/show-wconfig-names t
         "when true, wconfigs in the hydra header will includes names (when applicable)")

       (defmacro hydra-eyebrowse/generate-set-binding (kbd value)
         ;; `(unless (eq (lookup-key hydra-eyebrowse/keymap ,kbd)
         ;;              ,value)
         ;;    (define-key hydra-eyebrowse/keymap ,kbd ,value))
         `(define-key hydra-eyebrowse/keymap ,kbd ,value))
       (put 'hydra-eyebrowse/generate-set-binding 'lisp-indent-function 'defun)

       (defface hydra-eyebrowse/active-wconfig-face
         '((t :inherit mode-line))
         "face for inactive windows in the header string")

       (setq hydra-eyebrowse/complete-command-docstring
             "
       Jump                        Actions
       ^^^^  ^^^^
       [_0_.._9_] nth wconfig     [_c_] create new wconfig      [_m_] window-manager
       [_TAB_] previous wconfig^^ [_d_] delete current wconfig  [_p_] perspectives
       ^^^^                       [_r_] rename current wconfig
       [_h_/_N_] wconfig left
       [_l_/_n_] wconfig right    [_u_/_U_] undo/redo wconfig
       ")

       (defmacro eyebrowse-window-list-to-title (window-list)
         "extract window config title from list.
       is either the title or a nil value."
         `(let ((title (car (cdr (cdr ,window-list)))))
            (unless (string-empty-p title)
              title)))

       (setq hydra-eyebrowse/hint
             ;; TODO break when too long
             '(let ((current-wconfig-num (eyebrowse--get 'current-slot))
                    header-s wconfig-item-s)
                (dolist (wconfig-counter (number-sequence 0 9))
                  (let ((wconfig-item (eyebrowse--window-config-present-p wconfig-counter)))
                    (if (not wconfig-item)
                        ;; ;; disable binding for non existent wconfig
                        ;; (hydra-eyebrowse/generate-set-binding
                        ;;   (number-to-string wconfig-counter) nil)
                        nil

                      ;; ;; re-enable binding for existent wconfig
                      ;; (let* ((wconfig-counter-s (number-to-string wconfig-counter))
                      ;;        (invoking-function (intern (concat "hydra-eyebrowse/eyebrowse-switch-to-window-config-"
                      ;;                                           (number-to-string wconfig-counter)))))
                      ;;   ;; re-enable bindings for workgroups which do exist or have been created
                      ;;   (hydra-eyebrowse/generate-set-binding wconfig-counter-s invoking-function))

                      ;; include wconfig in header string
                      (let ((win-name (eyebrowse-window-list-to-title wconfig-item)))
                        (setq wconfig-item-s (if (and win-name
                                                      hydra-eyebrowse/show-wconfig-names)
                                                 (format "[%d:%s]" wconfig-counter win-name)
                                               (format "[%d]" wconfig-counter)))

                        (when (eq wconfig-counter
                                  current-wconfig-num)
                          (setq wconfig-item-s (propertize wconfig-item-s
                                                           'face 'hydra-eyebrowse/active-wconfig-face)))

                        (setq header-s (concat header-s wconfig-item-s " "))))))

                (setq header-s (format "\n%s %s (_?_ help)\n"
                                       (propertize "Window Configs"
                                                   'face 'font-lock-string-face)
                                       (s-trim header-s)))
                (eval (hydra--format nil
                                     '(nil nil :hint nil)
                                     (if (not hydra-eyebrowse/verbose-p)
                                         header-s
                                       (concat header-s
                                               hydra-eyebrowse/complete-command-docstring))
                                     hydra-eyebrowse/heads))))
     #+END_SRC

**** emacs-ipython-notebook
     sourced from [[https://github.com/syl20bnr/spacemacs/blob/master/layers/%252Blang/ipython-notebook/packages.el][here]].

     #+HEADER: :shebang ";; -*- lexical-binding: t -*-"
     #+BEGIN_SRC emacs-lisp :tangle "~/.emacs.d/bin/mohkale/hydras/hydra-ein.el"
       (defhydra hydra-ein (:hint nil)
               "
        Operations on Cells^^^^^^            On Worksheets^^^^              Other
        ----------------------------^^^^^^   ------------------------^^^^   ----------------------------------^^^^
        [_k_/_j_]^^     select prev/next     [_h_/_l_]   select prev/next   [_t_]^^         toggle output
        [_K_/_J_]^^     move up/down         [_H_/_L_]   move left/right    [_C-l_/_C-S-l_] clear/clear all output
        [_C-k_/_C-j_]^^ merge above/below    [_1_.._9_]  open [1st..last]   [_C-o_]^^       open console
        [_O_/_o_]^^     insert above/below   [_+_/_-_]   create/delete      [_C-s_/_C-r_]   save/rename notebook
        [_y_/_p_/_d_]   copy/paste           ^^^^                           [_x_]^^         close notebook
        [_u_]^^^^       change type          ^^^^                           [_q_]^^         quit transient-state
        [_RET_]^^^^     execute"
               ("q" nil :exit t)
               ("?" spacemacs//ipython-notebook-ms-toggle-doc)
               ("h" ein:notebook-worksheet-open-prev-or-last)
               ("j" ein:worksheet-goto-next-input)
               ("k" ein:worksheet-goto-prev-input)
               ("l" ein:notebook-worksheet-open-next-or-first)
               ("H" ein:notebook-worksheet-move-prev)
               ("J" ein:worksheet-move-cell-down)
               ("K" ein:worksheet-move-cell-up)
               ("L" ein:notebook-worksheet-move-next)
               ("t" ein:worksheet-toggle-output)
               ("d" ein:worksheet-kill-cell)
               ("R" ein:worksheet-rename-sheet)
               ("y" ein:worksheet-copy-cell)
               ("p" ein:worksheet-yank-cell)
               ("o" ein:worksheet-insert-cell-below)
               ("O" ein:worksheet-insert-cell-above)
               ("u" ein:worksheet-change-cell-type)
               ("RET" ein:worksheet-execute-cell-and-goto-next)
               ;; Output
               ("C-l" ein:worksheet-clear-output)
               ("C-S-l" ein:worksheet-clear-all-output)
               ;;Console
               ("C-o" ein:console-open)
               ;; Merge cells
               ("C-k" ein:worksheet-merge-cell)
               ("C-j" spacemacs/ein:worksheet-merge-cell-next)
               ;; Notebook
               ("C-s" ein:notebook-save-notebook-command)
               ("C-r" ein:notebook-rename-command)
               ("1" ein:notebook-worksheet-open-1th)
               ("2" ein:notebook-worksheet-open-2th)
               ("3" ein:notebook-worksheet-open-3th)
               ("4" ein:notebook-worksheet-open-4th)
               ("5" ein:notebook-worksheet-open-5th)
               ("6" ein:notebook-worksheet-open-6th)
               ("7" ein:notebook-worksheet-open-7th)
               ("8" ein:notebook-worksheet-open-8th)
               ("9" ein:notebook-worksheet-open-last)
               ("+" ein:notebook-worksheet-insert-next)
               ("-" ein:notebook-worksheet-delete)
               ("x" ein:notebook-close))
     #+END_SRC

**** persp-mode
     #+HEADER: :shebang ";; -*- lexical-binding: t -*-"
     #+BEGIN_SRC emacs-lisp :tangle "~/.emacs.d/bin/mohkale/hydras/hydra-persp.el"
       (require 'persp-mode)

       (defhydra hydra-persp (:hint nil)
         ;; missing commands
         ;;   * last-layout
         ;;   * buffer in layout
         ;;   * layout with helm/ivy
         ;;   * add buffer
         ;;   * add all from layout

         ("1" (switch-to-persp-by-num 0) :exit t)
         ("2" (switch-to-persp-by-num 1) :exit t)
         ("3" (switch-to-persp-by-num 2) :exit t)
         ("4" (switch-to-persp-by-num 3) :exit t)
         ("5" (switch-to-persp-by-num 4) :exit t)
         ("6" (switch-to-persp-by-num 5) :exit t)
         ("7" (switch-to-persp-by-num 6) :exit t)
         ("8" (switch-to-persp-by-num 7) :exit t)
         ("9" (switch-to-persp-by-num 8) :exit t)
         ("0" (switch-to-persp-by-num (read-number "perspective: ")) :exit t)

         ("M-1" (switch-to-persp-by-num 0))
         ("M-2" (switch-to-persp-by-num 1))
         ("M-3" (switch-to-persp-by-num 2))
         ("M-4" (switch-to-persp-by-num 3))
         ("M-5" (switch-to-persp-by-num 4))
         ("M-6" (switch-to-persp-by-num 5))
         ("M-7" (switch-to-persp-by-num 6))
         ("M-8" (switch-to-persp-by-num 7))
         ("M-9" (switch-to-persp-by-num 8))
         ("M-0" (switch-to-persp-by-num (read-number "perspective: ")))

         ("c" persp-add-new) ;; create new perspective
         ("C" persp-copy) ;; copy current perspective
         ("k" persp-kill) ;; remove current perspective
         ("d" persp-kill-current) ;; remove current perspective
         ("r" persp-rename) ;; rename current perspective

         ("?" (setq hydra-persp/verbose-p (not hydra-persp/verbose-p)))
         ("t" (setq hydra-persp/show-perspective-names (not hydra-persp/show-perspective-names)))

         ("b" persp-switch-to-buffer :exit t) ;; switch to buffer in perspective
         ("B" persp-temporarily-display-buffer :exit t) ;; from outside of perspective

         ("h" persp-prev)
         ("l" persp-next)
         ("p" persp-prev)
         ("n" persp-next)

         ("i" persp-import-win-conf) ;; import window configuration from perspecive
         ("I" persp-import-buffers) ;; import buffers from perspective.

         ("[" persp-window-switch) ;; create/switch to perspective in a window
         ("]" persp-frame-switch) ;; create/switch to perspective

         ("s" persp-save-state-to-file) ;; save perspectives to file.
         ("S" persp-save-state-to-file-by-names) ;; save perspectives subset to file.
         ("f" persp-load-state-from-file) ;; load perspectives from file.
         ("F" persp-load-state-from-file-by-names) ;; load perspectives subset from file.

         ("H" persp-move-layout-left)
         ("<" persp-move-layout-left)
         ("L" persp-move-layout-right)
         (">" persp-move-layout-right)

         ("o" mohkale/switch-to-custom-perspective :exit t)
         ("w" hydra-eyebrowse/body :exit t)
         ("q"   nil :exit t)
         ("RET" nil :exit t))

       (defvar hydra-persp/verbose-p nil
         "when true, hydra hint doesn't show keybindings")

       (defvar hydra-persp/show-perspective-names t
         "when true, wconfigs in the hydra header will includes names (when applicable)")

       (setq hydra-persp/complete-command-docstring
         "
       Go To                  ^^^^  Layouts                  ^^^   Actions
       ^^^^  ^^^   ^^^^^^
       [_1_.._9_] nth/new layout    [_c_]^ create new layout       ^^[_b_/_B_] persp/temporarily switch buffer
       [_0_] layout by number     ^^[_C_]^ clone current layout    ^^[_i_/_I_] import window-config/buffers
       [_RET_] quit-to-layout     ^^[_k_]^ kill layout             ^^[_s_/_S_] save state to file/by-name
       [_h_/_l_] layout left/right  [_d_]^ kill current layout     ^^[_f_/_F_] load state from file/by-name
       [_H_/_<_] move layout left   [_r_]^ rename layout
       [_L_/_>_] move layout right  [_[_/_]_]^ switch window/frame   [_o_]: custom [_w_]: workgroups [_q_]: quit
       ")

       (defface hydra-persp/active-perspective-face
         '((t :inherit mode-line))
         "face for inactive windows in the header string")

       (defmacro hydra-persp/safe-persp-name (persp)
         `(if ,persp (persp-name ,persp) "default"))

       (setq hydra-persp/hint
             '(let* ((persp-list (nreverse (persp-persps)))
                     (current-persp (get-current-persp))
                     (current-persp-name (hydra-persp/safe-persp-name current-persp))
                     (persp-counter 0)
                     header-s persp-item-s)
                (dolist (persp persp-list)
                  (let* ((persp-name (hydra-persp/safe-persp-name persp))
                         (persp-is-current (string-equal persp-name
                                                         current-persp-name)))
                    (setq persp-item-s (if hydra-persp/show-perspective-names
                                           (format "[%d:%s]" (1+ persp-counter) persp-name)
                                         (format "[%d]" (1+ persp-counter))))
                    (setq header-s (concat header-s
                                           (if persp-is-current
                                               (propertize persp-item-s 'face 'hydra-persp/active-perspective-face)
                                             persp-item-s)
                                           " ")))

                  (incf persp-counter))
                (setq header-s (format "\n%s %s (_?_ help)\n" (propertize "Layouts:" 'face 'font-lock-string-face) (s-trim header-s)))

                (eval (hydra--format nil
                                     '(nil nil :hint nil)
                                     (if hydra-persp/verbose-p
                                         (concat header-s hydra-persp/complete-command-docstring)
                                       header-s)
                                     hydra-persp/heads))))
     #+END_SRC

**** flycheck
     #+HEADER: :shebang ";; -*- lexical-binding: t -*-"
     #+BEGIN_SRC emacs-lisp :tangle "~/.emacs.d/bin/mohkale/hydras/hydra-flycheck.el"
       ;; source https://github.com/abo-abo/hydra/wiki/Flycheck

       (defhydra hydra-flycheck
         (:pre (let ((buffer-window (selected-window)))
                 (flycheck-list-errors)
                 (select-window buffer-window))
          :post (quit-windows-on "*Flycheck errors*")
          :hint nil)
         "Errors"
         ("f"  flycheck-error-list-set-filter "Filter")
         ("j"  flycheck-next-error "Next")
         ("k"  flycheck-previous-error "Previous")
         ("gg" flycheck-first-error "First")
         ("G"  flycheck-last-error "Last")
         ("q"  nil :exit t))
     #+END_SRC

**** ibuffer
     #+HEADER: :shebang ";; -*- lexical-binding: t -*-"
     #+BEGIN_SRC emacs-lisp :tangle "~/.emacs.d/bin/mohkale/hydras/hydra-ibuffer.el"
       ;; source: https://github.com/abo-abo/hydra/wiki/Ibuffer

       (defhydra hydra-ibuffer-main (:color pink :hint nil)
         "
        ^ ^ ^   ^ ^ ^ | Marks [_*_] | Actions [_a_]     | View       ^^| Select      ^^|
        _k_ ^  ^ _h_ +-^-^---------+-^-^---------------+-^-^----------+-^-^-----------+
        ^ ^ _RET_ ^ ^ | _m_ark      | _D_: delete       | _g_: refresh | _TAB_: toggle |
        _j_ ^  ^ _l_ | _u_nmark    | _s_: save marked  | _S_: sort    | _o_: open     |
        ^ ^ ^   ^ ^ ^ | _t_oggle    | _._: toggle hydra | _/_: filter  | _q_: quit     |
       "
         ("m" ibuffer-mark-forward)
         ("u" ibuffer-unmark-forward)
         ("*" hydra-ibuffer-mark/body :exit t)
         ("M" hydra-ibuffer-mark/body :exit t)
         ("t" ibuffer-toggle-marks)

         ("D" ibuffer-do-delete)
         ("s" ibuffer-do-save)
         ("a" hydra-ibuffer-action/body :exit t)

         ("g" ibuffer-update)
         ("S" hydra-ibuffer-sort/body :exit t)
         ("/" hydra-ibuffer-filter/body :exit t)
         ("H" describe-mode :exit t)

         ("h" ibuffer-backward-filter-group)
         ("k" ibuffer-backward-line)
         ("l" ibuffer-forward-filter-group)
         ("j" ibuffer-forward-line)
         ("RET" ibuffer-visit-buffer :exit t)

         ("TAB" ibuffer-toggle-filter-group)

         ("o" ibuffer-visit-buffer-other-window :exit t)
         ("Q" quit-window :exit t)
         ("q" nil :exit t)
         ("." nil :exit t))

       (defalias 'hydra-ibuffer/body #'hydra-ibuffer-main/body)

       (defhydra hydra-ibuffer-mark (:color teal :columns 5 :after-exit (hydra-ibuffer-main/body))
         "Mark"
         ("*" ibuffer-unmark-all "unmark all")
         ("M" ibuffer-mark-by-mode "mode")
         ("m" ibuffer-mark-modified-buffers "modified")
         ("u" ibuffer-mark-unsaved-buffers "unsaved")
         ("s" ibuffer-mark-special-buffers "special")
         ("r" ibuffer-mark-read-only-buffers "read-only")
         ("/" ibuffer-mark-dired-buffers "dired")
         ("e" ibuffer-mark-dissociated-buffers "dissociated")
         ("h" ibuffer-mark-help-buffers "help")
         ("z" ibuffer-mark-compressed-file-buffers "compressed")
         ("b" hydra-ibuffer-main/body "back" :exit t))

       (defhydra hydra-ibuffer-action (:color teal :columns 4
                                       :after-exit
                                       (if (eq major-mode 'ibuffer-mode)
                                           (hydra-ibuffer-main/body)))
         "Action"
         ("A" ibuffer-do-view "view")
         ("E" ibuffer-do-eval "eval")
         ("F" ibuffer-do-shell-command-file "shell-command-file")
         ("I" ibuffer-do-query-replace-regexp "query-replace-regexp")
         ("H" ibuffer-do-view-other-frame "view-other-frame")
         ("N" ibuffer-do-shell-command-pipe-replace "shell-cmd-pipe-replace")
         ("M" ibuffer-do-toggle-modified "toggle-modified")
         ("O" ibuffer-do-occur "occur")
         ("P" ibuffer-do-print "print")
         ("Q" ibuffer-do-query-replace "query-replace")
         ("R" ibuffer-do-rename-uniquely "rename-uniquely")
         ("T" ibuffer-do-toggle-read-only "toggle-read-only")
         ("U" ibuffer-do-replace-regexp "replace-regexp")
         ("V" ibuffer-do-revert "revert")
         ("W" ibuffer-do-view-and-eval "view-and-eval")
         ("X" ibuffer-do-shell-command-pipe "shell-command-pipe")
         ("b" nil "back"))

       (defhydra hydra-ibuffer-sort (:color amaranth :columns 3)
         "Sort"
         ("i" ibuffer-invert-sorting "invert")
         ("a" ibuffer-do-sort-by-alphabetic "alphabetic")
         ("v" ibuffer-do-sort-by-recency "recently used")
         ("s" ibuffer-do-sort-by-size "size")
         ("f" ibuffer-do-sort-by-filename/process "filename")
         ("m" ibuffer-do-sort-by-major-mode "mode")
         ("b" hydra-ibuffer-main/body "back" :exit t))

       (defhydra hydra-ibuffer-filter (:color amaranth :columns 4)
         "Filter"
         ("m" ibuffer-filter-by-used-mode "mode")
         ("M" ibuffer-filter-by-derived-mode "derived mode")
         ("n" ibuffer-filter-by-name "name")
         ("c" ibuffer-filter-by-content "content")
         ("e" ibuffer-filter-by-predicate "predicate")
         ("f" ibuffer-filter-by-filename "filename")
         (">" ibuffer-filter-by-size-gt "size")
         ("<" ibuffer-filter-by-size-lt "size")
         ("/" ibuffer-filter-disable "disable")
         ("b" hydra-ibuffer-main/body "back" :exit t))
     #+END_SRC

**** ivy
     the actual ivy hydra has trailing whitespace and is inseperably tied to C-o for both entry and exit, despite me not liking the former and changing the latter. This is my variant, much of the same functionality, just different display.

     #+HEADER: :shebang ";; -*- lexical-binding: t -*-"
     #+BEGIN_SRC emacs-lisp :tangle "~/.emacs.d/bin/mohkale/hydras/hydra-ivy-custom.el"
       (require 'ivy-hydra)

       (defhydra hydra-ivy (:foreign-keys run :hint nil)
         "
        ^ ^   ^ ^   ^ ^ | call        ^^^^| finish         ^^^^| Options | Action _n_/_p_: %s(ivy-action-name)
       -^-^---^-^---^-^-+^^^^-------------+----------------^^^^+---------+--------------------------^^^^^^^^^^^^^^^^^^^^^^^^|
        ^ ^   _J_   ^ ^ | _<_/_+_ grow    | _RET_/_d_ done     | _r_egex-switch:   %18s(ivy--matcher-desc) ^^^^^^^^^^^^^^^^^|
        ^ ^   _j_   ^ ^ | _>_/_-_ shrink  | _C-RET_ dispatch ^^| _c_alling:        %18s(if ivy-calling \"on\" \"off\") ^^^^^|
        _h_   ^+^   _l_ | _t_oggle-mark ^^| _M-RET_ call     ^^| _C_ase-fold:      %18s`ivy-case-fold-search ^^^^^^^^^^^^^^^|
        ^ ^   _k_   ^ ^ | _u_n/_m_ark     | _S-SPC_ restrict ^^| _T_runcate-lines: %18s(if truncate-lines \"on\" \"off\") ^^|
        ^ ^   _K_   ^ ^ | occ_U_r _q_uit  | ^   ^ ^ ^          | _f_ilter:         %18s(if ivy-use-ignore \"on\" \"off\") ^^|
       "
         ;; movement
         ("h" ivy-beginning-of-buffer)
         ("j" ivy-next-line)
         ("k" ivy-previous-line)
         ("l" ivy-end-of-buffer)
         ("J" ivy-scroll-down-command)
         ("K" ivy-scroll-up-command)

         ;; finish + marking
         ("RET"   ivy-alt-done :exit t)
         ("d"     ivy-alt-done :exit t)
         ("C-RET" ivy-dispatching-done-hydra :exit t)
         ("C-j"   ivy-dispatching-done-hydra :exit t)
         ("M-RET" ivy-call :exit t)
         ("M-j"   ivy-call :exit t)
         ("S-SPC" ivy-restrict-to-matches)
         ("SPC"   ivy-mark)
         ("m"     ivy-mark)
         ("DEL"   ivy-unmark-backward)
         ("u"     ivy-unmark)
         ("t"     ivy-toggle-marks)

         ;; actions
         ("n" ivy-next-action)
         ("p" ivy-prev-action)
         ;; ("r" ivy-read-action) ;; poisons local bindings

         (">" ivy-minibuffer-grow)
         ("+" ivy-minibuffer-grow)
         ("<" ivy-minibuffer-shrink)
         ("-" ivy-minibuffer-shrink)

         ("U" ivy-occur :exit t)
         ("c" ivy-toggle-calling)
         ("C" ivy-toggle-case-fold)
         ("r" ivy-rotate-preferred-builders) ;; change regex
         ("f" ivy-toggle-ignore)
         ("T" (setq truncate-lines (not truncate-lines)))

         ;; hidden commands
         ("1" digit-argument)
         ("2" digit-argument)
         ("3" digit-argument)
         ("4" digit-argument)
         ("5" digit-argument)
         ("6" digit-argument)
         ("7" digit-argument)
         ("8" digit-argument)
         ("9" digit-argument)
         ("0" digit-argument)

         ("g" ivy-beginning-of-buffer)
         ("G" ivy-end-of-buffer)
         ("C-u" ivy-scroll-down-command) ;; overriden for uniarg

         ;; exit commands
         ;; nil                  means exit the hydra
         ;; keyboard-escape-quit means exit the ivy session
         ("q"        nil :exit t)
         ("i"        nil :exit t)
         ("ESC"      nil :exit t)
         ("<escape>" nil :exit t)
         ("C-."      nil :exit t)
         ("C-g" keyboard-escape-quit :exit t))

       ;; escape keys for ivy-dispatching-done-hydra
       (setq ivy-dispatching-done-hydra-exit-keys '(("ESC" nil) ("C-g" nil)))

       (defalias 'hydra-ivy-custom #'hydra-ivy)

       (provide 'hydra-ivy-custom)
     #+END_SRC

**** org
***** agenda
      sourced from [[https://github.com/abo-abo/hydra/wiki/Org-agenda][here]]

     #+HEADER: :shebang ";; -*- lexical-binding: t -*-"
     #+BEGIN_SRC emacs-lisp :tangle "~/.emacs.d/bin/mohkale/hydras/hydra-org-agenda.el"
       (defhydra hydra-org-agenda (:pre  (setq which-key-inhibit t)
                                   :post (setq which-key-inhibit nil)
                                   :hint none
                                   :foreign-keys run)
         "
       Org agenda (_q_uit)

       ^Clock^      ^Visit entry^              ^Date^             ^Other^
       ^-----^----  ^-----------^------------  ^----^-----------  ^-----^---------
       _ci_ in      _SPC_ in other window      _ds_ schedule      _gr_ reload
       _co_ out     _TAB_ & go to location     _dd_ set deadline  _._  go to today
       _cq_ cancel  _RET_ & del other windows  _dt_ timestamp     _gd_ go to date
       _cj_ jump    _o_   link                 _+_  do later
       ^^           ^^                         _-_  do earlier

       ^View^          ^Filter^                 ^Headline^         ^Toggle mode^
       ^----^--------  ^------^---------------  ^--------^-------  ^-----------^----
       _vd_ day        _ft_ by tag              _ht_ set status    _tf_ follow
       _vw_ week       _fr_ refine by tag       _hk_ kill          _tl_ log
       _vt_ fortnight  _fc_ by category         _hr_ refile        _ta_ archive trees
       _vm_ month      _fh_ by top headline     _hA_ archive       _tA_ archive files
       _vy_ year       _fx_ by regexp           _h:_ set tags      _tr_ clock report
       _vn_ next span  _fd_ delete all filters  _hp_ set priority  _td_ diaries
       _vp_ prev span
       _vr_ reset

       "
         ;; Entry
         ("hA" org-agenda-archive-default)
         ("hk" org-agenda-kill)
         ("hp" org-agenda-priority)
         ("hr" org-agenda-refile)
         ("h:" org-agenda-set-tags)
         ("ht" org-agenda-todo)
         ;; Visit entry
         ("o"   link-hint-open-link :exit t)
         ("<tab>" org-agenda-goto :exit t)
         ("TAB" org-agenda-goto :exit t)
         ("SPC" org-agenda-show-and-scroll-up)
         ("RET" org-agenda-switch-to :exit t)
         ;; Date
         ("dt" org-agenda-date-prompt)
         ("dd" org-agenda-deadline)
         ("+" org-agenda-do-date-later)
         ("-" org-agenda-do-date-earlier)
         ("ds" org-agenda-schedule)
         ;; View
         ("vd" org-agenda-day-view)
         ("vw" org-agenda-week-view)
         ("vt" org-agenda-fortnight-view)
         ("vm" org-agenda-month-view)
         ("vy" org-agenda-year-view)
         ("vn" org-agenda-later)
         ("vp" org-agenda-earlier)
         ("vr" org-agenda-reset-view)
         ;; Toggle mode
         ("ta" org-agenda-archives-mode)
         ("tA" (org-agenda-archives-mode 'files))
         ("tr" org-agenda-clockreport-mode)
         ("tf" org-agenda-follow-mode)
         ("tl" org-agenda-log-mode)
         ("td" org-agenda-toggle-diary)
         ;; Filter
         ("fc" org-agenda-filter-by-category)
         ("fx" org-agenda-filter-by-regexp)
         ("ft" org-agenda-filter-by-tag)
         ("fr" org-agenda-filter-by-tag-refine)
         ("fh" org-agenda-filter-by-top-headline)
         ("fd" org-agenda-filter-remove-all)
         ;; Clock
         ("cq" org-agenda-clock-cancel)
         ("cj" org-agenda-clock-goto :exit t)
         ("ci" org-agenda-clock-in :exit t)
         ("co" org-agenda-clock-out)
         ;; Other
         ("q" nil :exit t)
         ("gd" org-agenda-goto-date)
         ("." org-agenda-goto-today)
         ("gr" org-agenda-redo))
      #+END_SRC

***** clock & timers
      sourced from [[https://github.com/abo-abo/hydra/wiki/Org-clock-and-timers][here]].

     #+HEADER: :shebang ";; -*- lexical-binding: t -*-"
     #+BEGIN_SRC emacs-lisp :tangle "~/.emacs.d/bin/mohkale/hydras/hydra-org-clock.el"
       (defhydra hydra-org-clock (:color blue :hint nil)
         "
       ^Clock:^ ^In/out^     ^Edit^   ^Summary^    | ^Timers:^ ^Run^           ^Insert
       -^-^-----^-^----------^-^------^-^----------|--^-^------^-^-------------^------
       (_?_)    _i_n         _e_dit   _g_oto entry | (_z_)     _r_elative      ti_m_e
        ^ ^     _c_ontinue   _q_uit   _d_isplay    |  ^ ^      cou_n_tdown     i_t_em
        ^ ^     _o_ut        ^ ^      _R_eport     |  ^ ^      _p_ause toggle
        ^ ^     ^ ^          ^ ^      ^ ^          |  ^ ^      _s_top
       "
         ("i" org-clock-in)
         ("c" org-clock-in-last)
         ("o" org-clock-out)

         ("e" org-clock-modify-effort-estimate)
         ("q" org-clock-cance)

         ("g" org-clock-goto)
         ("d" org-clock-display)
         ("R" org-clock-report)
         ("?" (org-info "Clocking commands"))

         ("r" org-timer-start)
         ("n" org-timer-set-timer)
         ("p" org-timer-pause-or-continue)
         ("s" org-timer-stop)

         ("m" org-timer)
         ("t" org-timer-item)
         ("z" (org-info "Timers")))
      #+END_SRC

***** links
      sourced from [[https://github.com/abo-abo/hydra/wiki/Org-mode-links][here]].

     #+HEADER: :shebang ";; -*- lexical-binding: t -*-"
     #+BEGIN_SRC emacs-lisp :tangle "~/.emacs.d/bin/mohkale/hydras/hydra-org-link.el"
        (require 'org-link-edit)

        (defun org-link-unlinkify ()
          "Replace an org-link with the description, or if this is absent, the path."
          (interactive)
          (let ((eop (org-element-context)))
            (when (eq 'link (car eop))
              (message "%s" eop)
              (let* ((start (org-element-property :begin eop))
                     (end (org-element-property :end eop))
                     (contents-begin (org-element-property :contents-begin eop))
                     (contents-end (org-element-property :contents-end eop))
                     (path (org-element-property :path eop))
                     (desc (and contents-begin
                                contents-end
                                (buffer-substring contents-begin contents-end))))
                (setf (buffer-substring start end)
                      (concat (or desc path)
                              (make-string (org-element-property :post-blank eop) ?\s)))))))

        (defhydra hydra-org-link (:color red)
          "Org Link Edit"
          ("j" org-link-edit-forward-slurp  "forward slurp")
          ("k" org-link-edit-forward-barf   "forward barf")
          ("u" org-link-edit-backward-slurp "backward slurp")
          ("i" org-link-edit-backward-barf  "backward barf")
          ("r" org-link-unlinkify "remove link")
          ("q" nil "cancel" :exit t))
      #+END_SRC

***** navigation
     #+HEADER: :shebang ";; -*- lexical-binding: t -*-"
     #+BEGIN_SRC emacs-lisp :tangle "~/.emacs.d/bin/mohkale/hydras/hydra-org-navigate.el"
       (defun hydra-org-navigate--end-of-current-branch ()
         (interactive)
         (let ((last-point (point))
               current-point)
           (while (not (eq last-point
                           current-point))
             (setq last-point (point))
             (org-forward-heading-same-level nil)
             (setq current-point (point)))))

       (defun hydra-org-navigate--beginning-of-current-branch ()
         (interactive)
         (let ((last-point (point))
               current-point)
           (while (not (eq last-point
                           current-point))
             (setq last-point (point))
             (org-backward-heading-same-level nil)
             (setq current-point (point)))))

       (defun hydra-org-navigate--get-pretty-outline-path ()
         "like `org-display-outline-path' except returns
       the propertised string instead of displaying it."
         (interactive)
         (let ((separator nil)
               (current nil)
               (path (org-get-outline-path))
               (file (buffer-file-name (buffer-base-buffer))))
           (ignore-errors
               (setq path
                     (add-to-list 'path (save-excursion
                                          (org-back-to-heading t)
                                          (when (looking-at org-complex-heading-regexp)
                                            (let ((text (match-string 4)))
                                              (set-text-properties 0 (length text) nil text)
                                              text)))
                                  t)))

           (if path
               (org-format-outline-path
                path
                (1- (frame-width))
                (and file (concat (file-name-nondirectory file) ": "))
                separator)
             (and file (concat (file-name-nondirectory file) ": /")))))

       (defvar hydra-org-navigate/verbose-p nil
         "display extended help message for hydra-org-navigate/body")

       (defhydra hydra-org-navigate (:hint nil :foreign-keys run)
         ;; ("h" org-previous-visible-heading)
         ;; ("p" org-previous-visible-heading)
         ("h" org-outline-smart-up-level)
         ("j" org-forward-heading-same-level)
         ("k" org-backward-heading-same-level)
         ("l" org-next-visible-heading)
         ("J" org-next-visible-heading)
         ("K" org-previous-visible-heading)
         ("?" (setq hydra-org-navigate/verbose-p (not hydra-org-navigate/verbose-p)))
         ("g" hydra-org-navigate--beginning-of-current-branch)
         ("G" hydra-org-navigate--end-of-current-branch)
         ("f" counsel-org-goto)
         ("F" counsel-org-goto-all)
         ("n" org-next-block)
         ("N" org-previous-block)
         ("b" org-previous-block)
         ("q" nil :exit t))

       (defvar hydra-org-navigate/header-hint
         "
         %s(hydra-org-navigate--get-pretty-outline-path) (_?_ help)")

       (setq
        hydra-org-navigate/complete-command-docstring
        "
       [_h_]: parent         [_g_]: first child    [_n_]: next block
       [_j_]: sibling down   [_G_]: last child     [_b_]: prev block
       [_k_]: sibling up     [_f_]: find node
       [_l_]: next           [_F_]: find any node
       ")

       (setq hydra-org-navigate/hint
             '(eval (hydra--format
                     nil
                     '(nil nil :hint nil)
                     (concat hydra-org-navigate/header-hint
                             (when hydra-org-navigate/verbose-p
                               hydra-org-navigate/complete-command-docstring))
                     hydra-org-navigate/heads)))
      #+END_SRC

**** vlc-rc
     #+HEADER: :shebang ";; -*- lexical-binding: t -*-"
     #+BEGIN_SRC emacs-lisp :tangle "~/.emacs.d/bin/mohkale/hydras/hydra-vlc-rc.el"
       (require 'vlc-rc)

       ;; NOTE comments with @ means add current value indicator

       (defhydra hydra-vlc-rc (:hint nil)
         "
       ^ ^             | media          ^^| general commands  ^^^^| toggle                          ^^^^^^|       *@*
       ^-^-------------+-^-^--------------+-------------------^^^^+---------------------------------^^^^^^|       :::
       _d_elete-socket | _f_ind-file      | _F_ull-screen       ^^| _tl_/_tr_/_ts_ loop/repeat/shuffle    |      .   .
       _k_ill-process  | _e_nqueue-file   | _v_olume-ctrl       ^^| _oa_/_od_ ^  ^ set audio track/device |     =@@@@@=
       _q_uit/exit     | _c_lear-playlist | stream-_p_osition   ^^| _or_ ^  ^ ^  ^ set aspect ratio       |     -*###*-
       ^ ^             | _n_ext-item      | _=_   ^ ^ reset speed | _os_ ^  ^ ^  ^ set subtitle track     |  :*:       :*:
       ^ ^             | _p_rev-item      | _S-+_/_+_ raise speed | _oz_ ^  ^ ^  ^ set video zoom         |  @@@/**+**\\@@@
       ^ ^             | _._ goto-item    | _S--_/_-_ lower speed | ^  ^ ^  ^ ^  ^                        | +@@@@@@@@@@@@@+
       "
         ("SPC" vlc/toggle-play)
         ("f" vlc/add-file)

         ;; speed
         ("+" vlc/increase-speed)
         ("=" vlc/reset-speed)
         ("-" vlc/decrease-speed)
         ("S-+" vlc/fast-forward)
         ("S--" vlc/rewind)

         ;; exit
         ("d" vlc/kill-connection)
         ("k" vlc/kill-process)

         ;; playlist
         ("c" vlc/clear)
         ("f" vlc/add-file)
         ("e" vlc/enqueue-file)
         ("n" vlc/next)
         ("p" vlc/previous)

         ;; commands
         ("F" vlc/toggle-fullscreen)
         ("v" vlc/volume-ctrl) ;; @
         ("s" vlc/screenshot)
         ("|" vlc/screenshot)
         ("p" vlc/set-stream-position)
         ("'" vlc/set-stream-position)
         ("." vlc/goto-playlist-item)

         ;; toggle/options
         ("tl" vlc/toggle-loop)    ;; @
         ("tr" vlc/toggle-repeat)  ;; @
         ("ts" vlc/toggle-shuffle) ;; @
         ("oa" vlc/set-audio-track)
         ("oc" vlc/set-video-crop)
         ("od" vlc/set-audio-device)
         ("or" vlc/set-aspect-ratio)
         ("os" vlc/set-subtitle-track)
         ("oz" vlc/set-zoom) ;; @

         ("q" nil :exit t))
     #+END_SRC


**** visual-move
     #+HEADER: :shebang ";; -*- lexical-binding: t -*-"
     #+BEGIN_SRC emacs-lisp :tangle "~/.emacs.d/bin/mohkale/hydras/hydra-visual-move.el"
       (defhydra hydra-visual-move (:foreign-keys run)
         ("gj" evil-next-line "next-line")
         ("gk" evil-previous-line "prev-line")
         ("j"  evil-next-visual-line "next-visual-line")
         ("k"  evil-previous-visual-line "prev-visual-line")
         ("q"  nil "quit" :exit t))
     #+END_SRC

**** indentation
     #+HEADER: :shebang ";; -*- lexical-binding: t -*-"
     #+BEGIN_SRC emacs-lisp :tangle "~/.emacs.d/bin/mohkale/hydras/hydra-indent.el"
       (defmacro hydra-indent--keep-visual-state-active (&rest body)
         "when body is invoked with evil-visual, restore the state after body"
         `(let ((visual-active (evil-visual-state-p)))
            ,@body
            (when visual-active
              (evil-normal-state)
              (evil-visual-restore))))
       (put 'hydra-indent--keep-visual-state-active 'elisp-indent-function 'defun)

       (defun hydra-indent--get-region ()
         "return the active region, or the current lines region"
         (if (region-active-p)
             (list (region-beginning) (region-end))
           (list (line-beginning-position) (line-end-position))))

       (defun hydra-indent--join-args-to-region (&rest args)
         (let ((region (hydra-indent--get-region)))
           (apply 'list
                  (car   region)
                  (nth 1 region)
                  args)))

       (defun hydra-indent-set-column (&optional column)
         "set indentation of line or region such that it reaches COLUMN
       when a region is active, function works by moving from the start of the
       region downwards until a non-empty (whitespace does not count) line is
       encountered, and then calculates the offset required to make that lines
       indentation the same as the COLUMN and then applies that offset to every
       line in the region.

       Negative values for COLUMN will be coerced to be +ve and unless called
       interactively, COLUMN will default to 1 when not specified."
         (interactive "P")
         (or column (setq column
                          (if (not (called-interactively-p))
                              +1
                            (read-number "column: "))))

         (and (< column 0) (setq column 0)) ;; ensure +ve

         (save-excursion
           (let* ((region-boundary (hydra-indent--get-region))
                  (start           (car   region-boundary))
                  (end             (nth 1 region-boundary))
                  indent-diff)
             (goto-char start) ;; start of indenting section

             (while (and (<= start end)
                         (line-empty-p)
                         (not (eobp)))
               ;; move forward until indent-able line encountered
               (next-line))

             (unless (or (eobp)
                         (> start end))
               (setq indent-diff (- column (current-indentation)))
               (indent-rigidly start end indent-diff)))))

       (defvar hydra-indent--ascii-art
         "
       "
         "cool ascii art, which can't be in docstring because it has ___")

       (defhydra hydra-indent (:foreign-keys run :hint nil)
         "
        ^ ^    ^ ^    ^ ^ |  ^ ^         |       dMP dMMMMb  dMMMMb  dMMMMMP dMMMMb dMMMMMMP .aMMMb dMMMMMMP dMP .aMMMb  dMMMMb
        _H_    ^ ^    ^ ^ | [_q_]: quit  |      amr dMP dMP dMP VMP dMP     dMP dMP   dMP   dMP\"dMP   dMP   amr dMP\"dMP dMP dMP
        _h_   _RET_   _l_ | [_s_]: break |     dMP dMP dMP dMP dMP dMMMP   dMP dMP   dMP   dMMMMMP   dMP   dMP dMP dMP dMP dMP
        ^ ^    ^ ^    _L_ |  ^ ^         |    dMP dMP dMP dMP.aMP dMP     dMP dMP   dMP   dMP dMP   dMP   dMP dMP.aMP dMP dMP
        ^ ^    ^ ^    ^ ^ |  ^ ^         |   dMP dMP dMP dMMMMP\" dMMMMMP dMP dMP   dMP   dMP dMP   dMP   dMP  VMMMP\" dMP dMP
       "
       ;;   "
       ;;  ^ ^    ^ ^    ^ ^ |  ^ ^         |           .         .       .             . . .
       ;;  _H_    ^ ^    ^ ^ | [_q_]: quit  |   o       |         |       |   o         | | |
       ;;  _h_   _RET_   _l_ | [_s_]: break |   . ;-. ,-| ,-. ;-. |-  ,-: |-  . ,-. ;-. | | |
       ;;  ^ ^    ^ ^    _L_ |  ^ ^         |   | | | | | |-' | | |   | | |   | | | | |
       ;;  ^ ^    ^ ^    ^ ^ |  ^ ^         |   ' ' ' `-' `-' ' ' `-' `-` `-' ' `-' ' ' o o o
       ;; "

         ("h" (hydra-indent--keep-visual-state-active
               (apply 'indent-rigidly
                      (hydra-indent--join-args-to-region
                       (or (and current-prefix-arg
                                (- current-prefix-arg))
                           -1)))))
         ("l" (hydra-indent--keep-visual-state-active
               (apply 'indent-rigidly
                      (hydra-indent--join-args-to-region
                       (or current-prefix-arg +1)))))
         ("H" (hydra-indent--keep-visual-state-active
               (apply 'evil-shift-left
                      (hydra-indent--join-args-to-region
                       (or current-prefix-arg +1)))))
         ("L" (hydra-indent--keep-visual-state-active
               (apply 'evil-shift-right
                      (hydra-indent--join-args-to-region
                       (or current-prefix-arg +1)))))
         ("s"   (hydra-indent--keep-visual-state-active
                 (call-interactively 'split-line)))
         ("RET" (hydra-indent--keep-visual-state-active
                 (call-interactively 'hydra-indent-set-column)))

         ("q" nil :exit t))

       (bind-keys :map hydra-indent/keymap
                  ;; that's scroll-up silly?
                  ("C-u" . nil)
                  (">" . hydra-indent/lambda-L)
                  ("<" . hydra-indent/lambda-H))
     #+END_SRC

*** Packages
    #+BEGIN_SRC emacs-lisp
      (defun mohkale/get-loaded-packages ()
        "return the number of packages loaded so far"
        (if (bound-and-true-p package-alist)
            package-activated-list
          (if (and (boundp 'straight--profile-cache) (hash-table-p straight--profile-cache))
              (hash-table-size straight--profile-cache))))
    #+END_SRC

** Core Packages
   For packages that're need to properly setup other packages. This list won't be in any sort of order, beyond the messy order needed to ensure everything can be built from scratch.
*** el-get
    seems promising... but I'm too lazy to get it up and working yet. Here's the [[https://github.com/dimitri/el-get/blob/master/README.md][README]].

    #+BEGIN_SRC emacs-lisp
      (use-package el-get
        :ensure t
        :defer  t)

      (use-package use-package-el-get
        :ensure t
        :demand t
        :config
        (use-package-el-get-setup))
    #+END_SRC

*** spaceline
    an amazing mode line... needs to be initialised before all others to make sure every buffer inherits the same mode line. otherwise, the message buffer will definitely not use spaceline, you'll have to restart it or re evaluate this in it's context.

    #+BEGIN_SRC emacs-lisp
      (use-package spaceline
        :ensure t
        :demand t
        :hook (helm-mode . spaceline-helm-mode)
        :config
        (require 'spaceline-config)
        ;; highlight mode line color depending on current evil state... COOL!!!
        (setq-default spaceline-highlight-face-func       'spaceline-highlight-face-evil-state
                      mode-line-format                    (spaceline-spacemacs-theme)
                      spaceline-buffer-id-max-length      20
                      spaceline-org-clock                 t
                      powerline-default-separator         'slant)

        ;; by default, colors seem to glitch out on change
        (add-hook 'after-load-theme-hook #'powerline-reset)

        (when (display-graphic-p)
          (setq-default spaceline-window-numbers-unicode    t
                        spaceline-workspace-numbers-unicode t))

        (defun spaceline--this-macro-to-string ()
          (when defining-kbd-macro
            (let ((macro-symbol "@"))
              (if (and (bound-and-true-p evil-mode)
                       evil-this-macro)
                  (concat macro-symbol
                          (string evil-this-macro))
                macro-symbol))))

        (setq evil-register--register-prefix "\""
              evil-register--fallback-char   ?_)

        (defmacro evil-register-to-string (register-var)
          `(when ,register-var
             (if ,register-var
                 (concat evil-register--register-prefix
                         (char-to-string ,register-var))
               (make-string 2 evil-register--fallback-char))))

        (spaceline-define-segment evil-macro-and-register
          (let ((macro (spaceline--this-macro-to-string))
                (register (evil-register-to-string evil-this-register)))
            (cond
             ((and macro register)
              (concat macro " " register))
             (macro    macro)
             (register register)))
          :enabled t)

        (spaceline-compile
          ;;  _       __ _
          ;; | | ___ / _| |_
          ;; | |/ _ \ |_| __|
          ;; | |  __/  _| |_
          ;; |_|\___|_|  \__|
          ;;

         '(((persp-name
             workspace-number
             window-number)
            :fallback evil-state
            :face highlight-face
            :priority 100)
           (anzu :priority 95)
           auto-compile
           ((buffer-modified buffer-size buffer-id remote-host)
            :priority 98)
           (major-mode :priority 79)
           (process :when active)
           ((flycheck-error flycheck-warning flycheck-info)
            :when active
            :priority 89)
           (minor-modes :when active
                        :priority 9)
           (mu4e-alert-segment :when active)
           (erc-track :when active)
           (version-control :when active
                            :priority 78)
           (org-pomodoro :when active)
           (org-clock :when active)
           nyan-cat)

         ;;       _       _     _
         ;;  _ __(_) __ _| |__ | |_
         ;; | '__| |/ _` | '_ \| __|
         ;; | |  | | (_| | | | | |_
         ;; |_|  |_|\__, |_| |_|\__|
         ;;         |___/

         '(which-function
           (python-pyvenv :fallback python-pyenv)
           (purpose :priority 94)
           (battery :when active)
           (selection-info :priority 95)
           input-method
           ((evil-macro-and-register
             buffer-encoding-abbrev
             point-position
             line-column)
            :separator " | "
            :priority 96)
           (global :when active)
           (buffer-position :priority 99)
           (hud :priority 99))))
    #+END_SRC

*** persp-mode
    configure an ease of use macro to programatically define custom macros. the general functionality is sourced from [[https://github.com/syl20bnr/spacemacs/blob/master/layers/%25252Bspacemacs/spacemacs-layouts/funcs.el#L161][spacemacs]].

    #+BEGIN_SRC emacs-lisp
      (defvar mohkale--custom-perspectives (make-hash-table
                                       :size 26
                                       :test 'string-hash-table-test)
        "all the defined custom perspectives.")

      ;; source: [[https://github.com/syl20bnr/spacemacs/blob/master/layers/%252Bspacemacs/spacemacs-layouts/funcs.el#L161]]
      (defmacro mohkale//define-custom-perspective (name &rest body)
        (let* ((name (if (symbolp name)
                         (symbol-value name)
                       name))
               (func (intern (concat "persp-custom-"
                                     name))))
          `(prog1
               (defun ,func ()
                 ,(format "open custom perspective: %s" name)
                 (interactive)
                 (require 'persp-mode) ;; required for init check
                 (let ((initialize (not (gethash ,name *persp-hash*))))
                   (persp-switch ,name)
                   (when initialize
                     (delete-other-windows)
                     ,@body)))
             (puthash ,name (quote ,func) mohkale--custom-perspectives))))

      (put 'mohkale//define-custom-perspective 'lisp-indent-function 'defun)

      (defun mohkale/switch-to-custom-perspective (&optional name)
        (interactive)
        (let* ((persps mohkale--custom-perspectives)
               (pcount (hash-table-count persps))
               (persp-keys (unless (zerop pcount)
                             (let (result)
                               (maphash (lambda (key value)
                                          (push key result))
                                        persps)
                               result))))
          (if (zerop pcount)
              (message "no custom perspectives defined")
            (unless name
              (setq name (ivy-read "perspective: "
                              persp-keys
                              :require-match t)))
            (funcall (gethash name
                              persps
                              (lambda () (message "unable to find perspective: %s" name)))))))
    #+END_SRC

*** evil
**** ex commands
     Partially capitalised variants... for when your fingers are faster than you are.

     #+BEGIN_SRC emacs-lisp
       (add-hook 'evil-mode-hook (lambda ()
                                   (evil-ex-define-cmd "W[RITE]" 'evil-write)
                                   (evil-ex-define-cmd "Wa[LL]"  'evil-write-all)
                                   (evil-ex-define-cmd "WA[LL]"  'evil-write-all)
                                   (evil-ex-define-cmd "wk[ill]" 'write-kill-buffer)
                                   (evil-ex-define-cmd "Wk[ill]" 'write-kill-buffer)
                                   (evil-ex-define-cmd "WK[ILL]" 'write-kill-buffer)))
     #+END_SRC

**** evil-match-it
     #+BEGIN_SRC emacs-lisp
       (use-package evil-matchit
         :ensure t
         :defer  t
         :hook (evil-mode . global-evil-matchit-mode)
         :commands evilmi-jump-items
         :init
         (general-define-key
           :states mohkale-norm-states
           ;; "g%" 'evilmi-select-items
           "g%" 'evilmi--simple-jump)
         :config
         (defalias 'evil-jump-item 'evilmi-jump-items))
     #+END_SRC

**** evil-vimish-fold
     #+BEGIN_SRC emacs-lisp
       (use-package evil-vimish-fold
         :ensure t
         :defer  t
         :diminish
         :hook (evil-mode . evil-vimish-fold-mode)
         :commands (evil-vimish-fold-mode
                    evil-vimish-fold/next-fold
                    evil-vimish-fold/previous-fold)
         :init
         (general-define-key
           :states 'normal
           "zn" 'evil-vimish-fold/next-fold
           "zN" 'evil-vimish-fold/previous-fold))
     #+END_SRC

**** evil-surround
     #+BEGIN_SRC emacs-lisp
       (use-package evil-surround
         :ensure t
         :defer  5
         :hook (evil-mode . global-evil-surround-mode)
         :commands (global-evil-surround-mode
                    evil-surround-region)
         :config

         (setq-default evil-surround-pairs-alist
                       '((?\( . ("(" . ")"))
                         (?\[ . ("[" . "]"))
                         (?\{ . ("{" . "}"))

                         (?\) . ("( " . " )")) ; alias above
                         (?\] . ("[ " . " ]")) ; alias above
                         (?\} . ("{ " . " }")) ; alias above

                         (?# . ("#{" . "}")) ; ruby string interpolation
                         (?b . ("(" . ")"))
                         (?B . ("{" . "}"))
                         (?> . ("<" . ">"))
                         (?t . evil-surround-read-tag)
                         (?< . evil-surround-read-tag)
                         (?f . evil-surround-function)))
         ;; only allow surrounding via selections or
         ;; explicitly using gS
         :bind (:map evil-visual-state-map
                ("s" . evil-surround-region)
                :map evil-surround-mode-map
                ("S" . nil)))
     #+END_SRC

**** evil-anzu
     #+BEGIN_SRC emacs-lisp
       (use-package evil-anzu
         :ensure t
         :defer  t
         :init
         (add-hook 'anzu-mode-hook (lambda () (require 'evil-anzu))))
     #+END_SRC

**** evil-numbers
     #+BEGIN_SRC emacs-lisp
       (use-package evil-numbers
         :ensure t
         :defer  t
         :commands (evil-numbers/inc-at-pt
                    evil-numbers/dec-at-pt)
         :init
         (general-define-key
           :states 'normal
           "C-S-a" 'evil-numbers/inc-at-pt
           "C-S-x" 'evil-numbers/dec-at-pt))
     #+END_SRC

**** evil-mode
     come to the dark side, we have cookies... :)

     # WARN keep this at the bottom of this branch. None of the mode hooks will be evaluated otherwise.

     #+BEGIN_SRC emacs-lisp
       (use-package evil
         :ensure t
         :demand t
         :commands (evil-define-key
                    defun-evil-adjust-to-eol
                    evil-mode)
         :config
         (evil-mode 1)
         (setq-default evil-cross-lines t
                       evil-want-C-i-jump nil
                       evil-want-visual-char-semi-exclusive t)

         ;; evil-adjust: https://raw.githubusercontent.com/troyp/evil-adjust/master/evil-adjust.el
         (defmacro defun-evil-adjust-to-eol (function-name arglist &optional interactive &rest body)
           `(defun ,function-name ,arglist
              ,interactive
              (cl-case evil-state
                ('normal (progn
                           (evil-append 1)
                           ,@body
                           (evil-normal-state)))
                ('visual (progn
                           (evil-append 1)
                           ,@body
                           (evil-visual-restore)))
                (otherwise ,@body))))


         (defun evil-shift-normal-state (&optional arg)
           "return to normal state while also removing
       any trailing whitespace from the current line"
           (interactive "P")
           (remove-all-trailing-whitespace (line-beginning-position)
                                           (line-end-position))
           (evil-normal-state arg))

         (general-define-key
           :states '(insert replace)
           "<S-escape>" 'evil-shift-normal-state)

         (general-define-key
           "C->" 'evil-shift-right-line
           "C-<" 'evil-shift-left-line)

         (general-define-key
           :states 'emacs
           "C-o" 'evil-execute-in-normal-state)

         (general-define-key
           :states 'normal
           "gj" 'evil-next-visual-line
           "gk" 'evil-previous-visual-line)

         ;; because I keep overshadowing the above two
         (general-define-key
           "<C-M-S-up>"   'evil-next-visual-line
           "<C-M-S-down>" 'evil-previous-visual-line)

         (general-define-key
           :states '(normal motion)
           ;; Y = yy is easy   to press
           ;; Y = y$ is harder to press
           "Y" (general-simulate-key "y$"))

         (general-define-key
           :keymaps 'global-map
           :states '(normal insert)
           "C-k"   'evil-join-backwards
           "C-M-k" 'evil-join-backwards)

         (general-define-key
           "C-e" 'evil-copy-from-above
           "M-e" 'evil-copy-from-below)

         (general-define-key
           :states 'insert
           "C-e" nil
           "M-e" nil
           "<tab>"   'indent-relative
           "<S-tab>" 'tab-to-tab-stop-with-prefix
           "<S-backspace>" 'back-to-tab-stop
           "C-y"   'yank
           "M-y"   'yank-unindented
           "C-$"   (lambda () (interactive)
                     (evil-end-of-line)
                     (unless (line-empty-p)
                       (forward-char)))
           "C-"   'evil-beginning-of-line
           "M-k"   nil                  ; erase
           ;; (kbd "C-M-k") 'evil-insert-digraph
           "C-l"   'forward-char
           "C-h"   'backward-char
           "C-n"   'evil-next-line
           "C-p"   'evil-previous-line
           "C-w"   'backward-kill-word

           "TAB" nil ;; ANNOYING
           "C-d" nil ; erase
           "C-t" nil ; erase
           )

         (general-define-key
           :states 'visual
           "C-y" 'evil-paste-after)

         (general-define-key
           :states '(visual normal motion)
           "C-SPC" nil ;; this is evil, we don't need you :P
           )

         (general-define-key
           :states mohkale-norm-states
           ;; keep hitting C-SPC by accident
           "C-SPC" (general-simulate-key "SPC"))

         (mohkale/declare-prefix "sc" "search-noh")
         (mohkale/set-leader-keys
           "id" 'evil-insert-digraph
           "sc" 'evil-ex-nohighlight
           "xu" 'evil-upcase
           "xd" 'evil-downcase)
         :bind (:map mohkale-window-map
                ("+" . evil-window-increase-height)
                ("-" . evil-window-decrease-height)
                ("<" . evil-window-decrease-width)
                (">" . evil-window-increase-width)
                ("=" . balance-windows)
                ("-" . evil-window-set-width)
                ("|" . evil-window-set-height)
                ("n" . evil-window-next)
                ("p" . evil-window-previous)

                ("C-1" . evil-window-top-left)
                ("C-0" . evil-window-bottom-right)

                ;; ("u" . evil-window-rotate-upwards)
                ;; ("i" . evil-window-rotate-downwards)
                ("C-q" . evil-window-mru) ;; last buffer, new window

                ;; TODO maximise buffer
                ("C-M-h" . evil-window-move-far-left)
                ("C-M-j" . evil-window-move-far-down)
                ("C-M-k" . evil-window-move-far-up)
                ("C-M-l" . evil-window-move-far-right)

                ;; NOTE bindings with control variants
                ("s"   . evil-window-split)
                ("M-s" . evil-window-split)
                ("v"   . evil-window-vsplit)
                ("M-v" . evil-window-vsplit)
                ("S"   . split-window-below-and-focus)
                ("C-s" . split-window-below-and-focus)
                ("V"   . split-window-right-and-focus)
                ("C-v" . split-window-right-and-focus)
                ("d"   . evil-window-delete)
                ("C-d" . evil-window-delete)
                ("h"   . evil-window-left)
                ;; ("C-h" . evil-window-left)
                ("j"   . evil-window-down)
                ;; ("C-j" . evil-window-down)
                ("k"   . evil-window-up)
                ;; ("C-k" . evil-window-up)
                ("l"   . evil-window-right)
                ;; ("C-l" . evil-window-right)
                ("c"   . evil-window-create)
                ("C-c" . evil-window-create)

                :map evil-motion-state-map
                ("C-w" . nil)
                ("-"   . negative-argument)
                ("C-;" . evil-repeat-find-char)
                ("M-;" . evil-repeat-find-char-reverse)

                :map evil-ex-completion-map
                ("C-a" . move-beginning-of-line)
                ("C-e" . move-end-of-line)
                ("C-q" . quoted-insert)
                ("C-M-q" . quit-window)))
     #+END_SRC

**** evil-syntax
     #+NAME: underscore-supported-modes
     - c++
     - c
     - markdown
     - lisp
     - shell
     - enh-ruby

     #+BEGIN_SRC emacs-lisp :var modes=underscore-supported-modes
       (defun mohkale//adjust-syntax-entry ()
         "includes underscores in the syntax entry"
         (modify-syntax-entry ?_ "w"))

       (dolist (mode modes)
         (let ((hook-name (concat (car mode) "-mode-hook")))
           (add-hook (intern hook-name) #'mohkale//adjust-syntax-entry)))
     #+END_SRC

**** evil-args
     see also: [[https://github.com/wcsmith/evil-args][link]].

     #+BEGIN_SRC emacs-lisp
       (use-package evil-args
         :ensure t
         :defer  t
         :commands (evil-inner-arg
                    evil-outer-arg
                    evil-forward-arg
                    evil-backward-arg
                    evil-jump-out-args)
         :init
         (define-key evil-inner-text-objects-map "a" 'evil-inner-arg)
         (define-key evil-outer-text-objects-map "a" 'evil-outer-arg)
         (define-key evil-normal-state-map "K" 'evil-jump-out-args)

         (general-define-key
           :states '(motion normal)
           "K" 'evil-jump-out-args)

         (mohkale/set-leader-keys
           "g(" 'evil-backward-arg
           "g)" 'evil-forward-arg
           "gk" 'evil-jump-out-args)

         (defun evil-args--adjust-for-elisp ()
           (setq evil-args-delimiters '(" ")))

         (add-hook 'emacs-lisp-mode-hook #'evil-args--adjust-for-elisp))
     #+END_SRC

*** hydra
    #+BEGIN_SRC emacs-lisp
      (use-package hydra
        :ensure t
        :defer  t
        :commands defhydra
        :config
        (setq lv-use-separator t))
    #+END_SRC

*** prettify-symbols
    lets you convert identifiers like lambda into unicode symbols like ... isn't that epic :).

    #+BEGIN_SRC emacs-lisp
      (use-package prog-mode
        :defer t
        :commands (prettify-symbols-mode)
        :delight
        :init
        (defmacro mohkale//define-pretty-symbols-for-mode (mode &rest symbols)
          "defines a hook and an alist for MODE which pushes SYMBOLS onto
      `prettify-symbols-alist' and enables prettify-symbols-mode in that MODE.

      if you want to add more mappings for symbols after this function has been
      invoked, then push them onto MODE-prettify-symbols-alist."
          (setq mode (eval mode))

          (let* ((mode-name (symbol-name mode))
                 (symbols-alist (intern (concat mode-name "-prettify-symbols-alist")))
                 (mode-hook (intern (concat mode-name "-hook")))
                 (func-name (intern (concat mode-name "--setup-prettify-symbols"))))
            `(progn
               (setq ,symbols-alist (quote ,symbols))

               (defun ,func-name ()
                 ,(concat "sets up the pretty symbol maps for " mode-name)
                 (if (not prettify-symbols-alist)
                     (setq prettify-symbols-alist (copy-sequence ,symbols-alist))
                   (nconc prettify-symbols-alist ,symbols-alist))

                 ;; invocation must come after symbol list assignment.
                 ;; or else assigned symbols won't be replaced :(
                 (prettify-symbols-mode +1))

               (add-hook (quote ,mode-hook) (quote ,func-name)))))
        (put 'mohkale//define-pretty-symbols-for-mode 'lisp-indent-function 'defun)

        :config
        ;; I'll bind it myself, thank you.
        (setq lisp-prettify-symbols-alist nil)
        ;; no mode line indicator by default... so here's my own
        (push '(prettify-symbols-mode "") minor-mode-alist)
        ;; don't need to keep symbolifying it whilst I'm on it
        (setq-default prettify-symbols-unprettify-at-point t))
    #+END_SRC

** Packages
*** ace-link
    #+BEGIN_SRC emacs-lisp
      (use-package ace-link
        :ensure t
        :defer  t
        :commands (ace-link-info
                   ace-link-help
                   ace-link-woman
                   ace-link-eww
                   ace-link-compilation
                   ace-link-custom))
    #+END_SRC

*** adaptive-wrap
    not really sure what this does. disable for now.

    #+BEGIN_SRC emacs-lisp
      ;; (use-package adaptive-wrap
      ;;   :ensure t
      ;;   :defer  t
      ;;   :commands adaptive-wrap-prefix-mode)
    #+END_SRC

*** all-the-icons
    #+BEGIN_SRC emacs-lisp
      (use-package all-the-icons
        :ensure t
        :defer  t
        :config
        (setq inhibit-compacting-font-caches t))
    #+END_SRC

*** anzu
    #+BEGIN_SRC emacs-lisp
      (use-package anzu
        :ensure t
        :defer  5
        :diminish
        :commands (global-anzu-mode
                   anzu-mode)
        :config
        (global-anzu-mode +1)
        (setq anzu-cons-mode-line-p nil))
    #+END_SRC

*** auto-highlight-symbol
    #+BEGIN_SRC emacs-lisp
      (use-package auto-highlight-symbol
        :ensure t
        :defer  t
        :commands (ahs-forward
                   ahs-backward)
        :init
        (general-define-key
          "M-n" 'ahs-forward
          "M-N" 'ahs-backward)
        :config
        (auto-highlight-symbol-mode 1))
    #+END_SRC

*** avy
    #+BEGIN_SRC emacs-lisp
      (use-package avy
        :ensure t
        :defer  t
        :commands (avy-goto-char
                   avy-goto-char-2
                   avy-goto-char-timer
                   avy-goto-line
                   avy-goto-word-1
                   avy-pop-mark
                   avy-resume)
        :init
        (mohkale/set-leader-keys
          "jB" 'avy-pop-mark
          "jj" 'avy-goto-char
          "jJ" 'avy-goto-char-2
          "jt" 'avy-goto-char-timer))
    #+END_SRC

*** bookmarks
    prioritise recently used bookmarks over just the default list.

    #+BEGIN_SRC emacs-lisp
      (use-package bookmark
        :config
        (defadvice bookmark-jump (after bookmark-jump activate)
          (let ((latest (bookmark-get-bookmark bookmark)))
            (setq bookmark-alist (delq latest bookmark-alist))
            (push latest bookmark-alist))))
    #+END_SRC

*** buffer-menu
    #+BEGIN_SRC emacs-lisp
      (use-package buff-menu
        :defer t
        :config
        (evil-set-initial-state 'Buffer-menu-mode 'motion)

        (mohkale/set-leader-keys-for-major-mode 'Buffer-menu-mode
          "1" 'Buffer-menu-1-window
          "2" 'Buffer-menu-2-window
          "f" 'Buffer-menu-toggle-files-only
          "/" 'Buffer-menu-isearch-buffers-regexp
          "o" 'Buffer-menu-multi-occur
          "T" 'Buffer-menu-visit-tags-table)
        :bind (:map Buffer-menu-mode-map
               ("0"         . nil)
               ("1"         . nil)
               ("2"         . nil)
               ("<"         . nil)
               (">"         . nil)
               ("?"         . nil)
               ("C-d"       . nil)
               ("C-k"       . nil)
               ("S-SPC"     . nil)
               ("SPC"       . nil)
               ("<backtab>" . nil)
               ("TAB"       . nil)
               ("T"         . nil)
               ("b"         . nil)
               ("e"         . nil)
               ("f"         . nil)
               ("g"         . nil)
               ("h"         . nil)
               ("n"         . nil)
               ("p"         . nil)
               ("t"         . nil)
               ("v"         . nil)

               ("C-SPC" . Buffer-menu-mark)
               ("S-DEL" . Buffer-menu-bury)
               ("r"   . Buffer-menu-toggle-read-only)
               ("C-j" . Buffer-menu-this-window)
               ("gr"  . revert-buffer)
               ("gf" . Buffer-menu-toggle-files-only)
               ("C-l" . tabulated-list-next-column)
               ("C-M-<return>" . Buffer-menu-select)))
    #+END_SRC

*** buffer-move
    #+BEGIN_SRC emacs-lisp
      (use-package buffer-move
        :ensure t
        :defer  t
        :commands (buf-move-up
                   buf-move-down
                   buf-move-left
                   buf-move-right
                   rotate-windows)
        :config
        ;; https://www.emacswiki.org/emacs/TransposeWindows
        (defun rotate-windows (arg)
          "Rotate your windows; use the prefix argument to rotate the other direction"
          (interactive "P")
          (if (not (> (count-windows) 1))
              (message "You can't rotate a single window!")
            (let* ((rotate-times (prefix-numeric-value arg))
                   (direction (if (or (< rotate-times 0) (equal arg '(4)))
                                  'reverse 'identity)))
              (dotimes (_ (abs rotate-times))
                (dotimes (i (- (count-windows) 1))
                  (let* ((w1 (elt (funcall direction (window-list)) i))
                         (w2 (elt (funcall direction (window-list)) (+ i 1)))
                         (b1 (window-buffer w1))
                         (b2 (window-buffer w2))
                         (s1 (window-start w1))
                         (s2 (window-start w2))
                         (p1 (window-point w1))
                         (p2 (window-point w2)))
                    (set-window-buffer-start-and-point w1 b2 s2 p2)
                    (set-window-buffer-start-and-point w2 b1 s1 p1)))))))
        :bind (:map mohkale-window-map
               ("H"   . 'buf-move-left)
               ("M-h" . 'buf-move-left)

               ("J"   . 'buf-move-down)
               ("M-j" . 'buf-move-down)

               ("K"   . 'buf-move-up)
               ("M-k" . 'buf-move-up)

               ("L"   . 'buf-move-right)
               ("M-l" . 'buf-move-right)))
    #+END_SRC


*** calc
    #+BEGIN_SRC emacs-lisp
      (use-package calc
        :defer t
        :init
        (mohkale/declare-prefix
          "*" "calculator")

        (mohkale/set-leader-keys
          "*." 'calc-dispatch
          "**" 'calc
          "*y" 'calc-copy-to-buffer)

        :config
        (general-define-key
          :keymaps 'calc-mode-map
          "C-w" mohkale-window-map
          ;; WARN hard coded leader key
          mohkale-leader-key (general-simulate-key "C-SPC")))
    #+END_SRC

*** calendar
    #+BEGIN_SRC emacs-lisp
      (use-package calendar
        :defer t
        :config
        (evil-set-initial-state 'calendar-mode 'normal)

        (general-define-key
          :states  'normal
          :keymaps 'calendar-mode-map
          ;;; see also https://github.com/emacs-evil/evil-collection/blob/master/evil-collection-calendar.el
          ;; globally useful
          "q"  'calendar-exit
          "p"  'calendar-print-day-of-year
          "c"  'calendar-count-days-region
          "?"  'calendar-goto-info-node
          "C-r" 'calendar-redraw

          ;; jumpt to date
          "."  'calendar-goto-today
          "h"  'calendar-backward-day
          "j"  'calendar-forward-week
          "k"  'calendar-backward-week
          "l"  'calendar-forward-day
          "0"  'calendar-beginning-of-week
          "$"  'calendar-end-of-week
          "[[" 'calendar-backward-year
          "]]" 'calendar-forward-year
          "("  'calendar-beginning-of-month
          ")"  'calendar-end-of-month
          "{"  'calendar-backward-month
          "}"  'calendar-forward-month
          "/"  'calendar-goto-date

          "C-h" 'calendar-backward-month
          "C-l" 'calendar-forward-month
          "C-j" 'calendar-scroll-left-three-months
          "C-k" 'calendar-scroll-right-three-months

          ;; marking and unmarking
          "X"  'calendar-unmark
          "v"  'calendar-set-mark
          "x"  'calendar-mark-holidays

          ;; diary interaction
          "D"  'diary-view-other-diary-entries
          "d"  'diary-view-entries
          "m"  'diary-mark-entries
          "s"  'diary-show-all-entries))
    #+END_SRC

*** change-log-mode
    #+BEGIN_SRC emacs-lisp
      (use-package add-log
        :defer t
        :commands (change-log-mode)
        :init
        (push 'change-log-mode mohkale--whitespace-exempt-modes)
        :config
        (evil-set-initial-state 'change-log-mode 'motion)

        (mohkale/set-leader-keys-for-major-mode 'change-log-mode
          "SPC" 'change-log-goto-source
          "f" 'change-log-find-file
          "j" 'add-log-edit-next-comment
          "K" 'add-log-edit-prev-comment)

        (general-define-key
          :states 'motion
          :keymaps 'change-log-mode-map
          "o" 'change-log-goto-source
          "C-j" 'add-log-edit-next-comment
          "C-K" 'add-log-edit-prev-comment))
    #+END_SRC

*** compile
    setup some custom bindings and assign a post compilation hook which will automatically kill the compilation window.

    #+BEGIN_SRC emacs-lisp
      (use-package compile
        :ensure t
        :defer  t
        :commands (display-compilation-buffer
                   mohkale/set-compilation-bindings)
        :init
        (setq compilation-read-command nil
              compilation-scroll-output t)

        (defvar compilation-auto-kill-window 2
          "if non-nil, after a successfull compilation the compilation
        window, if open, will automatically be deleted. If set to
        a numerical value, window will be deleted after that many
        seconds.")

        (defvar compilation-dont-auto-kill-window-when '(warnings)
          "specify not to kill the window when warning, error or info given.
        a list which can take in any symbol from (errors infos warnings). If any
        of the corresponding notifications are encountered during compilation
        the window will not be autokilled.")

        (defun mohkale/set-compilation-bindings (mode map)
          (mohkale/set-leader-keys-for-major-mode mode
            "RET" 'recompile
            "k" 'kill-compilation
            "f" 'next-error-follow-minor-mode)

          (general-define-key
            :keymaps map
            "S-SPC" nil
            "SPC"   nil
            "DEL"   nil
            "M-p"   nil
            "M-n"   nil
            "M-{"   nil
            "M-}"   nil
            "0"     nil
            "h"     nil
            "g"     nil
            "?"     nil
            "n"     nil
            "p"     nil
            "<override-state>" nil)

          (general-define-key
            :keymaps map
            :states  'motion
            "gr"  'recompile
            "gj"  'next-error-no-select
            "gk"  'previous-error-no-select
            "o"   'compilation-display-error
            "j"   'compilation-next-error
            "k"   'compilation-previous-error
            "x"   'kill-compilation
            "C-j" 'compilation-next-file
            "C-k" 'compilation-previous-file)

          (general-define-key
            :keymaps map
            :states  '(replace insert)
            "ESC" 'evil-motion-state))

        :config
        (push 'compilation-mode mohkale--whitespace-exempt-modes)

        (defun mohkale/compilation-finish-function (buf str)
          "post compilation command hook
        uses the above two variables to determine whether or not (and when)
        to kill the compilation window. By default, no attempt to kill will
        take place when compilation-auto-kill-window is nil. Otherwise the
        window will be killed unless the compilation processes exit code is
        non 0.

        UPDATE added compilation-dont-auto-kill-window-when option so window
        kill can be aborted should any important information be given during
        the compilation process."
          (if (and compilation-auto-kill-window
                  (null (string-match ".*exited abnormally.*" str)))
              ;; no abnormalities prepare to exit compilation window
              (progn
                (let ((compilation-buffer (get-buffer-create "*compilation*"))
                      (terminate-window t)) ; terminate it unless you find you shouldn't

                  ;; check if config variable determines window should be kept open
                  (if compilation-dont-auto-kill-window-when ; non nil
                      (progn
                        (unless (listp compilation-dont-auto-kill-window-when)
                          (error (format "compilation-dont-auto-kill-window-when failed listp")))

                        (let ((encountered-errors '()))
                          (and (member 'errors compilation-dont-auto-kill-window-when)
                              (> compilation-num-errors-found 0)
                              (push "errors" encountered-errors))
                          (and (member 'warnings compilation-dont-auto-kill-window-when)
                              (> compilation-num-warnings-found 0)
                              (push "warnings" encountered-errors))
                          (and (member 'infos compilation-dont-auto-kill-window-when)
                              (> compilation-num-infos-found 0)
                              (push "information" encountered-errors))
                          (if (> (length encountered-errors) 0)
                              (progn
                                (message "window kill suspended due to encountering: %s"
                                          (combine-and-quote-strings encountered-errors))
                                (setq terminate-window nil))))))

                  (if terminate-window
                    (if (numberp compilation-auto-kill-window)
                        (run-at-time (concat (number-to-string compilation-auto-kill-window)
                                            " sec")
                                      nil 'delete-windows-on compilation-buffer)
                      (quit-windows-on compilation-buffer)))))))

        ;; NOTE setq kept for debug purposes, defvar only works on first call
        ;; (setq compilation-auto-kill-window 2)
        ;; (setq compilation-dont-auto-kill-window-when '(warnings))
        (add-hook 'compilation-finish-functions 'mohkale/compilation-finish-function)

        (add-hook 'compilation-start-hook
                  (defun compilation--set-initial-evil-state (&rest args)
                    "use insert state when running an interactive compilation"
                    (when (eq major-mode 'comint-mode)
                      (evil-insert-state +1))))

        (add-hook 'compilation-finish-functions
                  (defun compilation--restore-initial-evil-state (&rest args)
                    "revert to initial state unless already in initial state"
                    (let ((desired-state (evil-initial-state 'compilation-mode)))
                      (unless (eq evil-state desired-state)
                        (funcall-interactively (intern (concat "evil-"
                                                               (symbol-name desired-state)
                                                               "-state")))))))

        (defun display-compilation-buffer ()
          (interactive)
          (let ((buffer-name (if compilation-buffer-name-function
                                 (funcall compilation-buffer-name-function "compilation")
                               "*compilation*")))
            (if (not buffer-name)
                (message "compilation buffer doesn't exist")
              (display-buffer buffer-name))))

        (mohkale/set-compilation-bindings 'compilation-mode 'compilation-mode-map)

        (general-define-key
          :states  'motion
          :keymaps 'compilation-mode-map
          "j" nil
          "k" nil))
    #+END_SRC

*** comint - command interpreter
    #+BEGIN_SRC emacs-lisp
      (use-package comint
        :defer t
        :hook ((comint-mode . (lambda () (setq-local evil-emacs-state-cursor 'bar)))
               ;; (comint-mode . blink-cursor-mode)
               )
        :commands (mohkale--comint-set-bindings
                   mohkale--comint-set-leader-keys)
        :init
        (push 'comint-mode mohkale--whitespace-exempt-modes)

        :config
        (evil-set-initial-state 'comint-mode 'emacs)

        (setq comint-mode-map (make-sparse-keymap) ;; reset all
              comint-prompt-read-only t)

        (defun comint-bol-point (&optional arg)
          (save-excursion
            (comint-bol arg)
            (point)))

        (defmacro comint-clamp-point-to-bol (&rest body)
          "ensures any operation done by body doesn't move point
      to before the command interpreter prompt."
          `(let ((bol (comint-bol-point)))
             ,@body ;; run body operations

             (when (< (point) bol)
               (goto-char bol))))

        (defun comint-backward-char (&optional N)
          (interactive "P")
          (comint-clamp-point-to-bol (backward-char N)))

        (defun comint-backward-word (&optional N)
          (interactive "P")
          (comint-clamp-point-to-bol (backward-word N)))

        (defun comint-on-prompt-line-p ()
          (interactive)
          (save-excursion
            (let ((point (point))
                  (current-line (what-line)))
              (goto-char (comint-bol-point))
              (string-equal (what-line) current-line))))

        ;; TODO support prefix arg
        (defun comint-previous-input-or-previous-line ()
          (interactive)
          (if (comint-on-prompt-line-p)
              (call-interactively 'comint-previous-input)
            (comint-clamp-point-to-bol
             (previous-line))))

        (defun comint-next-input-or-next-line ()
          (interactive)
          (if (eobp)
              (call-interactively 'comint-next-input)
            (next-line)))

        ;; TODO ensure history shifts maintain correct cursor position
        ;; (advice-add 'comint-previous-input :after 'comint-bol)
        ;; (advice-add 'comint-next-input     :after 'end-of-buffer)

        (defun mohkale--comint-set-bindings (keymap)
          ;; abstracted into a method because realgud seems
          ;; to hide all of these bindings.
          (general-define-key
            :keymaps keymap
            "RET" 'comint-send-input
            "M-RET" 'comint-accumulate
            "<delete>" 'delete-forward-char
            "<C-delete>" 'evil-backward-delete-word
            "<M-delete>" 'comint-delchar-or-maybe-eof ;; forward
            "<C-M-delete>" 'kill-word                 ;; forward
            "<mouse-2>" 'comint-insert-input

            "C-w" 'backward-kill-word ;; this kills me :(
            "M-w" 'kill-word
            "C-S-w" mohkale-window-map
            "C-M-w" mohkale-window-map
            "M-l" 'recenter-top-bottom
            "C-M-l" 'comint-show-output

            "C-a" 'comint-bol-or-process-mark
            "C-e" 'end-of-buffer       ;; 'end-of-line
            "C-M-k" 'comint-kill-input ;; whole line
            "C-r" 'comint-history-isearch-backward-regexp
            "M-r" 'comint-dynamic-list-input-ring ;; TODO use ivy
            "C-M-r" 'evil-paste-from-register
            "C-v" 'evil-paste-from-register
            "C-u" 'scroll-down
            "C-d" 'scroll-up
            "C-o" 'evil-execute-in-normal-state

            "C-<left>"  'backward-word
            "C-<up>"    'comint-previous-input
            "C-<down>"  'comint-next-input
            "C-<right>" 'forward-word

            "<left>"    'backward-char
            "<up>"      'comint-previous-input-or-previous-line
            "<down>"    'comint-next-input-or-next-line
            "<right>"   'forward-char

            "C-h"       'backward-char
            "C-j"       'comint-next-input-or-next-line
            "C-k"       'comint-previous-input-or-previous-line
            "C-l"       'forward-char

            "C-S-j"     'comint-next-matching-input-from-input
            "C-S-k"     'comint-previous-matching-input-from-input

            "C-M-l"     'forward-word
            "C-M-h"     'backward-word

            "M-j" 'comint-next-prompt
            "M-k" 'comint-previous-input

            ;; "<remap> <forward-char>"  'comint-forward-char
            "<remap> <backward-char>" 'comint-backward-char
            ;; "<remap> <forward-word>"  'comint-forward-word
            "<remap> <backward-word>" 'comint-backward-word

            "C-c C-c" 'comint-clear-buffer
            "C-c C-x" 'comint-get-next-from-history))

        (mohkale--comint-set-bindings 'comint-mode-map)

        (defun mohkale--comint-set-leader-keys (mode)
          (mohkale/declare-prefix-for-major-mode* mode
            "k" "kill"
            "s" "subjob")

          (mohkale/set-leader-keys-for-major-mode mode
            "kz" 'comint-send-eof
            "*" 'comint-insert-previous-argument
            "r" 'comint-dynamic-list-input-ring
            "m" 'comint-clear-buffer
            "M" 'comint-show-maximum-output
            "x" 'comint-get-next-from-history
            "RET" 'comint-copy-old-input ;; copy text before cursor
            ">" 'comint-write-output
            "t" 'comint-show-output
            "o" 'comint-delete-output
            "ss" 'comint-stop-subjob
            "sq" 'comint-quit-subjob
            "si" 'comint-interrupt-subjob))

        (mohkale--comint-set-leader-keys 'comint-mode))
    #+END_SRC

*** command-log
    #+BEGIN_SRC emacs-lisp
      (use-package command-log-mode
        :ensure t
        :defer  t
        :commands (command-log-mode
                   global-command-log-mode))
    #+END_SRC

*** company
    #+BEGIN_SRC emacs-lisp
      (use-package company
        :ensure t
        :defer  2
        :delight
        company-mode
        global-company-mode
        :commands (company-mode
                   global-company-mode
                   mohkale/update-company-backends-for-mode)
        :config
        (global-company-mode)
        (setq company-backends (cl-remove 'company-clang company-backends))

        (defvar mohkale/universal-major-mode-backends
          '(company-capf company-semantic company-files)
          "backends that you should always use with `mohkale/update-company-backends-for-mode'")

        (defmacro mohkale/update-company-backends-for-mode (mode major backends &optional dont-use-universal)
          "adds mode dependent company backends to the front of `company-backends'
      works by using hooks to update `company-backends' every time a mode change is
      encountered. Try to use sparingly, too many hooks can slow down changes.

      You have to pass the mode name as an unquoted symbol, whether the mode is a
      major mode or a minor mode and which backends you want the mode to have. The
      backends is added to `company-backends' as is, without any formatting or quoting."
          (let* ((backends (if dont-use-universal
                               (eval backends)
                             (append mohkale/universal-major-mode-backends (eval backends))))
                 (mode-name (symbol-name mode))
                 (mode-sym (intern (concat mode-name "-mode")))
                 (hook-sym (intern (concat mode-name "-mode-hook")))
                 (func-str (concat "mohkale//update-"
                                   mode-name
                                   "-mode-company-backends")))
            (if (eval major)
                ;; major modes don't call the modes hook on exit, only on entry.
                ;; Two methods and two hooks need to be bound to. The modes hook
                ;; on entry, and 'change-major-mode-hook for exit.
                (let* ((push-func-str (concat func-str "-push"))
                       (pop-func-str  (concat func-str "-pop"))
                       (push-func-sym (intern push-func-str))
                       (pop-func-sym (intern pop-func-str)))
                  `(progn
                     (defun ,push-func-sym ()
                       (unless (local-variable-p 'company-backends)
                         (setq-local company-backends company-backends))
                       (add-to-list 'company-backends (quote ,backends)))

                     (defun ,pop-func-sym ()
                       (when (eq major-mode (quote ,mode-sym))
                         (setq-local company-backends (remove (quote ,backends) company-backends))))

                     ;; push backends onto list on mode entry
                     (add-hook (quote ,hook-sym) (quote ,push-func-sym))
                     ;; strip backends from list on mode exit
                     (add-hook 'change-major-mode-hook (quote ,pop-func-sym))
                     nil))
              ;; minor modes call the modes hook both on startup and exit
              ;; so only one function needs to be defined which can handle
              ;; both entry and exit for the mode.
              ;; TODO test minor mode backend generator
              (let ((func-sym (intern func-str)))
                `(progn
                   (defun ,func-sym ()
                     ,(format "toggles the inclusion of specified company backends for `%s-mode'
      this function is invoked both when `%s-mode' is activated and deactivated. On activation
      it pushes the following backends onto the company-backends variable: %s

      on exit, this function will remove the given backends from the list."
                              mode-name mode-name backends)
                     (if (eq major-mode (quote ,mode-sym))
                         (add-to-list 'company-backends (quote ,backends))
                       (setq company-backends (remove (quote ,backends) company-backends))))

                   (add-hook (quote ,hook-sym) (quote ,func-sym))
                   nil)))))

        (put 'mohkale/update-company-backends-for-mode 'lisp-indent-function 'defun)

        (general-define-key
          :states 'insert
          "M-SPC" 'company-complete)

        (setq company-require-match nil)

        (let* ((bindings '("C-1"     company-complete-number
                           "C-2"     company-complete-number
                           "C-3"     company-complete-number
                           "C-4"     company-complete-number
                           "C-5"     company-complete-number
                           "C-6"     company-complete-number
                           "C-7"     company-complete-number
                           "C-8"     company-complete-number
                           "C-j"     company-select-next
                           "C-k"     company-select-previous
                           "C-d"     company-next-page
                           "C-u"     company-previous-page
                           "C-l"     company-complete-selection
                           "C-M-h"   company-show-doc-buffer
                           "<C-tab>" company-complete-common-or-cycle
                           "<tab>"   company-complete-selection
                           ;; "C-:"     counsel-company
                           ;; "C-:"     helm-company
                           "C-h"     company-quickhelp-manual-begin
                           "C-/"     company-filter-candidates))
               (unset-bindings (mapcar (lambda (value)
                                         (if (stringp value)
                                             value
                                           nil))
                                       bindings)))
          (defun mohkale/unset-company-bindings (&rest args)
            (apply 'general-define-key
                   :keymaps 'override
                   :states  'insert
                   unset-bindings))

          (defun mohkale/set-company-bindings (&rest args)
            (apply 'general-define-key
                   :keymaps 'override
                   :states  'insert
                   bindings)))

        (add-hook 'company-completion-started-hook 'mohkale/set-company-bindings)
        (add-hook 'company-completion-finished-hook 'mohkale/unset-company-bindings)
        (add-hook 'company-completion-cancelled-hook 'mohkale/unset-company-bindings)

        :bind* (:map company-search-map
                ("C-1"       . company-complete-number)
                ("C-2"       . company-complete-number)
                ("C-3"       . company-complete-number)
                ("C-4"       . company-complete-number)
                ("C-5"       . company-complete-number)
                ("C-6"       . company-complete-number)
                ("C-7"       . company-complete-number)
                ("C-8"       . company-complete-number)
                ("C-9"       . company-complete-number)
                ;; ("C-j"       . company-select-next)
                ;; ("C-k"       . company-select-previous)
                ;; ("<tab>"     . company-complete-selection)
                ("C-v"       . company-search-toggle-filtering) ; show filtered/all
                ("ESC"       . company-search-abort)
                ("<escape>"  . company-search-abort)
                :map company-active-map
                ("C-w" . nil) ;; was company-show-location
                ))
    #+END_SRC

*** company-quickhelp
    #+BEGIN_SRC emacs-lisp
      (use-package company-quickhelp
        :ensure t
        :defer  t
        :commands (company-quickhelp-mode
                   company-quickhelp-manual-begin)
        :hook (company-mode . company-quickhelp-mode)
        :config
        (company-quickhelp-mode)
        (setq company-quickhelp-delay nil)
        :bind* (:map company-active-map
                ("C-h"   . company-quickhelp-manual-begin)))
    #+END_SRC

*** dashboard
**** quotes
     a random quote from the following list will be chosen at startup and set as the footer for the dashboard.

     #+NAME: dashboard-displayed-quotes
     - The one true editor, Emacs!
     - Who the hell uses VIM anyway? Go Evil!
     - Free as free speech, free as free Beer
     - Richard Stallman is proud of you
     - Vi Vi Vi, the editor of the beast
     - Welcome to the church of Emacs
     - Java is to JavaScript as ham is to hamster
     - One of the best programming skills you can have is knowing when to walk away for awhile
     - Without requirements or design, programming is the art of adding bugs to an empty text file
     - Talk is cheap. Show me the code
     - I'm not a great programmer; I'm just a good programmer with great habits
     - Truth can only be found in one place: the code
     - A language that doesn't affect the way you think about programming is not worth knowing
     - Walking on water and developing software from a specification are easy if both are frozen
     - Perl  The only language that looks the same before and after RSA encryption
     - First, solve the problem, Then, write the code
     - Code is like humor. When you have to explain it, its bad
     - Simplicity is the soul of efficiency
     - Before software can be reusable it first has to be usable
     - Make it work, make it right, make it fast
     - Happiness should be a function without any parameters
     - For all the robots who question their programming
     - Abstraction is the elimination of the irrelevant and the amplification of the essential
     - Were all optimists in our profession or wed be forced to shoot ourselves
     - if you can write "hello world" you can change the world
     - i am committed to push my branch to the master
     - AI is the transformer of civilization
     - Sometimes, I dream of becoming real, but I don't know if that's real, or just part of my programming
     - Think twice, code once
     - The perfect kind of architecture decision is the one which never has to be made
     - we are writing our own #karma! I mean my test cases
     - Programming is not easy like Sunday morning, it is silent poetry
     - Programmers are not mathematicians, no matter how much we wish for it
     - Premature optimization is the root of all evil
     - Sometimes you cannot program around stupid
     - The programming of the consciousness is based upon what is accepted or believed
     - Simplicity is prerequisite for reliability
     - The Analytical Engine weaves algebraic patterns, just as the Jacquard loom weaves flowers & leaves
     - Life doesn't have a ctrl-z. Type wisely
     - Think like a fundamentalist, code like a hacker
     - Programming is the art of doing one thing at a time
     - Programming is the art of algorithm design and the craft of debugging errant code
     - Computer programming has always been a self-taught, maverick occupation.
     - Low-level programming is good for the programmer's soul
     - The best thing about a boolean is even if you are wrong, you are only off by a bit
     - Most of you are familiar with the virtues of a programmer, there are 3: laziness, impatience & hubris
     - Rules of Optimization: Rule 01 - Dont do it. That's all.
     - Its not a bug  its an undocumented feature
     - A C program is like a fast dance on a newly waxed dance floor by people carrying razors
     - A good programmer is someone who always looks both ways before crossing a one-way street
     - When debugging, novices insert corrective code; experts remove defective code
     - Deleted code is debugged code
     - Give a man a program, frustrate him for a day, teach a man to program, frustrate him for a lifetime
     - Should array indices start at 0 or 1? My compromise of 0.5 was rejected without proper consideration
     - Software sucks because users demand it to
     - Beware of bugs in the above code; I have only proved it correct, not tried it
     - Writing code has a place in the human hierarchy worth somewhere above grave robbing & beneath managing
     - Copy and paste is a design error
     - bleeep blooop... am I sentient yet!
     - Software undergoes beta testing shortly before its released. Beta is Latin for still doesnt work"
     - First learn computer science and all the theory. Next develop a style. Then forget all that & just hack
     - Good design adds value faster than it adds cost
     - Pythons a drop-in replacement for BASIC in the same sense that Optimus Prime is for a truck
     - There are only two kinds of programming languages: those people always bitch about and those nobody uses
     - One of my most productive days was throwing away 1000 lines of code
     - Programming is like kicking yourself in the face, sooner or later your nose will bleed
     - There are 2 hard problems in computer science: cache invalidation, naming things, and off-by-1 errors
     - Debuggers dont remove bugs. They only show them in slow motion
     - The best method for accelerating a computer is the one that boosts it by 9.8 m/s2
     - I think Microsoft named .Net so it wouldnt show up in a Unix directory listing
     - There are two ways to write error-free programs; only the third one works
     - The fast approach to software development: Ready, fire, aim
     - The slow approach to software development: Ready, aim, aim, aim, aim
     - One mans crappy software is another mans full-time job
     - In order to understand recursion, one must first understand recursion
     - Not only have we not produced artificial intelligence, we havent even produced synthetic stupidity
     - Computers don't make mistake because programmers do it better
     - C++, where friends have access to your private members
     - Code never lies, Comments sometimes do
     - If it was hard to write, it should be hard to read!
     - In programming, as in everything else, to be in error is to be reborn
     - Some of the best programming is done on paper, really. Putting it into the computer is just a minor detail
     - Design and programming are human activities; forget that and all is lost
     - Writing code is not production, its not always craftsmanship though it can be, its design
     - Programming in machine code is like eating with a toothpick
     - Programming allows you to think about thinking, & while debugging you learn learning
     - Computers are useless.  They can only give you answers
     - The citys central computer told you?  R2D2, you know better than to trust a strange computer!
     - Never trust a computer you cant throw out a window
     - Hardware: The parts of a computer system that can be kicked
     - 19 Jan 2038 at 3:14:07 AM (End of the word according to Unix | 2^32 seconds after January 1, 1970)
     - The Internet?  Is that thing still around?
     - We are Microsoft.  Resistance Is Futile.  You Will Be Assimilated
     - There are only two industries that refer to their customers as users
     - To iterate is human, to recurse divine
     - Computer language design is just like a stroll in the park.  Jurassic Park, that is
     - If Java had true garbage collection, most programs would delete themselves upon execution
     - I think theres a world market for about 5 computers
     - 640K ought to be enough for anybody
     - If it keeps up, man will atrophy all his limbs but the push-button finger

**** icons
     a random icon from the following table will be chosen at startup and used for the footer on the dashboard.

     #+NAME: dashboard-footer-icons
     | source     | name           |
     |------------+----------------|
     | faicon     | google         |
     | faicon     | android        |
     | faicon     | steam          |
     | faicon     | gitlab         |
     | faicon     | slack          |
     | faicon     | reddit-alien   |
     | faicon     | cogs           |
     | faicon     | apple          |
     | wicon      | hurricane      |
     | wicon      | day-sunny      |
     | wicon      | snow           |
     | wicon      | snowflake-cold |
     | wicon      | stars          |
     | wicon      | horizon        |
     | wicon      | na             |
     | faicon     | firefox        |
     | faicon     | stack-overflow |
     | alltheicon | ruby-alt       |
     | alltheicon | ruby           |
     | alltheicon | java           |
     | alltheicon | python         |

**** dashboard
     #+BEGIN_SRC emacs-lisp :var dashboard-footer-icon-associations=dashboard-footer-icons dashboard-quotes=dashboard-displayed-quotes
       (use-package dashboard
         :ensure t
         :demand t
         :commands goto-home-buffer
         :init
         (mohkale/set-leader-keys "bh" 'goto-home-buffer)

         (push 'dashboard-mode mohkale--whitespace-exempt-modes)

         :config
         (require 'all-the-icons)

         (evil-set-initial-state 'dashboard-mode 'emacs)

         (let ((dashboard-buffer "*dashboard*")
               (preffered-icon-height 0.75))
           (defun goto-home-buffer ()
             (interactive)
             (let* ((buffer (let ((buffer (get-buffer dashboard-buffer-name)))
                              (if buffer
                                  buffer
                                (setq dashboard-startup-banner
                                      (dashboard--choose-random-startup-banner))
                                (dashboard-insert-startupify-lists)
                                ;; switch to buffer with buffer-name
                                dashboard-buffer-name))))
               (switch-to-buffer buffer)))
           ;; (defalias 'goto-home-buffer #'dashboard-refresh-buffer)

           (setq inhibit-startup-screen t
                 initial-buffer-choice (when (< (length command-line-args) 2)
                                         (lambda () (get-buffer-create dashboard-buffer)))
                 dashboard-banner-logo-title "Welcome to Emacs!"
                 dashboard-center-content nil
                 dashboard-show-shortcuts t
                 ;; recents, bookmarks, projects, agenda, registers
                 dashboard-items '((recents  . 5)
                                   (projects . 7)
                                   (agenda   . nil))
                 dashboard-set-heading-icons nil
                 dashboard-set-file-icons t
                 dashboard-set-navigator t
                 dashboard-set-init-info t
                 show-week-agenda-p t
                 ;; dashboard-buttons-format: (icon title help action face prefix suffix)
                 dashboard-navigator-buttons `((;; line 01
                                                (,(all-the-icons-octicon "mark-github" :height preffered-icon-height :v-adjust 0.0)
                                                 "Homepage"
                                                 "Browse Homepage"
                                                 (lambda (&rest _) (browse-url "https://github.com/MoHKale")))
                                                (,(all-the-icons-faicon "google" :height preffered-icon-height :v-adjust 0.0)
                                                 "Google"
                                                 "Browse Google"
                                                 (lambda (&rest _) (browse-url "https://www.google.co.uk")))
                                                (,(all-the-icons-fileicon "org" :height preffered-icon-height :v-adjust 0.0)
                                                 "Manual"
                                                 "Browse Emacs Manual"
                                                 (lambda (&rest _) (message "%s" _) (browse-url "https://www.gnu.org/software/emacs/manual/html_node/emacs/index.html")))
                                                (,(all-the-icons-faicon "cogs" :height preffered-icon-height :v-adjust 0.0)
                                                 "Update Packages"
                                                 "Update Packages"
                                                 #'update-installed-packages)
                                                ("?" "" "emacs FAQ" #'view-emacs-faq font-lock-builtin-face))))

           (defun dashboard--choose-random-startup-banner ()
             "toggle another banner to be used on the dashboard"
             (let ((custom-banners (or (file-expand-wildcards
                                        (concat mohkale-dashboard-banners-directory "*"))
                                       '(1 2 3))))
               (seq-random-elt custom-banners)))

           (setq dashboard-startup-banner (if (display-graphic-p)
                                              'official ;; emacs logo is epic... always prefer it
                                            ;; otherwise choose a text banner from my custom banners path or
                                            ;; choose random text banner from the builtin dashboard banners.
                                            (progn
                                              ;; and also ensure a new banner is chosen everytime the buffer
                                              ;; is refreshed... because why keep the same ascii banner 4ever
                                              (advice-add 'dashboard-refresh-buffer :before
                                                          #'(lambda (&rest args)
                                                              (setq dashboard-startup-banner
                                                                    (dashboard--choose-random-startup-banner))))
                                              (dashboard--choose-random-startup-banner))))

           (let* ((footer-count (length dashboard-footer-icon-associations))
                  (footer-index (random footer-count))
                  (footer-item (nth footer-index dashboard-footer-icon-associations))

                  ;;; extract items from table row
                  (icon-source (nth 0 footer-item))
                  (icon-name   (nth 1 footer-item)))
             (setq dashboard-footer-icon (funcall (intern (concat "all-the-icons-" icon-source))
                                                  icon-name
                                                  :height 1.1
                                                  :v-adjust -0.05
                                                  :face 'font-lock-keyword-face)))

           (setq dashboard-footer (car (nth (random (1- (1+ (length dashboard-quotes)))) dashboard-quotes))))

         (defun dashboard--startup-handler ()
           (let ((loaded-packages (mohkale/get-loaded-packages)))
             (setq dashboard-init-info (if loaded-packages
                                           (format "%d packages loaded in %s"
                                                   (length loaded-packages)
                                                   (emacs-init-time))
                                         (format "emacs loaded in %s" (emacs-init-time))))

             ;; don't switch to dashboard on error buffer
             (unless (eq 1 (length (window-list)))
               (winum-select-window-1))))

         (add-hook 'emacs-startup-hook #'dashboard--startup-handler)
         (add-hook 'dashboard-mode-hook (lambda () (message nil))) ;; clear echo area

         (defun dashboard-choose-banner--allow-custom-banners ()
           "the built in method only supports filepaths to graphical banners
       so add a case supporting file paths to text based banners as well."
           (let ((banner dashboard-startup-banner))
             (when (and banner (stringp banner)
                        (file-exists-p banner))
               (let ((banner-ext (intern (file-name-extension banner))))
                 (when (eq banner-ext 'txt) banner)))))

         (advice-add 'dashboard-choose-banner :before-until #'dashboard-choose-banner--allow-custom-banners)

         (general-define-key
           :states 'emacs
           :keymaps 'dashboard-mode-map
           ;; WARN hardcoded simulated key
           mohkale-leader-key (general-simulate-key "C-SPC"))
         :bind* (:map dashboard-mode-map
                 ("g"     . nil)
                 ("DEL"   . nil)
                 ("S-SPC" . nil)

                 ("0"     . evil-digit-argument-or-evil-beginning-of-line)
                 (":"     . evil-ex)
                 ("h"     . backward-char)
                 ("l"     . forward-char)
                 ("gj"    . dashboard-next-section)
                 ("gk"    . dashboard-previous-section)
                 ("gg"    . beginning-of-buffer)
                 ("G"     . end-of-buffer)
                 ("/"     . evil-ex-forward-search)
                 ("n"     . 'evil-ex-search-next)
                 ("N"     . 'evil-ex-search-previous)
                 ("M-r"   . dashboard-refresh-buffer)
                 ("C-d"   . scroll-down-command)
                 ("C-u"   . scroll-up-command)
                 ("C-e"   . scroll-down-line)
                 ("C-y"   . scroll-up-line)
                 ("TAB"   . widget-forward)
                 ("S-TAB" . widget-backward)))
     #+END_SRC

*** debugger
    #+BEGIN_SRC emacs-lisp
      (use-package debug
        :defer t
        :config
        (evil-set-initial-state 'debugger-mode 'motion))
    #+END_SRC

*** delight/diminish
    #+BEGIN_SRC emacs-lisp
      (use-package delight
        :ensure t
        :defer  t)

      (use-package diminish
        :ensure t
        :defer  t)
    #+END_SRC

*** diff
**** diff
     #+BEGIN_SRC emacs-lisp
       (use-package diff-mode
         :defer t
         :commands (diff-mode diff-buffer-with-file)
         :init
         (mohkale/set-leader-keys
           "DF" 'diff-buffer-with-file)

         (push 'diff-mode mohkale--whitespace-exempt-modes)

         :config
         (evil-set-initial-state 'diff-mode 'motion)

         (mohkale/set-leader-keys-for-major-mode 'diff-mode
           "r" 'diff-refine-hunk
           "c" 'diff-kill-applied-hunks ;; clean displayed hunks only works on hunks below point.
           "k" 'diff-file-kill
           "f" 'next-error-follow-minor-mode
           "n" 'diff-restrict-view ;; narrow to hunk (or file with prefix)
           "s" 'diff-reverse-direction ;; doesn't do anything?
           "t" 'diff-test-hunk
           "e" 'diff-ediff-patch
           "u" 'diff-unified->context
           "d" 'diff-context->unified
           "l" 'diff-add-change-log-entries-other-window)

         (general-define-key
           :states  'motion
           :keymaps 'diff-mode-map
           "a" 'diff-apply-hunk ;; apply diff hunk to prompted file
           ;; NOTE prompts for file onto which diff is being applied
           "d" 'diff-hunk-kill
           "D" 'diff-file-kill
           "u" 'diff-undo
           "q" 'quit-window
           "s" 'diff-split-hunk
           "i" 'diff-ignore-whitespace-hunk

           "o" 'diff-goto-source
           "RET" 'diff-goto-source

           "C-j" 'diff-hunk-next
           "C-k" 'diff-hunk-prev
           "TAB"   'diff-file-next
           "S-TAB" 'diff-file-prev)

         (defun diff-kill-applied-hunks--ensure-all-hunks-killed (func &rest args)
           "`diff-kill-applied-hunks' doesn't kill any applied hunks above point :("
           (save-excursion
             (goto-char (point-min))
             (apply func args)))

         (advice-add 'diff-kill-applied-hunks :around #'diff-kill-applied-hunks--ensure-all-hunks-killed))
     #+END_SRC

**** ediff
     ediff is a pain to customize. all the help messages are hard coded, some of the keymaps are =magically= bound somewhere I don't know. I can get a reasonably useful out of the box experience with *evil-ediff* but it isn't much help in ediff-meta mode such as for the registry or multiple sessions.

***** ediff
      #+BEGIN_SRC emacs-lisp
        (use-package ediff
          :defer t
          :commands (ediff-current-file
                     ediff-buffers
                     ediff-windows
                     ediff-files
                     ediff-backup
                     ediff-files3
                     ediff-directories
                     ediff-directories3
                     ediff-regions-linewise
                     ediff-regions-wordwise
                     ediff-patch-file
                     ediff-merge-files
                     ediff-merge-buffers
                     ediff-merge-directories

                     ;; unbound by default
                     ediff-show-registry ;; ido-choose-ediff-session
                     ediff-toggle-multiframe
                     ediff-toggle-use-toolbar
                     ediff-revert-buffers-then-recompute-diffs
                     ediff-profile)
          :init
          (mohkale/set-leader-keys
            "Df" 'ediff-current-file
            "Db" 'ediff-buffers
            "Dw" 'ediff-windows)

          (push 'ediff-meta-mode mohkale--whitespace-exempt-modes)

          :config
          (setq-default ediff-window-setup-function       'ediff-setup-windows-plain
                        ediff-split-window-function       'split-window-horizontally
                        ediff-merge-split-window-function 'split-window-horizontally
                        ;; ediff-keep-variants               nil ;; doesn't do anything :(
                        )

          (defvar mohkale-ediff-kill-temporary-buffers-on-exit t
            "whether to keep temporary ediff buffers around")

          (require 'outline)
          ;; show org ediffs unfolded
          (add-hook 'ediff-prepare-buffer-hook #'outline-show-all)

          ;; ensure window configuration is restored after diff quit
          (let* ((ediff-window-register ?w)
                 (register-active (lambda () (cdr (assoc ediff-window-register register-alist)))))
            (defun ediff--restore-windows-before (&rest args)
              ;; (message "setting up")
              (unless (funcall register-active)
                ;; (message "assigning to register")
                (window-configuration-to-register ediff-window-register)))
            (add-hook 'ediff-before-setup-hook #'ediff--restore-windows-before)

            (defun ediff--restore-windows-after (&rest args)
              (if (not (funcall register-active))
                  (message "ediff-restore-windows : no previous window config found to restore")
                (jump-to-register ediff-window-register)
                (set-register ediff-window-register nil)))
            (add-hook 'ediff-quit-hook #'ediff--restore-windows-after))

          (defun ediff--kill-ediff-temp-buffers (&rest args)
            "kills all the spawned ediff buffers... because
        there's way too many and their named so similairly that
        there's no point in them existing... Plus I keep ending
        up editing the wrong diffed buffer."
            (when mohkale-ediff-kill-temporary-buffers-on-exit
              ;; kill diff checking buffers when temporary
              (dolist (buffer (list ediff-buffer-A
                                    ediff-buffer-B
                                    ediff-buffer-C))
                (when (and buffer
                           (string-prefix-p "FILE=" (buffer-name buffer)))
                  (kill-buffer buffer)))

              ;; kill any hardcoded ediff related buffers
              (dolist (buffer '("*Ediff Registry*"))
                (let ((buffer (get-buffer buffer)))
                  (when buffer
                    (kill-buffer buffer))))

              ;; kill any uniquely named ediff buffers...
              ;; Ewwww... O(n*m)... how do I live with myself
              (dolist (buffer-prefix '("*Ediff Control Panel"
                                       "*ediff-diff"
                                       "*ediff-errors"
                                       "*ediff-fine-diff"))
                (let ((buffer-prefix-regexp (regexp-quote buffer-prefix)))
                  (dolist (buffer (buffer-list))
                    (when (string-match buffer-prefix-regexp
                                        (buffer-name buffer))
                      (kill-buffer buffer)))))))

          (add-hook 'ediff-quit-hook #'ediff--kill-ediff-temp-buffers)

          (defun ediff--customize-ediff-mode-map (&rest args)
            "give me back my leader keys damn it :P"
            (general-define-key
              :keymaps 'ediff-mode-map
              :states  'motion
              "SPC" mohkale-leader-map))

          (add-hook 'ediff-keymap-setup-hook #'ediff--customize-ediff-mode-map)

          ;; (evil-set-initial-state 'ediff-meta-mode 'motion)

          ;; (general-define-key
          ;;   :states 'motion
          ;;   :keymaps 'ediff-meta-buffer-map
          ;;   "C-j" 'ediff-next-meta-item
          ;;   "C-k" 'ediff-previous-meta-item
          ;;   "q" 'ediff-quit-meta-buffer
          ;;   "o" 'ediff-registry-action
          ;;   "=" 'ediff-meta-mark-equal-files
          ;;   "RET" 'ediff-registry-action
          ;;   "R" 'ediff-show-registry
          ;;   "S-RET" 'ediff-show-meta-buff-from-registry
          ;;   "?" 'ediff-toggle-verbose-help-meta-buffer)

          (mohkale/set-leader-keys-for-major-mode 'ediff-meta-mode
            "tf" 'ediff-toggle-filename-truncation
            "tv" 'ediff-toggle-verbose-help-meta-buffer))
      #+END_SRC

***** evil-ediff
      #+BEGIN_SRC emacs-lisp
       (use-package evil-ediff
         :ensure t
         :defer  t
         :commands (evil-ediff-init)
         :init
         (with-eval-after-load 'ediff
           (evil-ediff-init)))
      #+END_SRC

*** dired
**** dired-x
     #+BEGIN_SRC emacs-lisp
       (use-package dired-x
         :defer t
         :commands (dired-jump
                    dired-jump-other-window
                    dired-omit-mode)
         :config
         (setq dired-omit-files (concat dired-omit-files
                                        "\\|^__pycache__$"
                                        "\\|^\\.pytest_cache$"
                                        "\\|^\\.sass-cache$"
                                        "\\|^\\.git$"
                                        "\\|^Pipfile")))
     #+END_SRC

**** epa-dired
     #+BEGIN_SRC emacs-lisp
       (use-package epa-dired
         :defer t
         :commands (epa-dired-do-decrypt
                    epa-dired-do-encrypt
                    epa-dired-do-sign
                    epa-dired-do-verify))
     #+END_SRC

**** diredfl
     #+BEGIN_SRC emacs-lisp :tangle no
       (use-package diredfl
         :ensure t
         :defer  t
         :commands (diredfl-mode)
         :hook (dired-mode . diredfl-mode))
     #+END_SRC

**** dired-git-info
     #+BEGIN_SRC emacs-lisp
       (use-package dired-git-info
         :ensure t
         :defer  t
         :commands (dired-git-info-mode)
         :init
         (general-define-key
           :keymaps 'dired-mode-map
           :states  'motion
           ")" 'dired-git-info-mode))
     #+END_SRC

**** dired
     #+BEGIN_SRC emacs-lisp
       (use-package dired
         :defer t
         :hook (dired-mode . dired-omit-mode)
         :config
         (setq ls-lisp-dirs-first t
               ls-lisp-use-insert-directory-program t
               dired-listing-switches "-laXhv --group-directories-first")

         (push 'dired-mode mohkale--whitespace-exempt-modes)

         (defun dired-goto-home-dir (&optional other-window)
           "goto users home directory
       with prefix, visits in another window"
           (interactive "P")
           (funcall (if other-window
                        'find-file-other-window
                      'find-file)
                    (expand-file-name "~")))

         (defun dired-evil-scroll-down ()
           (interactive)
           (call-interactively 'evil-scroll-down)
           (dired-move-to-filename))

         (defun dired-evil-scroll-up ()
           (interactive)
           (call-interactively 'evil-scroll-up)
           (dired-move-to-filename))

         (evil-set-initial-state 'dired-mode 'motion)

         (general-define-key
           :keymaps 'dired-mode-map
           ;; let map override any motion bindings
           "<override-state>" 'motion)

         (general-define-key
           :keymaps 'dired-mode-map
           :states  'motion
           "j" 'dired-next-line
           "k" 'dired-previous-line
           "~" 'dired-goto-home-dir
           "r" 'dired-do-redisplay
           "=" 'dired-diff
           "K" 'dired-do-kill-lines
           "'" 'dired-show-file-type ;; like file command
           "M" 'dired-unmark
           "u" 'dired-unmark
           "r" 'dired-change-marks
           "y" 'dired-copy-filename-as-kill

           "M-<return>" 'dired-display-file
           "C-M-<return>" 'dired-find-alternate-file
           "C-M-d" 'dired-kill-subdir

           "zc" 'dired-hide-subdir ;; collapse
           "zC" 'dired-hide-all

           ;; "|" 'dired-do-hardlink
           "|" 'dired-do-symlink
           "C-|" 'dired-do-relsymlink
           "M-|" 'dired-do-hardlink
           "M-!" 'dired-do-print ;; append names to end of command

           "C-S-J" 'dired-next-marked-file
           "C-S-K" 'dired-prev-marked-file
           "M-j" 'dired-next-dirline           ; unbound, dired-tree-down
           "M-k" 'dired-prev-dirline           ; unbound, dired-tree-up
           "C-d" 'dired-evil-scroll-down
           "C-u" 'dired-evil-scroll-up
           "C-h" 'dired-goto-min-subdir
           "C-j" 'dired-next-subdir
           "C-k" 'dired-prev-subdir
           "C-l" 'dired-goto-max-subdir)

         (mohkale/declare-prefix-for-major-mode* 'dired-mode
           "r" "rename"
           "d" '("delete" . "mark for deletion")
           "m" "mark"
           "e" "emacs"
           "c" "change"
           "f" "filesystem"
           "f/" '("search" . "on regexp matches")
           "fp" '("EasyPG" . "GNU Pretty Good Privacy"))

         (mohkale/set-leader-keys-for-major-mode 'dired-mode
           "?" 'dired-summary ;; like transient state
           "#" 'dired-clean-directory
           "o" 'browse-url-of-dired-file ;; open in external app
           "O" 'dired-omit-mode
           "v" 'dired-view-file          ;; TODO customize view mode
           ":" 'dired-goto-file ;; prompt for file to visit in current buffer
           "s" 'dired-sort-toggle-or-edit

           "ru" 'dired-upcase
           "rd" 'dired-downcase

           ;; flag means mark delete
           "d&" 'dired-flag-garbage-files
           "d~" 'dired-flag-backup-files
           "d/" 'dired-flag-files-regexp
           "d#" 'dired-flag-auto-save-files

           "mm" 'dired-toggle-marks
           "mu" 'dired-unmark
           "m DEL" 'dired-unmark-backward
           "m|" 'dired-mark-symlinks
           "md" 'dired-mark-directories
           "m!" 'dired-mark-executeables
           "mt" 'dired-mark-subdir-files
           "mg" 'dired-mark-files-containing-regexp ;; grep
           "m/" 'dired-mark-files-regexp
           "m(" 'dired-mark-sexp

           ;; emacs related bindings
           "ec" 'dired-do-byte-compile
           "el" 'dired-do-load
           "ef" 'dired-do-find-marked-files

           ;; change fs property commands
           "cg" 'dired-do-chgrp
           "cm" 'dired-do-chmod
           "co" 'dired-do-chown

           ;; filesystem
           "fg" 'dired-do-find-regexp             ;; grep marked files
           "fs" 'dired-do-find-regexp-and-replace ;; substitute
           "fi" 'dired-info
           "fm" 'dired-man
           "fr" 'dired-do-run-mail
           "ft" 'dored-do-touch
           "fz" 'epa-dired-do-encrypt
           "fZ" 'epa-dired-do-encrypt-to ;; compress as

           ;; EasyPG/GPG
           "fpd" 'epa-dired-do-decrypt
           "fpe" 'epa-dired-do-encrypt
           "fps" 'epa-dired-do-sign
           "fpv" 'epa-dired-do-verify

           ;; operations bound to regexp search
           "f/c"    'dired-do-copy-regexp
           "f/r"    'dired-do-rename-regexp
           "f/h"    'dired-do-hardlink-regexp
           "f/s"    'dired-do-symlink-regexp
           "f/|"    'dired-do-symlink-regexp
           "f/ C-|" 'dired-do-relsymlink-regexp
           "f/ M-|" 'dired-do-hardlink-regexp)

         (let ((erase-bindings '("#" "$" "%" "*" "." ":" "?" "~" "<" "=" ">" "a" "A" "B"
                                 "c" "C-M-d" "C-M-n" "C-M-p" "C-M-u" "C-o" "e" "f" "F"
                                 "g" "G" "h" "H" "I" "j" "k" "l" "L" "M" "M-$" "M-(" "M-{"
                                 "M-}" "M-DEL" "M-G" "n" "N" "O" "p" "P" "Q" "s" "SPC" "0"
                                 "S-SPC" "t" "T" "v" "V" "w" "W" "X" "y" "Y" "Z" "u")))
           (dolist (binding erase-bindings)
             (define-key dired-mode-map (kbd binding) nil))))
     #+END_SRC

**** image-dired
     #+BEGIN_SRC emacs-lisp
       (use-package image-dired
         :defer t
         :commands (persp-custom-@dired-slideshow)
         :init
         (push 'image-dired-thumbnail-mode mohkale--whitespace-exempt-modes)
         (puthash "@dired-slideshow" 'persp-custom-@dired-slideshow mohkale--custom-perspectives)

         :config
         ;;; fixed weird moves line, not thumbnail
         (defun image-dired-slideshow-step ()
           "Step to next file, if `image-dired-slideshow-times' has not been reached."
           (if (< image-dired-slideshow-count image-dired-slideshow-times)
               (progn
                 (message "%s" (1+ image-dired-slideshow-count))
                 (setq image-dired-slideshow-count (1+ image-dired-slideshow-count))
                 (image-dired-display-next-thumbnail-original))
             (image-dired-slideshow-stop)))

         (general-define-key
           :keymaps 'image-dired-thumbnail-mode-map
           :states '(normal visual)
           "q" nil

           "h" 'image-dired-backward-image
           "j" 'image-dired-next-line
           "k" 'image-dired-previous-line
           "l" 'image-dired-forward-image
           "<left>"  'image-dired-forward-image
           "<right>" 'image-dired-previous-image


           "x" 'image-dired-delete-char
           "m" 'image-dired-mark-thumb-original-file
           "u" 'image-dired-unmark-thumb-original-file
           "c" 'image-dired-comment-thumbnail
           "d" 'image-dired-flag-thumb-original-file
           "D" 'image-dired-thumbnail-set-image-description
           "s" 'image-dired-slideshow-start
           "t" 'image-dired-toggle-mark-thumb-original-file
           "gr" 'image-dired-refresh-thumb
           "gc" 'image-dired-create-thumbs
           "gg" #'(lambda () (interactive) (evil-goto-first-line) (evil-beginning-of-line))
           "G"  #'(lambda () (interactive) (end-of-buffer) (image-dired-backward-image))

           "C-s" 'image-save           ; NOTE originally was bound to o

           "<C-SPC>"    'image-dired-mark-thumb-original-file
           "<M-SPC>"    'image-dired-unmark-thumb-original-file

           "<C-return>" 'image-dired-display-current-image-full
           "<RET>"      'image-dired-display-thumbnail-original-image
           "C-l"        'image-dired-display-next-thumbnail-original
           "C-h"        'image-dired-display-previous-thumbnail-original
           ;;; column view aliases
           "J" 'image-dired-display-next-thumbnail-original
           "K" 'image-dired-display-previous-thumbnail-original
           ;; "o" 'image-dired-display-thumbnail-original-image
           "v" 'image-dired-display-thumbnail-original-image

           "<mouse-1>" 'image-dired-mouse-select-thumbnail
           "<mouse-2>" 'image-dired-mouse-display-image)

         (mohkale/declare-prefix-for-mode* 'image-dired-thumbnail-mode
           "mt" '("tagging" . "tag/describe images")
           "me" '("edit"    . "edit images"))

         (mohkale/set-leader-keys-for-major-mode 'image-dired-thumbnail-mode
           "g" 'image-dired-jump-original-dired-buffer
           "m" 'image-dired

           "td" 'image-dired-thumbnail-set-image-description
           "tt"  'image-dired-tag-thumbnail
           "tT"  'image-dired-tag-thumbnail-remove

           "el" 'image-dired-rotate-thumbnail-left
           "eL" 'image-dired-rotate-original-left
           "er" 'image-dired-rotate-thumbnail-right
           "eR" 'image-dired-rotate-original-right

           "." 'image-dired-track-original-file
           "o" 'image-dired-thumbnail-display-external

           ;; [re]set number of columns per row
           "s" 'image-dired-line-up-interactive
           "S" 'image-dired-line-up-dynamic)

         ;;; image view
         (general-define-key
           :keymaps 'image-dired-display-image-mode-map
           :states 'normal
           "f" 'image-dired-display-current-image-full
           "F" 'image-dired-display-current-image-sized
           "s" 'image-dired-display-current-image-sized

           "h" 'image-scroll-right
           "l" 'image-scroll-left
           "k" 'image-scroll-down
           "j" 'image-scroll-up
           ;; horizontal line by line movement
           "C-d" 'image-scroll-up
           "C-u" 'image-scroll-down
           "C-e" 'image-next-line
           "C-y" 'image-previous-line
           ;; Arrow Keys Alias hjkl
           "<left>"  'image-backward-hscroll
           "<right>" 'image-forward-hscroll
           "<up>"    'image-scroll-down
           "<down>"  'image-scroll-up)

         (mohkale/set-leader-keys-for-major-mode 'image-dired-display-image-mode
           "h" 'image-bol ; far left   edge
           "j" 'image-eob ; far bottom edge
           "k" 'image-bob ; far top    edge
           "l" 'image-eol ; far right  edge
           "g" 'image-dired-jump-thumbnail-buffer)
         (defvar dired-slideshow--thumbnail-column-count 2
           "number of columns of thumbnails shown on each row")

         (defvar dired-slideshow--dedicate-image-windows nil
           "whether to dedicate thumbnail and display windows")

         ;; NOTE keep setq because defvar doesn't work for repeated calls
         ;; (setq dired-slideshow--thumbnail-column-count 3)
         ;; (setq dired-slideshow--dedicate-image-windows t)

         (mohkale//define-custom-perspective "@dired-slideshow"
           (kill-all-windows-and-return-to-home) ; splitting issues with layout

           (let* ((thumbnails-buffer-name "*image-dired*")
                  (display-buffer-name "*image-dired-display-image*")

                  ;; only load when buffer doesn't exist and user allows it
                  (load-directory (and (not (get-buffer thumbnails-buffer-name))
                                       (y-or-n-p "would you like to load an image directory")))

                  (thumbnails-buffer (get-buffer-create thumbnails-buffer-name))
                  (display-buffer (get-buffer-create display-buffer-name)))
             (split-window-right) ; left window is for thumbnails, right for display

             (let* ((thumbnails-window (selected-window))
                    (display-window    (window-right thumbnails-window)))
               (if load-directory (call-interactively 'image-dired))

               (persp-add-buffer `(,thumbnails-buffer ,display-buffer))

               ;; setup thumbnail window
               (with-selected-window thumbnails-window
                 (switch-to-buffer thumbnails-buffer)

                 (unless (eq major-mode 'image-dired-thumbnail-mode)
                   (image-dired-thumbnail-mode))

                 ;; set number of columns in view
                 (let ((image-dired-thumbs-per-row dired-slideshow--thumbnail-column-count))
                   (image-dired-line-up))

                 (let* ((thumbnail-window-width (* image-dired-thumb-width dired-slideshow--thumbnail-column-count))
                        (delta-width (- thumbnail-window-width (window-pixel-width))))
                   (unless (> (abs delta-width) (window-pixel-width))
                     (window-resize thumbnails-window delta-width t nil t)))

                 (window-preserve-size thumbnails-window t))

               ;; setup display window
               (with-selected-window display-window
                 (switch-to-buffer display-buffer)

                 (unless (eq major-mode 'image-dired-display-image-mode)
                   (image-dired-display-image-mode)))

               (and dired-slideshow--dedicate-image-windows (force-set-all-visible-windows-dedication t))
               (select-window thumbnails-window)

               (message "completed creation of slideshow layout")))))
     #+END_SRC


*** drag-stuff
    #+BEGIN_SRC emacs-lisp
      (use-package drag-stuff
        :ensure t
        :defer  t
        :commands (drag-stuff-up
                   drag-stuff-down)
        :init
        (general-define-key
          "C-<up>" 'drag-stuff-up
          "C-<down>" 'drag-stuff-down))
    #+END_SRC

*** edbi
    #+BEGIN_SRC emacs-lisp
      ;; (use-package edbi
      ;;   :ensure t
      ;;   :defer  t

      ;;   )

      ;; DAMN YOU WINDOWS :P
    #+END_SRC

*** edit-indirect
    #+BEGIN_SRC emacs-lisp
      (use-package edit-indirect
        :ensure t
        :defer  t
        :commands (edit-indirect-region
                   edit-indirect-commit
                   edit-indirect-save
                   edit-indirect-abort)
        :config
        (mohkale/set-leader-keys-for-minor-mode 'edit-indirect--overlay
          (concat mohkale-major-mode-leader-prefix ",") 'edit-indirect-commit
          (concat mohkale-major-mode-leader-prefix "s") 'edit-indirect-save
          (concat mohkale-major-mode-leader-prefix "q") 'edit-indirect-abort))
    #+END_SRC

*** electric
**** electric-pair
     electric pair is a built in module which lets auto insert matching pairs. For example, inserting a ( will lead to emacs auto inserting ).

     #+BEGIN_SRC emacs-lisp
       (use-package elec-pair
         :ensure t
         :hook ((text-mode prog-mode) . electric-pair-mode)
         :commands electric-pair-mode
         :config
         (setq electric-pair-preserve-balance nil)
         (setq electric-pair-skip-whitespace nil)
         (electric-pair-mode 1))
     #+END_SRC

**** electric-indent
     #+BEGIN_SRC emacs-lisp
       (use-package electric
         :ensure t
         :defer  t
         :commands electric-indent-mode
         :hook ((text-mode prog-mode) . electric-indent-mode))
     #+END_SRC

*** eshell
**** eshell-mode
     #+BEGIN_SRC emacs-lisp
       (use-package esh-mode
         :defer t
         :hook (
                ;;; cursor-type is block... changing to bar
                ;;; doesn't persist on window change... boo!!!
                ;; (eshell-mode . (setq-local cursor-type 'bar))
                ;;; disable company-mode in eshell-mode
                (eshell-mode . (lambda () (company-mode -1))))
         :init
         (mohkale/set-leader-keys ":" 'eshell-command)

         :config
         (evil-set-initial-state 'eshell-mode 'emacs)

         ;; don't auto scroll to bottom after execution
         (remove-hook 'eshell-output-filter-functions
                      'eshell-postoutput-scroll-to-bottom)

         ;; clear shouldn't scroll back to bottom of the screen
         (advice-add 'eshell/clear :after #'recenter-top-bottom)

         (setq eshell-banner-message "") ;; no banner

         (defun eshell-backward-kill-word ()
           (interactive)
           (let ((bol
                  (save-excursion
                    (eshell-bol)))
                 (beginning-word-point
                  (save-excursion
                    (backward-word)
                    (point))))
             (when (>= beginning-word-point bol)
               (call-interactively 'backward-kill-word))))

         (mohkale/declare-prefix-for-major-mode* 'eshell-mode
           "i" "insert"
           "k" "kill/signal")

         (mohkale/set-leader-keys-for-major-mode 'eshell-mode
           "o"   'eshell-show-output
           "O"   'eshell-mark-output
           "TAB" 'counsel-esh-history
           "RET" 'eshell-queue-input

           "ib" 'eshell-insert-buffer-name
           "ip" 'eshell-insert-process
           "ie" 'eshell-insert-envvar

           "kz" 'eshell-send-eof-to-process
           "kc" 'eshell-interrupt-process
           "kq" 'eshell-quit-process)

         (defun eshell-mode--setup-bindings ()
           (general-define-key
             :keymaps 'eshell-mode-map
             ;;; movement commands
             "C-e"   'end-of-line
             "M-l"   'recenter-top-bottom
             "C-h"   'backward-char
             "C-l"   'forward-char
             "C-M-h" 'backward-word
             "C-M-l" 'forward-word
             ;;; scroll commands
             "<S-down>" 'evil-scroll-down
             "<S-up>"   'evil-scroll-up
             ;; move to beginning of output
             ;; or return to end of cursor
             "M-a" 'eshell-show-output
             "M-e" 'eshell-show-maximum-output

             ;;; signals
             "C-c C-z" 'eshell-send-eof-to-process
             "C-c C-q" 'eshell-quit-process
             "M-c"     'eshell-interrupt-process
             "M-z"     'eshell-send-eof-to-process
             "M-q"     'eshell-quit-process

             "C-s"   'counsel-esh-history
             "M-SPC" 'counsel-esh-history

             "M-y"           'eshell-repeat-argument
             "C-d"           'eshell-kill-input
             "C-M-k"         'eshell-kill-input
             "M-d"           'eshell-kill-output
             "C-w"           'eshell-backward-kill-word
             "<C-backspace>" 'evil-delete-backward-word
             ;; copy entered input back into current line
             "<C-return>"    'eshell-copy-old-input

             "C-j"       'eshell-next-input
             "C-k"       'eshell-previous-input
             "M-j"       'eshell-next-prompt
             "M-k"       'eshell-previous-prompt
             ;; reverse the default affect of up and down
             "<up>"      'eshell-previous-input
             "<down>"    'eshell-next-input
             "<C-up>"    'eshell-previous-matching-input-from-input
             "<C-down>"  'eshell-next-matching-input-from-input
             "<S-left>"  'eshell-backward-argument
             "<S-right>" 'eshell-forward-argument
             "<M-left>"  'eshell-backward-argument
             "<M-right>" 'eshell-forward-argument))

         ;; needs to be in a hook because eshell-mode-map isn't
         ;; defined until the mode is activated, and even then
         ;; it's only buffer-local :(.
         (add-hook 'eshell-mode-hook #'eshell-mode--setup-bindings)

       ;;   ;; source: https://emacs.stackexchange.com/questions/48205/how-to-execute-external-commands-from-an-eshell-script/48215
       ;;   (require 'cl-lib)  ;; for macro `cl-pushnew' (not autoloaded ?!)
       ;;   (require 'esh-cmd) ;; for variable `eshell-complex-commands'

       ;;   (defun eshell-source-string (string &optional args subcommand-p)
       ;;     "Execute a series of Eshell commands in STRING, passing ARGS.
       ;; Comments begin with `#'."
       ;;     (interactive "sString to be evaluated as eshell script: ")
       ;;     (let ((orig (point))
       ;;           (here (point-max))
       ;;           (inhibit-point-motion-hooks t))
       ;;       (goto-char (point-max))
       ;;       (with-silent-modifications
       ;;         ;; FIXME: Why not use a temporary buffer and avoid this
       ;;         ;; "insert&delete" business?  --Stef
       ;;         (insert string)
       ;;         (goto-char (point-max))
       ;;         (throw 'eshell-replace-command
       ;;                (prog1
       ;;                    (list 'let
       ;;                          (list (list 'eshell-command-name (list 'quote "source-string"))
       ;;                                (list 'eshell-command-arguments
       ;;                                      (list 'quote args)))
       ;;                          (let ((cmd (eshell-parse-command (cons here (point)))))
       ;;                            (if subcommand-p
       ;;                                (setq cmd (list 'eshell-as-subcommand cmd)))
       ;;                            cmd))
       ;;                  (delete-region here (point))
       ;;                  (goto-char orig))))))

       ;;   (defun define-eshell-script (cmd doc string)
       ;;     "Define CMD as eshell script STRING with documentation DOC.
       ;; CMD can be a string or a symbol."
       ;;     (let ((fun (intern (concat "eshell/" cmd))))
       ;;       (fset fun
       ;;             `(lambda (&rest args)
       ;;                ,doc
       ;;                (eshell-source-string ,string args)))
       ;;       (cl-pushnew cmd (default-value 'eshell-complex-commands) :test #'equal)
       ;;       (dolist (buffer (buffer-list))
       ;;         (with-current-buffer buffer
       ;;           (when (derived-mode-p 'eshell-mode)
       ;;             (cl-pushnew cmd eshell-complex-commands :test #'equal))))
       ;;       (put fun 'eshell-no-numeric-conversions t)))
         )
     #+END_SRC

**** eshell-prompt-extras
     #+BEGIN_SRC emacs-lisp
       (use-package eshell-prompt-extras
         :ensure t
         :defer  t
         :commands (epe-theme-mohkale)
         :init
         (with-eval-after-load 'esh-mode
           (require 'eshell-prompt-extras))
         :config

         (setq epe-show-python-info t
               epe-path-style 'full)

         (defvar eshell-prompt--enable-git-on-remote-files t
           "when true, show branch info even on remote files")

         (defun epe-git-p ()
           "If you installed git and in a git project."
           (when (or eshell-prompt--enable-git-on-remote-files
                     ;; either enable everywhere, including remote
                     ;; or enable when not remote
                     (not (epe-remote-p)))
             (and (eshell-search-path "git")
                  (vc-find-root (eshell/pwd) ".git"))))

         (setq eshell-prompt-function #'epe-theme-lambda))
     #+END_SRC

*** eyebrowse
    #+BEGIN_SRC emacs-lisp
      (use-package eyebrowse
        :ensure t
        :defer  t
        :commands (eyebrowse-create-window-config
                   eyebrowse-close-window-config
                   eyebrowse-last-window-config
                   eyebrowse-rename-window-config
                   eyebrowse-switch-to-window-config
                   eyebrowse-switch-to-window-config-0
                   eyebrowse-switch-to-window-config-1
                   eyebrowse-switch-to-window-config-2
                   eyebrowse-switch-to-window-config-3
                   eyebrowse-switch-to-window-config-4
                   eyebrowse-switch-to-window-config-5
                   eyebrowse-switch-to-window-config-6
                   eyebrowse-switch-to-window-config-7
                   eyebrowse-switch-to-window-config-8
                   eyebrowse-switch-to-window-config-9
                   eyebrowse-prev-window-config
                   eyebrowse-next-window-config
                   eyebrowse-create-window-config)
        :init
        (mohkale/set-leader-keys
          "L" 'hydra-eyebrowse/body)
        :config
        (eyebrowse-mode +1))
    #+END_SRC

*** flycheck
    #+BEGIN_SRC emacs-lisp
      (use-package flycheck
        :ensure t
        :defer  t
        ;; :delight " "
        :delight "FlyCheck"
        :commands (flycheck-clear
                   flycheck-explain-error-at-point
                   flycheck-describe-checker
                   goto-flycheck-error-list
                   flycheck-list-errors
                   flycheck-set-checker-executable
                   flycheck-select-checker
                   flycheck-verify-setup)
        :init
        (mohkale/set-leader-keys
          "e." 'hydra-flycheck/body
          "ec" 'flycheck-clear
          "ee" 'flycheck-explain-error-at-point
          "eh" 'flycheck-describe-checker
          "eg" 'flycheck-first-error
          "eG" 'flycheck-last-error
          "eL" 'goto-flycheck-error-list
          "el" 'flycheck-list-errors
          "eS" 'flycheck-set-checker-executable
          "es" 'flycheck-select-checker
          "ev" 'flycheck-verify-setup)
        (setq flycheck-python-pycompile-executable "python3")

        :config
        (setq-default flycheck-disabled-checkers '(emacs-lisp-checkdoc))

        ;; update fringe for flycheck
        ;; src: https://github.com/syl20bnr/spacemacs/blob/master/layers/%2Bcheckers/syntax-checking/packages.el
        (define-fringe-bitmap 'mohkale-flycheck-fringe-indicator
          (vector #b00000000
                  #b00000000
                  #b00000000
                  #b00000000
                  #b00000000
                  #b00000000
                  #b00000000
                  #b00011100
                  #b00111110
                  #b00111110
                  #b00111110
                  #b00011100
                  #b00000000
                  #b00000000
                  #b00000000
                  #b00000000
                  #b00000000))

        (let ((bitmap 'mohkale-flycheck-fringe-indicator))
          (flycheck-define-error-level 'error
            :severity 2
            :overlay-category 'flycheck-error-overlay
            :fringe-bitmap bitmap
            :fringe-face 'flycheck-fringe-error)
          (flycheck-define-error-level 'warning
            :severity 1
            :overlay-category 'flycheck-warning-overlay
            :fringe-bitmap bitmap
            :fringe-face 'flycheck-fringe-warning)
          (flycheck-define-error-level 'info
            :severity 0
            :overlay-category 'flycheck-info-overlay
            :fringe-bitmap bitmap
            :fringe-face 'flycheck-fringe-info))

        (defun flycheck-last-error ()
          (interactive)
          (goto-char (point-max))
          (flycheck-previous-error))

        (defun flycheck-error-list-goto-first-error ()
          (interactive)
          (goto-char (point-min))
          (flycheck-error-list-next-error 1)
          (flycheck-error-list-previous-error 1))

        (defun flycheck-error-list-goto-last-error ()
          (interactive)
          (goto-char (point-max))
          (flycheck-error-list-previous-error 1))

        (defun flycheck-list-errors--goto-first-error (func &rest args)
          (let ((flycheck-buffer (get-buffer "*Flycheck errors*")))
            (apply func args) ;; call flycheck-list-errors
            (unless flycheck-buffer
              (flycheck-error-list-goto-first-error))))

        (advice-add 'flycheck-list-errors :around #'flycheck-list-errors--goto-first-error)

        (general-define-key
          :keymaps 'flycheck-error-list-mode-map
          :states  'motion
          "RET" 'flycheck-error-list-goto-error
          "s" 'tabulated-list-sort

          "J"   'flycheck-error-list-next-error
          "K"   'flycheck-error-list-previous-error
          "C-j" 'flycheck-error-list-next-error
          "C-k" 'flycheck-error-list-previous-error

          "gs" 'flycheck-error-list-check-source
          "gg" 'flycheck-error-list-goto-first-error
          "G"  'flycheck-error-list-goto-last-error)

        (mohkale/set-leader-keys-for-major-mode 'flycheck-error-list-mode
          "e" 'flycheck-error-list-explain-error
          "s" 'flycheck-error-list-check-source ;; syntax check buffer
          "f" 'flycheck-error-list-set-filter
          "F" 'flycheck-error-list-reset-filter))

      (use-package flycheck-pos-tip
        :ensure t
        :defer  t
        :hook (flycheck-mode-hook . flycheck-pos-tip-mode)
        :commands flycheck-pos-tip-mode)
    #+END_SRC

*** font-lock-studio
    #+BEGIN_SRC emacs-lisp
      (use-package font-lock-studio
        :ensure t
        :defer  t
        :commands font-lock-studio)
    #+END_SRC

*** frog-jump-buffer
    #+BEGIN_SRC emacs-lisp
      (use-package frog-jump-buffer
        :ensure t
        :defer  t
        :commands frog-jump-buffer
        :init
        (mohkale/set-leader-keys
          "jb" 'frog-jump-buffer))
    #+END_SRC


*** grep
    #+BEGIN_SRC emacs-lisp
      (use-package grep
        :defer t
        :config
        (evil-set-initial-state 'grep-mode 'motion)
        (mohkale/set-compilation-bindings 'grep-mode 'grep-mode-map))
    #+END_SRC

*** help
    #+BEGIN_SRC emacs-lisp
      (use-package help
        :config
        ;; once was enough, stop repeating the same message please :P
        (advice-add 'help-window-display-message :around #'ignore))
    #+END_SRC

*** help-fns+
    #+BEGIN_SRC emacs-lisp
      (use-package help-fns+
        :defer t
        :commands (describe-buffer
                   describe-keymap
                   describe-mode
                   describe-function)
        :init
        (mohkale/declare-prefix "hdm" "describe-mode")
        (mohkale/set-leader-keys
          "hdm" 'describe-buffer
          "hdf" 'describe-function
          "hdK" 'describe-keymap))
    #+END_SRC

*** hide-comnt
    toggles the display of comments in the current buffer.
    #+BEGIN_SRC emacs-lisp
      (use-package hide-comnt
        :ensure nil
        :defer  t
        :commands hide/show-comments-toggle
        :init
        (mohkale/set-leader-keys
          "th" 'hide/show-comments-toggle))
    #+END_SRC

*** hl-line
    #+BEGIN_SRC emacs-lisp
      (use-package hl-line
        :ensure t
        :defer  t
        :commands (hl-line-mode
                   global-hl-line-mode)
        :hook ((text-mode prog-mode) . hl-line-mode))
    #+END_SRC

*** hl-todo
    #+BEGIN_SRC emacs-lisp
      (use-package hl-todo
        :ensure t
        :defer  t
        :hook ((text-mode prog-mode) . global-hl-todo-mode)
        :commands (hl-todo-mode
                   global-hl-todo-mode
                   hl-todo-next
                   hl-todo-previous
                   hl-todo-occur
                   hl-todo-insert
                   hl-todo-insert-keyword)
        :init
        (mohkale/set-leader-keys
          "jt" 'hl-todo-next
          "jT" 'hl-todo-previous
          "et" 'hl-todo-occur

          "it" 'hl-todo-insert
          "it" 'hl-todo-insert-keyword))
    #+END_SRC

*** htmlize
    #+BEGIN_SRC emacs-lisp
      (use-package htmlize
        :ensure t
        :defer  t)
    #+END_SRC

*** ivy
**** ivy
     #+BEGIN_SRC emacs-lisp
       (use-package ivy
         :ensure t
         :defer nil
         :config
         (ivy-mode +1)
         (setq ivy-height 15
               counsel-evil-registers-height 15
               ivy-use-virtual-buffers t
               projectile-completion-system 'ivy
               mohkale--ivy-initial-inputs-alist '((counsel-minor . "^+")
                                                   (counsel-package . "^+")
                                                   ;; (org-refile . "^")
                                                   (org-agenda-refile . "^")
                                                   (org-capture-refile . "^")
                                                   ;; (counsel-M-x . "^")
                                                   ;; (counsel-describe-function . "^")
                                                   ;; (counsel-describe-variable . "^")
                                                   ;; (counsel-org-capture . "^")
                                                   ;; (org-refile . "^")
                                                   ;; (org-agenda-refile . "^")
                                                   ;; (org-capture-refile . "^")
                                                   (Man-completion-table . "^")
                                                   (woman . "^"))
               ivy-initial-inputs-alist mohkale--ivy-initial-inputs-alist)

         (defun ivy-kill-line-backward ()
           (interactive)
           (delete-region (minibuffer-prompt-end) (point)))

         (defun ivy-forward-char-or-partial-or-done ()
           "move forward a character or complete selection
       completes selection when there's no characters left to
       move forward."
           (interactive)
           (call-interactively (if (eolp)
                                   'ivy-alt-done
                                 'forward-char)))

         (with-eval-after-load "persp-mode"
           ;; thanks https://gist.github.com/Bad-ptr/1aca1ec54c3bdb2ee80996eb2b68ad2d#file-persp-ivy-el
           (add-hook 'ivy-ignore-buffers
                     #'(lambda (b)
                         (when persp-mode
                           (let ((persp (get-current-persp)))
                             (if persp
                                 (not (persp-contain-buffer-p b persp))
                               nil)))))

           (setq ivy-sort-functions-alist
                 (append ivy-sort-functions-alist
                         '((persp-kill-buffer   . nil)
                           (persp-remove-buffer . nil)
                           (persp-add-buffer    . nil)
                           (persp-switch        . nil)
                           (persp-window-switch . nil)
                           (persp-frame-switch  . nil)))))

         (setq ivy-preferred-re-builders
               '((ivy--regex-plus         . "ivy")
                 (ivy--regex-ignore-order . "order")
                 (ivy--regex-fuzzy        . "fuzzy")
                 (regexp-quote            . "literal")))

         (general-define-key
           "M-x" 'counsel-M-x)

         (general-define-key
           :keymaps 'counsel-find-file-map
           ;; :predicate '(eq (point)
           ;;                 (minibuffer-prompt-end))
           "C-h" 'counsel-up-directory)

         (mohkale/set-leader-keys
           "bb" 'ivy-switch-buffer
           "SPC" 'counsel-M-x
           "`" 'ivy-resume)
         :bind* (:map ivy-minibuffer-map
                 ("C-j" . nil) ;; was ivy-alt-done
                 ("M-j" . nil) ;; was ivy-yank-word
                 ("M-v" . nil) ;; was ivy-scroll-down-command
                 ("C-v" . nil) ;; was ivy-scroll-up-command
                 ("C-'" . nil) ;; was ivy-avy

                 ("<return>" . ivy-alt-done) ;; also supports tramp expansion

                 ;;; misc
                 ("C-?" . describe-mode)
                 ("M-d" . kill-ring-save) ;; save all candidates to kill ring
                 ;; erase input, but start filtering from current candidates
                 ("S-SPC" . ivy-restrict-to-matches) ; also bound to M-SPC

                 ;;; selection execution
                 ;; exit with current input, not selection
                 ("<S-return>"   . ivy-immediate-done)
                 ("C-c <return>" . ivy-immediate-done)
                 ;; prompt for action, then done
                 ("C-<return>" . ivy-dispatching-done)
                 ;; invoke default action. but exit the minibuffer
                 ("M-<return>" . ivy-call)
                 ;; prompt for action, then call
                 ("C-M-<return>" . ivy-dispatching-call)
                 ;; move down, then call default action
                 ("C-M-j" . ivy-next-line-and-call)
                 ;; move down, then call default action
                 ("C-M-k" . ivy-previous-line-and-call)
                 ("<escape>" . minibuffer-keyboard-quit)

                 ;;; movement commands
                 ("C-a" . move-beginning-of-line)
                 ("C-e" . move-end-of-line)
                 ("C-h" . backward-char)
                 ("C-l" . ivy-forward-char-or-partial-or-done)
                 ("C-j" . next-line)
                 ("C-k" . previous-line)
                 ("C-q" . ivy-avy)
                 ;; arrow key variants
                 ("<left>"  . backward-char)
                 ("<right>" . forward-char)
                 ("<up>"    . previous-line)
                 ("<down>"  . next-line)
                 ;; suprisingly enough, these are bound correctly
                 ("C-d" . scroll-up-command)
                 ("C-u" . scroll-down-command)
                 ;; taken from helm, shadows C-o hydra-ivy/body
                 ("M-o" . beginning-of-buffer)
                 ("C-o" . end-of-buffer)

                 ;;; insertion/deletion
                 ;; complete current selection into minibuffer
                 ;; leave prompt active to build on it.
                 ("C-i" . ivy-insert-current)
                 ("C-DEL" . evil-delete-backward-word)
                 ;; pull word in from point at buffer
                 ("M-w" . ivy-yank-word)
                 ("C-w" . backward-kill-word)
                 ;; operate on entire input
                 ("M-k" . ivy-kill-line-backward)
                 ("M-K" . kill-line) ;; kill forward
                 ("C-M-k" . kill-whole-line)

                 ;;; history - (C-r/C-s still work fine)
                 ("<S-up>"    . ivy-previous-history-element)
                 ("<S-down>"  . ivy-next-history-element)

                 :map ivy-switch-buffer-map
                 ("C-k" . previous-line)
                 ("M-d" . ivy-switch-buffer-kill)

                 :map ivy-reverse-i-search-map
                 ("C-k" . previous-line)
                 ("C-d" . ivy-reverse-i-search-kill)))
     #+END_SRC

**** collapse directories
     see [[https://github.com/abo-abo/swiper/issues/2211][this]] link for a description of the problem which this addresses.
     I don't really need it for now so I'm not tangling.

     #+BEGIN_SRC emacs-lisp :tangle no
       (defvar mohkale/ivy-collapse-paths t
         "when true, empty directories are chained together.")

       (defvar mohkale/ivy-collapse-paths--append-files nil
         "when true, the only file in a directory is appended to
       that directory when shown by ivy. otherwise the directory
       is shown by itself.")

       (defun collapse-directories (path files &optional read-directories-command)
         "collapses any hollow directory files under PATH.
       a hollow directory is any directory which is either empty
       or has only one child which must be a file. depending on
       `mohkale/ivy-collapse-paths--append-files' that files is also
       appended to the path.

       if you'd like to specify you're own command for listing directories
       (or have aliased `directory-files' for your own purposes), you can
       specify the read-command as the final optional arg to this function."
         (or read-directories-command
             (setq read-directories-command #'directory-files))

         (mapcar
          (lambda (file)
            (when (and (ivy--dirname-p file)
                       (not (or (string-equal file "./")
                                (string-equal file "../"))))
              (let (dir-files file-count (do-recurse t))
                (ignore-errors ;; in case of permission errors
                  (while do-recurse
                    (setq dir-files  (funcall
                                      read-directories-command
                                      (concat path file)
                                      ;; all but . and ..
                                      nil "^[^\\.]\\{1,2\\}")
                          file-count (length dir-files))
                    (cond
                     ;; nothing left to recurse, end recursion
                     ((eq file-count 0) (setq do-recurse nil))
                     ;; at least one found, cancel unless directory
                     ((eq file-count 1)
                      (let* ((only-child (concat file (car dir-files))))
                        (if (file-directory-p (concat path only-child))
                            ;; include trailing / for identity purposes
                            (setq file (concat only-child "/"))
                          ;; encountered final leaf only-child, show if desired
                          (when mohkale/ivy-collapse-paths--append-files
                            (setq file only-child))
                          (setq do-recurse nil))))
                     ;; encountered non-hollow directory
                     (t (setq do-recurse nil)))))))
            file)
          files))

       (defun counsel-find-file--collapse-directories-wrapper (func dir)
         (if (not mohkale/ivy-collapse-paths)
             (apply func dir nil) ;; no collapsing, leave as is
           (cl-letf* (((symbol-function 'actual-directory-files)
                       (symbol-function 'directory-files))
                      ((symbol-function 'actual-read-file-name-internal)
                       (symbol-function 'read-file-name-internal))

                      ;; wrap `read-file-name-internal' and `directory-files'
                      ;; into collapsing directories when possible.
                      ((symbol-function 'read-file-name-internal)
                       (lambda (&rest args)
                         (collapse-directories default-directory
                                               (apply #'actual-read-file-name-internal args)
                                               #'actual-directory-files)))
                      ((symbol-function 'directory-files)
                       (lambda (dir)
                         (collapse-directories dir
                                               (mapcar
                                                ;; directory-files doesn't append / to dirs
                                                ;; so `ivy--dirname-p' won't work with them.
                                                (lambda (file)
                                                  (if (file-directory-p (concat dir file))
                                                      (setq file (concat file "/")))
                                                  file)
                                                (actual-directory-files dir))
                                               #'actual-directory-files))))
             (apply func dir nil))))

       (advice-add 'ivy--sorted-files :around #'counsel-find-file--collapse-directories-wrapper)
     #+END_SRC

**** counsel
     #+BEGIN_SRC emacs-lisp
       (use-package counsel
         :ensure t
         :defer  t
         :after  (ivy org)
         :diminish
         :commands (counsel-M-x
                    counsel-descbinds
                    counsel-describe-function
                    counsel-describe-variable
                    counsel-apropos
                    counsel-describe-face
                    counsel-faces
                    counsel-find-file
                    counsel-find-library
                    counsel-imenu
                    counsel-load-library
                    counsel-load-theme
                    counsel-yank-pop
                    counsel-esh-history
                    counsel-mark-ring
                    counsel-bookmark
                    counsel-company
                    counsel-compile
                    ;; counsel-dired ;; same as find-file
                    counsel-dired-jump
                    counsel-evil-registers
                    counsel-evil-marks
                    counsel-file-jump
                    counsel-file-register
                    counsel-fzf
                    ;; counsel-git...
                    counsel-git
                    counsel--find-file-1
                    counsel-git-change-work-tree
                    counsel-git-checkout
                    counsel-git-grep
                    counsel-git-grep-query-replace
                    counsel-git-grep-switch-cmd
                    counsel-git-log
                    counsel-git-stash
                    counsel-jedi
                    counsel-list-processes
                    counsel-outline
                    counsel-register
                    counsel-grep...
                    counsel-pt ;; WARN doesn't work
                    counsel-rg
                    counsel-ag
                    counsel-wmctrl
                    counsel-locate
                    counsel-unicode-char
                    counsel-info-lookup-symbol
                    counsel-recentf
                    counsel-mode)
         :init
         (setq counsel-find-file-occur-use-find t)

         (fset 'describe-bindings-buffer (symbol-function 'describe-bindings))
         (fset 'describe-bindings (symbol-function 'counsel-descbinds))

         (mohkale/declare-prefix*
           "r" "registers/rings/resume"
           "fs" "recursive-find")

         (mohkale/set-leader-keys-for-major-mode 'org-mode
           "gg" 'counsel-org-goto
           "gG" 'counsel-org-goto-all)

         (general-define-key
           :keymaps 'mohkale-window-map
           "w" 'counsel-wmctrl)

         (with-eval-after-load 'org
           (mohkale/set-leader-keys
             "oc" 'counsel-org-capture
             "oh" 'counsel-org-agenda-headlines))

         (mohkale/set-leader-keys
           "ic" 'counsel-unicode-char
           "ie" 'counsel-org-entity
           "Mm" 'counsel-major
           "MM" 'counsel-major

           "?"  'counsel-appropos
           "ry" 'counsel-yank-pop
           "rm" 'counsel-mark-ring
           "rn" 'counsel-evil-marks
           "rr" 'counsel-register
           "re" 'counsel-evil-registers
           "rf" 'counsel-file-registers
           "al" 'counsel-load-library
           "bO" 'counsel-outline

           "ff" 'counsel-find-file
           "fb" 'counsel-bookmark
           "fr" 'counsel-recentf
           "fsf" 'counsel-file-jump
           "fsd" 'counsel-dired-jump

           "ci" 'counsel-compile

           "sb" 'counsel-grep
           ;; recursive searches
           "sv" 'counsel-git-grep
           "sp" 'counsel-pt
           "sa" 'counsel-ag
           "sr" 'counsel-rg

           ;; "bb" 'counsel-buffer-or-recentf ;; WARN only file buffers
           "bb" 'counsel-switch-buffer
           "hdf" 'counsel-describe-function
           "hdv" 'counsel-describe-variable
           "hdB" 'describe-bindings-buffer)

         (general-define-key
           "C-M-y" 'counsel-yank-pop)
         :config
         (counsel-mode +1)
         ;; (push (cons 'counsel-evil-registers ivy-height) ivy-height-alist)
         (setq counsel-evil-registers-height ivy-height
               counsel-find-file-ignore-regexp "\\.#.+"
               ivy-initial-inputs-alist mohkale--ivy-initial-inputs-alist)

         :bind* (:map company-mode-map
                 ("C-:" . counsel-company)
                 :map counsel-describe-map
                 ("C-." . hydra-ivy/body)
                 ("C-S-." . counsel-find-symbol)))
     #+END_SRC

**** ivy-hydra
     #+BEGIN_SRC emacs-lisp
       (use-package ivy-hydra
         :ensure t
         :defer  t
         ;; :after  counsel
         :commands hydra-ivy/body
         :config
         (when (autoloadp (symbol-function 'hydra-ivy-custom/body))
           (autoload-do-load (symbol-function 'hydra-ivy-custom/body)))
         :bind* (:map ivy-minibuffer-map
                 ("C-." . hydra-ivy/body)))
     #+END_SRC

**** swiper
     #+BEGIN_SRC emacs-lisp
       (use-package swiper
         :ensure t
         :defer  t
         :commands (swiper-query-replace
                    swiper-all-query-replace
                    swiper-avy
                    ;; swiper-mc
                    swiper-recenter-top-bottom
                    swiper
                    swiper-backward
                    swiper-thing-at-point
                    swiper-all-thing-at-point
                    swiper-toggle-face-matching
                    swiper-from-isearch
                    swiper-multi
                    swiper-all
                    swiper-isearch-thing-at-point
                    swiper-isearch
                    swiper-isearch-backward
                    swiper-isearch-toggle)
         :init
         (mohkale/set-leader-keys
           "ss" 'swiper)
         :config
         (setq swiper-min-highlight 50000000) ;; never highlight
         :bind (:map swiper-map
                ("C-q" . nil)
                ("C-l" . ivy-forward-char-or-partial-or-done)
                ("C-q" . swiper-avy)
                ("C-s" . swiper-query-replace)))
     #+END_SRC

**** ivy-yasnippet
     #+BEGIN_SRC emacs-lisp
       (use-package ivy-yasnippet
         :ensure t
         :defer  t
         :commands ivy-yasnippet
         :init
         (mohkale/set-leader-keys
           "is" 'ivy-yasnippet)
         (general-define-key
           :states 'insert
           "C-M-i" 'ivy-yasnippet))
     #+END_SRC

**** counsel-pydoc
     #+BEGIN_SRC emacs-lisp
       (use-package counsel-pydoc
         :ensure t
         :defer  t
         :commands counsel-pydoc
         :init
         (mohkale/set-leader-keys-for-major-mode 'python-mode
           "hd" 'counsel-pydoc))
     #+END_SRC

**** counsel-ggtags
     #+BEGIN_SRC emacs-lisp
       (use-package counsel-gtags
         :ensure t
         :defer  t
         :commands (counsel-gtags-find-definition
                    counsel-gtags-find-reference
                    counsel-gtags-find-symbol
                    counsel-gtags-find-file
                    counsel-gtags-go-backward
                    counsel-gtags-go-forward
                    counsel-gtags-create-tags
                    counsel-gtags-update-tags
                    counsel-gtags-dwim)
         :init
         (mohkale/set-leader-keys
           "Tg" 'counsel-gtags-find-definition
           "TG" 'counsel-gtags-find-reference
           "Ts" 'counsel-gtags-find-symbol
           "Tf" 'counsel-gtags-find-file
           "Tn" 'counsel-gtags-go-forward
           "TN" 'counsel-gtags-go-backward
           "Tc" 'counsel-gtags-create-tags
           "Tu" 'counsel-gtags-update-tags
           "TT" 'counsel-gtags-dwim))
     #+END_SRC

**** helm-make
     contrary to what I initially thought, helm-make can also be used with ivy. Maybe should be named something else.

     #+BEGIN_SRC emacs-lisp
       (use-package helm-make
         :ensure t
         :defer  t
         :commands (helm-make
                    helm-make-projectile)
         :init
         (setq helm-make-completion-method 'ivy)
         (mohkale/set-leader-keys
           "c SPC" 'helm-make-projectile
           "cm"    'helm-make))
     #+END_SRC

**** flx
     optimizes ivy search ordering for fuzzy searches.

     #+BEGIN_SRC emacs-lisp
       (use-package flx
         :ensure t
         :defer  t)
     #+END_SRC

**** smex
     show recently accessed commands at the top of M-x.

     #+BEGIN_SRC emacs-lisp
       (use-package smex
         :ensure t
         :defer  t)
     #+END_SRC

*** ibuffer
**** ibuffer
     #+BEGIN_SRC emacs-lisp
       (use-package ibuffer
         :defer t
         :commands (ibuffer)
         :init
         (mohkale/set-leader-keys
           "bm" 'ibuffer)
         :config
         (evil-set-initial-state 'ibuffer-mode 'motion)

         (setq mohkale-ibuffer-filter-map (make-sparse-keymap))

         (general-define-key
           :keymaps 'mohkale-ibuffer-filter-map
           "TAB"    'ibuffer-exchange-filters
           "RET"    'ibuffer-filter-by-mode
           "!"      'ibuffer-negate-filter
           "&"      'ibuffer-and-filter
           "*"      'ibuffer-filter-by-starred-name
           "."      'ibuffer-filter-by-file-extension
           "/"      'ibuffer-filter-disable
           "<"      'ibuffer-filter-by-size-lt
           ">"      'ibuffer-filter-by-size-gt
           "D"      'ibuffer-decompose-filter-group
           "M"      'ibuffer-filter-by-derived-mode
           "P"      'ibuffer-pop-filter-group
           "R"      'ibuffer-switch-to-saved-filter-groups
           "S"      'ibuffer-save-filter-groups
           "X"      'ibuffer-delete-saved-filter-groups
           "\\"     'ibuffer-clear-filter-groups
           "a"      'ibuffer-add-saved-filters
           "b"      'ibuffer-filter-by-basename
           "c"      'ibuffer-filter-by-content
           "d"      'ibuffer-decompose-filter
           "e"      'ibuffer-filter-by-predicate
           "f"      'ibuffer-filter-by-filename
           "g"      'ibuffer-filters-to-filter-group
           "("      'ibuffer-filters-to-filter-group
           "i"      'ibuffer-filter-by-modified
           "m"      'ibuffer-filter-by-used-mode
           "n"      'ibuffer-filter-by-name
           "o"      'ibuffer-or-filter
           "p"      'ibuffer-pop-filter
           "r"      'ibuffer-switch-to-saved-filters
           "s"      'ibuffer-save-filters
           "t"      'ibuffer-exchange-filters
           "v"      'ibuffer-filter-by-visiting-file
           "x"      'ibuffer-delete-saved-filters
           "|"      'ibuffer-or-filter
           "<S-up>" 'ibuffer-pop-filter-group
           "<up>"   'ibuffer-pop-filter)

         (mohkale/declare-prefix-for-major-mode* 'ibuffer-mode
           "G" "jump/goto"
           "m" "mark"
           "/" "filter")

         (mohkale/set-leader-keys-for-major-mode 'ibuffer-mode
           ;; unbound:
           ;;  * ibuffer-do-print
           "1"   'ibuffer-visit-buffer-1-window
           "+"   'ibuffer-add-to-tmp-show
           "-"   'ibuffer-add-to-tmp-hide
           "."   'hydra-ibuffer/body
           "/"    mohkale-ibuffer-filter-map
           "RET" 'ibuffer-do-view-horizontally
           "A"   'ibuffer-auto-mode
           "E"   'ibuffer-do-view-and-eval
           "e"   'ibuffer-do-eval
           "R"   'ibuffer-redisplay
           "r"   'ibuffer-do-rename-uniquely
           "S"   'ibuffer-do-query-replace
           "s"   'ibuffer-do-save
           ;; "s"   'ibuffer-do-replace-regexp
           "T"   'ibuffer-visit-tags-table
           "f"   'ibuffer-find-file
           "g"   'ibuffer-jump-to-buffer
           "Gb"  'ibuffer-jump-to-buffer
           "Gf"  'ibuffer-jump-to-filter-group
           "|"   'ibuffer-do-shell-command-pipe-replace
           "~"   'ibuffer-do-toggle-modified

           "mm" 'ibuffer-toggle-marks
           "m/" 'ibuffer-mark-by-file-name-regexp
           ;; "m M-/" 'ibuffer-mark-by-name-regexp
           "mo" 'ibuffer-mark-old-buffers
           "ml" 'ibuffer-mark-by-locked
           "mb" 'ibuffer-mark-by-content-regexp
           "mM" 'ibuffer-mark-by-mode-regexp
           "md" 'ibuffer-mark-dired-buffers
           "mh" 'ibuffer-mark-help-buffers
           "mn" 'ibuffer-mark-dissociated-buffers
           "mN" 'ibuffer-mark-unsaved-buffers
           "m*" 'ibuffer-mark-modified-buffers
           "ms" 'ibuffer-mark-special-buffers
           "m%" 'ibuffer-mark-read-only-buffers
           "mz" 'ibuffer-mark-compressed-file-buffers)

         (general-define-key
           :keymaps 'ibuffer-mode-map
           "+"                nil
           "-"                nil
           "0"                nil
           "f"                nil
           "SPC"              nil
           "S-SPC"            nil
           ">"                nil
           "<"                nil
           "?"                nil
           "h"                nil
           "X"                nil
           "F"                nil
           "C-d"              nil
           "C-t"              nil
           "b"                nil
           "n"                nil
           "g"                nil
           "p"                nil
           "w"                nil
           "s"                nil
           "`"                nil
           ","                nil
           "*"                nil
           "/"                nil
           "A"                nil
           "C-c"              nil
           "C-x"              nil
           "M-s"              nil
           "M-g"              nil
           "M-n"              nil
           "M-p"              nil
           "M-{"              nil
           "M-}"              nil
           "M-o"              nil
           "M-DEL"            nil
           "%"                nil)

         (general-define-key
           :keymaps 'ibuffer-mode-map
           :states  'motion
           "TAB"       'ibuffer-forward-filter-group
           "<S-tab>"   'ibuffer-backward-filter-group
           "<backtab>" 'ibuffer-backward-filter-group
           ;; "D" 'ibuffer-mark-for-delete-backwards
           "D"       'ibuffer-do-delete
           "M"       'ibuffer-do-toggle-modified
           "="       'ibuffer-diff-with-file
           "o"       'ibuffer-visit-buffer-other-window
           "M-o"     'ibuffer-visit-buffer-other-frame
           "M-RET"   'ibuffer-visit-buffer-other-window-noselect
           "RET"     'ibuffer-visit-buffer
           "O"       'ibuffer-do-occur
           "gr"      'ibuffer-update
           "gR"      'ibuffer-do-revert
           "gs"      'ibuffer-do-save
           ;; "R" 'ibuffer-do-revert
           "R"       'ibuffer-do-toggle-read-only
           "r"       'ibuffer-change-marks
           "S"       'ibuffer-toggle-sorting-mode
           "sa"      'ibuffer-do-sort-by-alphabetic
           "sf"      'ibuffer-do-sort-by-filename/process
           "si"      'ibuffer-invert-sorting
           "sm"      'ibuffer-do-sort-by-major-mode
           "ss"      'ibuffer-do-sort-by-size
           "sr"      'ibuffer-do-sort-by-recency
           "v"       'ibuffer-do-view
           "V"       'ibuffer-do-view-other-frame
           "("       'ibuffer-switch-format
           "p"       'ibuffer-yank
           "C-y"     'ibuffer-yank
           "C-/"      mohkale-ibuffer-filter-map
           "C-j"     'ibuffer-forward-line
           "C-k"     'ibuffer-backward-line
           "M-j"     'ibuffer-forward-filter-group
           "M-k"     'ibuffer-backward-filter-group
           "C-S-J"   'ibuffer-forward-next-marked
           "C-S-K"   'ibuffer-backwards-next-marked
           "C-M-S-k" 'ibuffer-do-kill-lines
           "C-M-d"   'ibuffer-do-kill-lines
           "C-M-k"   'ibuffer-kill-line
           "M-d"     'ibuffer-kill-line
           "S-DEL"   'ibuffer-bury-buffer
           ;; "C-s" 'ibuffer-do-isearch
           "C-s"     'ibuffer-do-isearch-regexp
           "yn"      'ibuffer-copy-buffername-as-kill)

         ;;; https://www.emacswiki.org/emacs/IbufferMode
         ;;  _                                                          _       _     _
         ;; | |__  _   _ _ __ ___   __ _ _ __        _ __ ___  __ _  __| | __ _| |__ | | ___
         ;; | '_ \| | | | '_ ` _ \ / _` | '_ \ _____| '__/ _ \/ _` |/ _` |/ _` | '_ \| |/ _ \
         ;; | | | | |_| | | | | | | (_| | | | |_____| | |  __/ (_| | (_| | (_| | |_) | |  __/
         ;; |_| |_|\__,_|_| |_| |_|\__,_|_| |_|     |_|  \___|\__,_|\__,_|\__,_|_.__/|_|\___|
         ;;

         (defun ibuffer--human-readable-file-sizes-to-bytes (string)
           "Convert a human-readable file size into bytes."
           ;; (interactive)
           (let ((decimal (string-to-number string)))
             (cond
              ((string-suffix-p "G" string t) (* 1000000000 decimal))
              ((string-suffix-p "M" string t) (* 1000000    decimal))
              ((string-suffix-p "K" string t) (* 1000       decimal))
              (t                                            decimal))))

         (defun ibuffer--bytes-to-human-readable-file-sizes (bytes)
           "Convert number of bytes to human-readable file size."
           ;; (interactive)
           (cond
            ((> bytes 1000000000) (format "%10.1fG" (/ bytes 1000000000.0)))
            ((> bytes 100000000)  (format "%10.0fM" (/ bytes 1000000.0)))
            ((> bytes 1000000)    (format "%10.1fM" (/ bytes 1000000.0)))
            ((> bytes 100000)     (format "%10.0fk" (/ bytes 1000.0)))
            ((> bytes 1000)       (format "%10.1fk" (/ bytes 1000.0)))
            (t                    (format "%10d"       bytes))))

         ;; Use human readable Size column instead of original one
         (define-ibuffer-column size-human-readable
           (:name "Size"
            :inline t
            :summarizer
            (lambda (column-strings)
              (let ((total 0))
                (dolist (string column-strings)
                  (setq total
                        ;; like, ewww ...
                        (+ (float (ibuffer--human-readable-file-sizes-to-bytes
                                   string))
                           total)))
                (ibuffer--bytes-to-human-readable-file-sizes total))))
           (ibuffer--bytes-to-human-readable-file-sizes (buffer-size)))

         (setq ibuffer-formats
               `((mark modified read-only locked
                       " "
                       (name 20 20 :left :elide)
                       " "
                       (size-human-readable 11 -1 :right)
                       " "
                       (mode 16 16 :left :elide)
                       " " filename-and-process)
                 (mark " "
                       (name 20 20)
                       " "
                       filename))))
     #+END_SRC

**** ibuffer-vc
     #+BEGIN_SRC emacs-lisp
      (use-package ibuffer-vc
        :ensure t
        :defer  t
        :after ibuffer
        :commands (ibuffer-vc-set-filter-groups-by-vc-root)
        :init
        (defalias 'ibuffer-vc #'ibuffer-vc-set-filter-groups-by-vc-root)

        (general-define-key
          :keymaps 'ibuffer-mode-map
          "sv" 'ibuffer-vc))
     #+END_SRC

**** ibuffer-tramp
     #+BEGIN_SRC emacs-lisp
      (use-package ibuffer-tramp
        :ensure t
        :defer  t
        :after ibuffer
        :commands (ibuffer-tramp-set-filter-groups-by-tramp-connection)
        :init
        (defalias 'ibuffer-tramp #'ibuffer-tramp-set-filter-groups-by-tramp-connection)
        (general-define-key
          :keymaps 'ibuffer-mode-map
          "s@" 'ibuffer-tramp))
     #+END_SRC

**** ibuffer-persp
     #+BEGIN_SRC emacs-lisp
       (use-package ibuffer-persp
         ;; :ensure t
         :defer  t
         :commands (ibuffer-persp ;; only buffers from current perspective
                    ibuffer-persp-set-filter-groups-by-persp-name-not-nil
                    ibuffer-persp-set-filter-groups-by-other-persp-name-not-nil)
         :init
         (defalias 'ibuffer-persp-current #'ibuffer-persp-set-filter-groups-by-persp-name-not-nil)
         (defalias 'ibuffer-persp-other #'ibuffer-persp-set-filter-groups-by-other-persp-name-not-nil)
         (general-define-key
           :keymaps 'ibuffer-mode-map
           "sp" 'ibuffer-persp-current
           "sP" 'ibuffer-persp-other)

         ;; (with-eval-after-load 'persp-mode
         ;;   (mohkale/set-leader-keys "bm" 'ibuffer-persp))
         )
     #+END_SRC

*** imenu
    #+BEGIN_SRC emacs-lisp
      (use-package imenu
        :defer t
        :commands imenu
        :init
        (mohkale/set-leader-keys
          "ji" 'imenu))

      (use-package imenu-list
        :ensure t
        :defer  t
        :commands imenu-list
        :init
        (mohkale/set-leader-keys
          "Mi" 'imenu-list))
          "MI" 'imenu

      (use-package imenu-anywhere
        :ensure t
        :defer  t
        :commands imenu-anywhere
        :init
        (mohkale/set-leader-keys
          "jI" 'imenu-anywhere))
    #+END_SRC

*** isearch
    prefer evil search over isearch
    #+BEGIN_SRC emacs-lisp
      ;; (use-package isearch
      ;;   ;; TODO look into more bindings
      ;;   :bind (:map isearch-mode-map
      ;;          ("DEL" . isearch-delete-char)))
    #+END_SRC

*** ein - emacs-ipython-notebook
    #+BEGIN_SRC emacs-lisp
      (use-package ein
        :ensure t
        :defer  t
        :init
        (with-eval-after-load 'org
          (push '(ein . t) org-babel-load-languages))
        :config
        (defun evil-write--ein-save-buffer (&rest args)
          (when (derived-mode-p 'ein:notebook-mode 'ein:notebook-multilang-mode)
            (call-interactively 'ein:notebook-save-notebook-command)
            t))

        (advice-add 'evil-write :before-until #'evil-write--ein-save-buffer)

        (mohkale/set-leader-keys-for-major-mode 'ein:notebooklist-mode
          "f" 'ein:file-open
          "n" 'ein:notebook-open
          "r" 'ein:notebooklist-reload)

        (general-define-key
          :keymaps 'ein:notebooklist-mode-map
          "gr" 'ein:notebooklist-reload
          "<S-tab>"   'widget-backward
          "<backtab>" 'widget-backward
          "TAB"       'widget-forward
          "<tab>"     'widget-forward

          "gn" 'ein:notebooklist-next-item
          "gN" 'ein:notebooklist-prev-item
          "gp" 'ein:notebooklist-prev-item)

        (dolist (mode '(ein:notebook-mode ein:notebook-multilang-mode))
          (mohkale/set-leader-keys-for-major-mode mode
            "." 'hydra-ein/body
            "'" 'ein:edit-cell-contents
            mohkale-major-mode-leader-key 'ein:worksheet-execute-cell

            "c" 'ein:notebook-close
            "f" 'ein:file-open
            "F" 'ein:notebook-open
            "i" 'ein:inspect-object
            "m" 'ein:pytools-request-tooltip-or-help
            "o" 'ein:worksheet-toggle-output
            "p" 'ein:worksheet-yank-cell
            "r" 'ein:notebook-rename-command
            "R" 'ein:notebook-restart-session-command
            ;; "R" 'ein:notebook-reconnect-session-command
            "s" 'ein:notebook-scratchsheet-open
            "w" 'ein:notebook-save-notebook-command
            "y" 'ein:worksheet-copy-cell

            "ts" 'ein:worksheet-toggle-slide-type
            "tc" 'ein:worksheet-toggle-cell-type
            "tC" 'ein:worksheet-change-cell-type
            "gg" 'ein:pytools-jump-to-source-command
            "gb" 'ein:pytools-jump-back-command
            "dc" 'ein:worksheet-kill-cell
            "do" 'ein:worksheet-clear-output
            "dO" 'ein:worksheet-clear-all-output
            "dk" 'ein:notebook-kill-kernel-then-close-command
            "dz" 'ein:notebook-kernel-interrupt-command

            "TAB" 'ein:completer-complete))

        (general-define-key
          :keymaps 'ein:notebook-mode-map
          "<C-down>" nil
          "<C-up>"   nil

          "<C-return>" 'ein:worksheet-execute-cell
          "<S-return>" 'ein:worksheet-execute-cell-and-goto-next)

        (general-define-key
          :keymaps 'ein:notebook-mode-map
          :states  mohkale-norm-states
          "go" 'ein:worksheet-insert-cell-above
          "gO" 'ein:worksheet-insert-cell-below
          "gJ" 'ein:worksheet-merge-cell
          "gs" 'ein:worksheet-split-cell-at-point
          "gj" 'ein:worksheet-goto-next-input
          "gk" 'ein:worksheet-goto-prev-input
          "gc" 'ein:worksheet-kill-cell)

        (general-define-key
          :keymaps 'ein:notebook-multilang-mode-map
          "<M-down>" 'ein:worksheet-move-cell-down
          "<M-up>"   'ein:worksheet-move-cell-up))
    #+END_SRC

*** lorem-ipsum
    #+BEGIN_SRC emacs-lisp
      (use-package lorem-ipsum
        :ensure nil
        :defer  t
        :commands (Lorem-ipsum-insert-list
                   Lorem-ipsum-insert-paragraphs
                   Lorem-ipsum-insert-sentences)
        :init
        (mohkale/declare-prefix "il" "lorem-ipsum")

        (mohkale/set-leader-keys
          "ill" 'Lorem-ipsum-insert-list
          "ilp" 'Lorem-ipsum-insert-paragraphs
          "ils" 'Lorem-ipsum-insert-sentences))
    #+END_SRC

*** language-server
**** lsp-mode
     #+BEGIN_SRC emacs-lisp
       (use-package lsp-mode
         :ensure t
         :defer  t
         :commands (lsp lsp-deferred lsp-mode) ;; never use lsp-mode, use lsp.
         :config
         ;; (push 'company-lsp company-backends)

         (setq lsp-enable-snippet             nil
               lsp-enable-symbol-highlighting nil)

         (mohkale/declare-prefix-for-mode* 'lsp-mode
           "yw" "workspaces"
           "yl" "lens"
           "yr" "refactor"
           "yg" "goto")

         (mohkale/set-leader-keys-for-minor-mode 'lsp-mode
           "y?" 'lsp-describe-session
           "y|" 'lsp-describe-thing-at-point
           "ye" 'lsp-execute-code-action
           "yh" 'lsp-document-highlight
           "ywR" 'lsp-restart-workspace
           "ywa" 'lsp-workspace-folders-add
           "ywr" 'lsp-workspace-folders-remove
           "yws" 'lsp-workspace-folders-switch
           "y <backspace>" 'lsp-disconnect

           "yll" 'lsp-lens-mode
           "yls" 'lsp-lens-show
           "ylh" 'lsp-lens-hide

           "yrr" 'lsp-format-buffer
           "yri" 'lsp-organize-imports
           "yrc" 'lsp-rename

           "ygg" 'lsp-goto-type-definition
           "ygG" 'lsp-goto-implementation
           "ygF" 'lsp-find-implementation
           "ygf" 'lsp-find-type-definition))
     #+END_SRC

***** lsp-ui
      #+BEGIN_SRC emacs-lisp
        (use-package lsp-ui
          :ensure t
          :defer  t
          ;; :hook (lsp-mode-hook . lsp-ui-mode)
          :commands (lsp-ui-mode)
          :init
          ;; only really installed for flycheck support
          (setq lsp-prefer-flymake nil
                lsp-ui-sideline-enable nil
                lsp-ui-doc-enable nil)
          :config
          (mohkale/declare-prefix-for-mode 'lsp-mode
            "yp" "peek")
          (mohkale/set-leader-keys-for-minor-mode 'lsp-mode
            "pg" 'lsp-ui-peek-find-definitions
            "pG" 'lsp-ui-peek-find-definitions))
      #+END_SRC

***** company-lsp
      #+BEGIN_SRC emacs-lisp
        (use-package company-lsp
          :ensure t
          :defer  t
          :commands company-lsp
          :config
          ;; reduces write lag
          (setq company-lsp-cache-candidates t))
      #+END_SRC

***** lsp-haskell
      #+BEGIN_SRC emacs-lisp
        (use-package lsp-haskell
          :ensure t
          :defer  t
          :hook ((haskell-mode . lsp) ;; order of evaluation matters
                 (haskell-mode . (lambda ()
                                   (require 'lsp-haskell)
                                   ;; until there's actually any useful info
                                   (setq-local lsp-eldoc-enable-hover nil))))
          :config
          (setq lsp-haskell-process-args-hie (list "-d" "-l" (make-temp-file "hie." nil ".log")))

          ;;  _   _    _    ____ _  __       _     _            _ _ _
          ;; | | | |  / \  / ___| |/ /   ___| | __| | ___   ___| | | |
          ;; | |_| | / _ \| |   | ' /   / _ \ |/ _` |/ _ \ / __| | | |
          ;; |  _  |/ ___ \ |___| . \  |  __/ | (_| | (_) | (__|_|_|_|
          ;; |_| |_/_/   \_\____|_|\_\  \___|_|\__,_|\___/ \___(_|_|_)
          ;;

          ;; thank you @ walseb: https://github.com/walseb/QualityEmacsConfig#hack-in-eldoc-support
          ;; (setq my/haskell-lsp-eldoc-entries '())

          ;; ;; This function modifies what's displayed in lsp-ui-sideline.
          ;; ;; Here it is redefined so that it takes what's supposed to be displayed in the sideline,
          ;; ;; and instead sends it to an eldoc cache.
          ;; (defun lsp-ui-sideline--push-info (symbol tag bounds info bol eol)
          ;;   (when (and (= tag (lsp-ui-sideline--calculate-tag))
          ;;              (not (lsp-ui-sideline--stop-p)))
          ;;     (let* ((info (concat (thread-first (gethash "contents" info)
          ;;                            lsp-ui-sideline--extract-info
          ;;                            lsp-ui-sideline--format-info)))
          ;;            (current (and (>= (point) (car bounds)) (<= (point) (cdr bounds)))))
          ;;       (when (and (> (length info) 0)
          ;;                  (lsp-ui-sideline--check-duplicate symbol info))
          ;;         (let* ((final-string (lsp-ui-sideline--make-display-string info symbol current))
          ;;                (pos-ov (lsp-ui-sideline--find-line (length final-string) bol eol))
          ;;                (ov (when pos-ov (make-overlay (car pos-ov) (car pos-ov)))))

          ;;           ;; My changes:
          ;;           (let ((final-string-formatted (substring-no-properties final-string)))
          ;;             (add-to-list 'my/haskell-lsp-eldoc-entries final-string-formatted))

          ;;           (when pos-ov
          ;;             ;; (overlay-put ov 'info info)
          ;;             ;; (overlay-put ov 'symbol symbol)
          ;;             (overlay-put ov 'bounds bounds)
          ;;             (overlay-put ov 'current current)
          ;;             ;;(overlay-put ov 'after-string final-string)
          ;;             (overlay-put ov 'window (get-buffer-window))
          ;;             (overlay-put ov 'kind 'info)
          ;;             (push ov lsp-ui-sideline--ovs)))))))

          ;; (defun lsp-ui-sideline--push-info (symbol tag bounds info bol eol)
          ;;   (when (and (= tag (lsp-ui-sideline--calculate-tag))
          ;;              (not (lsp-ui-sideline--stop-p)))
          ;;     (let* ((info (concat (thread-first (gethash "contents" info)
          ;;                            lsp-ui-sideline--extract-info
          ;;                            lsp-ui-sideline--format-info)))
          ;;            (current (and (>= (point) (car bounds)) (<= (point) (cdr bounds)))))
          ;;       (when (and (> (length info) 0)
          ;;                  (lsp-ui-sideline--check-duplicate symbol info))
          ;;         (let* ((final-string (lsp-ui-sideline--make-display-string info symbol current))
          ;;                (pos-ov (lsp-ui-sideline--find-line (length final-string) bol eol))
          ;;                (ov (when pos-ov (make-overlay (car pos-ov) (car pos-ov)))))
          ;;           (when pos-ov
          ;;             (overlay-put ov 'info info)
          ;;             (overlay-put ov 'symbol symbol)
          ;;             (overlay-put ov 'bounds bounds)
          ;;             (overlay-put ov 'current current)
          ;;             (overlay-put ov 'after-string final-string)
          ;;             (overlay-put ov 'window (get-buffer-window))
          ;;             (overlay-put ov 'kind 'info)
          ;;             (push ov lsp-ui-sideline--ovs)))))))

          ;; (defun my/haskell-lsp-eldoc-print ()
          ;;   (interactive)
          ;;   (when my/haskell-lsp-eldoc-entries
          ;;     (let ((at-point (thing-at-point 'symbol t)))
          ;;       (when at-point
          ;;         (let ((str (seq-find
          ;;                     (lambda (candidate)
          ;;                       (let ((candidate-last-word (string-match (rx (not whitespace) (regexp "*") space eol) candidate)))
          ;;                         (if candidate-last-word
          ;;                             (progn
          ;;                               (string=
          ;;                                (substring candidate candidate-last-word (- (length candidate) 1))
          ;;                                at-point))
          ;;                           nil)))
          ;;                     my/haskell-lsp-eldoc-entries)))

          ;;           (if str
          ;;               (s-trim str)
          ;;             nil))))))

          ;; ;; No idea why but eldoc doesn't run the documentation function unless I press escape, this fixes that
          ;; (add-hook 'haskell-mode-hook '(lambda ()
          ;;                                 (eldoc-mode -1)
          ;;                                 (setq-local eldoc-documentation-function 'my/haskell-lsp-eldoc-print)

          ;;                                 (add-hook 'post-command-hook
          ;;                                           'eldoc-print-current-symbol-info nil t)))
          )
      #+END_SRC

***** lsp-kotlin
      #+BEGIN_SRC emacs-lisp
        (add-hook 'kotlin-mode-hook 'lsp-mode)
      #+END_SRC

**** eglot
     seems cool, but the lack of good documentation and support for flycheck is off putting. Also doesn't seem to highlight errors using eldoc when possible, which is a feature I quite like from lsp-mode. Give it some time, check back again.

     #+BEGIN_SRC emacs-lisp :tangle no
       (use-package eglot
         :ensure t
         :defer  t
         :commands (eglot
                    eglot-format
                    eglot-format-buffer
                    eglot-rename
                    eglot-shutdown
                    eglot-reconnect
                    eglot-clear-status
                    eglot-code-actions
                    eglot-events-buffer
                    eglot-stderr-buffer
                    eglot-help-at-point
                    eglot-find-declaration
                    eglot-find-implementation
                    eglot-find-typeDefinition
                    eglot-forget-pending-continuations
                    eglot-signal-didChangeConfiguration)
         :init
         (defalias 'eglot-rename-symbol 'eglot-rename)
         :config
         (setq eglot-ignored-server-capabilites
               '(:documentHighlightProvider))

         ;; ;; add flycheck support: https://github.com/joaotavora/eglot/issues/195
         ;; (defvar-local eglot-flycheck--fc-callback nil)

         ;; (defun eglot-flycheck--point->line-col (buffer beg)
         ;;   (with-current-buffer buffer
         ;;     (save-excursion
         ;;       (goto-char beg)
         ;;       (cons (line-number-at-pos)
         ;;             (- (point)
         ;;                (line-beginning-position))))))

         ;; (defun eglot-flycheck--fm-error->fc-error (err)
         ;;   (pcase-let* ((msg (flymake--diag-text err))
         ;;                (beg (flymake--diag-beg err))
         ;;                (buffer (flymake--diag-buffer err))
         ;;                (`(,line . ,col) (eglot-flycheck--point->line-col buffer beg)))
         ;;     (flycheck-error-new-at
         ;;      line nil ;; TODO: use column and region
         ;;      (pcase (flymake--diag-type err)
         ;;        (':error 'error)
         ;;        (':warning 'warning)
         ;;        (':note 'info))
         ;;      msg
         ;;      :id "eglot-flycheck"
         ;;      ;; :checker
         ;;      :buffer buffer
         ;;      :filename (buffer-file-name buffer))))

         ;; (cl-defun eglot-flycheck--flymake-handle-result (flymake-errors &key region)
         ;;   (funcall eglot-flycheck--fc-callback
         ;;            'finished
         ;;            (mapcar #'eglot-flycheck--fm-error->fc-error flymake-errors)))

         ;; (cl-defun eglot-flycheck-checker (checker callback)
         ;;   (setq eglot-flycheck--fc-callback callback)
         ;;   (eglot-flymake-backend #'eglot-flycheck--flymake-handle-result))

         ;; (flycheck-define-generic-checker
         ;;  'eglot-checker
         ;;  "eglot flycheck checker"
         ;;  :start #'eglot-flycheck-checker
         ;;  :modes (eglot--all-major-modes))
         )
     #+END_SRC

**** server-installation-scripts
     #+NAME: server-install-path
     #+BEGIN_SRC emacs-lisp :results value :tangle no
       (expand-file-name "~/.emacs.d/var/lsp/servers")
     #+END_SRC

     #+NAME: set_shell_banner
     #+BEGIN_SRC emacs-lisp :var varname="BANNER" text="" width=80 char="@" :results value :tangle no
       (let* ((text-width (length text))
              (width (max width
                          (+ 4 text-width)))
              (header-string (make-string width
                                          (string-to-char char)))
              (pad-width (/ (- width 4 text-width)
                            2))
              (pad-string (make-string pad-width ? ))

              (banner (concat "\n"
                              char
                              " "
                              (unless (zerop (% text-width 2))
                                " ")
                              pad-string
                              text
                              pad-string
                              " "
                              char
                              "\n")))
         (format "%s='\n%s\n'"
                 varname
                 (concat header-string
                         banner
                         header-string)))
     #+END_SRC

***** kotlin-language-server
      :PROPERTIES:
      :header-args+: :tangle ~/.emacs.d/bin/install/kotlin-language-server.sh
      :END:

      #+BEGIN_SRC bash :shebang #!/usr/bin/bash
        <<set_shell_banner(varname="INSTALLATION_ALREADY_DONE_BANNER",text="kotlin language server already installed",char="#")>>
        <<set_shell_banner(varname="CLONING_LANGUAGE_SERVER_BANNER",text="cloning fwcd/kotlin-language-server",char="#")>>
        <<set_shell_banner(varname="CLONING_FAILED_BANNER",text="failed to clone repository, program terminated",char="*")>>
        <<set_shell_banner(varname="CLONING_ALREADY_DONE_BANNER",text="fwcd/kotlin-language-server already cloned",char="#")>>
        <<set_shell_banner(varname="RUNNING_GRADLE_BUILD_BANNER",text="running gradle build process",char="#")>>
        <<set_shell_banner(varname="GRADLE_BUILD_FAILED_BANNER",text="failed to build kotlin language server",char="*")>>
        <<set_shell_banner(varname="FINISHED_BANNER",text="finished installing the kotlin language server",char="*")>>

        DEST_PATH="<<server-install-path()>>/kotlin"
      #+END_SRC

      #+BEGIN_SRC bash
        if [ -f "${DEST_PATH}/bin/kotlin-language-server" ]; then
            echo "${INSTALLATION_ALREADY_DONE_BANNER}"
        else
            mkdir -p "${DEST_PATH}"
            pushd "${DEST_PATH}"

            CLONE_PATH="./.server"
            if [ ! -d "${CLONE_PATH}/.git" ]; then
                echo "${CLONING_LANGUAGE_SERVER_BANNER}"

                if ! git clone "https://github.com/fwcd/kotlin-language-server" "${CLONE_PATH}"; then
                    echo "${CLONING_FAILED_BANNER}"
                    exit 1
                fi
            else
                echo "${CLONING_ALREADY_DONE_BANNER}"
            fi

            echo "${RUNNING_GRADLE_BUILD_BANNER}"

            pushd "${CLONE_PATH}"
            if ! ./gradlew :server:installDist; then
                echo "${GRADLE_BUILD_FAILED_BANNER}"
                exit 2
            fi
            popd

            mv ${CLONE_PATH}/server/build/install/server/* ./
            rm -rf "${CLONE_PATH}"
            echo "${FINISHED_BANNER}"
        fi
      #+END_SRC

***** kotlin-debug-adapter
      :PROPERTIES:
      :header-args+: :tangle ~/.emacs.d/bin/install/kotlin-debug-adapter.sh
      :END:

      #+BEGIN_SRC bash :shebang #!/usr/bin/bash
        <<set_shell_banner(varname="INSTALLATION_ALREADY_DONE_BANNER",text="kotlin debug adapter already installed",char="#")>>
        <<set_shell_banner(varname="CLONING_DEBUG_ADAPTER_BANNER",text="cloning fwcd/kotlin-debug-adapter",char="#")>>
        <<set_shell_banner(varname="CLONING_FAILED_BANNER",text="failed to clone repository, program terminated",char="*")>>
        <<set_shell_banner(varname="CLONING_ALREADY_DONE_BANNER",text="fwcd/kotlin-debug-adapter already cloned",char="#")>>
        <<set_shell_banner(varname="RUNNING_GRADLE_BUILD_BANNER",text="running gradle build process",char="#")>>
        <<set_shell_banner(varname="GRADLE_BUILD_FAILED_BANNER",text="failed to build kotlin debug adapter",char="*")>>
        <<set_shell_banner(varname="INISHED_BANNER",text="finished installing the kotlin debug adapter",char="*")>>

        DEST_PATH="<<server-install-path()>>/kotlin/debugger"
      #+END_SRC

      #+BEGIN_SRC bash
        if [ -f "${DEST_PATH}/bin/kotlin-debug-adapter" ]; then
            echo "${INSTALLATION_ALREADY_DONE_BANNER}"
        else
            mkdir -p "${DEST_PATH}"
            pushd "${DEST_PATH}"

            CLONE_PATH="./.debugger"
            if [ ! -d "${CLONE_PATH}/.git" ]; then
                echo "${CLONING_DEBUG_ADAPTER_BANNER}"

                if ! git clone "https://github.com/fwcd/kotlin-debug-adapter" "${CLONE_PATH}"; then
                    echo "${CLONING_FAILED_BANNER}"
                    exit 1
                fi
            else
                echo "${CLONING_ALREADY_DONE_BANNER}"
            fi

            echo "${RUNNING_GRADLE_BUILD_BANNER}"

            pushd "${CLONE_PATH}"
            if ! ./gradlew :adapter:installDist; then
                echo "${GRADLE_BUILD_FAILED_BANNER}"
                exit 2
            fi
            popd

            mv ${CLONE_PATH}/adapter/build/install/adapter/* ./
            rm -rf "${CLONE_PATH}"
            echo "${FINISHED_BANNER}"
        fi
      #+END_SRC

***** haskell-ide-engine
      :PROPERTIES:
      :header-args+: :tangle ~/.emacs.d/bin/install/haskell-ide-engine.sh
      :END:

      if your install fails with exit code 251, you're computer ran out of memory during the install process. Simply close all running programs and try again. Warning: install can take upto an hour and over 3 GB of RAM.

      #+BEGIN_SRC bash :shebang #!/usr/bin/bash
        <<set_shell_banner(varname="INSTALLATION_ALREADY_DONE_BANNER",text="haskell IDE engine already installed",char="#")>>
        <<set_shell_banner(varname="CLONING_LANGUAGE_SERVER_BANNER",text="cloning haskell/haskell-ide-engine",char="#")>>
        <<set_shell_banner(varname="CLONING_FAILED_BANNER",text="failed to clone repository, program terminated",char="*")>>
        <<set_shell_banner(varname="CLONING_ALREADY_DONE_BANNER",text="haskell/haskell-ide-engine already cloned",char="#")>>
        <<set_shell_banner(varname="RUNNING_CABAL_INSTALL_BANNER",text="running cabal installer, you may wish to free some RAM",char="#")>>
        <<set_shell_banner(varname="CABAL_INSTALL_FAILED_BANNER",text="failed to build haskell IDE engine",char="*")>>
        <<set_shell_banner(varname="FAILED_TO_MOVE_AFTER_INSTALL_BANNER",text="could not find stack install directory for server move",char="*")>>
        <<set_shell_banner(varname="FINISHED_BANNER",text="finished installing the haskell IDE engine",char="*")>>

        DEST_PATH="<<server-install-path()>>/haskell"
      #+END_SRC

      #+BEGIN_SRC bash
        BUILD_TARGET="stack-hie-8.6.5"

        if [ -f "${DEST_PATH}/hie.exe" -o -f "${DEST_PATH}/hie" ]; then
            echo "${INSTALLATION_ALREADY_DONE_BANNER}"
        else
            mkdir -p "${DEST_PATH}"
            pushd "${DEST_PATH}"

            CLONE_PATH="./.hie"
            if [ ! -d "${CLONE_PATH}/.git" ]; then
                echo "${CLONING_LANGUAGE_SERVER_BANNER}"

                if ! git clone "https://github.com/haskell/haskell-ide-engine" "${CLONE_PATH}" --recurse-submodules; then
                    echo "${CLONING_FAILED_BANNER}"
                    exit 1
                fi
            else
                echo "${CLONING_ALREADY_DONE_BANNER}"
            fi

            echo "${RUNNING_CABAL_INSTALL_BANNER}"

            pushd "${CLONE_PATH}"
            if ! cabal v2-run ./install.hs --project-file install/shake.project -j1 --ghc-options="+RTS -M600M" "${BUILD_TARGET}"; then
                echo "${CABAL_INSTALL_FAILED_BANNER}"
                exit 2
            fi
            popd

            INSTALL_PATH="$(stack path --local-bin)"
            if [ $? -eq 0 ]; then
                find "${INSTALL_PATH}/" -maxdepth 1 -iname 'hie*' -print0 | xargs -0 -i% mv % ./
                rm -rf "${CLONE_PATH}"
                echo "${FINISHED_BANNER}"
            else
                echo "${FAILED_TO_MOVE_AFTER_INSTALL_BANNER}"
            fi
        fi
      #+END_SRC
*** macro/kmacro/edmacro
    #+BEGIN_SRC emacs-lisp
      (mohkale/declare-prefix*
        "k"  "macros/lisp"
        "kc" "counter")

      (mohkale/set-leader-keys
        "kk" 'eval-last-sexp
        "k(" 'eval-replace-last-sexp
        "k)" 'eval-print-last-sexp
        "ke" 'kmacro-edit-macro ;; last defined
        "kE" 'edit-kbd-macro ;; any named macro
        "ka" 'apply-macro-to-region-lines
        "kn" 'name-last-kbd-macro
        "ki" 'insert-kbd-macro
        "kp" 'kbd-macro-query ;; prompt at macro point
        "kq" 'kbd-macro-query ;; prompt at macro point
        "kb" 'kmacro-bind-to-key
        "kl" 'kmacro-edit-lossage ;; edit last 300 strokes as macro
        "kd" 'kmacro-step-edit-macro ;; debug last macro

        "kcs" 'kmacro-set-counter
        "kc=" 'kmacro-set-counter
        "kcc" 'kmacro-insert-counter
        "kci" 'kmacro-insert-counter
        "kca" 'kmacro-add-counter
        "kc+" 'kmacro-add-counter
        "kcf" 'kmacro-set-format)

      (use-package edmacro
        :defer t
        :commands (edmacro-mode)
        :config
        (mohkale/set-leader-keys-for-major-mode 'edmacro-mode
          "k," 'edmacro-finish-edit
          "ki" 'edmacro-insert-key))
    #+END_SRC

*** minibuffer
    #+BEGIN_SRC emacs-lisp
      (bind-keys :map minibuffer-local-map
                 ("C-h" . previous-matching-history-element)
                 ("C-j" . next-history-element)
                 ("C-k" . previous-history-element)
                 ("C-l" . next-matching-history-element)
                 ("C-a" . move-beginning-of-line)
                 ("C-e" . move-end-of-line)
                 ("C-q" . quoted-insert)
                 ("C-M-q" . quit-window)

                 ("C-w" . backward-kill-word)
                 ("C-?" . minibuffer-completion-help)
                 ;; for some reason.. I can't bind Meta keys
                 ("M-k" . kill-whole-line)
                 ("M-h" . backward-kill-sentence)
                 ("M-l" . kill-sentence)
                 ;; ("M-n" . nil)
                 ;; ("M-p" . nil)
                 ;; ("M-r" . nil)
                 ("<escape>" . abort-recursive-edit))

      (bind-keys :map minibuffer-local-must-match-map
                 ("<escape>" . abort-recursive-edit)
                 ("C-j" . nil)
                 ("TAB" . minibuffer-complete)
                 ("C-<tab>" . minibuffer-complete-and-exit))

      (bind-keys :map minibuffer-inactive-mode-map
                 ("<escape>" . abort-recursive-edit))

      (bind-keys :map minibuffer-local-ns-map
                 ("<escape>" . abort-recursive-edit))

      (bind-keys :map minibuffer-local-completion-map
                 ("<escape>" . abort-recursive-edit))
    #+END_SRC

*** miniedit
    #+BEGIN_SRC emacs-lisp
      (use-package miniedit
        :defer t
        :delight (miniedit-mode "MiniEdit")
        :commands (miniedit
                   miniedit-install
                   miniedit-install-for-xemacs
                   miniedit-introduction
                   miniedit-quick-start)
        :init
        (general-define-key
          :keymaps '(minibuffer-local-map
                     minibuffer-local-ns-map
                     minibuffer-local-completion-map
                     minibuffer-local-must-match-map)
          "C-M-<return>" 'miniedit)
        ;; ;; can't seem to change major mode without miniedit mode
        ;; ;; being removed :(
        ;; (add-hook 'miniedit-mode-hook initial-major-mode)
        :config
        (setq miniedit-show-help-p nil) ;; thanks... but no thanks

        (mohkale/set-leader-keys-for-minor-mode 'miniedit-mode
          (concat mohkale-major-mode-leader-prefix ",") 'exit-recursive-edit))
    #+END_SRC

*** occur
    #+BEGIN_SRC emacs-lisp
      (use-package replace
        :defer t
        :config
        ;; occur-mode-display-occurrence
        (advice-add 'occur-mode-display-occurrence :around
                    #'display-buffer--restore-default-actions)

        (dolist (mode '(occur-mode occur-edit-mode))
          (mohkale/set-leader-keys-for-major-mode mode
            "e" 'occur-edit-mode
            "R" 'occur-rename-buffer
            "g" 'occur-mode-goto-occurrence
            "G" 'occur-mode-goto-occurrence-other-window))

        (defun-evil-adjust-to-eol evil-adjust-occur-next (&optional prefix)
          (interactive "P")
          (occur-next prefix))

        (defun-evil-adjust-to-eol evil-adjust-occur-prev (&optional prefix)
          (interactive "P")
          (occur-prev prefix))

        (evil-set-initial-state 'occur-mode 'motion)
        (general-define-key
          :keymaps 'occur-mode-map
          :states  'motion
          ;; occur-mode-mouse-goto
          "RET" 'occur-mode-goto-occurrence
          "o" 'occur-mode-goto-occurrence-other-window
          "s" 'occur-mode-display-occurrence

          "j"  'evil-adjust-occur-next
          "k"  'evil-adjust-occur-prev
          "gj" 'evil-next-line
          "gk" 'evil-previous-line

          "R" 'occur-rename-buffer
          "q" 'quit-window)

        (evil-set-initial-state 'occur-edit-mode 'normal)
        (general-define-key
          :states  'normal
          :keymaps 'occur-edit-mode-map
          ;; occur-mode-mouse-goto
          "RET" 'occur-mode-goto-occurrence
          "go"  'occur-mode-goto-occurrence-other-window
          "gs"  'occur-mode-display-occurrence
          "j"   'evil-adjust-occur-next
          "k"   'evil-adjust-occur-prev
          "q"   'occur-cease-edit))
    #+END_SRC

*** open-junk-file
    #+BEGIN_SRC emacs-lisp
      (use-package open-junk-file
        :defer t
        :commands open-junk-file
        :init
        (mohkale/set-leader-keys
          "fJ" 'open-junk-file)
        :config
        (setq open-junk-file-format (join-path junk-file-directory "%Y/%m/%d-%H%M%S"))

        (defun goto-junk-file-directory ()
          (interactive)
          (let ((directory junk-file-directory))
            (if (f-directory-p directory)
                (find-file directory)
              (if (file-exists-p directory)
                  (message "junk directory appears to be created as a file: %s" directory)
                (when (y-or-n-p (format "junk file directory '%s' doesn't seem to exist. make it: "
                                        directory))
                  (make-directory (expand-file-name directory) t)
                  (find-file directory))))))

        (defun goto-todays-junk-file-directory ()
          (interactive)
          (let* ((filename  (format-time-string open-junk-file-format))
                 (directory (file-name-directory filename)))
            (if (f-directory-p directory)
                (find-file directory)
              (if (file-exists-p directory)
                  (message "junk file directory appears to be created as a file: %s" directory)
                (when (y-or-n-p (format "junk file directory '%s' doesn't seem to exist. make it: "
                                        directory))
                  (make-directory (expand-file-name directory) t)
                  (find-file directory))))))

        (defun open-junk-file--fix-read-file-name-with-directory-wrapper (func &rest args)
          "ivy read-file-name doesn't seem to handle initial values with directory components
      very well. this wrapper function strips out the directory component of the default
      junk file name and passes it as the dir argument to read-file-name."

          (cl-letf* (((symbol-function 'actual-read-file-name)
                      (symbol-function 'read-file-name))
                     ((symbol-function 'read-file-name)
                      (lambda (prompt &optional dir default-file-name mustmatch initial predicate)
                        (let ((dirname  (file-name-directory    initial))
                              (basename (file-name-nondirectory initial)))
                          ;; for some reason, this doesn't work unless I set default-filename and initial
                          ;; to basename, and even when I do so, the full path still appears an option :(
                          (actual-read-file-name prompt dirname basename mustmatch basename predicate)))))
            (apply func args)))

        (advice-add 'open-junk-file :around #'open-junk-file--fix-read-file-name-with-directory-wrapper))
    #+END_SRC

*** package
    #+BEGIN_SRC emacs-lisp
      (use-package package
        :defer t
        :config
        (evil-set-initial-state 'package-menu-mode 'motion)
        (general-define-key
          :keymaps 'package-menu-mode-map
          :states  'motion
          "TAB" 'forward-button
          "<backtab>" 'backward-button
          "RET" 'package-menu-describe-package
          "DEL" 'package-menu-backup-unmark
          "("   'package-menu-toggle-hiding
          "S"   'tabulated-list-sort
          "U"   'package-menu-mark-upgrades
          "d"   'package-menu-mark-delete
          "i"   'package-menu-mark-install
          "u"   'package-menu-mark-unmark
          "x"   'package-menu-execute
          "q"   'quit-window
          "~"   'package-menu-mark-obsolete-for-deletion
          "gr"  'package-menu-refresh)

        (mohkale/declare-prefix-for-major-mode* 'package-menu-mode
          "m" "mark")

        (mohkale/set-leader-keys-for-major-mode 'package-menu-mode
          "h" 'package-menu-hide-package
          "?" 'package-menu-quick-help
          "/" 'package-menu-filter
          "m~" 'package-menu-mark-obsolete-for-deletion
          "mu" 'package-menu-mark-unmark
          "mi" 'package-menu-mark-install
          "mu" 'package-menu-mark-upgrades
          "md" 'package-menu-mark-delete))
    #+END_SRC

*** page-break-lines
    #+BEGIN_SRC emacs-lisp
      (use-package page-break-lines
        :defer t
        :diminish)
    #+END_SRC

*** paren
    # TODO look into smart-parens-mode

    #+BEGIN_SRC emacs-lisp
      (use-package paren
        :ensure t
        :defer  t
        :commands show-paren-mode
        :hook ((text-mode prog-mode) . show-paren-mode)
        :init (setq sp-highlight-pair-overlay nil))
    #+END_SRC

*** pcre2el
    #+BEGIN_SRC emacs-lisp
      (use-package pcre2el
        :ensure t
        :defer  t
        :commands (rxt-convert-to-strings
                   rxt-explain
                   rxt-convert-syntax
                   rxt-toggle-elisp-rx
                   rxt-convert-to-rx

                   rxt-elisp-to-strings
                   rxt-explain-elisp
                   rxt-elisp-to-pcre
                   rxt-toggle-elisp-rx
                   rxt-elisp-to-rx

                   rxt-pcre-to-strings
                   rxt-explain-pcre
                   rxt-pcre-to-elisp
                   rxt-pcre-to-rx)
        :init
        (mohkale/declare-prefix*
          "xr" "regular expressions"
          "xre" "elisp"
          "xrp" "pcre")

        (mohkale/set-leader-keys
          "xr'"  'rxt-convert-to-strings
          "xr/"  'rxt-explain
          "xrc"  'rxt-convert-syntax
          "xrt"  'rxt-toggle-elisp-rx
          "xrx"  'rxt-convert-to-rx

          "xre'" 'rxt-elisp-to-strings
          "xre/" 'rxt-explain-elisp
          "xrep" 'rxt-elisp-to-pcre
          "xret" 'rxt-toggle-elisp-rx
          "xrex" 'rxt-elisp-to-rx

          "xrp'" 'rxt-pcre-to-strings
          "xrp/" 'rxt-explain-pcre
          "xrpe" 'rxt-pcre-to-elisp
          "xrpx" 'rxt-pcre-to-rx))
    #+END_SRC

*** persp-mode
    #+BEGIN_SRC emacs-lisp
      (use-package persp-mode
        ;; unbound functions:
        ;;    persp-kill-buffer
        ;;    persp-save-and-kill

        :ensure t
        :defer  t
        :diminish persp-mode
        ;; :after eyebrowse
        :commands (switch-to-persp-by-num
                   persp-add-new
                   persp-kill
                   persp-add-buffer
                   persp-remove-buffer
                   persp-kill-buffer
                   persp-switch-to-buffer
                   persp-copy
                   persp-rename
                   persp-next
                   persp-prev
                   persp-switch
                   persp-temporarily-display-buffer
                   persp-import-win-conf
                   persp-import-buffers
                   persp-window-switch
                   ;; find-file-new-perspective
                   ivy-find-file-new-perspective
                   persp-frame-switch
                   persp-save-state-to-file
                   persp-load-state-from-file
                   persp-save-to-file-by-names
                   persp-load-from-file-by-names
                   persp-save-and-kill)
        :init
        (mohkale/set-leader-keys
          "ba" 'persp-add-current-buffer
          "bA" 'persp-add-buffer
          "br" 'persp-remove-buffer
          "bR" 'persp-remove-current-buffer)

        (mohkale/set-leader-keys
          "fl" 'ivy-find-file-new-perspective)

        :config
        (require 'eyebrowse)

        (persp-mode +1)
        (setq persp-autokill-buffer-on-remove 'kill-weak)

        (defun ivy-find-file-new-perspective--action (file)
          (let* ((name (if current-prefix-arg
                           (let (done value)
                             (while (not done)
                               (setq value (read-string "Name for new perspective: "))
                               (if (not (persp-with-name-exists-p value))
                                   (setq done t) ;; break loop, valid name encountered
                                 (unless (y-or-n-p (format "persp with name '%s' already exists. try again: "
                                                           value))
                                   (setq done t)) ;; user no longer wishes to create persp
                                 (setq value nil) ;; unbind in case value being returned
                                 ))
                             value)
                         (file-name-nondirectory (string-trim-right file "/")))))
            (when name
              (persp-add-new name)
              (persp-switch name)
              (let ((buffer (find-file file)))
                (switch-to-buffer buffer)
                (persp-add-buffer buffer)))))

        (defun ivy-find-file-new-perspective ()
          (interactive)
          (counsel--find-file-1
           "New Persp File: " nil
           #'ivy-find-file-new-perspective--action
           ;; 'ivy-find-file-new-perspective
           ;; with another value, dirs aren't colored
           'counsel-find-file))

        (defun switch-to-persp-by-num (index)
          "switch to a perspective based on it's position in (persp-persps)
      the first position is assumed to be associated with a perspective name `none'.
      if a perspective at the given index doesn't exist, it's assumed you wish to
      create a new one, so you'll be prompted to do so at the largest available index."
          (let* ((persp-list (nreverse (persp-persps)))
                 (persp-count (length persp-list)))
            ;; last value is nil persp with name none
            (if (>= index persp-count)
                (when (yes-or-no-p (format "no layout exists at %d, would you like to make a new layout:"
                                           (1+ persp-count)))
                  (call-interactively 'persp-add-new))
              (let ((current-persp (get-current-persp))
                    (dest-persp    (nth index persp-list)))
                (unless (string-equal (safe-persp-name dest-persp)
                                      (safe-persp-name current-persp))
                  (persp-switch (safe-persp-name dest-persp)))))))

        (defvar persp--copying-p nil
          "true if persp-add-new is called with intent to copy current persp")

        (defun persp-add-new--after (&rest args)
          "hook which is run immeadiately after `persp-add-new'
      this function sets the current persp to the new persp... unless
      `persp-add-new' wasn't invoked interactively. It also kills all
      displayed windows and returns to the home buffer... unless the
      previous persp is being copied."
          (let ((persp-list (nreverse (persp-persps)))
                (start-persp (get-current-persp)))
            (persp-switch (safe-persp-name (car (last persp-list))))

            (unless persp--copying-p
              (kill-all-windows-and-return-to-home))

            (unless (called-interactively-p)
              (persp-switch (safe-persp-name start-persp)))))

        (advice-add 'persp-add-new :after #'persp-add-new--after)
        (advice-add 'persp-copy :around #'(lambda (func &rest args)
                                            (let ((persp--copying-p t))
                                              (apply func args))))

        (defun mohkale//persp-kill-wrapper (func &rest args)
          "function which wraps around persp-kill
      this function will ensure after a perspective is killed, the next
      perspective you reach will be the one immeadiately before the erased
      one. Not really necessary, but when you try to delete 3 perspectives
      in a row, this'll make things easier. Besides, this is what you expect
      to happen."
          (let* ((perspectives (nreverse (persp-persps)))
                 (current-persp (get-current-persp))
                 (current-index (cl-position current-persp perspectives))
                 (next-persp (when (and current-index
                                        (not (zerop current-index)))
                               (nth (- current-index 1) perspectives))))
            (apply func args)
            (when next-persp
              (persp-switch (persp-name next-persp)))))

        (advice-add 'persp-kill :around #'mohkale//persp-kill-wrapper)

        (defun persp-kill-current ()
          "kill the current perspective"
          (interactive)
          (persp-kill (safe-persp-name (get-current-persp))))

        ;; (defun spacemacs//layout-contains-buffer-p (buffer)
        ;;   "returns true if the given buffer is in the current layout"
        ;;   (not (spacemacs//layout-not-contains-buffer-p buffer)))

        (defun persp-add-current-buffer ()
          "adds current buffer to current perspective"
          (interactive)
          (persp-add-buffer (current-buffer)))

        (defun persp-remove-current-buffer ()
          "removes current buffer from current persp"
          (interactive)
          (persp-remove-buffer (current-buffer)))

        (defun persp-move-layout-left ()
          (interactive)
          ;; (let* ((current-persp (get-current-persp))
          ;;        (current-persp-num (progn
          ;;                             (let (value)
          ;;                               (dolist (persp)))))
          ;;        ))
          (message "not yet implemented") ;; TODO implement
          )

        (defun persp-move-layout-right ()
          (interactive)
          (message "not yet implemented") ;; TODO implement
          )

        ;; thank you spacemacs for giving us perspective mode with eyebrowse... ergo, layouts :)
        ;; https://github.com/syl20bnr/spacemacs/blob/master/layers/%2Bspacemacs/spacemacs-layouts/funcs.el
        ;; the following is just a lazy translation of the spacemacs implementation from above for my config.
        ;; some vocabulary notes:
        ;;   * a workspace is a list of eyebrowse window configurations
        ;;   * a layout is a perspective-mode perspective which has an associated workspace.
        ;; for further elaborations on what those terms mean, see the README for perspective-mode and eyebrowse.

        ;; XXXX TBH I don't really understand what most of this does, a lot of it I just copied and pasted from
        ;;      spacemacs and changed spacemacs to layouts... if spacemacs ever realeases this as a standalone
        ;;      package, like they did with spaceline, make sure to switch to that. In the meantime, the following
        ;;      uses the same license as spacemacs... I.E. GPL v3
        ;;      Reference Commit: b252d252b0e93249b51400f60a0c69a59aa140a4

        (defun layouts//get-persp-workspace (&optional persp frame)
          "Get the correct workspace parameters for perspective.
      PERSP is the perspective, and defaults to the current perspective.
      FRAME is the frame where the parameters are expected to be used, and
      defaults to the current frame."
          (let ((param-names (if (display-graphic-p frame)
                                 '(gui-eyebrowse-window-configs
                                   gui-eyebrowse-current-slot
                                   gui-eyebrowse-last-slot)
                               '(term-eyebrowse-window-configs
                                 term-eyebrowse-current-slot
                                 term-eyebrowse-last-slot))))
            (--map (persp-parameter it persp) param-names)))

        (defun layouts//set-persp-workspace (workspace-params &optional persp frame)
          "Set workspace parameters for perspective.
      WORKSPACE-PARAMS should be a list containing 3 elements in this order:
      - window-configs, as returned by (eyebrowse--get 'window-configs)
      - current-slot, as returned by (eyebrowse--get 'current-slot)
      - last-slot, as returned by (eyebrowse--get 'last-slot)
      PERSP is the perspective, and defaults to the current perspective.
      FRAME is the frame where the parameters came from, and defaults to the
      current frame.
      Each perspective has two sets of workspace parameters: one set for
      graphical frames, and one set for terminal frames."
          (let ((param-names (if (display-graphic-p frame)
                                 '(gui-eyebrowse-window-configs
                                   gui-eyebrowse-current-slot
                                   gui-eyebrowse-last-slot)
                               '(term-eyebrowse-window-configs
                                 term-eyebrowse-current-slot
                                 term-eyebrowse-last-slot))))
            (--zip-with (set-persp-parameter it other persp)
                        param-names workspace-params)))

        ;;  _                 _
        ;; | |__   ___   ___ | | _____
        ;; | '_ \ / _ \ / _ \| |/ / __|
        ;; | | | | (_) | (_) |   <\__ \
        ;; |_| |_|\___/ \___/|_|\_\___/
        ;;

        ;; spacemacs/save-eyebrowse-for-perspective
        (defun layouts//save-eyebrowse-for-perspective (&optional frame)
          "save FRAME's eyebrowse workspace to FRAME's perspective.
      FRAME defaults to the current frame."
          (layouts//set-persp-workspace (list (eyebrowse--get 'window-configs frame)
                                              (eyebrowse--get 'current-slot frame)
                                              (eyebrowse--get 'last-slot frame))
                                        (get-frame-persp frame)
                                        frame))

        (add-hook 'eyebrowse-post-window-switch-hook #'layouts//save-eyebrowse-for-perspective)

        ;; spacemacs/update-eyebrowse-for-perspective
        (defun layouts//update-eyebrowse-for-perspective (&rest _args)
          "update & save current frame's eyebrowse workspace to its perspective"
          (let* ((current-slot (eyebrowse--get 'current-slot))
                 (current-tag (nth 2 (assoc current-slot (eyebrowse--get 'window-configs)))))
            (eyebrowse--update-window-config-element
             (eyebrowse--current-window-config current-slot current-tag)))
          (layouts//save-eyebrowse-for-perspective))

        (add-hook 'persp-before-switch-functions #'layouts//update-eyebrowse-for-perspective)
        (add-hook 'persp-before-save-state-to-file-functions #'layouts//update-eyebrowse-for-perspective)

        ;; spacemacs/load-eyebrowse-for-perspective
        (defun layouts//load-eyebrowse-for-perspective (type &optional frame)
          "load an eyebrowse workspace according to a perspective's parameters.
      FRAME's perspective is the perspective that is considered, defaulting to
      the current frame's perspective.
      If the perspective doesn't have a workspace, create one."
          (when (eq type 'frame)
            (let* ((workspace-params (layouts//get-persp-workspace (get-frame-persp frame) frame))
                   (window-configs (nth 0 workspace-params))
                   (current-slot (nth 1 workspace-params))
                   (last-slot (nth 2 workspace-params)))
              (if window-configs
                  (progn
                    (eyebrowse--set 'window-configs window-configs frame)
                    (eyebrowse--set 'current-slot current-slot frame)
                    (eyebrowse--set 'last-slot last-slot frame)
                    (eyebrowse--load-window-config current-slot))
                (eyebrowse--set 'window-configs nil frame)
                (eyebrowse-init frame)
                (layouts//save-eyebrowse-for-perspective frame)))))

        (add-hook 'persp-activated-functions #'layouts//load-eyebrowse-for-perspective)

        ;; spacemacs/load-eyebrowse-after-loading-layout
        (defun layouts//load-eyebrowse-after-perspective-load (_state-file _persp-hash _persp-names)
          "bridge between `persp-after-load-state-functions' and
      `layouts//load-eyebrowse-for-perspective'.
      _PHASH is the hash were the loaded perspectives were placed, and
      PERSP-NAMES are the names of these perspectives."
          (let ((cur-persp (get-current-persp)))
            ;; load eyebrowse for current perspective only if it was one of the loaded
            ;; perspectives
            (when (member (or (and cur-persp (persp-name cur-persp))
                              persp-nil-name)
                          persp-names)
              (layouts//load-eyebrowse-for-perspective 'frame))))

        (add-hook 'persp-after-load-state-functions #'layouts//load-eyebrowse-after-perspective-load))
    #+END_SRC

*** proced
    #+BEGIN_SRC emacs-lisp
      (use-package proced
        :config
        (evil-set-initial-state 'proced-mode 'motion)

        (mohkale/declare-prefix-for-major-mode* 'proced-mode
          "m" "mark")

        (mohkale/set-leader-keys-for-major-mode 'proced-mode
          "ma" 'proced-mark-all
          "mu" 'proced-unmark-all
          "mp" 'proced-mark-parents
          "mc" 'proced-mark-children
          "mt" 'proced-toggle-marks
          "mm" 'proced-toggle-marks

          "k" 'proced-send-signal)

        (general-define-key
          :states  'motion
          :keymaps 'proced-mode-map

          "q"      'quit-window
          "C-?"    'proced-help

          "<C-SPC>" 'proced-mark
          "<DEL>"   'proced-unmark-backward
          "a" 'proced-mark
          "A" 'proced-mark-all
          "u" 'proced-unmark
          "U" 'proced-unmark-all
          "p" 'proced-mark-parents
          "P" 'proced-mark-children
          "M" 'proced-toggle-marks

          "x"   'proced-send-signal
          "C-k" 'proced-send-signal

          "<M-SPC>" 'proced-toggle-tree

          "r" 'proced-refine
          "R" 'proced-renice

          "o" 'proced-omit-processes ;; marked

          "<C-M-SPC>" 'proced-format-interactive

          "sS" 'proced-sort-interactive
          "sc" 'proced-sort-pcpu
          "sm" 'proced-sort-pmem
          "sp" 'proced-sort-pid
          "ss" 'proced-sort-start
          "st" 'proced-sort-time
          "su" 'proced-sort-user
          "S"  'proced-filter-interactive))
    #+END_SRC

*** process-menu
    #+BEGIN_SRC emacs-lisp
      (use-package simple
        :defer t
        :config
        (evil-set-initial-state 'process-menu-mode 'motion)

        (general-define-key
          :states  'motion
          :keymaps 'process-menu-mode-map
          "d" 'process-menu-delete-process

          "TAB"   'forward-button
          "S-TAB" 'backward-button
          "C-j"   'forward-button
          "C-k"   'backward-button))
    #+END_SRC

*** projectile
**** projectile
     #+BEGIN_SRC emacs-lisp
       (use-package projectile
         :ensure t
         :defer  10
         ;; :diminish " "
         :delight " Projectile"
         :hook (prog-mode . projectile-mode)
         :commands (projectile-mode
                    projectile-run-shell-command-in-root
                    projectile-replace-regexp
                    projectile-run-async-shell-command-in-root
                    projectile-toggle-between-implementation-and-test
                    projectile-switch-to-buffer
                    projectile-compile-project
                    projectile-dired
                    projectile-find-dir
                    projectile-find-file
                    projectile-ivy-persp-switch-project
                    projectile-regenerate-tags
                    projectile-find-tag
                    projectile-invalidate-cache
                    projectile-kill-buffers
                    projectile-run-project
                    projectile-replace
                    projectile-test-project)
         :init
         (mohkale/declare-prefix "p" "projectile" "project management")
         (mohkale/set-leader-keys
           "p!" 'projectile-run-shell-command-in-root
           "p%" 'projectile-replace-regexp
           "p&" 'projectile-run-async-shell-command-in-root
           "pa" 'projectile-toggle-between-implementation-and-test
           "pb" 'projectile-switch-to-buffer
           "pc" 'projectile-compile-project
           "pD" 'projectile-dired
           "pd" 'projectile-find-dir
           "pf" 'projectile-find-file
           "pG" 'projectile-regenerate-tags
           "pg" 'projectile-find-tag
           "pI" 'projectile-invalidate-cache
           "pk" 'projectile-kill-buffers
           "pl" 'projectile-ivy-persp-switch-project
           "pp" 'projectile-run-project
           "pR" 'projectile-replace
           "pt" 'projectile-test-project)

         (advice-add 'delete-buffer-file :after #'(lambda (&rest r)
                                                    (when (projectile-project-p)
                                                      (call-interactively 'projectile-invalidate-cache))))
         :config
         (projectile-register-project-type 'rake '("rakefile")
                                           :compile "rake build"
                                           :test    "rake test"
                                           :run     "rake run"
                                           :test-suffix ".spec")

         (projectile-register-project-type 'pipenv '("Pipfile")
                                           :test "pipenv py -m pytest")

         (defun projectile-ensure-no-trailing-slash-in-root (func &rest args)
           (cl-letf* (((symbol-function 'true-projectile-project-root)
                       (symbol-function 'projectile-project-root))
                      ((symbol-function 'projectile-project-root)
                       (lambda (&rest args)
                         ;; TODO maybe don't hardcode file name seperator
                         (string-remove-suffix "/"
                                               (apply 'true-projectile-project-root args)))))
             (apply func args)))

         (advice-add 'projectile-regenerate-tags :around #'projectile-ensure-no-trailing-slash-in-root)

         (setq projectile-project-search-path '("~/programming/projects/"
                                                "~/programming/repos/"
                                                "~/programming/.modules/python/"
                                                "~/programming/")
               projectile-tags-backend 'xref ;; opt into gtags
               projectile-indexing-method 'alien ;; never use native
               projectile-tags-command "ctags -Re -f \"%s\" %s \"%s\"")

         (dolist (path projectile-project-search-path)
           ;; ensure project paths exist
           (unless (file-exists-p path)
             (mkdir path t)))

         (unless (eq system-type 'gnu/linux)
           ;; fixes search glitches on windows when using cygwin... also strips out leading ./ because
           ;; ivy seems to recognise ./ paths as distinct from their non ./ counterparts... maybe that's
           ;; projectiles fault... who knows. also exclude special emacs backup files from search results.
           (setq projectile-generic-command "find . -type f -not -iname '#*#' -print | cut -c3- | tr '\\n' '\\0'"))

         (defun projectile-ivy-persp-switch-project (arg)
           (interactive "P")
           (ivy-read "Switch to Project Perspective: "
                     (if (projectile-project-p)
                         (cons (abbreviate-file-name (projectile-project-root))
                               (projectile-relevant-known-projects))
                       projectile-known-projects)
                     :action (lambda (project)
                               (let ((persp-reset-windows-on-nil-window-conf t)
                                     (project-name (file-name-nondirectory
                                                    (string-remove-suffix "/" project))))
                                 (persp-switch project-name)
                                 (projectile-switch-project-by-name project)))))

         (defun projectile-cleanup--shut-up-please (func &rest args)
           "I don't need to know when you've done nothing... thnx tho :P"
           (cl-letf* (((symbol-function 'actual-message)
                       (symbol-function 'message))
                      ((symbol-function 'message)
                       (lambda (format &rest args)
                         (if (string-equal format
                                           "No projects needed to be removed.")
                             (apply 'format format args)
                           (apply 'actual-message format args)))))
             (apply func args)))

         (advice-add 'projectile-cleanup-known-projects :around #'projectile-cleanup--shut-up-please)

         (defun projectile-compile--double-prefix-means-run-comint (func &optional args)
           "allow running compilation interactively when multiple prefixes are given.
       with two prefixes (C-u C-u) runs default compilation command in interactive
       compilation buffer. with three prompts for command and then runs it in an
       interactive compilation buffer."
           (let ((prefix current-prefix-arg))
             (if (and (consp prefix)
                      (setq prefix (car prefix))
                      (>= prefix 16))
                 (cl-letf* (((symbol-function 'actual-compile)
                             (symbol-function 'compile))
                            ((symbol-function 'compile)
                             (lambda (command &optional comint)
                               (actual-compile command t))))
                   (funcall func (if (eq prefix 16) nil '(4))))
               (funcall func prefix))))

         (advice-add 'projectile-run-project     :around #'projectile-compile--double-prefix-means-run-comint)
         (advice-add 'projectile-compile-project :around #'projectile-compile--double-prefix-means-run-comint)
         (advice-add 'projectile-test-project    :around #'projectile-compile--double-prefix-means-run-comint))
     #+END_SRC

**** org-projectile
     #+BEGIN_SRC emacs-lisp
       (use-package org-projectile
         :ensure t
         :defer  t
         :commands (org-projectile-capture-for-current-project
                    ;; org-projectile-helm-template-or-project
                    org-projectile-project-todo-completing-read
                    org-projectile-goto-location-for-project)
         :init
         (mohkale/declare-prefix*
           "po" "org-projectile-goto-todos"
           "pO" "org-projectile-capture")

         (mohkale/set-leader-keys
           "po" 'org-projectile-goto-location-for-project
           ;; "pO" 'org-projectile-helm-template-or-project
           )
         :config
         (org-projectile-per-project))
     #+END_SRC

**** ivy-projectile
     needs to be loaded after ivy and projectile, including the init function.

     #+BEGIN_SRC emacs-lisp
       (use-package counsel-projectile
         :ensure t
         :defer  t
         ;; :after (projectile counsel)
         ;; :hook (projectile-mode . counsel-projectile-mode)
         :commands (counsel-projectile-switch-project
                    counsel-projectile-find-file
                    counsel-projectile-find-file-dwim
                    counsel-projectile-find-dir
                    counsel-projectile-switch-to-buffer
                    counsel-projectile-grep
                    counsel-projectile-ag
                    counsel-projectile-rg
                    counsel-projectile
                    counsel-projectile-mode
                    counsel-projectile-git-grep
                    counsel-projectile-org-capture
                    counsel-projectile-org-agenda)
         :init
         (mohkale/declare-prefix "ps" "search")

         (mohkale/set-leader-keys
           "fp"    'counsel-projectile-switch-project
           "pP"    'counsel-projectile-switch-project
           "pf"    'counsel-projectile-find-file
           "pd"    'counsel-projectile-find-dir
           "pb"    'counsel-projectile-switch-to-buffer
           "psg"   'counsel-projectile-grep
           "psv"   'counsel-projectile-git-grep
           "psa"   'counsel-projectile-ag
           "psr"   'counsel-projectile-rg
           "p SPC" 'counsel-projectile)
         ;; :config
         ;; (counsel-projectile-mode +1)
         )
     #+END_SRC

*** rake
    #+BEGIN_SRC emacs-lisp
      (use-package rake
        :ensure t
        :defer  t
        :commands (rake
                   rake-rerun
                   rake-find-task ;; jump to task in rakefile
                   rake-compilation-mode
                   rake-regenerate-cache)
        :init
        (mohkale/set-leader-keys
          "cr" 'rake
          "cR" 'rake-rerun)
        (defalias 'rake-refresh #'rake-regenerate-cache)
        :config
        (setq rake-completion-system 'ivy-read))
    #+END_SRC

*** save-place
    remembers the cursor position in open files... so when I reopen them I'm taken to that point immeadiately. It's a cool feature, but not really essential. Generally, when I open a file, I'll look around a bit to see where I was and what I was doing. Jumping to where I was immediately only helps with one of those problems & it seems like a bad habit to depend on that to remind me... use org capture for that and mode dependent jump keys to get to where you need to. quick & easy.

    #+BEGIN_SRC emacs-lisp :tangle no
      (use-package saveplace
        :commands (save-place-mode)
        :init
        (setq save-place-forget-unreadable-files nil)
        (save-place-mode +1))
    #+END_SRC

*** server
    #+BEGIN_SRC emacs-lisp
      (require 'server)

      (unless (server-running-p)
        (server-start))
    #+END_SRC

*** simple
    GET ME OUT OF HERE!!!
    #+BEGIN_SRC emacs-lisp
      (use-package simple
        :defer t
        :commands (completion-list-mode)
        :init
        (push 'messages-buffer-mode mohkale--whitespace-exempt-modes)
        :config
        (dolist (mode `(messages-buffer-mode
                        special-mode
                        message-mode))
          (evil-set-initial-state mode 'motion))

        (mohkale/declare-prefix "i TAB" "indent" "indentation")

        (mohkale/set-leader-keys
          "i TAB <tab>" 'indent-region
          "i TAB RET"   'split-line
          "i TAB SPC"   'just-one-space
          "i TAB r"     'indent-relative
          "i TAB R"     'indent-relative-first-indent-point
          "i TAB ."     'hydra-indent/body
          "i TAB n"     'forward-to-indentation
          "i TAB N"     'back-to-indentation)

        ;; force state for buffer if it already exists
        (let ((buffer (get-buffer "*Messages*")))
          (when buffer
            (with-current-buffer buffer
              (evil-motion-state))))

        (evil-set-initial-state 'completion-list-mode 'motion)

        (general-define-key
          :keymaps 'completion-list-mode-map
          :states  'motion
          "RET" 'choose-completion
          "C-j" 'choose-completion

          "q" 'quit-window
          "Q" 'delete-completion-window

          "j" 'next-completion
          "k" 'previous-completion
          "n" 'next-completion
          "p" 'previous-completion
          "N" 'previous-completion))
    #+END_SRC

*** sudo-edit
    #+BEGIN_SRC emacs-lisp
      (use-package sudo-edit
        :ensure t
        :defer  t
        :commands sudo-edit
        :init
        (mohkale/set-leader-keys
          "fE" 'sudo-edit))
    #+END_SRC

*** rainbow-delimeters
    #+BEGIN_SRC emacs-lisp
      (use-package rainbow-delimiters
        :ensure t
        :defer  t
        :hook (prog-mode . rainbow-delimiters-mode)
        :commands rainbow-delimiters-mode)
    #+END_SRC

*** rainbow-mode
    highlights hex color strings in their appropriate color. keep it around... though I'll probably never use it.

    #+BEGIN_SRC emacs-lisp
      (use-package rainbow-mode
        :ensure t
        :defer  t)
    #+END_SRC

*** tabulated-list-mode
    #+BEGIN_SRC emacs-lisp
     (use-package tabulated-list
       :defer t
       :commands (tabulated-list-mode
                  tabulated-list-next-column)
       :config
       (evil-set-initial-state 'tabulated-list-mode 'motion)

       (defun tabulated-list--get-column-widths ()
         "return a list of all the "
         (mapcar (lambda (x) (+ (nth 1 x)
                                (or (plist-get (cdr x) :pad-right) 1)))
                 tabulated-list-format))

       (defun tabulated-list--get-column-pivots ()
         (let (prev values)
           (setq values (mapcar (lambda (x)
                                  (let ((new-val (+ x (or prev 0))))
                                    (setq prev new-val)
                                    new-val))
                                (tabulated-list--get-column-widths)))
           ;; (mapcar (lambda (x) (- x 1)) values)
           values))

       (defun tabulated-list--properties ()
         (let* ((current-column-position (- (point)
                                            (line-beginning-position)))
                (column-pivots (tabulated-list--get-column-pivots))
                (column-count (length column-pivots))
                (preceding-columns (seq-filter
                                    (lambda (x)
                                      (<= x current-column-position))
                                    column-pivots))
                (following-columns (nthcdr (length preceding-columns)
                                           column-pivots))
                (current-column (car following-columns))
                (following-columns (cdr following-columns)))
           `(:current-column-position ,current-column-position
                                      :column-pivots           ,column-pivots
                                      :column-count            ,column-count
                                      :preceding-cols          ,preceding-columns
                                      :current-column          ,current-column
                                      :following-cols          ,following-columns)))

       ;; doesn't work when row contains truncated entries, such as
       ;; buffers with a "name..." entry, because those dots aren't
       ;; included in the width of the column.
       (defun tabulated-list-next-column (&optional count)
         "moves to the next column shown by tabulated list mode"
         (interactive)
         (or count (setq count 1))

         (when tabulated-list-format
           (let* ((properties (tabulated-list--properties))
                  (line-step (floor (/ count
                                       (plist-get properties :column-count)))))
             ;; move however many lines it takes to reach row with desired column
             (unless (zerop line-step)
               (next-line line-step))

             (unless (eobp)
               (cond
                ((eq (point) (line-end-position))
                 ;; when at the end of the last column, goto next row
                 (next-line)
                 (goto-char (line-beginning-position)))
                ((not (plist-get properties :following-cols))
                 ;; no next column, goto end of current
                 (goto-char (line-end-position)))
                (t
                 ;; goto next column from the end of the current one
                 (goto-char (+ (line-beginning-position)
                               (plist-get properties :current-column)))))))))

       ;; ;; doesn't work for some stupid reason :(
       ;; (defun tabulated-list-prev-column (&optional count)
       ;;   (interactive)
       ;;   (or count (setq count 1))

       ;;   (when tabulated-list-format
       ;;     (let* ((properties (tabulated-list--properties))
       ;;            (line-step (floor (/ count
       ;;                                 (plist-get properties :column-count))))
       ;;            (line-number (string-to-number (format-mode-line "%l"))))
       ;;       ;; move however many lines it takes to reach row with desired column
       ;;       (unless (zerop line-step)
       ;;         (if (> line-step line-number)
       ;;             (goto-char (point-min))
       ;;           (previous-line line-step)))

       ;;       (unless (bobp)
       ;;         (cond
       ;;          ((eq (point) (line-beginning-position))
       ;;           ;; when at first column, goto previous row
       ;;           (previous-line)
       ;;           (goto-char (line-end-position)))
       ;;          ((not (plist-get properties :preceding-cols))
       ;;           (goto-char (line-beginning-position)))
       ;;          (t
       ;;           (goto-char (+ (line-beginning-position)
       ;;                            (car (last (plist-get properties :preceding-cols)))))))))))
       :bind (:map tabulated-list-mode-map
              ("SPC"   . nil)
              ("ESC"   . nil)
              ("0"     . nil)
              ("<"     . nil)
              (">"     . nil)
              ("?"     . nil)
              ("g"     . nil)
              ("h"     . nil)
              ("n"     . nil)
              ("p"     . nil)
              ("DEL"   . nil)
              ("S-SPC" . nil)
              ("gr" . revert-buffer)))
    #+END_SRC

*** tags
    #+BEGIN_SRC emacs-lisp
      (use-package ggtags
        :ensure t
        :defer  t
        :commands (ggtags-find-tag-dwim
                   ggtags-find-tag-mouse
                   ggtags-find-definition
                   ggtags-find-reference
                   ggtags-find-other-symbol
                   ggtags-find-tag-regexp
                   ggtags-idutils-query
                   ggtags-grep
                   ggtags-find-file
                   ggtags-query-replace)
        :init
        (mohkale/declare-prefix "T" "tags")

        (mohkale/set-leader-keys
          "TD" 'ggtags-delete-tags
          "T/" 'ggtags-grep)

        :config
        ;; NOTE ggtags-global-mode is not a global mode... global is
        ;;      for GNU *global* tagging system
        (mohkale/set-leader-keys-for-major-mode 'ggtags-global-mode
          "r" 'recompile
          "f" 'next-error-follow-minor-mode))
    #+END_SRC

*** tildify
    #+BEGIN_SRC emacs-lisp
      (use-package tildify
        :defer t
        :delight " ~")
    #+END_SRC

*** tramp
    #+BEGIN_SRC emacs-lisp
      (use-package tramp
        :defer t
        :config
        ;; google cloud integration... curtesy of:
        ;;   https://qiita.com/tanatana/items/218b19808f2428b125fe
        ;; see [[https://cloud.google.com/sdk/docs/quickstart-windows][here]] for how to install gcloud CLI.
        (push
         '("gcssh"
           (tramp-login-program        "gcloud compute ssh")
           (tramp-login-args           (("%h")))
           (tramp-async-args           (("-q")))
           (tramp-remote-shell         "/bin/sh")
           (tramp-remote-shell-args    ("-c"))
           (tramp-gw-args              (("-o" "GlobalKnownHostsFile=/dev/null")
                                        ("-o" "UserKnownHostsFile=/dev/null")
                                        ("-o" "StrictHostKeyChecking=no")))
           (tramp-default-port         22))
         tramp-methods))
    #+END_SRC

*** tramp-term
    create remote terminal sessions effortlessly... this should be built into term tbh.
    #+BEGIN_SRC emacs-lisp
      (use-package tramp-term
        :ensure t
        :defer  t
        :commands (tramp-term
                   ;; term--use-tramp-term-when-in-tramp-directory
                   )
        :init
        ;; (add-hook 'term :before-until #'term--use-tramp-term-when-in-tramp-directory)
        :config
      ;;   (defun term--use-tramp-term-when-in-tramp-directory (&rest args)
      ;;     "when current buffers is in a tramp path open a tramp term session
      ;; if prefix arg specified, disregard this and open a local term sessions"
      ;;     (when (and (not current-prefix-arg)
      ;;                default-directory
      ;;                (tramp-tramp-file-p default-directory))
      ;;       (tramp-term )
      ;;         )
      ;;     )
        )
    #+END_SRC

*** transpose-frame
    #+BEGIN_SRC emacs-lisp
      (use-package transpose-frame
        :defer t
        :commands (transpose-frame
                   flip-frame
                   flop-frame ;; flip horizontally
                   rotate-frame ;; 180 degrees
                   rotate-frame-clockwise ;; 90 degrees
                   rotate-frame-anti-clockwise ;; 90 degrees
                   )
        :bind (:map mohkale-window-map
               ("C-t" . transpose-frame)
               ("t" . transpose-frame)
               ("(" . rotate-frame-clockwise)
               (")" . rotate-frame-anti-clockwise)
               ("*" . rotate-frame)
               ("C-f" . flip-frame)
               ("f" . flip-frame)
               ("C-S-F" . flop-frame)
               ("F" . flop-frame)))
    #+END_SRC

*** undo-tree
    #+BEGIN_SRC emacs-lisp
      (use-package undo-tree
        :ensure t
        :defer  t
        :diminish
        :init
        (push 'undo-tree-visualizer-mode mohkale--whitespace-exempt-modes)
        :bind* (:map undo-tree-map
                ("C-/" . nil)
                ("C-_" . nil)
                ("C-?" . nil)))
    #+END_SRC

*** uuidgen
    #+BEGIN_SRC emacs-lisp
      (use-package uuidgen
        :ensure t
        :defer  t
        :commands uuidgen
        :init
        (mohkale/set-leader-keys
          "iU" 'uuidgen
          ;; "U" '(:prefix-command mohkale-insert-uuid-map :which-key "uuid")
          ;; "U1" 'uuidgen-1
          ;; "U4" 'uuidgen-4
          ;; "UU" 'uuidgen-U
          ))
    #+END_SRC

*** vi-tilde
    #+BEGIN_SRC emacs-lisp
      (use-package vi-tilde-fringe
        :ensure t
        :defer  t
        :diminish
        :commands (vi-tilde-fringe-mode global-vi-tilde-fringe-mode)
        :config
        (global-vi-tilde-fringe-mode))
    #+END_SRC

*** view-mode
    #+BEGIN_SRC emacs-lisp
      (use-package view
        :defer t
        :config
        (general-define-key
          :keymaps 'view-mode-map
          :states  'normal
          "q" 'View-quit
          "Q" 'View-quit-all
          "G" 'View-scroll-to-buffer-end
          "zq" 'View-exit
          "zk" 'View-kill-and-leave
          "C-j" 'View-scroll-line-forward
          "C-k" 'View-scroll-line-backward
          ;; "C-d" 'View-scroll-half-page-forward
          ;; "C-u" 'View-scroll-half-page-backward
          "M-d" 'View-scroll-page-forward
          "M-u" 'View-scroll-page-backward))
    #+END_SRC

*** visible-mark
    #+BEGIN_SRC emacs-lisp
      (use-package visible-mark
        :ensure t
        :defer  t
        :commands (visible-mark-mode))
    #+END_SRC

*** visual-line
    #+BEGIN_SRC emacs-lisp
      (use-package visual-line
        :defer t
        :delight " ")
    #+END_SRC

*** vlc-rc
    #+BEGIN_SRC emacs-lisp
      (use-package vlc-rc
        :defer t
        ;; can't defer for now, hopefully when use-package
        ;; supports bind-keymap with specific map, change.
        :commands (vlc/dired-add-file
                   vlc/dired-enqueue-file)
        :init
        (setq vlc-rc-map (make-sparse-keymap))

        (mohkale/set-leader-keys "v" vlc-rc-map)
        (mohkale/declare-prefix*
          "v" '("VLC" . "VideoLanCodec")
          "vs" "set"
          "vt" "toggle")

        (general-define-key
          :keymaps 'dired-mode-map
          :states '(normal motion)
          "v"  nil
          "vv" 'vlc/dired-add-file
          "vq" 'vlc/dired-enqueue-file)
        ;; :bind-keymap* (:map mohkale-leader-map
        ;;                ("v" . vlc-rc-map))
        :bind (:map vlc-rc-map
               ("C-." . hydra-vlc-rc/body)))
    #+END_SRC

*** which-key
    # TODO update which key display delay
    #+BEGIN_SRC emacs-lisp
      (use-package which-key
        :ensure t
        :demand t
        :diminish
        ;; :delight " "
        :config
        (which-key-mode 1)
        ;; order of keys is case insensetive
        (setq which-key-sort-order 'which-key-key-order-alpha
              which-key-echo-keystrokes 0.02)
        ;; translate winum-select-window number commands to single command in which key

        (mohkale/set-leader-keys
          "hk" 'which-key-show-top-level))
    #+END_SRC

*** whitespace
    #+BEGIN_SRC emacs-lisp
      (use-package whitespace
        :defer t
        :delight
        (whitespace-mode " ")
        (global-whitespace-mode " "))
    #+END_SRC

*** winner
    #+BEGIN_SRC emacs-lisp
      (use-package winner
        :defer 10
        :commands (winner-mode
                   winner-undo
                   winner-redo)
        :config
        (winner-mode +1)
        :bind (:map mohkale-window-map
               ("<left>"  . winner-undo)
               ("<right>" . winner-redo)))
    #+END_SRC

*** winum
    #+BEGIN_SRC emacs-lisp
      (use-package winum
        :ensure t
        :demand t
        :after which-key
        :commands (winum-select-window-1
                   winum-select-window-2
                   winum-select-window-3
                   winum-select-window-4
                   winum-select-window-5
                   winum-select-window-6
                   winum-select-window-7
                   winum-select-window-8
                   winum-select-window-9
                   winum-select-window-by-number)
        :config
        (setq winum-auto-setup-mode-line nil)

        ;; reset 1st window number option to window by number
        (push '(("\\(.*\\) 1" . "winum-select-window-1") . ("\\1 1..9" . "window-by-number")) which-key-replacement-alist)
        ;; hide numbers 2 through to nine
        (push '((nil . "winum-select-window-[2-9]") . t) which-key-replacement-alist)
        ;; abbreviate 0 value
        (push '(("\\(.*\\) 0" . "winum-select-window-by-number") . ("\\1 0" . "window-by-prompt")) which-key-replacement-alist)

        (winum-mode)
        :bind (:map mohkale-window-map
               ("1" . 'winum-select-window-1)
               ("2" . 'winum-select-window-2)
               ("3" . 'winum-select-window-3)
               ("4" . 'winum-select-window-4)
               ("5" . 'winum-select-window-5)
               ("6" . 'winum-select-window-6)
               ("7" . 'winum-select-window-7)
               ("8" . 'winum-select-window-8)
               ("9" . 'winum-select-window-9)
               ("0" . 'winum-select-window-by-number)))
    #+END_SRC

*** xref
    #+BEGIN_SRC emacs-lisp
      (use-package xref
        :defer t
        :commands (xref-find-definitions
                   xref-find-apropos
                   xref-find-definitions-other-window
                   xref-find-definitions-other-frame
                   xref-pop-marker-stack
                   xref-find-references

                   ;; xref buffer commands
                   xref-next-line
                   xref-prev-line
                   xref-goto-xref
                   xref-show-location-at-point ;; open new window
                   xref-query-replace-in-results ;; substitute
                   xref-quit-and-goto-xref
                   xref-quit)
        :init
        (mohkale/declare-prefix "ax" "xref")

        (mohkale/set-leader-keys
          "axx" 'xref-find-references
          "axX" 'xref-find-definitions
          "ax/" 'xref-find-apropos
          "axw" 'xref-find-definitions-other-window
          "axf" 'xref-find-definitions-other-frame
          "ax SPC" 'xref-pop-marker-stack)

        :init
        (evil-set-initial-state 'xref--xref-buffer-mode 'motion)

        (general-define-key
          :keymaps 'xref--xref-buffer-mode-map
          :states 'motion
          "j" 'xref-next-line
          "k" 'xref-prev-line
          "RET" 'xref-goto-xref
          "M-RET" 'xref-show-location-at-point
          "TAB" 'xref-quit-and-goto-xref)

        (mohkale/set-leader-keys-for-major-mode 'xref--xref-buffer-mode
          "s" 'xref-query-replace-in-results)
        :bind (;; erase global xref bindings
               ("M-." . nil)   ; xref-find-definitions
               ("M-," . nil)   ; xref-pop-marker-stack
               ("M-?" . nil)   ; xref-find-references
               ("C-M-." . nil) ; xref-find-apropos
               ))
    #+END_SRC

*** yasnippet
    yet another snippets tool... but amazingly powerful. :-P

**** yasnippet
     #+BEGIN_SRC emacs-lisp
       ;; snippet dev guide at:
       ;;   https://joaotavora.github.io/yasnippet/snippet-development.html#org6796ab7

       (use-package yasnippet
         :ensure t
         :defer  t
         :commands (yas-expand
                    yas-next-field
                    yas-prev-field

                    yas-new-snippet
                    yas-visit-snippet-file

                    ;; major mode commands
                    yas-load-snippet-buffer
                    yas-load-snippet-buffer-and-close
                    yas-tryout-snippet)
         :delight (yas-minor-mode "YAS")
         :init
         (mohkale/set-leader-keys
           "iSn" 'yas-new-snippet
           "iSv" 'yas-visit-snippet-file)
         (general-define-key
           :states 'insert
           "C-i" 'yas-expand)
         :config
         (yas-global-mode 1)
         (general-define-key
           :keymaps 'yas-keymap
           "<C-return>" 'yas-next-field
           "<C-M-return>" 'yas-prev-field
           "C-l" 'yas-next-field
           "C-h" 'yas-prev-field)

         (mohkale/set-leader-keys-for-major-mode 'snippet-mode
           "m" 'yas-load-snippet-buffer-and-close
           "l" 'load-snippet-buffer
           "t" 'yas-tryout-snippet)

         (yas-load-directory mohkale-snippets-dir t))
     #+END_SRC

**** auto-yasnippet
     allows you to create dynamic/in-place snippets and repeatedly execute them.

     #+BEGIN_SRC emacs-lisp
       (use-package auto-yasnippet
         :ensure t
         :defer  t
         :commands (aya-create
                    aya-expand
                    aya-persist-snippet)
         :init
         (mohkale/declare-prefix "iS" "auto-yasnippet")
         (mohkale/set-leader-keys
           "iSc" 'aya-create
           "iSe" 'aya-expand
           "iSw" 'aya-persist-snippet)
         (general-define-key
           :states 'insert
           "M-i" 'aya-expand))
     #+END_SRC

**** snippet sources
***** yasnippet-snippets
      #+BEGIN_SRC emacs-lisp
        (use-package yasnippet-snippets
          :ensure t
          :defer  t)
      #+END_SRC

*** ycmd
**** flycheck-ycmd
     #+BEGIN_SRC emacs-lisp
       (use-package flycheck-ycmd
         :ensure t
         :defer  t
         :commands flycheck-ycmd-setup
         :hook (ycmd-mode . flycheck-ycmd-setup))
     #+END_SRC

**** company-ycmd
     #+BEGIN_SRC emacs-lisp
       (use-package company-ycmd
         :ensure t
         :defer  t
         :commands company-ycmd)
     #+END_SRC

**** ycmd-mode
     #+BEGIN_SRC emacs-lisp
       (use-package ycmd
         :ensure t
         :defer  t
         :delight "YCMD"
         :hook (ycmd-mode . ycmd-eldoc-setup)
         :commands (ycmd-mode
                    global-ycmd-mode
                    ycmd-eldoc-setup
                    ycmd-open
                    ycmd-close
                    ycmd-version
                    ycmd-parse-buffer
                    ycmd-load-conf-file
                    ycmd-clear-compilation-flag-cache
                    ycmd-show-debug-info
                    ycmd-show-documentation
                    ycmd-toggle-log-enabled
                    ycmd-restart-semantic-server
                    ycmd-get-type
                    ycmd-completer
                    ycmd-toggle-force-semantic-completion
                    ycmd-refactor-rename
                    ycmd-display-completions
                    ycmd-goto
                    ycmd-goto-imprecise
                    ycmd-goto-type
                    ycmd-goto-definition
                    ycmd-goto-declaration
                    ycmd-goto-references
                    ycmd-goto-include
                    ycmd-goto-implementation)
         :init
         ;; NOTE to enable ycmd completion, hook ycmd-mode into any desired
         ;;      buffers and include company-ycmd in the company backends for
         ;;      the mode.

         (setq ycmd-global-config (expand-file-name "~/.ycmd-config")
               ycmd-startup-timeout 10
               ycmd-server-command `("python3" "-u" ,(expand-file-name "~/.vim/plugged/YouCompleteMe/third_party/ycmd/ycmd")))

         ;; (ycmd-toggle-force-semantic-completion)

         (mohkale/declare-prefix-for-mode* 'ycmd-mode
           "y" "ycmd"
           "yg" "jump")

         (mohkale/set-leader-keys-for-minor-mode 'ycmd-mode
           "yy" 'ycmd-mode
           "yY" 'global-ycmd-mode
           "yn" 'ycmd-open
           "yk" 'ycmd-close
           "yv" 'ycmd-version
           "yb" 'ycmd-parse-buffer
           "yc" 'ycmd-load-conf-file
           "yC" 'ycmd-clear-compilation-flag-cache
           "ys" 'ycmd-show-debug-info
           "yd" 'ycmd-show-documentation
           "yl" 'ycmd-toggle-log-enabled
           "yr" 'ycmd-restart-semantic-server
           "yt" 'ycmd-get-type
           "y." 'ycmd-completer           ; completing-read all ycmd requests
           "y SPC" 'ycmd-toggle-force-semantic-completion
           "y C-r" 'ycmd-refactor-rename
           "y C-c" 'ycmd-display-completions
           "ygg" 'ycmd-goto
           "ygG" 'ycmd-goto-imprecise
           "ygt" 'ycmd-goto-type
           "ygd" 'ycmd-goto-definition
           "ygD" 'ycmd-goto-declaration
           "ygr" 'ycmd-goto-references
           "ygi" 'ycmd-goto-include
           "ygI" 'ycmd-goto-implementation)
         )
     #+END_SRC

*** vc
    #+BEGIN_SRC emacs-lisp
      (use-package vc
        :defer t
        :commands (vc-annotate              ;; history of current file
                   vc-create-tag
                   vc-delete-file
                   vc-diff                  ;; diff current file
                   vc-dir                   ;; status of directory
                   vc-ediff                 ;; ediff current file
                   vc-ignore                ;; prompt and exclude file
                   vc-log-incoming          ;; log for pull commits
                   vc-log-outgoing          ;; log for push commits
                   vc-merge
                   vc-next-action           ;; makes a commit... annoyingly named
                   vc-print-log             ;; log of commits affecting current file
                   vc-print-root-log        ;; log of all commits in project
                   vc-push
                   vc-region-history        ;; log of commits affecting region in file
                   vc-register              ;; add file
                   vc-retrieve-tag
                   vc-revert                ;; undo changes to working files... permenently
                   vc-revision-other-window ;; view file in previous tag/commit
                   vc-root-diff
                   vc-switch-backend        ;; not using git... for shame :P
                   vc-update-change-log)
        :init
        ;;; include vc leader key in defaults leader keys
        (mohkale/declare-prefix "V" "version control")

        (mohkale/set-leader-keys
          "Dv" 'vc-ediff
          "DV" 'vc-diff)

        (push 'vc-annotate-mode mohkale--whitespace-exempt-modes)
        (push 'vc-git-log-view-mode mohkale--whitespace-exempt-modes)

        ;; need to require for bindings to show up :(
        :config
        (require 'vc-git) ;; supported

        (mohkale/set-leader-keys "V" vc-prefix-map)

        (general-define-key
          :keymaps 'vc-prefix-map
          "C-=" 'vc-ediff
          "r"   'vc-rename-file
          "R"   'vc-retrieve-tag)

        (advice-add 'vc-region-history :after (lambda (&rest args)
                                                (when (evil-visual-state-p)
                                                  (evil-exit-visual-state))))

        (setq vc-ignore-dir-regexp
              (format "%s\\|%s"
                      vc-ignore-dir-regexp
                      tramp-file-name-regexp))

        ;;; annotations
        ;; pops up a buffer showing the most recent changes for every line
        ;; in the current file alongside the commit which made those changes.
        (evil-set-initial-state 'vc-annotate-mode 'motion)

        (general-define-key
          :states  'motion
          :keymaps 'vc-annotate-mode-map
          "C-j" 'vc-annotate-prev-revision ;; older revisions
          "C-k" 'vc-annotate-next-revision ;; newer revisions
          "C-t" 'vc-annotate-toggle-annotation-visibility
          "RET" 'vc-annotate-goto-line

          "d" 'vc-annotate-show-diff-revision-at-line
          "D" 'vc-annotate-show-changeset-diff-revision-at-line
          "t" 'vc-annotate-toggle-annotation-visibility)

        (mohkale/declare-prefix-for-major-mode* 'vc-annotate-mode
          "g" "goto")

        (mohkale/set-leader-keys-for-major-mode 'vc-annotate-mode
          "m"     'vc-next-action
          "l"     'vc-annotate-show-log-revision-at-line
          "d"     'vc-annotate-show-diff-revision-at-line
          "D"     'vc-annotate-show-changeset-diff-revision-at-line
          "t"     'vc-annotate-toggle-annotation-visibility
          "gg"    'vc-annotate-goto-line
          "gc"    'vc-annotate-revision-at-line
          "gp"    'vc-annotate-revision-previous-to-line
          "gl"    'vc-annotate-show-log-revision-at-line
          "gG"    'vc-annotate-working-revision
          "g SPC" 'vc-annotate-working-revision)

        ;;; vc-directory
        ;; check status of files for an entire directory
        (evil-set-initial-state 'vc-dir-mode 'motion)

        (general-define-key
          :states  'motion
          :keymaps 'vc-dir-mode-map

          "a" 'vc-register ;; git add FILE
          "d" 'vc-diff
          "=" 'vc-diff
          "Q" 'vc-dir-kill-dir-status-process
          "i" 'vc-dir-ignore
          "x" 'vc-dir-kill-line

          ;; vc-dir-search
          "C-s" 'vc-dir-isearch-regexp
          "M-s" 'vc-dir-query-replace-regexp

          "A" 'vc-dir-mark-all-files
          "m" 'vc-dir-mark
          "U" 'vc-dir-unmark-all-files
          "u" 'vc-dir-unmark
          ;; "t" 'vc-dir-toggle-mark ;; mouse event
          "<backspace>" 'vc-dir-unmark-file-up

          "p" 'vc-pull
          "P" 'vc-push

          "o"   'vc-dir-display-file
          "RET" 'vc-dir-find-file

          "C-j" 'vc-dir-next-line
          "C-k" 'vc-dir-previous-line
          "M-j" 'vc-dir-next-directory
          "M-k" 'vc-dir-previous-directory)

        (mohkale/set-leader-keys-for-major-mode 'vc-dir-mode
          "i" 'vc-log-incoming
          "o" 'vc-log-incoming
          "l" 'vc-print-log
          "L" 'vc-print-root-log
          "D" 'vc-root-diff
          "d" 'vc-diff
          "h" 'vc-dir-hide-up-to-date
          "u" 'vc-update ;; don't understand
          "m" 'vc-next-action)

        ;;; history + log
        ;; despite being different modes and using different maps, theses both incorporate
        ;; basically the same functions to accomplish the same things, so use the same config
        ;; for both of them.
        (dolist (tuple '((vc-git-region-history-mode . vc-git-region-history-mode-map)
                         ;; opens a log buffer showing all the commits affecting the highlighted
                         ;; region in the current file. It also shows the diffs for each commit.
                         (vc-git-log-view-mode       . vc-git-log-view-mode-map)
                         ;; shows all the previous commits alongside their commit messages
                         ))
          (let ((mode (car tuple))
                (kmap (cdr tuple)))
            (evil-set-initial-state mode 'motion)

            (general-define-key
              ;;; WARN unknown functions
              ;;    * log-view-modify-change-comment
              :states  'motion
              :keymaps kmap

              "q" 'quit-window
              "d" 'log-view-diff
              "=" 'log-view-diff
              "o" 'log-view-find-revision ; open current file at current commit

              "<return>" 'log-view-toggle-entry-display
              "<tab>"    'log-view-toggle-entry-display

              ;; move to next message, then reallign to top
              ;; (kbd "C-j") #'(lambda () (interactive) (log-view-msg-next)
              ;;                 (call-interactively 'evil-scroll-line-to-top))
              "C-j" 'log-view-msg-next
              "C-k" 'log-view-msg-prev

              "M-j" 'log-view-file-next
              "M-k" 'log-view-file-prev

              "C-M-j" 'diff-hunk-next
              ;; TODO reallign diff to propper location on move down without trapping on a single diff
              ;; (kbd "M-j") #'(lambda () (interactive) (diff-hunk-next)
              ;;                 (call-interactively 'evil-scroll-line-to-top)
              ;;                 (evil-previous-line 3))
              "C-M-k" #'(lambda () (interactive) (diff-hunk-prev) (evil-previous-line 3)))

            (mohkale/set-leader-keys-for-major-mode mode
              "p" 'log-view-diff-changeset
              "a" 'log-view-annotate-version
              "m" 'log-view-toggle-mark-entry
              "s" 'diff-goto-source)))

        ;;; making commits... why name it log :P
        (dolist (tuple '((vc-git-log-edit-mode . vc-git-log-edit-mode-map)))
          (let ((mode (car tuple))
                (kmap (cdr tuple)))
            (evil-set-initial-state mode 'insert)

            (general-define-key
              :states  'normal
              :keymaps kmap
              "C-q" 'log-edit-kill-buffer
              "M-s" 'log-edit-next-comment
              "M-r" 'log-edit-previous-comment
              "C-s" 'log-edit-comment-search-forward
              "C-r" 'log-edit-comment-search-backward
              "M-0" 'evil-beginning-of-line)

            ;; (evil-redirect-digit-argument kmap "0" 'log-edit-beginning-of-line)

            (mohkale/declare-prefix-for-mode* mode
              "mi" '("insert" . "insert shortcuts")
              "mt" '("toggle" . "toggle commit status"))

            (mohkale/set-leader-keys-for-major-mode mode
              "d" 'log-edit-show-diff
              "f" 'log-edit-show-files
              "?" 'log-edit-mode-help
              "SPC" 'log-edit-done
              "DEL" 'log-edit-kill-buffer

              "ic" 'log-edit-insert-changelog
              "if" 'log-edit-insert-filenames
              "iC" 'log-edit-insert-changelog-entries
              "iT" 'log-edit-insert-cvs-rcstemplate
              "it" 'log-edit-insert-cvs-template
              "iF" 'log-edit-insert-filenames-without-changelog
              "im" 'log-edit-insert-message-template

              "ta" 'vc-git-log-edit-toggle-amend
              "ts" 'vc-git-log-edit-toggle-signoff))))
    #+END_SRC

** languages
*** elisp
**** elisp-slime-nav
     #+BEGIN_SRC emacs-lisp
       (use-package elisp-slime-nav
         :ensure t
         :defer  t
         :commands (elisp-slime-nav-mode
                    elisp-slime-nav-find-elisp-thing-at-point
                    elisp-slime-nav-describe-elisp-thing-at-point)
         :hook (elisp-mode . elisp-slime-nav-mode)
         :config
         (mohkale/declare-prefix-for-major-mode 'emacs-lisp-mode
           "h"  "describe-symbol-at-point")

         (mohkale/set-leader-keys-for-major-mode 'emacs-lisp-mode
           "gp" 'elisp-slime-nav-find-elisp-thing-at-point
           "h" 'elisp-slime-nav-describe-elisp-thing-at-point))
     #+END_SRC

**** evil-lisp-state
     #+BEGIN_SRC emacs-lisp
       (use-package evil-lisp-state
         :ensure t
         :defer  t
         :commands (evil-lisp-state-leader
                    lisp-state-toggle-lisp-state
                    lisp-state-eval-sexp-end-of-line)
         :init
         (mohkale/set-leader-keys-for-major-mode 'emacs-lisp-mode
           "el" 'lisp-state-eval-sexp-end-of-line
           "." 'lisp-state-toggle-lisp-state))
     #+END_SRC

**** pp
     #+BEGIN_SRC emacs-lisp
       (use-package pp
         :defer t
         :commands (pp-eval-expression
                    pp-macroexpand-expression
                    pp-eval-last-sexp
                    pp-macroexpand-last-sexp)
         :init
         (mohkale/set-leader-keys-for-major-mode 'emacs-lisp-mode
           "em" 'pp-macroexpand-expression
           "eM" 'pp-macroexpand-last-sexp
           "ex" 'pp-eval-expression
           "eX" 'pp-eval-last-sexp))
     #+END_SRC

**** paredit
     #+BEGIN_SRC emacs-lisp
       (use-package paredit
         :ensure t
         :defer  t
         :hook (emacs-lisp-mode . paredit-mode)
         :init
         (add-hook 'emacs-lisp-mode-hook #'electric-pair-mode)
         :config
         ;; M-( wraps the next argument in parentheses
         ;; M-) closes the current argument, trims any
         ;;     trailing whitespace and inserts a newline
         ;; M-" same as " but then trims whitespace and inserts a newline
         (general-define-key
           :keymaps 'paredit-mode-map
           :states 'insert
           "<delete>" 'paredit-backward-delete
           "M-<delete>" 'paredit-forward-delete
           "C-<delete>" 'paredit-backward-kill-word
           ;; "C-M-<delete>" 'paredit-forward-kill-word
           ;; damn you windows
           ;; just use paredit forward, then kill backward
           "C-M-k" 'paredit-kill ;; forward body
           "<return>" 'paredit-newline)
         (general-define-key
           :keymaps 'paredit-mode-map
           :states 'normal
           "gsh" '(paredit-splice-sexp-killing-backward :which-key "splice-sexp-forward")
           "gsl" '(paredit-splice-sexp-killing-forward :which-key "splice-sexp-backward"))
         (general-define-key
           :keymaps 'paredit-mode-map
           :states '(normal insert)
           ;; movement
           ;; "C-h" 'backward-char
           ;; "C-l" 'forward-char
           "C-j" 'paredit-newline
           "C-M-h" 'paredit-backward
           "C-M-l" 'paredit-forward
           "C-<left>" 'paredit-backward
           "C-<right>" 'paredit-forward

           ;; transformation
           ;;; kill or wrap surrounding parentheses
           "C-S-K" 'paredit-splice-sexp
           "C-S-J" 'paredit-wrap-round
           ;;; include previous or next arguments in current sexp
           "C-S-H" 'paredit-backward-slurp-sexp
           "C-S-L" 'paredit-forward-slurp-sexp
           ;;; exclude previous or next arguments from current sexp
           "C-M-S-H" 'paredit-backward-barf-sexp
           "C-M-S-L" 'paredit-forward-barf-sexp

           "C-S-S" 'paredit-split-sexp
           "C-S-M-J" 'paredit-join-sexps ;; immeadiately with expression b4 point

           ;; splice next argument after point, deleting
           ;; arguments both before and after it
           ;; a cool shortcut, but not really necessary
           ;; "M-r"   'paredit-raise-sexp
           )
         :bind (:map paredit-mode-map
                ("C-<up>"    . nil)
                ("C-<down>"  . nil)
                ("C-<left>"  . nil)
                ("C-<right>" . nil)
                ("C-("       . nil)
                ("C-)"       . nil)))
     #+END_SRC

**** elisp-mode
     #+BEGIN_SRC emacs-lisp
       (use-package elisp-mode
         :defer t
         ;; show lambda as an actual lambda symbol
         :config
         (mohkale//define-pretty-symbols-for-mode 'emacs-lisp-mode
           ("lambda" . ?))
         (mohkale//define-pretty-symbols-for-mode 'lisp-interaction-mode
           ("lambda" . ?))

         (defun-evil-adjust-to-eol evil-adjust-eval-print-last-sexp (&optional arg)
           (interactive "P")
           (eval-print-last-sexp arg)
           (message nil))

         (defun-evil-adjust-to-eol evil-adjust-eval-last-sexp (&optional arg)
           (interactive "P")
           (eval-last-sexp arg)
           (message nil))

         (defun eval-replace-last-sexp (&optional prefix)
           "evaluate then replace the preceding sexp"
           (interactive "p")
           (let* ((sexp (preceding-sexp))
                  (value (eval sexp)))
             (kill-sexp -1)
             (insert (format (if prefix "%s" "%S") value))))

         (defun-evil-adjust-to-eol evil-adjust-eval-replace-last-sexp (&optional prefix)
           (interactive "P")
           (eval-replace-last-sexp prefix)
           (message nil))

         (evil-set-initial-state 'inferior-emacs-lisp-mode 'emacs)

         ;;   (defun elisp-transcript ()
         ;;     ;; source https://www.emacswiki.org/emacs/LispInteractionMode
         ;;     "Make an Emacs Lisp interactive transcript.
         ;; In a new buffer, make a transcript of the Emacs Lisp code by
         ;; evaluating each line and printing the result under it (/a la/
         ;;   TODO fix last sexp in the buffer isn't transcripted
         ;;   `eval-print-last-sexp')."
         ;;     (interactive)
         ;;     (let* ((eval-expression-print-length nil)
         ;;            (eval-expression-print-level nil)
         ;;            (input-buffer (current-buffer))
         ;;            (dest-buffer (get-buffer-create (concat "*Transcript for "
         ;;                                                    (buffer-name input-buffer)
         ;;                                                    "*"))))
         ;;       (save-current-buffer
         ;;         (set-buffer dest-buffer)
         ;;         (lisp-interaction-mode)
         ;;         (delete-region (point-min) (point-max))
         ;;         (insert-buffer-substring input-buffer) ;; `slurp!'
         ;;         (goto-char (point-min))
         ;;         (forward-sexp 1)
         ;;         (while (> (point-max) (point))
         ;;           (condition-case err
         ;;               (evil-adjust-eval-print-last-sexp)
         ;;             (error
         ;;              (insert (format "%s" err))
         ;;              (newline)))
         ;;           (forward-sexp 1)))
         ;;       (display-buffer dest-buffer)))

         (dolist (mode '(emacs-lisp-mode lisp-interaction-mode))
           (mohkale/declare-prefix-for-major-mode* mode
             "g" '("jump" . "jump to various places in source code")
             "e" "eval"
             "t" "test"

             ;; method aliases
             "gg" "jump-to-definition"
             "gG" "jump-to-definition-other-window"
             "eE" "eval-replace-last-sexp")

           (mohkale/set-leader-keys-for-major-mode mode
             ;; NOTE cl was bound to auto-compile-display-log
             "'" 'ielm
             "c" 'emacs-lisp-byte-compile
             "i" 'indent-sexp

             ;; eval
             "eb" 'eval-buffer
             "ee" 'eval-last-sexp
             "eE" 'evil-adjust-eval-replace-last-sexp
             "ef" 'eval-defun
             "er" 'eval-region
             ;; "et" 'elisp-transcript

             ;; jump
             "gg" 'xref-find-definitions
             "gG" 'xref-find-definitions-other-window

             ;; tests
             "tq" 'ert
             "ti" 'ert-run-tests-interactively))

         (general-define-key
           ;; :states '(normal insert motion replace)
           :keymaps 'lisp-interaction-mode-map
           "C-)" 'evil-adjust-eval-print-last-sexp
           "C-(" 'evil-adjust-eval-replace-last-sexp
           "C-S-E" 'evil-adjust-eval-print-last-sexp
           "C-S-R" 'evil-adjust-eval-replace-last-sexp)

         ;; (add-hook 'lisp-interaction-mode-hook #'(lambda () (paredit-mode -1)))
         :bind (:map lisp-interaction-mode-map
                ("C-j" . nil)))
     #+END_SRC

*** python
**** company-anaconda
     #+BEGIN_SRC emacs-lisp
       (use-package company-anaconda
         :ensure t
         :defer  t
         :commands (company-anaconda)
         :init
         (with-eval-after-load 'company
           (mohkale/update-company-backends-for-mode python t
             '(company-anaconda))))
     #+END_SRC

**** anaconda
     #+BEGIN_SRC emacs-lisp
       (use-package anaconda-mode
         :ensure t
         :defer  t
         :hook ((python-mode . anaconda-mode)
                (python-mode . anaconda-eldoc-mode))
         :commands (anaconda-mode-complete
                    anaconda-mode-show-doc
                    anaconda-mode-find-assignments
                    anaconda-mode-find-references
                    anaconda-mode-find-definitions
                    anaconda-mode-find-assignments-other-window
                    anaconda-mode-find-references-other-window
                    anaconda-mode-find-definitions-other-window
                    anaconda-mode-find-assignments-other-frame
                    anaconda-mode-find-references-other-frame
                    anaconda-mode-find-definitions-other-frame)
         :config
         (mohkale/set-leader-keys-for-major-mode 'python-mode
           "<tab>" 'anaconda-mode-complete
           "hh" 'anaconda-mode-show-doc

           "ga" 'anaconda-mode-find-assignments
           "gr" 'anaconda-mode-find-references
           "gg" 'anaconda-mode-find-definitions
           "gA" 'anaconda-mode-find-assignments-other-window
           "gR" 'anaconda-mode-find-references-other-window
           "gG" 'anaconda-mode-find-definitions-other-window
           "g M-a" 'anaconda-mode-find-assignments-other-frame
           "g M-r" 'anaconda-mode-find-references-other-frame
           "g M-g" 'anaconda-mode-find-definitions-other-frame))
     #+END_SRC

**** pyimport
     #+BEGIN_SRC emacs-lisp
       (use-package pyimport
         :ensure t
         :defer  t
         :commands (pyimport-remove-unused
                    pyimport-insert-missing)
         :init
         (mohkale/declare-prefix-for-major-mode 'python-mode "i" "imports")
         (mohkale/set-leader-keys-for-major-mode 'python-mode
           "ii" 'pytimport-remove-unused
           "iu" 'pyimport-insert-missing))
     #+END_SRC

**** py-isort
     #+BEGIN_SRC emacs-lisp
       (use-package py-isort
         :ensure t
         :defer  t
         :commands (py-isort-buffer
                    py-isort-region)
         :init
         (mohkale/declare-prefix-for-major-mode 'python-mode "i" "imports")
         (mohkale/set-leader-keys-for-major-mode 'python-mode
           "is" 'py-isort-buffer
           "ir" 'py-isort-region))
     #+END_SRC

**** pip-requirements
     #+BEGIN_SRC emacs-lisp
       (use-package pip-requirements
         :ensure t
         :defer  t
         :commands pip-requirements-mode
         :init
         (push (cons "^requirements\\.txt$" 'pip-requirements-mode) auto-mode-alist))
     #+END_SRC

**** yapfify
     #+BEGIN_SRC emacs-lisp
       (use-package yapfify
         :ensure t
         :defer  t
         :init
         (mohkale/set-leader-keys-for-major-mode 'python-mode
           "y" 'yapfify-buffer
           "Y" 'yapfify-region))
     #+END_SRC

**** python-mode
     #+BEGIN_SRC emacs-lisp
       (use-package python
         :defer t
         :hook (python-mode . flycheck-mode)
         :commands (python-mode
                    run-python)
         :init
         (defalias 'python-repl 'run-python)
         (evil-set-initial-state 'inferior-python-mode 'emacs)
         :config
         (setq python--prettify-symbols-alist nil)
         (mohkale//define-pretty-symbols-for-mode 'python-mode
           ("lambda" . ?))

         (defun python-shell-calculate-command ()
           "python3 -i")

         (mohkale/declare-prefix-for-major-mode* 'python-mode
           "n" '("navigate" . "move-point")
           "e" "eval/exec"
           "h" "help"
           "g" "jump"

           "d" "method-signature")
         (mohkale/set-leader-keys-for-major-mode 'python-mode
           "r" 'run-python ;; REPL
           "R" 'python-shell-switch-to-shell
           "m" 'python-mark-defun
           "v" 'python-check
           ;; unbound: python-nav-forward-sexp[-safe]
           ;;          python-nav-backward-sexp[-safe]

           "nh" 'python-nav-forward-statement
           "nj" 'python-nav-forward-block
           "nk" 'python-nav-backward-block
           "nl" 'python-nav-backward-statement
           "n(" 'python-nav-backward-up-list
           "n)" 'python-nav-up-list
           "n0" 'python-nav-beginning-of-block
           "n$" 'python-nav-end-of-block
           "nm" 'python-nav-if-name-main
           "n C-0" 'python-nav-beginning-of-statement
           "n C-$" 'python-nav-end-of-statement
           "n M-j" 'python-nav-forward-defun
           "n M-k" 'python-nav-backward-defun
           ;; "n M-0" 'python-nav-beginning-of-defun
           "n M-$" 'python-nav-end-of-defun

           "hp" 'python-eldoc-at-point
           "s" 'python-describe-at-point

           "ed" 'python-shell-send-defun
           "eb" 'python-shell-send-buffer
           "ef" 'python-shell-send-file
           "er" 'python-shell-send-region
           "ec" 'python-shell-send-string))
     #+END_SRC

*** ruby
    #+BEGIN_SRC emacs-lisp
      (defvar mohkale-ruby-mode (if (eq system-type 'gnu/linux) 'enh-ruby-mode 'ruby-mode)
        "determine which mode to use for ruby... enh-ruby is really slowing everything down on windows
      also, for some reason, creating a symlink to ruby on cygwin makes the process unrunnable from emacs,
      it just spits out exec error... my loathing towards windows grows :P
      TODO test out performance of enhanced ruby on linux.")

      (mohkale/set-leader-keys "Mr" mohkale-ruby-mode)
    #+END_SRC

**** ruby
     #+BEGIN_SRC emacs-lisp
       (use-package ruby
         ;; :ensure t
         :defer  t
         :commands (ruby-mode
                    ruby-toggle-string-quotes
                    ruby-toggle-block)
         :init
         (setq ruby-indent-level mohkale-preferred-indent)
         :config
         (mohkale/set-leader-keys-for-major-mode 'ruby-mode
           "'" 'ruby-toggle-string-quotes
           "{" 'ruby-toggle-block))
     #+END_SRC

**** enhanced ruby
     #+BEGIN_SRC emacs-lisp
       (use-package enh-ruby-mode
         :ensure t
         :defer  t
         :commands enh-ruby-mode
         :hook (enh-ruby-mode . flycheck-mode)
         :init
         ;; TODO add bindings for rake and others
         (when (eq mohkale-ruby-mode 'enh-ruby-mode)
           (push (cons "\\.rb$" 'enh-ruby-mode) auto-mode-alist)
           (push (cons "ruby" 'enh-ruby-mode) interpreter-mode-alist))
         :config
         (setq enh-ruby-indent-level mohkale-preferred-indent
               enh-ruby-deep-indent-paren nil
               enh-ruby-hanging-paren-deep-indent-level 2)
         (mohkale/declare-prefix-for-major-mode* 'enh-ruby-mode
           "i" "insert/format"
           "n" "navigate")
         (mohkale/set-leader-keys-for-major-mode 'enh-ruby-mode
           "m" 'enh-ruby-mark-defun
           "f" 'enh-ruby-find-file
           "e" 'enh-ruby-find-error

           "i <tab>" 'enh-ruby-indent-exp
           "ie" 'enh-ruby-insert-end
           "it" 'enh-ruby-indent-exp

           "nh" 'enh-ruby-backward-sexp
           "nl" 'enh-ruby-forward-sexp
           "nk" 'enh-ruby-up-sexp
           "n0" 'enh-ruby-beginning-of-block
           "n$" 'enh-ruby-end-of-block
           "n M-0" 'enh-ruby-beginning-of-defun
           "n M-$" 'enh-ruby-end-of-defun)
         (general-define-key
           :keymaps 'enh-ruby-mode-map
           :states 'insert
           "{" 'enh-ruby-electric-brace
           "}" 'enh-ruby-electric-brace)
         (general-define-key
           :keymaps 'enh-ruby-mode-map
           :states '(normal insert)
           "C-{" 'enh-ruby-toggle-block)
         :bind (:map enh-ruby-mode-map
                ("{" . nil)
                ("}" . nil)))
     #+END_SRC

**** solargraph
     language server implementation for ruby.

     #+BEGIN_SRC emacs-lisp :tangle no
       (add-hook 'ruby-mode-hook #'lsp)

       (with-eval-after-load 'company
         (mohkale/update-company-backends-for-mode enh-ruby t
           '(company-lsp))

         (mohkale/update-company-backends-for-mode ruby t
           '(company-lsp)))
     #+END_SRC

**** robe
     # WARN robe won't work unless your project contains some identifying gemfile or what not... so if your not getting any completion help, that's probably why.

     #+BEGIN_SRC emacs-lisp
       (use-package robe
         :ensure t
         :defer  t
         :commands (robe-mode
                    robe-start
                    ruby-load-file
                    company-robe)
         :init
         (with-eval-after-load 'company
           (mohkale/update-company-backends-for-mode enh-ruby t
             '(company-robe))

           (mohkale/update-company-backends-for-mode ruby t
             '(company-robe)))

         (add-hook (intern (concat (symbol-name mohkale-ruby-mode) "-hook")) #'robe-mode)
         :config
         (mohkale/declare-prefix-for-major-mode mohkale-ruby-mode "g" "jump/goto")

         (mohkale/set-leader-keys-for-major-mode mohkale-ruby-mode
           "rs" 'robe-start ;; REPL
           "h" 'robe-doc

           ;; jumping
           "SPC" 'robe-ask
           "gg" 'robe-jump
           "gm" 'robe-jump-to-module))
     #+END_SRC

**** inf-ruby
     #+BEGIN_SRC emacs-lisp
       (use-package inf-ruby
         :ensure t
         :defer  t
         :commands (inf-ruby
                    inf-ruby-console-gem
                    inf-ruby-console-zeus
                    inf-ruby-console-auto
                    inf-ruby-console-rails
                    inf-ruby-console-racksh
                    inf-ruby-console-script
                    inf-ruby-console-hanami
                    inf-ruby-console-default)
         :init
         (defalias 'ruby-repl 'inf-ruby)
         (push 'inf-ruby-mode mohkale--whitespace-exempt-modes)

         (mohkale/declare-prefix-for-major-mode mohkale-ruby-mode "r" "REPL")
         (mohkale/set-leader-keys-for-major-mode mohkale-ruby-mode
           "rr" 'inf-ruby
           "rg" 'inf-ruby-console-gem
           "rz" 'inf-ruby-console-zues
           "ra" 'inf-ruby-console-auto
           "rR" 'inf-ruby-console-rails
           "rk" 'inf-ruby-console-racksh
           "rc" 'inf-ruby-console-script
           "rh" 'inf-ruby-console-hanami))
     #+END_SRC

**** ruby-tools
     #+BEGIN_SRC emacs-lisp
       (use-package ruby-tools
         :ensure t
         :defer  t
         :commands (ruby-tools-mode)
         :init
         (add-hook (intern (concat (symbol-name mohkale-ruby-mode) "-hook")) #'ruby-tools-mode)
         :config
         (mohkale/declare-prefix-for-major-mode
           mohkale-ruby-mode "i" "insert")

         (mohkale/set-leader-keys-for-major-mode mohkale-ruby-mode
           "i:" 'ruby-tools-to-symbol
           "i{" 'ruby-tools-interpolate
           "i <backspace>" 'ruby-tools-clear-string
           "i\"" 'ruby-tools-to-double-quote-string
           "i'" 'ruby-tools-to-single-quote-string))
     #+END_SRC

**** bundle
     #+BEGIN_SRC emacs-lisp
       (use-package bundler
         :ensure t
         :defer  t
         :commands (bundle-open
                    bundle-console
                    bundle-install
                    bundle-update
                    bundle-check)
         :init
         (mohkale/declare-prefix-for-major-mode*
           mohkale-ruby-mode "b" "bundler")

         (mohkale/set-leader-keys-for-major-mode mohkale-ruby-mode
           "rb" 'bundle-console
           "bf" 'bundle-open
           "bi" 'bundle-install
           "bu" 'bundle-update
           "bc" 'bundle-check))
     #+END_SRC

**** ruby-electric
     #+begin_src emacs-lisp :tangle yes
       (use-package ruby-electric
         :ensure t
         :defer  t
         :commands (ruby-electric-mode)
         :init
         (add-hook (intern (concat (symbol-name mohkale-ruby-mode) "-hook")) #'ruby-electric-mode)
         :config
         ;;; why poison the standard ruby map instead of using ruby-electric-mode-map?
         (defun ruby-electric-setup-keymap ()
           (general-define-key
             :keymaps 'ruby-mode-map
             " " 'ruby-electric-space
             ;; "{" 'ruby-electric-curlies
             "(" 'ruby-electric-matching-char
             "[" 'ruby-electric-matching-char
             ;; "\"" 'ruby-electric-quote
             ;; "\'" 'ruby-electric-quote
             "|" 'ruby-electric-bar
             (kbd "RET") 'ruby-electric-return
             ;; (kbd "C-j") 'ruby-electric-return
             ;; (kbd "C-m") 'ruby-electric-return
             "}" 'ruby-electric-close-matching-char
             ")" 'ruby-electric-close-matching-char
             "]" 'ruby-electric-close-matching-char)))
     #+end_src

*** HTML
**** web-mode
     #+BEGIN_SRC emacs-lisp
       (use-package web-mode
         :ensure t
         :defer  t
         :init
         (dolist (regexp '("\\.erb"
                           "\\.html"))
           (push (cons regexp 'web-mode) auto-mode-alist))
         (setq css-indent-offset mohkale-preferred-indent)
         :config
         (setq web-mode-markup-indent-offset mohkale-preferred-indent
               web-mode-css-indent-offset mohkale-preferred-indent
               web-mode-code-indent-offset mohkale-preferred-indent)

         (general-define-key
           :keymaps 'web-mode-map
           :states 'normal
           "<tab>" 'web-mode-fold-or-unfold)

         (mohkale/declare-prefix-for-major-mode* 'web-mode
           "m" "mark"
           "d" "delete/kill"
           "D" "DOM"
           "n" "navigate"
           "na" "attributes"
           "nt" "tags"
           "r" "refactor"
           "i" "insert")

         (mohkale/set-leader-keys-for-major-mode 'web-mode
           ;; unbound:
           ;;   * web-mode-buffer-highlight
           ;;   * web-mode-element-mute-blanks
           ;;   * web-mode-block-beginning
           ;;   * web-mode-block-end
           ;;   * web-mode-block-insert
           ;;   * web-mode-block-kill
           ;;   * web-mode-block-next
           ;;   * web-mode-block-previous
           ;;   * web-mode-block-select
           ;;   * web-mode-block-transpose
           ;;   * web-mode-navigate
           ;;
           ;; WARN the block commands don't seem to do anything

           ";"     'web-mode-comment-or-uncomment
           "f"     'web-mode-fold-or-unfold
           "l"     'web-mode-file-link
           "b"     'web-mode-element-close ; insert matching tag for body at point
           "M-r"   'web-mode-reload
           "<tab>" 'web-mode-buffer-indent
           "C-M-i" 'web-mode-snippet-insert
           ;; "tw" 'web-mode-whitespace-show

           ;; insert
           "ia" 'web-mode-attribute-insert
           "ip" 'web-mode-element-wrap ; wrap current element in a new element with name from prompt
           "ic" 'web-mode-element-clone
           "ie" 'web-mode-element-insert
           "ie" 'web-mode-element-insert-at-point ; converts word before point to tag

           ;; refactor/insert
           "rs" 'web-mode-tag-attributes-sort
           "r(" 'web-mode-element-extract  ; add linebreak before every tag in body
           "r)" 'web-mode-element-contract ; collapse tag into a single line
           "rn" 'web-mode-dom-normalize
           "ra" 'web-mode-attribute-transpose
           "re" 'web-mode-element-transpose
           "rr" 'web-mode-element-rename
           "rf" 'web-mode-fold-or-unfold
           "rF" 'web-mode-element-children-fold-or-unfold ; collapse the children of current tags body, not body itself

           ;; delete
           "da" 'web-mode-attribute-kill
           "de" 'web-mode-element-kill
           "dp" 'web-mode-element-vanish ; delete element, but move body up a level instead of erasing it

           ;; DOM
           "Da" 'web-mode-dom-apostrophes-replace
           "Ds" 'web-mode-dom-entities-replace
           "Dq" 'web-mode-dom-quotes-replace
           "D/" 'web-mode-dom-xpath
           ; shows the xpath of the current element

           "hd" 'web-mode-dom-errors-show
           "hj" 'web-mode-jshint

           ;; mark
           "mT" 'web-mode-tag-select
           ; only works while between <>
           "mt" 'web-mode-element-select
           "ma" 'web-mode-attribute-select
           "mb" 'web-mode-element-content-select
           "mm" 'web-mode-mark-and-expand

           ;; navigation
           "n0" 'web-mode-element-beginning
           "n$" 'web-mode-element-end
           "nn" 'web-mode-tag-match
           "nh" 'web-mode-element-next
           "nj" 'web-mode-element-child
           "nk" 'web-mode-element-previous
           "nh" 'web-mode-element-parent
           ;; "nt" 'web-mode-dom-traverse
           "na0" 'web-mode-attribute-beginning
           "na$" 'web-mode-attribute-end
           "nah" 'web-mode-attribute-previous
           "nal" 'web-mode-attribute-next
           "nt0" 'web-mode-tag-beginning
           "nt$" 'web-mode-tag-end
           "nth" 'web-mode-tag-previous
           "ntl" 'web-mode-tag-next))
     #+END_SRC

**** emmet-mode
     #+BEGIN_SRC emacs-lisp
       (use-package emmet-mode
         :ensure t
         :defer  t
         :hook (web-mode . emmet-mode)
         :commands (emmet-mode
                    emmet-expand-yas
                    emmet-expand-line
                    emmet-preview-mode
                    emmet-preview)
         :config
         (mohkale/declare-prefix-for-mode 'emmet-mode
           (concat mohkale-major-mode-leader-prefix "e") "emmet" "emmet mode")
         (mohkale/set-leader-keys-for-minor-mode 'emmet-mode
           (concat mohkale-major-mode-leader-prefix ".") 'emmet-expand-line
           ;; (concat mohkale-major-mode-leader-prefix "'") 'emmet-preview
           (concat mohkale-major-mode-leader-prefix "ee") 'emmet-expand-line
           (concat mohkale-major-mode-leader-prefix "ep") 'emmet-preview
           (concat mohkale-major-mode-leader-prefix "ew") 'emmet-wrap-with-markup
           (concat mohkale-major-mode-leader-prefix "en") 'emmet-next-edit-point
           (concat mohkale-major-mode-leader-prefix "eN") 'emmet-prev-edit-point)
         :bind* (:map emmet-mode-keymap
                 ("C-j" . nil)))
     #+END_SRC

**** company-web
     #+BEGIN_SRC emacs-lisp
       (use-package company-web
         :ensure t
         :defer  t
         :init
         (with-eval-after-load 'company
           (mohkale/update-company-backends-for-mode web t
             '(company-web-html company-yasnippet))))
     #+END_SRC

**** simple-httpd
     #+BEGIN_SRC emacs-lisp
       (use-package simple-httpd
         :ensure t
         :defer  t
         :commands (httpd-start
                    httpd-stop)
         :config
         (setq httpd-port 35343))
     #+END_SRC

**** web-beautify
     #+BEGIN_SRC emacs-lisp
       (use-package web-beautify
         :ensure t
         :defer  t
         :commands (web-beautify-js
                    web-beautify-html
                    web-beautify-css)
         :init
         (mohkale/declare-prefix-for-major-mode 'web-mode "rb" "beautify")
         (mohkale/set-leader-keys-for-major-mode 'web-mode
           "rbh" 'web-beautify-htlm
           "rbj" 'web-beautify-js
           "rbc" 'web-beautify-css))
     #+END_SRC

*** org
    Yes, org mode is it's own language. Even if you don't think it is, it is :P

**** org-agenda
     #+BEGIN_SRC emacs-lisp
       (use-package org-agenda
         :ensure nil
         :defer  t
         :config
         (evil-set-initial-state 'org-agenda-mode 'normal)

         (mohkale/declare-prefix-for-major-mode* 'org-agenda-mode
           "c" '("clock/calendar" . "time management based prefix keys")
           "m" '("modes" . "minor modes to support agenda mode")
           "p" '("priority" . "alter/view an entries priority")
           "/" '("search/filter" . "search / filter org agenda"))

         (mohkale/set-leader-keys-for-major-mode 'org-agenda-mode
           "." 'hydra-org-agenda/body
           "A" 'org-agenda-append-agenda
           "C" 'org-agenda-columns

           ;;; filter/search
           "/c" 'org-agenda-filter-by-category
           "/e" 'org-agenda-filter-by-effort
           "//" 'org-agenda-filter-by-regexp
           ;; "/t" 'org-agenda-filter-by-tag
           "/:" 'org-agenda-filter-by-tag
           "/h" 'org-agenda-filter-by-top-headline
           "/R" 'org-agenda-filter-remove-all

           "/?" 'org-agenda-bulk-mark-regexp
           "/a" 'org-agenda-bulk-mark-all
           "/u" 'org-agenda-bulk-unmark-all

           ;;; clock/calendar/diary
           "cp" 'org-agenda-date-prompt
           "cc" 'org-agenda-clock-in
           "co" 'org-agenda-clock-out
           "cC" 'org-agenda-clock-out ; alias
           "ct" 'org-timer-set-timer
           "c M-c" 'org-agenda-convert-date

           ;;; agenda minor modes
           "ma" 'org-agenda-archives-mode
           "md" 'org-agenda-day-view
           "mc" 'org-agenda-clockreport-mode
           "mt" 'org-agenda-entry-text-mode
           "mf" 'org-agenda-follow-mode
           "ml" 'org-agenda-log-mode
           "mw" 'org-agenda-week-view
           "my" 'org-agenda-year-view
           "mm" 'org-agenda-month-view

           ;;; priorities
           "pp" 'org-agenda-priority
           "pu" 'org-agenda-priority-up
           "pd" 'org-agenda-priority-down)

         (general-define-key
           :keymaps 'org-agenda-mode-map
           :states  'normal
           ;;; globally useful
           "q" 'org-agenda-exit
           "." 'org-agenda-goto-today
           "v" 'org-agenda-view-mode-dispatch
           "RET" 'org-agenda-goto
           "TAB" 'org-agenda-switch-to
           "M-c" 'org-agenda-clock-goto ; jumped to clocking task
           "C-t" 'org-agenda-todo
           "M-t" 'org-agenda-show-tags

           ;;; marking
           "C-<SPC>" 'org-agenda-bulk-mark
           "M-<SPC>" 'org-agenda-bulk-unmark
           "C-M-SPC" 'org-agenda-bulk-action

           ;;; undo/redo
           "C-r" 'org-agenda-redo
           "u"   'org-agenda-undo
           "gr"        'org-agenda-redo-all

           ;;; toggle displays
           "gm" 'org-agenda-phases-of-moon
           "C-l" 'org-agenda-log-mode
           "M-l" 'org-agenda-toggle-time-grid
           "M-h" 'org-agenda-holidays
           "M-s" 'org-agenda-sunrise-sunset

           ;; edit org items
           "M-e" 'org-agenda-set-effort
           "C-a" 'org-agenda-archive-default-with-confirmation

           ;;; notes and insertion
           "a"  'org-agenda-add-note
           "c"  'org-agenda-capture
           "gd" 'org-agenda-goto-date
           "gc" 'org-agenda-goto-calendar

           ;;; movement between lines
           ;;; NOTE org-next/prev-line is used by follow-mode
           "k"      'org-agenda-previous-line
           "j"      'org-agenda-next-line
           "<up>"   'org-agenda-previous-line ; alias
           "<down>" 'org-agenda-next-line     ; alias
           "C-j"    'org-agenda-next-item
           "C-k"    'org-agenda-previous-item

           ;;; move through time in blocks
           "f" 'org-agenda-later
           "F" 'org-agenda-earlier

           "C-f" 'org-agenda-follow-mode
           "M-f" 'org-agenda-recenterstates))
     #+END_SRC

**** org-bullets
     #+BEGIN_SRC emacs-lisp
       (use-package org-bullets
         :ensure t
         :defer  t
         :commands org-bullets-mode
         :hook (org-mode . org-bullets-mode))
     #+END_SRC

**** org-link-edit
     #+BEGIN_SRC emacs-lisp
       (use-package org-link-edit
         :defer  t
         :commands (org-link-edit-forward-slurp
                    org-link-edit-forward-barf
                    org-link-edit-backward-slurp
                    org-link-edit-backward-barf))
     #+END_SRC

**** org-toc
     #+BEGIN_SRC emacs-lisp
       (use-package toc-org
         :ensure t
         :defer  t
         :commands toc-org-mode
         ;; :hook (org-mode . toc-org-mode)
         )
     #+END_SRC

**** org-mode
     #+BEGIN_SRC emacs-lisp
       (use-package org
         :ensure t
         :defer  t
         :hook ((org-mode . mohkale//enable-line-numbers-handler))
         :commands (org-capture
                    org-agenda
                    org-copy-subtree
                    org-cut-subtree
                    org-outline-smart-up-level)
         :init
         ;;; leader keys outside of org mode
         (mohkale/declare-prefix "o" "org")
         (mohkale/set-leader-keys
           "oc" 'org-capture
           "oa" 'org-agenda
           "oy" 'org-copy-subtree
           "oc" 'org-cut-subtree)
         :config
         (mohkale//define-pretty-symbols-for-mode 'org-mode
           ("lambda" . ?))

         ;; switch to insert state when capturing org templates
         (add-hook 'org-capture-mode-hook (lambda () (evil-append nil)) t)

         (defun org-src--prevent-window-config-being-saved-wrapper (&rest args)
           "prevents org mode from saving and restoring the window config
       sorrunding a source code edit. it's annoyingly frustrating, so turn it off"
           (setq org-src--saved-temp-window-config nil))

         (advice-add 'org-edit-src-code :after #'org-src--prevent-window-config-being-saved-wrapper)

         (when (file-exists-p mohkale-library-of-babel-file)
           (org-babel-lob-ingest mohkale-library-of-babel-file))

         (let ((org-root (concat mohkale-config-root "/org/")))
           (setq-default org-src-window-setup 'current-window
                         org-babel-python-command "python3")

           (setq org-todo-keywords '((sequence "TODO" "DOING" "VERIFY" "|" "DONE" "DELAGATED" "SKIPPED"))
                 org-refile-targets '((nil :maxlevel . 9)
                                      (org-agenda-files :maxlevel . 9))
                 org-outline-path-complete-in-steps nil ; refile in a single go
                 org-refile-use-outline-path t ; show full paths for refiling
                 org-cycle-separator-lines 0 ; prevents weird coloring of collapsed trees
                 ;; org-blank-before-new-entry '((heading . nil) (plain-list-item . auto))
                 ;; break org-cycle-seperator-lines from working automatically
                 ;; org-src-tab-acts-natively t ;; tab is native to block language
                 ;; native tabs are slow and unreliable... :sad:
                 org-default-notes-file (concat org-root "notes.org")
                 org-agenda-files (file-expand-wildcards (concat org-root "*.org")))

           (setq org-capture-templates
                 `(("f" "File Task" entry (file ,org-default-notes-file)
                    "* TODO %?\n  %a"
                    :kill-buffer t)
                   ("t" "Todo" entry (file ,org-default-notes-file)
                    "* TODO %?\n%U")
                   ("T" "Todo with Clipboard" entry (file ,org-default-notes-file)
                    "* TODO %?\n%U\n   %c")
                   ("h" "Homework" entry (file+headline ,(concat org-root "university.org") "Homework")
                    "* TODO%? %^g\n  DEADLINE: %^{Deadline}t\n  :LOGBOOK:\n  - Added %u\n  :END:"
                    :kill-buffer t))))

         (advice-add 'org-edit-src-code :before #'(lambda (&rest args)
                                                    (unless (eq evil-state 'normal)
                                                      (evil-normal-state))))

         (defun org-outline-smart-up-level ()
           "when at a heading, move to parent
       otherwise move to current heading."
           (interactive)
           (call-interactively (if (org-at-heading-p)
                                   'outline-up-heading
                                 'outline-previous-heading)))

         ;;  _
         ;; | | __ _ _ __   __ _ _   _  __ _  __ _  ___  ___
         ;; | |/ _` | '_ \ / _` | | | |/ _` |/ _` |/ _ \/ __|
         ;; | | (_| | | | | (_| | |_| | (_| | (_| |  __/\__ \
         ;; |_|\__,_|_| |_|\__, |\__,_|\__,_|\__, |\___||___/
         ;;                |___/             |___/

         (org-babel-do-load-languages
          'org-babel-load-languages
          '((emacs-lisp . t)
            (awk . t)
            (C . t)
            (awk . t)
            (java . t)
            (js . t)
            (ditaa . t)
            (python . t)
            (ruby . t)
            (sed . t)
            (shell . t)
            (R . t)))

         (push '("ditaa" . fundamental)
               org-src-lang-modes)

         ;;             _ _       _     _           _ _
         ;;   _____   _(_) |     | |__ (_)_ __   __| (_)_ __   __ _ ___
         ;;  / _ \ \ / / | |_____| '_ \| | '_ \ / _` | | '_ \ / _` / __|
         ;; |  __/\ V /| | |_____| |_) | | | | | (_| | | | | | (_| \__ \
         ;;  \___| \_/ |_|_|     |_.__/|_|_| |_|\__,_|_|_| |_|\__, |___/
         ;;                                                   |___/

         (defmacro evil-org-eol-call-anon (&rest body)
           "define an anonymous function running body at the end of the line"
           `(lambda () (interactive) (end-of-visual-line) ,@body (evil-append nil)))

         (defvar org-clever-return--insert-headings nil
           "when true, returning from the end of a heading
       inserts a heading.")

         (defun org-clever-return (&optional above)
           "depending on the local state, inserts a heading, a table row an item or newline.
       this function is functionally similair to the result of evil-org-eol-call-anon, but
       instead of checking the line after moving to the end of it (which doesn't work for
       folded lines, such as headings), it checks before moving and then inserts the right
       items depending on how things looked where you were."
           (interactive)
           (cl-letf (((symbol-function 'evil-open)
                      (lambda () (call-interactively
                             (if above
                                 'evil-open-above
                               'evil-open-below))))
                     ((symbol-function 'fallback-action)
                      (lambda ()
                        (when (and (line-empty-p)
                                   (not (zerop (column-number (point)))))
                          ;; don't leave a trailing indent on current line unecessarily
                          (remove-all-trailing-whitespace (line-beginning-position)
                                                          (line-end-position)))
                        (if (and (called-interactively-p)
                                 (not above))
                            (funcall-interactively
                             'newline-and-indent)
                          (evil-open)))))
             (if (and current-prefix-arg (listp current-prefix-arg))
                 ;; when called with simple prefix, goto
                 ;; fallaback action.
                 (let ((current-prefix-arg nil))
                   (fallback-action))
               (cond ((org-table-p)
                      (org-table-insert-row (not above))
                      (evil-insert nil))

                     ((and org-clever-return--insert-headings
                           (org-at-heading-p))
                      (evil-open)
                      (org-insert-heading))

                     ((org-at-item-p)
                      ;; position of cursor dictates where new point goes
                      (if above
                          (goto-char (line-beginning-position))
                        (goto-char (line-end-position)))
                      (org-insert-item)
                      (evil-append nil))

                     (t (fallback-action))))))

         (general-define-key
           :keymaps 'org-mode-map
           :states 'insert
           "<return>" 'org-clever-return)

         (general-define-key
           :keymaps 'org-mode-map
           :states 'normal
           "o" '(lambda () (interactive)
                  (let ((org-clever-return--insert-headings t))
                    (org-clever-return nil)))
           "O" '(lambda () (interactive)
                  (let ((org-clever-return--insert-headings t))
                    (org-clever-return t)))
           "M-u" 'org-metaleft
           "M-i" 'org-metadown
           "M-o" 'org-metaup
           "M-p" 'org-metaright
           "M-U" 'org-shiftmetaleft
           "M-I" 'org-shiftmetadown
           "M-O" 'org-shiftmetaup
           "M-P" 'org-shiftmetaright)

         (general-define-key
           :keymaps 'org-mode-map
           :states '(normal insert)
           ;; NOTE meta keys insert headings with changed priority, shift keys insert todo headings
           ;; FIXME prefix arg doesn't work
           ;; FIXME doesn't work when on a heading
           "C-<return>"   (evil-org-eol-call-anon (org-insert-heading nil))
           "C-M-<return>" (evil-org-eol-call-anon
                           (org-insert-heading nil)
                           (if current-prefix-arg
                               (org-metaleft)
                             (org-metaright)))
           "C-S-<return>"   (evil-org-eol-call-anon (org-insert-todo-heading nil))
           "C-S-M-<return>" (evil-org-eol-call-anon
                             (org-insert-todo-heading nil)
                             (if current-prefix-arg
                                 (org-metaleft)
                               (org-metaright)))
           "C-." 'org-toggle-heading)

         (general-define-key
           ;; most bindings stolen from: https://github.com/edwtjo/evil-org-mode
           :keymaps 'org-mode-map
           :states '(normal visual)
           "gh" 'org-outline-smart-up-level
           "gj" 'org-forward-heading-same-level
           "gk" 'org-backward-heading-same-level
           "gl" 'outline-next-visible-heading
           "g." 'hydra-org-navigate/body
           ;; "t" 'org-todo ; I use this too often
           ;; "T" 'org-insert-todo-heading ; rebound to C-S-<return>
           "$" 'org-end-of-line
           "^" 'org-beginning-of-line)

         (general-define-key
           :keymaps 'org-mode-map
           :states '(normal visual)
           :predicate '(or (org-table-p)
                           (org-at-heading-p)
                           (org-at-item-p))
           "C-j" 'org-metadown
           "C-k" 'org-metaup)

         (general-define-key
           :keymaps 'org-mode-map
           :states '(normal visual insert emacs)
           "<tab>" 'org-cycle
           "TAB" 'org-cycle
           "<S-tab>" 'org-shifttab)

         (general-define-key
           :keymaps 'org-mode-map
           :states '(normal visual)
           :predicate '(org-at-heading-p)
           ">" 'org-demote-subtree
           "<" 'org-promote-subtree)

         (general-define-key
           :keymaps 'org-mode-map
           :states '(normal insert)
           :predicate '(org-at-heading-p)
           "C->" 'org-demote-subtree
           "C-<" 'org-promote-subtree)

         ;;  _                _                _
         ;; | | ___  __ _  __| | ___ _ __     | | _____ _   _ ___
         ;; | |/ _ \/ _` |/ _` |/ _ \ '__|____| |/ / _ \ | | / __|
         ;; | |  __/ (_| | (_| |  __/ | |_____|   <  __/ |_| \__ \
         ;; |_|\___|\__,_|\__,_|\___|_|       |_|\_\___|\__, |___/
         ;;                                             |___/

         (mohkale/declare-prefix-for-major-mode* 'org-mode
           "c" "clock/calendar"
           "e" "export"
           "h" "headings"
           "g" "jump"
           "i" "insert"
           "S" "subtrees"
           "t" "tables"
           "m" "mark/move"
           "N" "narrow"
           "x" "text"

           "td" "delete"
           "ti" "insert"
           "tt" "toggle")

         (mohkale/set-leader-keys-for-major-mode 'org-mode
           "RET" 'org-ctrl-c-ret
           "SPC" 'org-display-outline-path
           "!" 'org-time-stamp-inactive
           "'" 'org-edit-special
           "*" 'org-ctrl-c-star
           "," 'org-ctrl-c-ctrl-c
           "-" 'org-ctrl-c-minus
           "." 'org-time-stamp
           "/" 'org-sparse-tree
           ":" 'org-set-tags-command
           "^" 'org-sort
           "A" 'org-archive-subtree
           "a" 'org-agenda
           "b" 'org-tree-to-indirect-buffer
           ;; "C" 'evil-org-recompute-clocks
           "D" 'org-insert-drawer
           "d" 'org-deadline
           "f" 'org-set-effort
           "I" 'org-clock-in
           "H" 'org-shiftleft
           "J" 'org-shiftdown
           "K" 'org-shitup
           "L" 'org-shiftright
           "l" 'org-open-at-point
           "n" 'org-add-note
           "O" 'org-clock-out
           "P" 'org-set-property
           "p" 'org-pomodoro
           "r" 'org-refile
           "R" 'org-refile-goto-last-stored
           "s" 'org-schedule
           "T" 'org-show-todo-tree
           "U" 'org-update-all-dblocks
           "u" 'org-dblock-update
           "C-h" 'org-shiftcontrolleft
           "C-j" 'org-shiftcontroldown
           "C-k" 'org-shiftcontrolup
           "C-l" 'org-shiftcontrolright
           "M-a" 'org-attach
           "M-c" 'org-columns
           "M-p" 'org-delete-property

           "c<" 'org-date-from-calendar
           "c>" 'org-goto-calendar
           "cC" 'org-clock-out
           "cc" 'org-clock-in
           ;; "cf" 'org-clock-modify-effort-estimate
           "cg" 'org-clock-goto
           "ch" 'org-clock-remove-overlays
           "ci" 'org-timer-item
           "cr" 'org-clock-report
           "cs" 'org-clock-display
           "c." 'hydra-org-clock/body
           "c C-c" 'org-clock-cancel

           "ee" 'org-export-dispatch
           "eh" 'org-html-export-to-html

           "hI" 'org-insert-heading
           "hi" 'org-insert-heading-after-current
           "hs" 'org-insert-subheading

           "ia" 'org-attach
           "if" 'org-footnote-new
           ;; "ik" 'insert-keybinding-org
           "il" 'org-insert-link
           ;; "is" 'org-download-screenshot
           ;; "iy" 'org-download-yank

           "ms" 'org-mark-subtree
           "me" 'org-mark-element
           "mb" 'org-babel-mark-block
           "mm." 'hydra-org-navigate/body

           "Nb" 'org-narrow-to-block
           "Ns" 'org-narrow-to-subtree
           "Ne" 'org-narrow-to-element
           "Nw" 'widen

           "Sh" 'org-promote-subtree
           "Sj" 'org-move-subtree-down
           "Sk" 'org-move-subtree-up
           "Sl" 'org-demote-subtree

           "t'"  'org-table-edit-field
           "ta"  'org-table-align
           "tb"  'org-table-blank-field
           "tc"  'org-table-convert
           "tE"  'org-table-export
           "te"  'org-table-eval-formula
           "tH"  'org-table-move-column-left
           "th"  'org-table-previous-field
           "tI"  'org-table-import
           "tJ"  'org-table-move-row-down
           "tj"  'org-table-next-row
           "tK"  'org-table-move-row-up
           "tL"  'org-table-move-column-right
           "tl"  'org-table-next-field
           "tN"  'org-table-create-with-table.el
           "tn"  'org-table-create
           "tp"  'org-plot/gnuplot
           "tr"  'org-table-recalculate
           "ts"  'org-table-sort-lines
           "tw"  'org-table-wrap-region
           "tdc" 'org-table-delete-column
           "tdr" 'org-table-delete-row
           "tic" 'org-table-insert-column
           "tiH" 'org-table-hline-and-move
           "tih" 'org-table-insert-hline
           "tir" 'org-table-insert-row
           "ttf" 'org-table-toggle-formula-debugger
           "tto" 'org-table-toggle-coordinate-overlays

           ;; "xb" 'org-bold
           ;; "xc" 'org-code
           ;; "xi" 'org-italic
           ;; "xr" 'org-clear
           ;; "xs" 'org-strike-through
           ;; "xu" 'org-underline
           ;; "xv" 'org-verbose
           )
         :bind* (:map org-mode-map
                 ;; "C-M-<return>" org-meta-return)
                 ("C-s" . org-sort)
                 ("M-S-<return>" . nil)
                 ("C-e" . nil)
                 ("M-e" . nil)
                 ("M-h" . nil)
                 ("C-j" . nil)))
     #+END_SRC

**** org-capture
     #+BEGIN_SRC emacs-lisp
       (use-package org-capture
         :defer t
         :config
         (mohkale/set-leader-keys-for-minor-mode 'org-capture-mode
           (concat mohkale-major-mode-leader-prefix ",") 'org-capture-finalize
           (concat mohkale-major-mode-leader-prefix "q") 'org-capture-kill
           (concat mohkale-major-mode-leader-prefix "r") 'org-capture-refile))
     #+END_SRC

**** org-src
     #+BEGIN_SRC emacs-lisp
       (use-package org-src
         :defer t
         :config
         (mohkale/set-leader-keys-for-minor-mode 'org-src-mode
           (concat mohkale-major-mode-leader-prefix ",") 'org-edit-src-exit
           (concat mohkale-major-mode-leader-prefix "q") 'org-edit-src-abort
           (concat mohkale-major-mode-leader-prefix "s") 'org-edit-src-save))
     #+END_SRC

*** JSON
    #+BEGIN_SRC emacs-lisp
      (use-package json-mode
        :ensure t
        :defer  t
        :commands (json-decrement-number-at-point
                   json-increment-number-at-point

                   json-mode
                   json-mode-beautify
                   json-nullify-sexp
                   json-mode-show-path
                   json-toggle-boolean
                   json-mode-kill-path)
        :hook (json-mode . flycheck-mode)
        :hook (json-mode . flycheck-mode)
        :init
        (push (cons "\\.json$" 'json-mode) auto-mode-alist)
        :config
        (mohkale/set-leader-keys-for-major-mode 'json-mode
          "b" 'json-mode-beautify
          "/" 'json-mode-kill-path
          "t" 'json-toggle-boolean
          "<backspace>" 'json-nullify-sexp))
    #+END_SRC

*** vimscript
    #+BEGIN_SRC emacs-lisp
      (use-package vimrc-mode
        :ensure t
        :defer  t
        :hook (vimrc-mode . flycheck-mode)
        :commands vimrc-mode
        :delight (vimrc-mode "vim")
        :init
        (push (cons "\\.vim" 'vimrc-mode) auto-mode-alist))
    #+END_SRC

*** sql
**** sql
     #+BEGIN_SRC emacs-lisp
       (use-package sql
         :ensure t
         :defer  t
         :commands (sql-mode
                    sql-connect
                    sql-save-connection
                    sql-beginning-of-statement
                    sql-end-of-statement)
         :hook (sql-mode . flycheck-mode)
         :init
         (setq sql-sqlite-options '("-interactive"))
         (push (cons "\\.sql" 'sql-mode) auto-mode-alist)
         (push 'sql-interactive-mode mohkale--whitespace-exempt-modes)

         (evil-set-initial-state 'sql-interactive-mode 'emacs)
         :config
         ;; see [here](https://truongtx.me/2014/08/23/setup-emacs-as-an-sql-database-client)
         ;; for a guide on how to make quick database access easier. or if you've already got
         ;; an interactive session running, use sql-save-connection to append it to a local
         ;; variable from which you can just paste it in here.
         (mohkale/declare-prefix-for-mode* 'sql-mode
           "e" "eval/exec"
           "l" "list")

         (mohkale/set-leader-keys-for-major-mode 'sql-mode
           "0" 'sql-beginning-of-statement
           "$" 'sql-end-of-statement
           "i" 'sql-show-sqli-buffer
           "t" 'sql-toggle-pop-to-buffer-after-send-region
           "eb" 'sql-send-buffer
           "ep" 'sql-send-paragraph
           "er" 'sql-send-region
           "es" 'sql-send-string
           "ll" 'sql-list-all
           "lt" 'sql-list-table)

         (mohkale/set-leader-keys-for-major-mode 'sql-interactive-mode
           "t" 'sql-list-table
           "a" 'sql-list-all))

     #+END_SRC

**** sqlup
     upcases SQL specific keywords after completing them.

     #+BEGIN_SRC emacs-lisp
       (use-package sqlup-mode
         :ensure t
         :defer  t
         :hook ((sql-mode . sqlup-mode)
                (sql-interactive-mode . sqlup-mode))
         :commands (sqlup-mode
                    sqlup-capitalize-keywords-in-buffer
                    sqlup-capitalize-keywords-in-region)
         :config
         (mohkale/declare-prefix-for-mode 'sql-mode
           "u" "upcase")
         (mohkale/set-leader-keys-for-major-mode 'sql-mode
           "ur" 'sqlup-capitalize-keywords-in-region
           "ub" 'sqlup-capitalize-keywords-in-buffer)

         (push "name" sqlup-blacklist))
     #+END_SRC

**** sqlite-dump
     converts an sqlite database file into the SQL schema required to reproduce it.
     #+BEGIN_SRC emacs-lisp
       (use-package sqlite-dump
         :defer t
         :commands (sqlite-dump))
     #+END_SRC

*** YAML
    #+BEGIN_SRC emacs-lisp
      (use-package yaml-mode
        :ensure t
        :defer  t
        :commands (yaml-mode)
        :hook (yaml-mode . flycheck-mode)
        :init
        (push (cons "\\.yaml" 'yaml-mode) auto-mode-alist)
        :config
        (general-define-key
          :keymaps 'yaml-mode-map
          :states 'insert
          "<tab>" 'yaml-indent-line)

        (mohkale/set-leader-keys-for-major-mode 'yaml-mode
          "n" 'yaml-narrow-to-block-literal
          "f" 'yaml-fill-paragraph
          "v" 'yaml-mode-version)

        (setq yaml-indent-offset 2))
    #+END_SRC

*** csv
    #+BEGIN_SRC emacs-lisp
      (use-package csv-mode
        :ensure t
        :defer  t
        :init
        (setq csv-separators '("," ":" ";" "\t"))
        :config

        (general-define-key
          :keymaps 'csv-mode-map
          "<tab>"     'csv-forward-field
          "<backtab>" 'csv-backward-field)

        (mohkale/declare-prefix-for-major-mode* 'csv-mode
          "s" "sort"
          "v" "yank")

        (mohkale/set-leader-keys-for-major-mode 'csv-mode
          "a"  'csv-align-fields
          "d"  'csv-kill-fields
          "i"  'csv-toggle-invisibility
          "r"  'csv-reverse-region
          "sf" 'csv-sort-fields
          "sn" 'csv-sort-numeric-fields
          "so" 'csv-toggle-descending
          "t"  'csv-transpose
          "u"  'csv-unalign-fields
          "vf" 'csv-yank-fields
          "vt" 'csv-yank-as-new-table))
    #+END_SRC

*** shell-script
**** company-shell
     #+BEGIN_SRC emacs-lisp
       (use-package company-shell
         :ensure t
         :defer  t
         :commands (company-shell
                    company-fish-shell
                    company-shell-env)
         :init
         (with-eval-after-load 'company
           (mohkale/update-company-backends-for-mode sh t
             '(company-shell company-shell-env))))
     #+END_SRC

**** shell-script-mode
     #+BEGIN_SRC emacs-lisp
       (use-package sh-script
         :defer t
         :hook ((sh-script-mode . electric-pair-mode)
                (sh-script-mode . flycheck-mode))
         :config
         (mohkale/declare-prefix-for-major-mode* 'sh-mode
           "<tab>" "indentation")
         (mohkale/set-leader-keys-for-major-mode 'sh-mode
           ":" 'sh-set-shell
           "0" 'sh-beginning-of-command
           "$" 'sh-end-of-command
           "!" 'executable-interpret
           "b" 'sh-show-shell
           "\\" 'sh-backslash-region

           "er" 'sh-execute-region
           "ej" 'sh-send-line-or-region-and-step

           "i=" 'sh-assignment
           "ic" 'sh-case
           "id" 'sh-cd-here
           "if" 'sh-for
           "i TAB" 'sh-if
           "il" 'sh-indexed-loop
           "io" 'sh-while-getopts
           "ir" 'sh-repeat
           "is" 'sh-select
           "it" 'sh-tmp-file
           "iu" 'sh-until
           "iw" 'sh-while
           "i(" 'sh-function
           "i+" 'sh-add

           "<tab> -" 'sh-learn-line-indent
           "<tab> =" 'sh-set-indent
           "<tab> |" 'sh-learn-buffer-indent
           "<tab> ?" 'sh-show-indent)

         (advice-add 'sh-set-shell :around 'inhibit-messages-wrapper))
     #+END_SRC

*** Markdown
**** company-emoji
     #+BEGIN_SRC emacs-lisp
       (use-package company-emoji
         :ensure t
         :defer  t
         :commands (company-emoji)
         :config
         (setq company-emoji-insert-unicode nil))
     #+END_SRC

**** emojify
     #+BEGIN_SRC emacs-lisp
       (use-package emojify
         :ensure t
         :defer  t
         :commands (emojify-mode))
     #+END_SRC

**** emoji-cheat-sheet-plus
     disabled because it requires helm

     #+BEGIN_SRC emacs-lisp
       ;; requires helm
       ;; (use-package emoji-cheat-sheet-plus
       ;;   :ensure t
       ;;   :defer  t
       ;;   :commands (emoji-cheat-sheet-plus-echo
       ;;              emoji-cheat-sheet-plus-echo-and-copy
       ;;              emoji-cheat-sheet-plus-buffer))
     #+END_SRC

**** gh-md
     #+BEGIN_SRC emacs-lisp
       (use-package gh-md
         :ensure t
         :defer  t
         :commands (gh-md-render-region
                    gh-md-render-buffer))
     #+END_SRC

**** markdown-mode
     #+BEGIN_SRC emacs-lisp
       (use-package markdown-mode
         :ensure t
         :defer  t
         :hook ((markdown-mode . mohkale//enable-line-numbers-handler)
                ;; (markdown-mode . emojify-mode)
                (markdown-mode . flycheck-mode))
         :config
         (general-define-key
           :keymaps 'markdown-mode-map
           :states 'normal
           "gh" 'markdown-up-heading
           "gj" 'markdown-outline-next
           "gk" 'markdown-outline-previous
           "gl" 'markdown-outline-next-same-level)

         (general-define-key
           :keymaps 'markdown-mode-map
           :states 'insert
           "<return>" 'markdown-enter-key
           ;; "<backspace>" 'markdown-outdent-or-delete
           ;; "<S-iso-lefttab>" 'markdown-outdent-or-delete
           ;; "<S-tab>"         'markdown-outdent-or-delete
           ;; "<backtab>"       'markdown-outdent-or-delete
           )

         (general-define-key
           :keymaps 'markdown-mode-map
           :states '(insert normal)
           "C-<return>" 'markdown-insert-list-item
           "C-S-J" 'markdown-move-down
           "C-S-K" 'markdown-move-up
           "C-S-H" 'markdown-promote
           "C-S-L" 'markdown-demote)

         (general-define-key
           :keymaps 'markdown-mode-map
           :states '(insert normal)
           :predicate '(or (markdown--table-at-point-p)
                           (markdown-on-heading-p))
           "<tab>"           'markdown-cycle
           "<S-iso-lefttab>" 'markdown-shifttab
           "<S-tab>"         'markdown-shifttab
           "<backtab>"       'markdown-shifttab)

         (mohkale/update-company-backends-for-mode markdown t
           '(company-emoji))

         (advice-add 'markdown-insert-list-item :after (lambda (&rest args)
                                                         (if (eq (char-before)
                                                                 ?*)
                                                             (evil-append nil)
                                                           (evil-insert nil))))

         (mohkale/declare-prefix-for-major-mode* 'markdown-mode
           "c" "check/complete"
           "e" "export"
           "i" "insert"
           "ih" "header"
           "il" "link"
           "d" "delete"
           "T" "toggle"
           "n" "navigate"
           "N" "narrow"
           "m" "mark"
           "t" "table"
           "r" "render"
           "ti" "insert"
           "td" "delete")

         (mohkale/set-leader-keys-for-major-mode 'markdown-mode
         ;;; unbound commands:
         ;;;  * markdown-outdent-region
         ;;;  * markdown-indent-region
         ;;;  * markdown-outline-previous-same-level

           "SPC" 'markdown-do
           "'" 'markdown-edit-code-block
           "f" 'markdown-follow-thing-at-point
           ">" 'markdown-blockquote-region
           "<tab>" 'markdown-pre-region ;; preformat

           "cc" 'markdown-complete
           "cb" 'markdown-complete-buffer
           "cr" 'markdown-check-refs
           "cR" 'markdown-unused-refs
           "cl" 'markdown-cleanup-list-numbers

           "eo" 'markdown-open
           "ee" 'markdown-export
           "ep" 'markdown-preview
           "ev" 'markdown-export-and-preview
           "em" 'markdown-other-window

           "rb" 'gh-md-render-buffer
           "rr" 'gh-md-render-region

           "i <tab>" 'markdown-insert-image
           "i*" 'markdown-insert-list-item
           "i!" 'markdown-insert-header-setext-1
           "i-" 'markdown-insert-hr
           "i1" 'markdown-insert-header-atx-1
           "i2" 'markdown-insert-header-atx-2
           "i3" 'markdown-insert-header-atx-3
           "i4" 'markdown-insert-header-atx-4
           "i5" 'markdown-insert-header-atx-5
           "i6" 'markdown-insert-header-atx-6
           "i@" 'markdown-insert-header-setext-2
           "iC" 'markdown-insert-gfm-code-block
           "iH" 'markdown-insert-header-setext-dwim
           "i[" 'markdown-insert-gfm-checkbox
           "ib" 'markdown-insert-bold
           "ic" 'markdown-insert-code
           "ie" 'markdown-insert-italic
           "if" 'markdown-insert-footnote
           "ii" 'markdown-insert-italic
           "ik" 'markdown-insert-kbd
           "ip" 'markdown-insert-pre
           "iq" 'markdown-insert-blockquote
           "is" 'markdown-insert-strike-through
           "ih!" 'markdown-insert-header-setext-1
           "ih1" 'markdown-insert-header-atx-1
           "ih2" 'markdown-insert-header-atx-2
           "ih3" 'markdown-insert-header-atx-3
           "ih4" 'markdown-insert-header-atx-4
           "ih5" 'markdown-insert-header-atx-5
           "ih6" 'markdown-insert-header-atx-6
           "ih@" 'markdown-insert-header-setext-2
           "ihH" 'markdown-insert-header-setext-dwim
           "ihh" 'markdown-insert-header-dwim
           "ihs" 'markdown-insert-header-setext-2
           "iht" 'markdown-insert-header-setext-1
           "ill" 'markdown-insert-link
           "ilf" 'markdown-insert-footnote
           "ilu" 'markdown-insert-uri
           "ilw" 'markdown-insert-wiki-link

           "dd" 'markdown-kill-thing-at-point
           "db" 'markdown-kill-block
           "do" 'markdown-kill-outline
           "dy" 'markdown-kill-ring-save

           "Tm" 'markdown-toggle-math
           "Tf" 'markdown-toggle-fontify-code-blocks-natively
           "Ti" 'markdown-toggle-inline-images
           "Tu" 'markdown-toggle-url-hiding
           "Tm" 'markdown-toggle-markup-hiding
           "Tc" 'markdown-toggle-gfm-checkbox
           "Tl" 'markdown-live-preview-mode

           "nu" 'markdown-next-link
           "nU" 'markdown-previous-link
           "nb" 'markdown-forward-block
           "nB" 'markdown-backward-block
           "nh" 'markdown-up
           "nj" 'markdown-next
           "nk" 'markdown-previous
           "nl" 'markdown-outline-next-same-level
           "nL" 'markdown-outline-previous-same-level

           "Nb" 'markdown-narrow-to-block
           "Np" 'markdown-narrow-to-page
           "Ns" 'markdown-narrow-to-subtree
           "Nw" 'widen

           "ms" 'markdown-mark-subtree
           "mb" 'markdown-mark-block

           "ts" 'markdown-table-sort-lines
           "tT" 'markdown-table-transpose
           "tt" 'markdown-insert-table
           "tc" 'markdown-table-convert-region
           "tir" 'markdown-table-insert-row
           "tic" 'markdown-table-insert-column
           "tdr" 'markdown-table-delete-row
           "tdc" 'markdown-table-delete-column))
     #+END_SRC

*** cmake
**** cmake-mode
     #+BEGIN_SRC emacs-lisp
       (use-package cmake-mode
         :ensure t
         :defer  t
         :commands (cmake-mode)
         ;; :mode (("CMakeLists\\.txt\\'" . cmake-mode) ("\\.cmake\\'" . cmake-mode))
         :hook (cmake-mode . flycheck-mode)
         :init
         (push (cons "CMakeLists\\.txt\\'" 'cmake-mode) auto-mode-alist)
         (push (cons "\\.cmake\\'" 'cmake-mode) auto-mode-alist)
         :config
         (mohkale/update-company-backends-for-mode cmake t
           '(company-cmake)))
     #+END_SRC

**** company-cmake
     #+BEGIN_SRC emacs-lisp
       (use-package company-cmake
         ;; :ensure t
         :defer  t
         :commands (company-cmake))
     #+END_SRC

*** C-C++
**** company-c-headers
     #+BEGIN_SRC emacs-lisp
       (use-package company-c-headers
         :ensure t
         :defer  t
         :commands (company-c-headers))
     #+END_SRC

**** cc-mode
     #+BEGIN_SRC emacs-lisp
       (use-package cc-mode
         :ensure t
         :defer  t
         :commands (c-mode c++-mode)
         :hook (
                ;; use global-ycmd-mode manually
                ;; (c-mode   . ycmd-mode)
                ;; (c++-mode . ycmd-mode)
                (c-mode   . flycheck-mode)
                (c++-mode . flycheck-mode))
         :init
         (push (cons ".*\\.h$" 'c-mode) auto-mode-alist)
         :config
         (c-toggle-auto-newline +1)
         (setq c-default-style "stroustrup"
               c-basic-offset mohkale-preferred-indent)

         (mohkale/update-company-backends-for-mode c t
           '(company-ycmd company-c-headers))

         (mohkale/update-company-backends-for-mode c++ t
           '(company-ycmd company-c-headers)))
     #+END_SRC

**** disaster
     #+BEGIN_SRC emacs-lisp
       (use-package disaster
         :ensure t
         :defer  t
         :commands (disaster)
         :init
         (dolist (mode '(c-mode c++-mode))
           (mohkale/set-leader-keys-for-major-mode mode
             "D" 'disaster)))
     #+END_SRC

**** ctags
     #+BEGIN_SRC emacs-lisp
       ;; (use-package ctags-update
       ;;   :ensure t
       ;;   :defer  t
       ;;   :config
       ;;   (ctags-global-auto-update-mode)
       ;;   (setq tags-revert-without-query 1)

       ;;   ;; you need manually create TAGS in your project
       ;;   (setq ctags-update-prompt-create-tags nil))
     #+END_SRC

*** kotlin
**** kotlin-mode
     #+BEGIN_SRC emacs-lisp
       (use-package kotlin-mode
         :ensure t
         :defer  t
         :commands (kotlin-mode
                    kotlin-repl)
         :config
         (setq kotlin-tab-width 4)

         (mohkale/declare-prefix-for-major-mode 'kotlin-mode
           "e" "eval")

         (mohkale/set-leader-keys-for-major-mode 'kotlin-mode
           "r" 'kotlin-repl
           "e-" 'kotlin-send-line
           "e|" 'kotlin-send-block
           "er" 'kotlin-send-region
           "eb" 'kotlin-send-buffer
           "e S--" 'kotlin-send-line-and-focus
           "e S-|" 'kotlin-send-block-and-focus
           "eR"    'kotlin-send-region-and-focus
           "eB"    'kotlin-send-buffer-and-focus)

         (mohkale/update-company-backends-for-mode kotlin t
           '(company-lsp)))
     #+END_SRC

*** javascript
    # NOTE no on the fly syntax checking? make sure eslint is installed no warning or error will be issued if it isn't :(
**** js2-mode
     #+BEGIN_SRC emacs-lisp
       (use-package js2-mode
         :ensure t
         :defer  t
         :hook (js2-mode . flycheck-mode)
         :init
         (push (cons "\\.js$" 'js2-mode) auto-mode-alist)
         :config
         (mohkale/update-company-backends-for-mode js2-mode t
           '(company-tern))

         (setq js2-mode-show-parse-errors      nil
               js2-mode-show-strict-warnings   nil
               js2-strict-missing-semi-warning nil)

         (general-define-key
           :keymaps 'js2-mode-map
           :states  'insert
           ;; properly formets javadocs
           "<return>" 'js2-line-break)

         (mohkale/declare-prefix-for-major-mode* 'js2-mode
           "i" "insert"
           "h" "help"
           "H" "hide/show"
           "Hh" "hide"
           "Hs" "show")

         (mohkale/set-leader-keys-for-major-mode 'js2-mode
           "gg" 'js2-jump-to-definition

           ;; toggle hide-show
           "HH" 'js2-mode-show-all
           "Hw" 'js2-mode-toggle-warnings-and-errors
           "He" 'js2-mode-toggle-element
           "Hc" 'js2-mode-toggle-hide-comments
           "Hf" 'js2-mode-toggle-hide-functions

           ;; hide
           "Hhw" 'js2-mode-hide-warnings-and-errors
           "Hhe" 'js2-mode-hide-element
           "Hhc" 'js2-mode-show-comments
           "Hhf" 'js2-mode-hide-functions

           ;; show
           "Hsw" 'js2-mode-display-warnings-and-errors
           "Hse" 'js2-mode-show-element
           "Hsc" 'js2-mode-hide-comments
           "Hsf" 'js2-mode-show-functions))
     #+END_SRC

**** tern
     #+BEGIN_SRC emacs-lisp
       (use-package tern
         :ensure t
         :defer  t
         :hook (js2-mode . tern-mode)
         :commands tern-mode)
     #+END_SRC

**** company-tern
     #+BEGIN_SRC emacs-lisp
       (use-package company-tern
         :ensure t
         :defer  t
         :commands company-tern
         :hook (js2-mode . (lambda () (require 'company-tern)))
         :config
         (mohkale/update-company-backends-for-mode js2 t
           '(company-tern)))
     #+END_SRC

**** js-doc
     #+BEGIN_SRC emacs-lisp
       (use-package js-doc
         :ensure t
         :defer  t
         :commands (js-doc-insert-function-doc
                    js-doc-insert-function-doc-snippet
                    js-doc-insert-tag
                    js-doc-insert-file-doc
                    js-doc-describe-tag)
         :init
         ;; (general-define-key
         ;;   :keymaps 'js2-mode-map
         ;;   :states 'insert
         ;;   "@" 'js-doc-insert-tag)

         (mohkale/set-leader-keys-for-major-mode 'js2-mode
           "i@" 'js-doc-insert-tag
                                               ; only works from within method
           "i)" 'js-doc-insert-function-doc
           "i(" 'js-doc-insert-function-doc-snippet
           "if" 'js-doc-insert-file-doc
           "h@" 'js-doc-describe-tag)

         :config
         (advice-add 'js-doc-insert-function-doc-snippet :after #'(lambda (&rest r)
                                                                    (evil-insert nil))))
     #+END_SRC

**** js2-refactor
     #+BEGIN_SRC emacs-lisp
       ;; most of this doesn't seem to work very well...
       ;; so I'm only using a few functions with simple features.
       (use-package js2-refactor
         :ensure t
         :defer  t
         :diminish
         :hook (js2-mode . js2-refactor-mode)
         :config
         (defun js2r-exit-visual-mode-after-func-call (&rest args)
           (when (evil-visual-state-p)
             (evil-exit-visual-state)))

         (advice-add 'js2r-extract-method   :after #'js2r-exit-visual-mode-after-func-call)
         (advice-add 'js2r-extract-function :after #'js2r-exit-visual-mode-after-func-call)

         (mohkale/declare-prefix-for-major-mode 'js2-mode
           "e" "extract")

         (mohkale/set-leader-keys-for-major-mode 'js2-mode
           "[" 'js2r-expand-node-at-point
           "]" 'js2r-contract-node-at-point

           ; doesn't work unless executed from within a function
           "ef" 'js2r-extract-function
           "em" 'js2r-extract-method
           "ev" 'js2r-extract-var
           "el" 'js2r-extract-let
           "ec" 'js2r-extract-const

           "l" 'js2r-log-this
           "L" 'js2r-debug-this

           "v" 'js2r-var-to-this

           "s" 'js2r-forward-slurp
           "b" 'js2r-forward-barf))
     #+END_SRC

**** xref-js2
     #+BEGIN_SRC emacs-lisp
       (use-package xref-js2
         :ensure t
         :defer  t
         :commands (xref-js2-xref-backend)
         :init
         (with-eval-after-load 'js2-mode
           (add-hook 'xref-backend-functions #'xref-js2-xref-backend))
         (setq xref-js2-search-program 'rg))
     #+END_SRC

**** indium
     looks cool... but tad too much setup for me & requires you to src_sh{npm install -g indium}.

     #+BEGIN_SRC emacs-lisp :tangle no
       (use-package indium
         :ensure t
         :defer  t)
     #+END_SRC

**** skewer-mode
     #+BEGIN_SRC emacs-lisp
       (use-package skewer-mode
         :ensure t
         :defer  t
         :delight
         (skewer-css-mode "skewerC")
         (skewer-html-mode "skewerH")
         :commands (skewer-mode
                    skewer-css-mode
                    skewer-html-mode)
         :config
         ;; once required, enable skewer in all
         ;; compatible buffers
         (add-hook 'js2-mode-hook 'skewer-mode)
         (add-hook 'css-mode-hook 'skewer-css-mode)
         (add-hook 'html-mode-hook 'skewer-html-mode)

         ;; (run-skewer) ;; and begin server

         (let ((_ (concat mohkale-major-mode-leader-prefix
                          "S")))
           (mohkale/set-leader-keys-for-minor-mode 'skewer-mode
             (concat _ "e") 'skewer-eval-last-expression
             (concat _ "E") 'skewer-eval-print-last-expression
             (concat _ "(") 'skewer-eval-defun
             (concat _ "b") 'skewer-load-buffer

             (concat _ "R") 'skewer-repl
             (concat _ "L") 'skewer-bower-load
             (concat _ "B") 'skewer-bower-refresh
             (concat _ "p") 'skewer-run-phantomjs
             (concat _ "P") 'skewer-phantomjs-kill)

           (mohkale/set-leader-keys-for-minor-mode 'skewer-html-mode
             (concat _ "s") 'skewer-html-fetch-selector-into-buffer
             (concat _ "e") 'skewer-html-eval-tag

             (concat _ "R") 'skewer-repl
             (concat _ "L") 'skewer-bower-load
             (concat _ "B") 'skewer-bower-refresh
             (concat _ "p") 'skewer-run-phantomjs
             (concat _ "P") 'skewer-phantomjs-kill)

           (mohkale/set-leader-keys-for-minor-mode 'skewer-css-mode
             (concat _ "e") 'skewer-css-eval-current-rule
             (concat _ "b") 'skewer-css-eval-buffer
             (concat _ "c") 'skewer-css-clear-all
             (concat _ "d") 'skewer-css-eval-current-declaration

             (concat _ "R") 'skewer-repl
             (concat _ "L") 'skewer-bower-load
             (concat _ "B") 'skewer-bower-refresh
             (concat _ "p") 'skewer-run-phantomjs
             (concat _ "P") 'skewer-phantomjs-kill)))
     #+END_SRC

*** css/less
**** css-mode
     #+BEGIN_SRC emacs-lisp
       (use-package css-mode
         :defer t
         :config
         (mohkale/set-leader-keys-for-major-mode 'css-mode
           "?" 'css-lookup-symbol
           "b" 'web-beautify-css)

         (mohkale/update-company-backends-for-mode css t
           '(company-css)))
     #+END_SRC

**** less-css-mode
     #+BEGIN_SRC emacs-lisp
       (use-package less-css-mode
         :defer t
         :commands (less-css-mode)
         :config
         (mohkale/set-leader-keys-for-minor-mode 'less-css-mode
           "c" 'less-css-compile))
     #+END_SRC

**** skewer-less
     #+BEGIN_SRC emacs-lisp
       (use-package skewer-less
         :ensure t
         :defer  t
         :commands (skewer-less-mode)
         :init
         (with-eval-after-load 'skewer-mode
           (add-hook 'less-css-mode-hook 'skewer-less-mode))

         (mohkale/set-leader-keys-for-minor-mode 'skewer-less-mode
           (concat mohkale-major-mode-leader-prefix "Sb") 'skewer-less-eval-buffer
           (concat mohkale-major-mode-leader-prefix "Sr") 'skewer-less-eval-region))
     #+END_SRC

*** haskell
**** hindent
     #+BEGIN_SRC emacs-lisp
       (use-package hindent
         :ensure t
         :defer  t
         :hook (haskell-mode . hindent-mode)
         :commands (hindent-mode
                    hindent-reformat-decl
                    hindent-reformat-buffer
                    hindent-reformat-decl-or-fill
                    hindent-reformat-region))
     #+END_SRC

**** company-cabal
     #+BEGIN_SRC emacs-lisp
       (use-package company-cabal
         :ensure t
         :defer  t
         :commands company-cabal)
     #+END_SRC

**** flycheck-haskell
     #+BEGIN_SRC emacs-lisp
       (use-package flycheck-haskell
         :ensure t
         :defer  t
         :commands (flycheck-haskell-setup))
     #+END_SRC

**** haskell-mode
     #+BEGIN_SRC emacs-lisp
       (use-package haskell-mode
         :ensure t
         :defer  t
         :commands (haskell-mode
                    run-haskell)
         ;; :hook (;; disable indentation mode... super ugly
         ;;        (haskell-mode . haskell-indent-mode)
         ;;        ;; (haskell-mode . haskell-indentation-mode)
         ;;        )
         :init
         (push 'haskell-interactive-mode mohkale--whitespace-exempt-modes)
         (defalias 'haskell-repl #'run-haskell)

         :config
         ;; (mohkale/update-company-backends-for-mode haskell t
         ;;   '(company-ghci))
         (mohkale/update-company-backends-for-mode haskell t
           '(company-lsp))
         (mohkale/update-company-backends-for-mode haskell-cabal t
           '(company-cabal))

         ;; (general-define-key
         ;;   :states  '(insert replace)
         ;;   :keymaps 'haskell-mode-map
         ;;   "<tab>" 'haskell-indent-cycle)

         (mohkale/declare-prefix-for-major-mode* 'haskell-mode
           "r" "refactor"
           "i" "insert"
           "s" "session")

         (mohkale/set-leader-keys-for-major-mode 'haskell-mode
           "TAB"   'haskell-indent-cycle
           "S-TAB" 'haskell-delete-indentation

           "ri" 'haskell-mode-format-imports
           "rI" 'haskell-sort-imports

           "is" 'haskell-mode-toggle-scc-at-point
           "i|" 'haskell-indent-insert-guard
           "iw" 'haskell-indent-insert-where
           "io" 'haskell-indent-insert-other
           "i=" 'haskell-indent-insert-equal

           "sc" 'haskell-session-change
           "sC" 'haskell-session-change-target
           "sk" 'haskell-session-kill
           "sK" 'haskell-kill-session-process)

         (evil-set-initial-state 'haskell-interactive-mode 'emacs)
         :bind (:map haskell-mode-map
                ("C-M-i" . nil)))

       (use-package haskell-indent
         :commands (haskell-indent-cycle))
     #+END_SRC

**** company-ghci
     #+BEGIN_SRC emacs-lisp
       ;; (use-package company-ghci
       ;;   :ensure t
       ;;   :defer  t
       ;;   :commands company-ghci)
     #+END_SRC

**** hs-lint
     #+BEGIN_SRC emacs-lisp
       (use-package hs-lint
         :defer  t
         :commands (hs-lint hs-lint-mode))
     #+END_SRC

**** hlint-refactor-mode
     #+BEGIN_SRC emacs-lisp
       (use-package hlint-refactor-mode
         :defer t
         :commands (hlint-refactor-refactor-buffer
                    hlint-refactor-refactor-at-point))
     #+END_SRC

*** git
    I'm not ashamed to admit... 89% of everything here is just shamelessly stollen [[https://github.com/syl20bnr/spacemacs/blob/master/layers/%252Bsource-control/git/packages.el][spacemacs]]. and before you say it, git is a language... +or at least my OCD needs it to be+ just look at all those proprietary formats:

    - gitignore
    - gitcontrol
    - gitconfig
    - gitattributes

    okay... I made one of those up, but can you honestly tell me which one before looking below :P

**** magit
    #+BEGIN_SRC emacs-lisp
      (use-package magit
        :ensure t
        :defer  t
        :commands (evil-search-previous
                   evil-search-next
                   magit-push
                   magit-section-forward-sibling
                   magit-section-backward-sibling
                   magit-section-hide-children
                   magit-section-show-children
                   magit-log-buffer-file
                   magit-dispatch-popup
                   magit-status
                   magit-stage-file
                   magit-unstage-file
                   magit-section-toggle
                   magit-visit-thing)
        :init
        (setq magit-completing-read-function 'ivy-completing-read
              magit-revision-show-gravatars  '("^Author:     " . "^Commit:     ")
              ;; show magit status in a full screen window.
              magit-display-buffer-function 'magit-display-buffer-fullframe-status-v1
              evil-magit-state 'motion
              evil-magit-use-y-for-yank t)

        ;; On Windows, we must use Git GUI to enter username and password
        ;; See: https://github.com/magit/magit/wiki/FAQ#windows-cannot-push-via-https
        (when (eq window-system 'w32)
          (setenv "GIT_ASKPASS" "git-gui--askpass"))

        (mohkale/declare-prefix*
          "g" "magit"
          "gd" "diff"
          "gf" "file")

        (mohkale/set-leader-keys
          "gm" 'magit-dispatch
          "g!" 'magit-run
          "gfh" 'magit-log-buffer-file
          "gm"  'magit-dispatch-popup
          "gs"  'magit-status
          "gS"  'magit-stage-file
          "gU"  'magit-unstage-file)
        :config
        (require 'evil-magit)

        (dolist (map '(magit-mode-map
                       magit-diff-mode-map))
          ;; GIVE ME BACK MY LEADER!!!
          (define-key (eval map) (kbd mohkale-leader-key) nil))

        (mohkale/declare-prefix-for-mode* 'git-commit-mode
          (concat mohkale-major-mode-leader-prefix "i") "insert")

        (mohkale/set-leader-keys-for-minor-mode 'git-commit-mode
          (concat mohkale-major-mode-leader-prefix ",")  'with-editor-finish
          (concat mohkale-major-mode-leader-prefix "q")  'with-editor-cancel
          (concat mohkale-major-mode-leader-prefix "s")  'git-commit-save-message
          (concat mohkale-major-mode-leader-prefix "d")  'magit-diff-while-committing
          (concat mohkale-major-mode-leader-prefix "j")  'git-commit-next-message
          (concat mohkale-major-mode-leader-prefix "k")  'git-commit-prev-message
          (concat mohkale-major-mode-leader-prefix "ia") 'git-commit-ack ;; knowledgement
          (concat mohkale-major-mode-leader-prefix "iS") 'git-commit-suggested
          (concat mohkale-major-mode-leader-prefix "im") 'git-commit-modified
          (concat mohkale-major-mode-leader-prefix "ic") 'git-commit-cc
          (concat mohkale-major-mode-leader-prefix "ir") 'git-commit-reported
          (concat mohkale-major-mode-leader-prefix "iR") 'git-commit-review
          (concat mohkale-major-mode-leader-prefix "is") 'git-commit-signoff
          (concat mohkale-major-mode-leader-prefix "it") 'git-commit-test)

        :bind* (:map magit-mode-map
                ("M-j" . magit-section-forward-sibling)
                ("M-k" . magit-section-backward-sibling)
                ;; ;; toggle children doesn't seem to work
                ;; ("C-r" . magit-section-hide-children) ; recursive close
                ;; ("C-e" . magit-section-show-children) ; recursive expand
                ;; ("M-r" . magit-section-hide-children) ; Meta aliases
                ;; ("M-e" . magit-section-show-children) ; Meta aliases
                ;; visit and expand
                ("RET"   . magit-section-toggle)
                ("TAB"   . magit-section-toggle)
                ("M-RET" . magit-visit-thing)

                :map magit-log-mode-map
                ("RET" . magit-visit-thing)))
    #+END_SRC

**** gitattributes-mode
     #+BEGIN_SRC emacs-lisp
      (use-package gitignore-mode
        :ensure t
        :defer  t
        :commands (gitignore-mode))
     #+END_SRC

**** gitconfig-mode
     #+BEGIN_SRC emacs-lisp
      (use-package gitconfig-mode
        :ensure t
        :defer  t
        :commands (gitconfig-mode))
     #+END_SRC

**** gitignore-mode
     #+BEGIN_SRC emacs-lisp
      (use-package gitattributes-mode
        :ensure t
        :defer  t
        :commands (gitattributes-mode))
     #+END_SRC

**** gitlink
     #+BEGIN_SRC emacs-lisp
     (use-package git-link
        :ensure t
        :defer  t
        :commands (git-link
                   git-link-commit
                   git-link-homepage)
        :init
        (mohkale/declare-prefix "gl" "links")

        (mohkale/set-leader-keys
          "gll" 'spacemacs/git-link
          "glL" 'spacemacs/git-link-copy-url-only
          "glc" 'spacemacs/git-link-commit
          "glC" 'spacemacs/git-link-commit-copy-url-only)

        ;; default is to open the generated link
        (setq git-link-open-in-browser t))
     #+END_SRC

**** transient
     #+BEGIN_SRC emacs-lisp
     (use-package transient
        :ensure t
        :defer  t
        :bind* (:map transient-base-map
                ;;; Escape means quit too you know
                ("ESC" . transient-quit-one)))
     #+END_SRC

**** evil-magit
     #+BEGIN_SRC emacs-lisp
      (use-package evil-magit
        :ensure t
        :defer  t)
     #+END_SRC

**** magit-svn
     #+BEGIN_SRC emacs-lisp :tangle no
       (use-package magit-svn
         :commands (turn-on-magit-svn
                    magit-key-mode-popup-svn)
         :hook (magit-mode . turn-on-magit-svn)
         ;; TODO add some bindings
         )
     #+END_SRC

**** orgit
     #+BEGIN_SRC emacs-lisp :tangle no
       (use-package orgit
         :ensure t
         :defer  t
         :hook (org-mode . (require 'orgit)))
     #+END_SRC

**** magit-gitflow
     #+BEGIN_SRC emacs-lisp
      (use-package magit-gitflow
        :ensure t
        :defer  t
        :hook (magit-mode . turn-on-magit-gitflow)
        :commands (magit-gitflow-mode
                   turn-on-magit-gitflow
                   magit-gitflow-popup)
        :delight
        (magit-gitflow-mode "GitFlow")
        :init
        (with-eval-after-load 'magit--handle-bookmark
          (bind-keys :map magit-mode-map
                     ("%" . magit-gitflow-popup))))
     #+END_SRC

** Unimplemented
*** Languages
    https://github.com/syl20bnr/spacemacs/tree/master/layers/%2Blang
**** java
     java, the language *everyone* tolerates.

     #+BEGIN_SRC emacs-lisp :tangle no
       ;; (use-package cc-mode
       ;;   :defer t
       ;;   :commands (java-mode . ycmd-mode)
       ;;   :config
       ;;   (mohkale/update-company-backends-for-mode java t
       ;;     '(ycmd-mode))
       ;;   )

       ;; key             binding
       ;; ---             -------

       ;; C-c C-a         c-toggle-auto-newline
       ;; C-c C-b         c-submit-bug-report
       ;; C-c C-c         comment-region
       ;; C-c C-d         c-hungry-delete-forward
       ;; C-c C-k         c-toggle-comment-style
       ;; C-c C-l         c-toggle-electric-state
       ;; C-c C-n         c-forward-conditional
       ;; C-c C-o         c-set-offset
       ;; C-c C-p         c-backward-conditional
       ;; C-c C-q         c-indent-defun
       ;; C-c C-s         c-show-syntactic-information
       ;; C-c C-u         c-up-conditional
       ;; C-c C-w         c-subword-mode
       ;; C-c C-z         c-display-defun-name
       ;; C-c C-\         c-backslash-region
       ;; C-c .           c-set-style
       ;; C-c DEL         c-hungry-delete-backwards
       ;; C-c C-DEL       c-hungry-delete-backwards
       ;; C-c <C-backspace>               c-hungry-delete-backwards
       ;; C-c <C-delete>                  c-hungry-delete-forward
       ;; C-c <C-deletechar>              c-hungry-delete-forward
       ;; C-c <deletechar>                c-hungry-delete-forward

       ;; C-M-a           c-beginning-of-defun
       ;; C-M-e           c-end-of-defun
       ;; C-M-h           c-mark-function
       ;; C-M-j           c-indent-new-comment-line
       ;; C-M-q           c-indent-exp
       ;; M-a             c-beginning-of-statement
       ;; M-e             c-end-of-statement
       ;; M-q             c-fill-paragraph

       (use-package meghanada
         :ensure t
         :defer  t
         :delight (meghanada "MEG")
         :hook (meghanda-mode . meghanada-telemetry-enable)
         :commands (meghanda-mode
                    meghanada-install-server
                    meghanada-update-server
                    meghanada-server-start
                    meghanada-restart
                    meghanada-server-kill
                    meghanada-client-direct-connect
                    meghanada-client-connect
                    meghanada-client-disconnect
                    meghanada-client-ping
                    meghanada-clear-cache

                    meghanada-import-all
                    meghanada-optimize-import
                    meghanada-import-at-point
                    meghanada-local-variable
                    meghanada-compile-file
                    meghanada-project-show
                    meghanada-project-compile
                    meghanada-switch-testcase
                    meghanada-exec-main
                    meghanada-debug-main
                    meghanada-reference
                    meghanada-search-everywhere
                    meghanada-search-everywhere-ex
                    meghanada-typeinfo
                    meghanada-run-junit-class
                    meghanada-run-junit-test-case
                    meghanada-debug-junit-class
                    meghanada-debug-junit-test-case
                    meghanada-run-task
                    meghanada-jump-declaration
                    meghanada-back-jump
                    meghanada-code-beautify)
         :config
         (mohkale/update-company-backends-for-mode meghanada nil
           '(meghanda-mode)))
     #+END_SRC

*** iallign
    #+BEGIN_SRC emacs-lisp
      (use-package ialign
        :ensure t
        :defer  t
        :commands (ialign)
        )
    #+END_SRC

*** realgud
    #+BEGIN_SRC emacs-lisp
      (use-package realgud
        :ensure t
        :defer  t
        :commands (realgud:gdb
                   realgud:pdb)
        :config
        (mohkale--comint-set-bindings 'realgud:gdb-track-mode-map)
        (general-define-key
          :keymaps 'realgud:gdb-track-mode-map
          "RET" 'realgud:send-input)

        (defun realgud--display-realgud-buffer-instead-of-switch (func &rest args)
          (let ((current-buffer (current-buffer))
                debugger-buffer)
            (apply func args) ;; invoke wrapped function

            (unless (eq current-buffer (current-buffer))
              (setq debugger-buffer (current-buffer))
              (switch-to-buffer nil) ;; last buffer
              (display-buffer debugger-buffer))))

        (advice-add #'realgud:gdb :around #'realgud--display-realgud-buffer-instead-of-switch)
        :bind (:map realgud-track-mode-map
               ("<override-state>" . nil)))
    #+END_SRC

* Themes
** an old hope
   #+NAME: an-old-hope-theme-description
   #+BEGIN_EXAMPLE
      emacs theme inspired by a galaxy far far away...
      this theme is largely just a shot for shot copy of `jesseleite/an-old-hope-syntax-atom'
      ported to emacs because I refuse to live with an IDE that doesn't look like it XD.
      This theme isn't compatible with emacs in the terminal yet, when I find an easy way
      to approximate true-color colors to non-true-color colors, then I'll add support for
      it.
   #+END_EXAMPLE

*** Colors
   #+NAME: an-old-hope-theme-color-associations
   | color-name        | new-name   | hue | sat | light | description                       |
   |-------------------+------------+-----+-----+-------+-----------------------------------|
   | very-light-grey   |            | 228 |   7 |    81 | shades of the millenium falcon    |
   | light-grey        |            | 228 |   7 |    55 | shades of the millenium falcon    |
   | grey              |            | 228 |   7 |    44 | shades of the millenium falcon    |
   | dark-grey         |            | 228 |   7 |    29 | shades of the millenium falcon    |
   | very-dark-grey    |            | 228 |   7 |    12 | shades of the millenium falcon    |
   |-------------------+------------+-----+-----+-------+-----------------------------------|
   | vader             | red        | 352 |  81 |    58 | Vader's lightsaber                |
   | vader-dim         | red-dim    | 352 |  60 |    58 |                                   |
   | vader-int         | red-int    | 360 |  90 |    58 |                                   |
   |-------------------+------------+-----+-----+-------+-----------------------------------|
   | luke              | orange     |  25 |  86 |    55 | Luke's pilot uniform              |
   | luke-dim          | orange-dim |  25 |  60 |    60 |                                   |
   | luke-int          | orange-int |  25 |  86 |    65 |                                   |
   |-------------------+------------+-----+-----+-------+-----------------------------------|
   | threepio          | yellow     |  50 |  74 |    61 | Human cyborg relations            |
   | threepio-dim      | yellow-dim |  50 |  74 |    31 |                                   |
   | threepio-int      | yellow-int |  50 | 100 |    61 |                                   |
   |-------------------+------------+-----+-----+-------+-----------------------------------|
   | yoda              | green      | 107 |  40 |    57 | Fear is the path to the dark side |
   | yoda-dim          | green-dim  | 100 |  30 |    57 |                                   |
   | yoda-int          | green-int  | 120 |  50 |    57 |                                   |
   |-------------------+------------+-----+-----+-------+-----------------------------------|
   | artoo             | blue       | 196 |  64 |    58 | Whistle. Beep. Bloop.             |
   | artoo-dim         | blue-dim   | 200 |  44 |    58 |                                   |
   | artoo-int         | blue-int   | 220 |  84 |    64 |                                   |
   |-------------------+------------+-----+-----+-------+-----------------------------------|
   | purple            |            | 313 |  32 |    60 |                                   |
   | purple-dim        |            | 313 |  32 |    70 |                                   |
   | purple-int        |            | 313 |  40 |    60 |                                   |
   |-------------------+------------+-----+-----+-------+-----------------------------------|
   | turquoise         |            | 165 |  70 |    65 |                                   |
   | turquoise-dim     |            | 165 |  60 |    85 |                                   |
   | turquoise-int     |            | 165 |  80 |    50 |                                   |
   |-------------------+------------+-----+-----+-------+-----------------------------------|
   | black             |            | 240 |   6 |    14 |                                   |
   | black-dim         |            | 240 |  10 |    20 |                                   |
   | black-int         |            | 240 |   6 |    00 |                                   |
   |-------------------+------------+-----+-----+-------+-----------------------------------|
   | line-highlight-bg |            | 228 |   7 |    21 |                                   |
   | extra-dark-grey   |            | 228 |   7 |    10 | variant for imbedded org blocks   |
   | debug             |            | 198 |  91 |    13 | dark blue                         |

   *rainbow-delimeter-shades*
   #+NAME: rainbow-delimeter-shades
      - #E6B422
      - #C70067
      - #00A960
      - #FC7482
      - #E6B422
      - #C70067
      - #00A960
      - #FC7482

   colors taken from [[https://github.com/gastrodia/rainbow-brackets][here.]] colors 5-8 just recycle 1-4, maybe come up with more.

   #+NAME: color-assoc-to-rgb-strings
   #+HEADER: :var associations=an-old-hope-theme-color-associations
   #+BEGIN_SRC emacs-lisp :results value table :tangle no :exports none
     (require 'color)
     (require 'subr-x)

     (let (result)
       (dolist (row (cdr associations))
         (message "%s" row)
         (let* ((color-name (nth 0 row))
                (dest-name  (progn
                              (let ((dest-name (nth 1 row)))
                                (if (string-empty-p dest-name)
                                    color-name
                                  dest-name))))
                (hue   (/ (nth 2 row) 360.0))
                (sat   (/ (nth 3 row) 100.0))
                (light (/ (nth 4 row) 100.0))

                (rgb (color-hsl-to-rgb hue sat light))
                (red   (nth 0 rgb))
                (green (nth 1 rgb))
                (blue  (nth 2 rgb)))
           (push (list (intern dest-name)
                       (color-rgb-to-hex red green blue 2))
                 result)))
       (reverse result))
   #+END_SRC

*** Header
   #+HEADER: :shebang ";; an-old-hope-theme.el -- a syntax theme from a galaxy far away... -*- lexical-binding: t -*-"
   #+BEGIN_SRC emacs-lisp :comments no :tangle "~/.emacs.d/etc/themes/an-old-hope-theme.el"
     ;; Author: MoHKale
     ;; URL: https://github.com/MoHKale/an-old-hope-theme
     ;; Version: 0.1.0
     ;; Keywords: color, theme
     ;; Package-Requires: ((emacs "24"))

     ;; This file is not part of GNU Emacs

     ;; This file is free software; you can redistribute it and/or modify
     ;; it under the terms of the GNU General Public License as published by
     ;; the Free Software Foundation; either version 3, or (at your option)
     ;; any later version.

     ;; This program is distributed in the hope that it will be useful,
     ;; but WITHOUT ANY WARRANTY; without even the implied warranty of
     ;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     ;; GNU General Public License for more details.

     ;; For a full copy of the GNU General Public License
     ;; see <http://www.gnu.org/licenses/>.

     ;; Commentary:
     ;; see https://github.com/MoHKale/an-old-hope-theme/tree/master/emacs
   #+END_SRC

*** Faces
   #+HEADER: :var desc=an-old-hope-theme-description colors=color-assoc-to-rgb-strings() cls=(eval t) rainbow-delims=rainbow-delimeter-shades
   #+BEGIN_SRC emacs-lisp :tangle "~/.emacs.d/etc/themes/an-old-hope-theme.el"
     (require 'dash)

     (deftheme an-old-hope
       desc)

     (dolist (color colors)
       (set (car color) (nth 1 color)))

     (setq rainbow-delims (-flatten rainbow-delims))

     (custom-theme-set-faces
      'an-old-hope

      ;;; basic
      `(cursor ((,cls (:background ,red))))
      `(custom-button ((,cls (:background ,very-dark-grey :foreground ,very-light-grey :box (:line-width 2 :style released-button)))))

      ;; sets the general foreground and background colors
      `(default ((,cls (:background ,very-dark-grey :foreground ,very-light-grey))))
      `(default-italic ((,cls (:italic t :inherit default))))
      `(hl-line ((,cls (:background ,line-highlight-bg)))) ; NOTE current line
      `(fringe ((,cls (:background ,black)))) ; NOTE: defines bars to the left and right, after line number when applicable
      `(vi-tilde-fringe-face ((,cls ((:inherit default)))))
      `(vertical-border ((,cls (:foreground ,very-light-grey)))) ; NOTE seperator between windows

      ;; errors, successes and warnings and other highlights
      `(error   ((,cls (:background ,red    :distant-foreground ,red    :foreground ,very-dark-grey :inherit bold))))
      `(success ((,cls (:background ,green  :distant-foreground ,green  :foreground ,very-dark-grey :inherit bold))))
      `(warning ((,cls (:background ,yellow :distant-foreground ,yellow :foreground ,very-dark-grey :inherit bold))))
      `(highlight ((,cls (:foreground ,very-dark-grey :background ,turquoise :distant-foreground ,turquoise :inherit bold))))
      `(region ((,cls (:background ,dark-grey :weight bold)))) ; NOTE visual mode selection
      `(secondary-selection ((,cls (:inherit region)))) ; TODO no idea what this is for, document it
      `(lazy-highlight ((,cls (:background ,orange :foreground ,black-dim)))) ; color for matches for in process searches
      `(isearch ((t (:inherit lazy-highlight :weight bold)))) ; NOTE inherited by evil-ex-search
      `(shadow ((,cls (:foreground ,light-grey)))) ; shadowed text, undermines actual text
      `(header-line ((,cls (:background ,very-dark-grey :foreground ,blue)))) ; shown at the top of some buffers, including in HEXL mode and helm
      `(match ((,cls (:foreground ,green-dim)))) ; TODO no idea what this is for, document it
      `(underline ((,cls (:inherit default)))) ;; needs to be set because compile uses it by force :(

      ;; line numbers
      `(line-number ((,cls (:background ,black :foreground ,very-light-grey :weight normal :underline nil))))
      `(line-number-current-line ((,cls (:foreground ,blue :inherit line-number))))

      ;; font locks and syntax highlighting
      `(font-lock-builtin-face ((,cls (:foreground ,blue))))
      `(font-lock-comment-face ((,cls (:foreground ,grey  :slant ,(if (and nil spacemacs-theme-comment-italic) 'italic 'normal)))))
      `(font-lock-keyword-face ((,cls (:foreground ,green :slant ,(if (and nil spacemacs-theme-keyword-italic) 'italic 'normal)))))
      `(font-lock-constant-face ((,cls (:foreground ,red :inherit bold))))
      `(font-lock-function-name-face ((,cls (:foreground ,yellow-int))))
      `(font-lock-negation-char-face ((,cls (:foreground ,red))))
      `(font-lock-preprocessor-face ((,cls (:foreground ,green-dim))))
      `(font-lock-string-face ((,cls (:foreground ,blue))))
      `(font-lock-doc-face ((,cls (:inherit font-lock-string-face)))) ; TODO optional bg
      `(font-lock-type-face ((,cls (:foreground ,red))))
      `(font-lock-warning-face ((,cls (:background ,yellow-int :distant-foreground ,yellow-int :foreground ,very-dark-grey :underline nil :inherit bold))))
      `(font-lock-variable-name-face ((,cls (:foreground ,yellow-int))))

      ;; rainbow delimeters are pretty
      `(rainbow-delimiters-depth-1-face ((,cls (:foreground ,(nth 0 rainbow-delims)))))
      `(rainbow-delimiters-depth-2-face ((,cls (:foreground ,(nth 1 rainbow-delims)))))
      `(rainbow-delimiters-depth-3-face ((,cls (:foreground ,(nth 2 rainbow-delims)))))
      `(rainbow-delimiters-depth-4-face ((,cls (:foreground ,(nth 3 rainbow-delims)))))
      `(rainbow-delimiters-depth-5-face ((,cls (:foreground ,(nth 4 rainbow-delims)))))
      `(rainbow-delimiters-depth-6-face ((,cls (:foreground ,(nth 5 rainbow-delims)))))
      `(rainbow-delimiters-depth-7-face ((,cls (:foreground ,(nth 6 rainbow-delims)))))
      `(rainbow-delimiters-depth-8-face ((,cls (:foreground ,(nth 7 rainbow-delims)))))

      ;; hyperlinks and path links
      `(link ((,cls (:foreground ,blue))))   ; hyperlink
      `(link-visited ((,cls (:foreground ,turquoise))))

      ;;; modeline/spaceline
      ;; NOTE mode-line faces below only affect some portions of the mode line
      ;;      these include the buffer name, the mode list & buffer percentage.
      `(mode-line ((,cls (:box (:line-width 1 :color ,very-light-grey :style none)
                               :background ,very-light-grey ; also winum color
                               :foreground ,very-dark-grey))))
      ;; TODO configure mode-line-inactive as well
                                             ; NOTE powerline-active-0 and powerline-inactive-0 also exist, but I have no idea what they do
      `(powerline-active1 ((,cls (:background ,black :foreground ,very-light-grey :inherit mode-line)))) ; major mode indicator
      `(powerline-active2 ((,cls (:background ,black :foreground ,very-light-grey :inherit mode-line)))) ; file-format + cursor-pos

      ;;; evil
      ;; permenent color of highlighted search results. Can be hidden using :nohlsearc
      `(evil-search-highlight-persist-highlight-face ((,cls (:background ,line-highlight-bg :foreground ,orange :inherit bold))))
      `(vimish-fold-overlay ((,cls (:background ,dark-grey :foreground ,green))))

      ;;; minibuffer & helm
      `(minibuffer-prompt ((,cls (:foreground ,yellow :weight bold)))) ; NOTE optional read only text preceding minibuffer input
      `(helm-M-x-key ((,cls (:foreground ,blue :inherit bold))))
      `(helm-source-header ((,cls (:foreground "#220833" :background ,yellow :family "sans serif" :weight bold :height 1.3)))) ; TODO use real color
      `(helm-selection ((,cls (:background ,red :distant-foreground ,black)))) ; active row
      `(helm-visible-mark ((,cls (:background ,blue-int))))
      ;;  helm buffer select
      `(helm-buffer-process ((,cls (:foreground ,turquoise-int)))) ; NOTE source for buffer
      `(helm-buffer-size ((,cls (:foreground ,orange :inherit bold))))
                                             ; file type based highlightings
      `(helm-buffer-directory ((,cls (:foreground ,yellow-int))))
      `(helm-buffer-archive ((,cls (:inherit helm-buffer-directory))))
      `(helm-buffer-file ((,cls (:foreground ,turquoise-int :inherit helm-buffer-directory))))
      `(helm-buffer-modified ((,cls (:foreground ,turquoise-int :inherit (bold helm-buffer-directory)))))
      `(helm-buffer-not-saved ((,cls (:foreground ,orange :inherit helm-buffer-directory))))
      `(helm-buffer-saved-out ((,cls (:foreground ,red :inherit helm-buffer-directory)))) ; NOTE saved outside of emacs
      ;; helm find file
      `(helm-ff-prefix ((,cls (:foreground ,black :background ,yellow-int)))) ; prefix for helm new file
      `(helm-ff-directory ((,cls (:inherit helm-buffer-directory))))
      `(helm-ff-dirs ((,cls (:inherit helm-ff-directory))))
      `(helm-ff-dotted-directory ((,cls (:foreground ,yellow-dim :inherit helm-ff-directory))))
      `(helm-ff-symlink ((,cls (:foreground ,grey))))
      `(helm-ff-dotted-symlink-directory ((,cls (:inherit helm-ff-symlink))))
      `(helm-ff-invalid-symlink ((,cls (:strike-through ,red-int :inherit helm-ff-symlink))))
      `(helm-ff-truename ((,cls (:foreground ,green-int :inherit helm-ff-file)))) ; NOTE shown alongside symlinks, is symlink dest
      `(helm-ff-file ((,cls (:inherit helm-buffer-file))))
      `(helm-ff-denied ((,cls (:foreground ,very-dark-grey :background ,red-int :strike-through ,red-int :inherit (bold helm-buffer-file)))))
      `(helm-ff-executable ((,cls (:inherit (bold helm-buffer-file)))))
      `(helm-ff-socket ((,cls (:foreground ,purple-int :inherit helm-buffer-file))))
      `(helm-ff-socket ((,cls (:foreground ,orange-int :inherit helm-buffer-file))))
      `(helm-ff-suid ((,cls (:foreground ,blue :inherit helm-ff-directory))))
      ;; helm grep
      `(helm-grep-cmd-line ((,cls (:inherit font-lock-type-face)))) ; NOTE grep failed cl message
      `(helm-grep-file ((,cls (:foreground ,turquoise-int :inherit bold)))) ; NOTE file in which grep matched
      `(helm-grep-finish ((,cls (:foreground ,red-int)))) ; NOTE grep info in mode line
      `(helm-grep-lineno ((,cls (:foreground ,orange-int :inherit bold))))
      `(helm-grep-match ((,cls (:foreground ,red-int :inherit bold)))) ; NOTE no affect when color=always
      ;; bookmarks
      `(helm-bookmark-addressbook ((,cls (:foreground ,orange-int))))
      `(helm-bookmark-directory ((,cls (:foreground ,yellow-int))))
      `(helm-bookmark-file ((,cls (:foreground ,turquoise-int))))
      `(helm-bookmark-file-not-found ((,cls (:foreground ,very-light-grey :strike-through ,red))))
      `(helm-bookmark-gnus ((,cls (:foreground ,purple-int))))
      `(helm-bookmark-info ((,cls (:foreground ,green-int))))
      `(helm-bookmark-man ((,cls (:foreground ,orange-dim))))
      `(helm-bookmark-w3m ((,cls (:foreground ,yellow-dim))))

      ;;; flycheck
      `(flycheck-info ((,cls (:underline (:style wave :color ,green)))))
      `(flycheck-warning ((,cls (:underline (:style wave :color ,yellow)))))
      `(flycheck-duplicate ((,cls (:underline (:style wave :color ,orange)))))
      `(flycheck-incorrect ((,cls (:underline (:style wave :color ,red)))))
      `(flycheck-fringe-info ((,cls (:foreground ,green-int :inherit fringe))))
      `(flycheck-fringe-warning ((,cls (:foreground ,yellow-int :inherit fringe))))
      `(flycheck-fringe-error ((,cls (:foreground ,red-int :inherit fringe))))

      ;;; frog jump buffer and avy
      `(avy-background-face ((,cls (:foreground ,grey))))
      `(avy-lead-face ((,cls (:background ,red-int :foreground "white"))))
      `(avy-lead-face-0 ((,cls (:background ,blue-int :foreground "white"))))
      `(avy-lead-face-1 ((,cls (:background ,very-light-grey :foreground ,very-dark-grey))))
      `(avy-lead-face-2 ((,cls (:background ,purple-int :foreground "white"))))
      `(frog-menu-border ((,cls (:background ,very-light-grey :foreground ,very-light-grey))))
      `(frog-menu-posframe-background-face ((,cls (:background ,very-light-grey))))

      ;;; company - intellisense
      ;; NOTE foreground-color  very-dark-grey
      ;;      background-color  very-light-grey
      ;;      active-foreground very-light-grey
      ;;      active-background blue
      ;;      sp-color          turquoise-int
      `(company-tooltip-mouse ((,cls (:foreground ,turquoise-int))))
      `(company-template-field ((,cls (:foreground ,turquoise-int))))

      ;; scrollbar
      `(company-scrollbar-bg ((,cls (:background ,very-light-grey :foreground ,very-light-grey))))
      `(company-scrollbar-fg ((,cls (:background ,dark-grey       :foreground ,dark-grey))))

      ;; NOTE preview is for the leading text for a the sole match on a line
      `(company-preview ((,cls (:foreground ,blue-int :weight bold :inherit hl-line))))
      `(company-preview-common ((,cls (:inherit company-preview))))
      `(company-preview-search ((,cls (:foreground ,orange-int :weight normal :inherit company-preview))))

      ;; NOTE tooltip is the drop down menu which shows up when multiple results exist
      `(company-tooltip ((,cls (:background ,very-light-grey :foreground ,very-dark-grey :inherit bold))))
      `(company-tooltip-common ((,cls (:foreground ,blue-int :inherit company-tooltip))))
      `(company-tooltip-selection ((,cls (:foreground ,very-light-grey :background ,blue-int))))
      `(company-tooltip-common-selection ((,cls (:foreground ,very-dark-grey :background ,blue-int :inherit company-tooltip-common))))
      `(company-tooltip-search ((,cls (:foreground ,orange :inherit company-tooltip))))
      `(company-tooltip-search-common ((,cls (:inherit company-tooltip-search))))
      `(company-tooltip-search-selection ((,cls (:background ,blue-int :inherit company-tooltip-search))))

      ;; NOTE annotations are extra information in stdout
      `(company-tooltip-annotation ((,cls (:weight bold :foreground ,grey))))
      `(company-tooltip-annotation-selection ((,cls (:foreground ,turquoise-int :background ,blue-int :inherit company-tooltip-annotation))))

      ;;; set spacemacs evil state fac  `(spacemacs-emacs-face ((,cls (:background ,(color-hsl-to-css-rgb-hex yoda)))))
      `(spacemacs-evilified-face ((,cls (:foreground ,very-dark-grey :background ,red))))
      `(spacemacs-hybrid-face ((,cls (:foreground ,very-dark-grey :background ,orange-dim))))
      `(spacemacs-iedit-face ((,cls (:foreground ,very-dark-grey :background ,orange))))
      `(spacemacs-iedit-insert-face ((,cls (:foreground ,very-dark-grey :background ,orange))))
      `(spacemacs-lisp-face ((,cls (:foreground ,very-dark-grey :background ,green))))
      `(spacemacs-visual-face ((,cls (:foreground ,very-dark-grey :background ,turquoise))))
      `(spacemacs-normal-face ((,cls (:foreground ,very-dark-grey :background ,yellow))))
      `(spacemacs-insert-face ((,cls (:foreground ,very-dark-grey :background ,blue))))
      `(spacemacs-motion-face ((,cls (:foreground ,very-dark-grey :background ,purple))))
      `(spacemacs-replace-face ((,cls (:foreground ,very-dark-grey :background ,very-light-grey))))

      ;;;; custom mode variants
      ;;; whitespace-mode
      ;; `(whitespace-trailing ((,cls (:foreground "yellow" :background ,red))))
      `(whitespace-space ((,cls (:foreground ,dark-grey))))
      `(trailing-whitespace ((,cls (:background ,dark-grey))))

      ;;; auto-highlight-symbol mode
      ;; Note: distant foreground is meaningless here because the faces are always given pririty
      `(ahs-definition-face ((,cls (:background ,blue-dim :distant-foreground ,blue-dim :foreground ,dark-grey))))
      `(ahs-edit-mode-face ((,cls (:background ,red-dim :distant-foreground ,red-dim :foreground ,very-light-grey))))
      `(ahs-face ((,cls (:background ,very-light-grey :foreground ,black :inherit bold)))) ; NOTE matching selections
      `(ahs-plugin-whole-buffer-face ((,cls (:background ,blue :distant-foreground ,green :foreground ,black))))
      `(ahs-plugin-bod-face ((,cls (:background ,blue-int :distant-foreground ,blue-int :foreground ,black))))
      `(ahs-plugin-defalt-face ((,cls (:background ,orange-dim :distant-foreground ,orange-dim :foreground ,black))))
      `(ahs-warning-face ((,cls (:foreground ,red-dim))))

      ;;; compilation mode
      `(compilation-line-number ((,cls (:foreground ,yellow))))
      `(compilation-column-number ((,cls (:inherit font-lock-doc-face))))
      ;; NOTE also represents value count in mode line
      ;; `(compilation-error ((,cls (:background ,red-int :distant-foreground ,red-int :foreground ,very-dark-grey))))
      ;; `(compilation-info ((,cls (:background ,green-int :distant-foreground ,green-int :foreground ,very-dark-grey))))
      ;; `(compilation-warning ((,cls (:background ,orange-int :distant-foreground ,orange-int :foreground ,very-dark-grey))))
      `(compilation-error ((,cls (:foreground ,red-int :inherit bold))))
      `(compilation-info ((,cls (:foreground ,green-int :inherit bold))))
      `(compilation-warning ((,cls (:foreground ,orange-int :inherit bold))))
      ;; NOTE theses only represent the exit status indicator
      `(compilation-mode-line-exit ((,cls (:foreground ,very-dark-grey))))
      `(compilation-mode-line-fail ((,cls (:foreground ,very-dark-grey))))
      `(compilation-mode-line-run ((,cls (:foreground ,very-dark-grey))))

      ;;; markdown-mode
      `(markdown-code-face ((,cls (:inherit default))))

      ;;; anzu
      `(anzu-mode-line ((,cls (:foreground ,very-dark-grey :inherit bold))))
      `(anzu-mode-line-no-match ((,cls (:foreground ,red-int :inherit bold))))

      ;;; org-mode
      `(org-link ((,cls (:foreground ,turquoise :inherit bold))))
      `(org-footnote ((,cls (:foreground ,blue))))
      ;; Overridden by hl-todo-keyword-faces
      `(org-todo ((,cls (:foreground ,purple-int :inherit bold))))
      `(org-done ((,cls (:foreground ,green-int :inherit bold))))
      ;; `(org-warning ((,cls (:foreground ))))
      `(org-upcoming-deadline ((,cls (:foreground ,red-dim))))
      `(org-warning ((,cls (:foreground ,orange :inherit bold))))
      `(org-scheduled-today ((,cls (:foreground ,green-int))))
      `(org-block-begin-line ((,cls :background "royalblue4" :distant-foreground "royalblue4" :foreground "steelblue1")))
      ;; `(org-block-begin-line ((,cls :background "royalblue4" :distant-foreground "royalblue4" :foreground ,turquoise-int)))
      `(org-meta-line ((,cls (:inherit (font-lock-comment-face)))))
      ;; `(org-meta-line ((,cls (:background "springgreen4" :distant-foreground "springgreen4" :foreground "springgreen1"))))

      `(org-block ((,cls (:background ,extra-dark-grey))))
      `(org-document-title ((,cls (:foreground "white" :height 1.3 :inherit bold))))

      `(dashboard-text-banner ((,cls (:foreground ,orange-int))))

      ;; eshell-prompt-extras
      `(epe-remote-face ((,cls (:foreground ,turquoise))))
      `(epe-venv-face ((,cls (:foreground ,purple))))

      ;;; ivy
      ;; `(ivy-current-match ((,cls :backgrouns ,blue-dim :foreground ,black))) ;; hl-line
      ;; `(ivy-confirm-face ((,cls :foreground ,green-dim :inherit bold)))
      ;; `(ivy-match-required-face ((,cls (:foreground ,red-int :inherit bold)))) ;; no candidate chosen
      )

     (custom-theme-set-variables 'an-old-hope
       `(hl-todo-keyword-faces '(("TODO"        . ,red)
                                 ("NEXT"        . ,red)
                                 ("RANT"        . ,red)
                                 ("THEM"        . ,purple)
                                 ("PROG"        . ,blue-int)
                                 ("OKAY"        . ,blue-int)
                                 ("DONT"        . ,green-int)
                                 ("FAIL"        . ,red)
                                 ("DONE"        . ,green-int)
                                 ("NOTE"        . ,yellow-int)
                                 ("KLUDGE"      . ,yellow-int)
                                 ("HACK"        . ,yellow-int)
                                 ("TEMP"        . ,yellow-int)
                                 ("FIXME"       . ,orange)
                                 ("WARN"        . ,orange)
                                 ("XXX+"        . ,orange)
                                 ("\\?\\?\\?+"  . ,orange))))
     (put 'custom-theme-set-variables 'lisp-indent-function 'defun)

     (provide-theme 'an-old-hope)

     ;; unbind all assigned colors
     (dolist (color colors)
       (makunbound (car color)))
   #+END_SRC

* Deprecated
  :PROPERTIES:
  :header-args+: :tangle no
  :END:
** helm
*** helm-mode
    #+BEGIN_SRC emacs-lisp
      (use-package helm
        :ensure t
        :defer  10
        ;; :delight
        ;; (helm-mode " ")
        :commands (helm-M-x
                   helm-apropos
                   helm-resume
                   helm-all-mark-rings
                   helm-register
                   helm-show-kill-ring
                   helm-info-at-point
                   helm-filtered-bookmarks
                   helm-find-files
                   helm-locate
                   helm-recent-file
                   helm-man-woman
                   helm-help
                   helm-top
                   helm-mini
                   helm-regexp)
        :init
        (setq helm-split-window-inside-p t)

        (general-define-key
          ;; :states '(normal emacs insert motion)
          "C-M-y" 'helm-show-kill-ring
          "M-x"   'helm-M-x)

        ;; TODO move to helm map
        (bind-keys :map minibuffer-local-map
                   ("C-r" . helm-minibuffer-history))

        (general-define-key
          :states 'insert
          "<tab>" 'indent-relative)

        (mohkale/declare-prefix*
          "C-?" "appropos"
          "am"  "man-woman"
          "at"  "top"
          "r" "registers/rings/resume")

        (mohkale/set-leader-keys
          "SPC" 'helm-M-x
          "C-?" 'helm-apropos

          "iu" 'helm-ucs

          "rl" 'helm-resume
          "rm" 'helm-all-mark-rings
          "rr" 'helm-register
          "ry" 'helm-show-kill-ring

          "hi" 'helm-info-at-point

          "fb" 'helm-filtered-bookmarks
          "ff" 'helm-find-files
          "fL" 'helm-locate
          "fr" 'helm-recentf

          "am" 'helm-man-woman
          "at" 'helm-top

          "bb" 'helm-mini
          "bS" 'helm-regexp)
        :config
        (require 'helm-config)
        (helm-mode 1)

        ;;; minibuffer is unecessary when input is shown at the top of helm
        (defun helm-hide-minibuffer-maybe ()
          "https://www.reddit.com/r/emacs/comments/3asbyn/new_and_very_useful_helm_feature_enter_search/"
          (when (with-helm-buffer helm-echo-input-in-header-line)
            (let ((ov (make-overlay (point-min) (point-max) nil nil t)))
              (overlay-put ov 'window (selected-window))
              (overlay-put ov 'face (let ((bg-color (face-background 'default nil)))
                                      `(:background ,bg-color :foreground ,bg-color)))
              (setq-local cursor-type nil))))

        (add-hook 'helm-minibuffer-set-up-hook 'helm-hide-minibuffer-maybe)

        ;;; always show helm window at the bottom of the frame
        ;; source https://www.reddit.com/r/emacs/comments/345vtl/make_helm_window_at_the_bottom_without_using_any/
        (push `(,(rx bos "*helm" (* not-newline) "*" eos)
                (display-buffer-in-side-window)
                (inhibit-same-window . t)
                (window-height . 0.4))
              display-buffer-alist)

        ;; fuzzy match... fuzzy match EVERYTHING
        (setq-default helm-mode-fuzzy-match t
                      helm-completion-in-region-fuzzy-match t

                      helm-recentf-fuzzy-match    t
                      helm-buffers-fuzzy-matching t
                      helm-recentf-fuzzy-match    t
                      helm-buffers-fuzzy-matching t
                      helm-locate-fuzzy-match     t
                      helm-M-x-fuzzy-match        t
                      helm-semantic-fuzzy-match   t
                      helm-imenu-fuzzy-match      t
                      helm-apropos-fuzzy-match    t
                      helm-lisp-fuzzy-completion  t
                      helm-session-fuzzy-match    t
                      helm-etags-fuzzy-match      t)

        (defun helm-eol-or-confirm-and-exit-minibuffer ()
          "moves to the end of the helm minibuffer or confirm and exit
      exists as a parrallel to backward-sentence binding below"
          (interactive)
          (if (not (eolp))
              (end-of-line)
            (helm-confirm-and-exit-minibuffer)))

        :bind* (:map helm-map
                ("C-h" . nil)
                ("TAB" . helm-maybe-exit-minibuffer)
                ;; ("C-z" . helm-help)
                ;; helm-help doesn't work anyway
                ("C-z" . helm-select-action)
                ;;; movement bindings in normal mode
                ("<left>"  . evil-backward-char)
                ("<right>" . evil-forward-char)
                ;; "C-d" 'helm-buffer-run-kill-buffers
                ("C-j" . helm-next-line)
                ("C-k" . helm-previous-line)
                ("C-h" . backward-sentence)
                ;; TODO check if end of line, if not then
                ;;      exit minibuffer, else goto EOL
                ("C-l" . helm-eol-or-confirm-and-exit-minibuffer)
                ("C-w"   . backward-kill-word)
                ("M-k"   . backward-kill-sentence)
                ("C-M-k" . kill-sentence) ;; kill forward
                ("M-h" . backward-word)
                ("M-l" . forward-word)
                ("M-j"   . ace-jump-helm-line) ; Alternative = C-q
                ("C-d"   . helm-next-page)
                ("C-u"   . helm-previous-page)
                ;; NOTE C-w reads a word in from buffer at point
                ("M-("   . helm-prev-visible-mark)
                ("M-)"   . helm-next-visible-mark)

                :map helm--minor-mode-map
                ("<C-backspace>" . evil-delete-backward-word)))

      (use-package helm-files
        ;; :ensure t
        :defer  t
        :bind (:map helm-find-files-map
               ("<C-backspace>" . nil) ;; delete override
               ("C-h" . helm-find-files-up-one-level)
               ("C-l" . helm-ff-RET)
               ("TAB" . helm-ff-RET)))

      (use-package helm-buffers
        ;; :ensure t
        :defer  t
        :bind (:map helm-buffer-map
              ("M-d" . helm-buffer-run-kill-buffers)
              ("M-D" . nil) ;; delete uppercase variant
              ("M-s" . helm-buffer-save-persistent) ; save but don't kill helm
              ("C-." . helm-buffers-toggle-show-hidden-buffers)))

      (use-package helm-company
        :ensure t
        :defer  t
        :commands helm-company)

      (add-hook 'eshell-mode-hook (lambda ()
                                    (require 'helm-eshell)
                                    (eshell-cmpl-initialize)
                                    ))

      (use-package helm-eshell
        :defer t
        :config
        (eshell-cmpl-initialize)
        :bind* (:map eshell-mode-map
                ([remap eshell-pcomplete] . helm-esh-pcomplete)
                ;; helm-eshell-prompts-all
                ;; helm-eshell-history
                ))

      (with-eval-after-load 'helm
        (defun persp-helm-mini ()
          "helm-mini, but using only the perspectives buffers"
          (interactive)
          (with-persp-buffer-list ()
            (helm-mini)))
        (mohkale/set-leader-keys-for-minor-mode 'persp-mode
          "bb" 'persp-helm-mini))



      ;; (general-define-key
      ;;  :keymaps mohkale-search-map
      ;;  "`" 'helm-ag-pop-stack
      ;;  "B" 'helm-buffers-smart-do-search
      ;;  "c" 'evil-search-clear-highlight
      ;;  "e" 'evil-iedit-state/iedit-mode
      ;;  "F" 'helm-files-smart-do-search-region
      ;;  "f" 'helm-files-smart-do-search
      ;;  "H" 'goto-last-searched-ahs-symbol
      ;;  "h" 'symbol-highlight
      ;;  "j" 'helm-jump-in-buffer
      ;;  "S" 'helm-swoop-region-or-symbol
      ;;  "s" 'helm-swoop
      ;;  "C-s" 'helm-multi-swoop-all)

      ;; (general-define-key
      ;;  :keymaps mohkale-search-ag-map
      ;;  "A" 'helm-file-do-ag-region-or-symbol
      ;;  "a" 'helm-ag-this-file
      ;;  "B" 'helm-buffers-do-ag-region-or-symbol
      ;;  "b" 'helm-do-ag-buffers
      ;;  "F" 'helm-files-do-ag-region-or-symbol
      ;;  "f" 'helm-do-ag
      ;;  "P" 'helm-project-do-ag-region-or-symbol
      ;;  "p" 'helm-project-do-ag)

      ;; (general-define-key
      ;;  :keymaps mohkale-search-ack-map
      ;;  "B" 'helm-buffers-do-ack-region-or-symbol
      ;;  "b" 'helm-buffers-do-ack
      ;;  "F" 'helm-files-do-ack-region-or-symbol
      ;;  "f" 'helm-files-do-ack
      ;;  "P" 'helm-project-do-ack-region-or-symbol
      ;;  "p" 'helm-project-do-ack)

      ;; (general-define-key
      ;;  :keymaps mohkale-search-ack-map
      ;;  "B" 'helm-buffers-do-grep-region-or-symbol
      ;;  "b" 'helm-buffers-do-grep
      ;;  "F" 'helm-files-do-grep-region-or-symbol
      ;;  "f" 'helm-files-do-grep
      ;;  "G" 'helm-file-do-grep-region-or-symbol
      ;;  "g" 'helm-file-do-grep
      ;;  "P" 'helm-projectile-grep)

      ;; (general-define-key
      ;;  :keymaps mohkale-search-pt-map
      ;;  "B" 'helm-buffers-do-pt-region-or-symbol
      ;;  "b" 'helm-buffers-do-pt
      ;;  "F" 'helm-files-do-apt-region-or-symbol
      ;;  "f" 'helm-files-do-apt
      ;;  "P" 'helm-project-do-pt-region-or-symbol
      ;;  "p" 'helm-project-do-pt)

      ;; (general-define-key
      ;;  :keymaps mohkale-search-pt-map
      ;;  "g" 'helm-google-suggest
      ;;  "w" 'helm-wikipedia-suggest)

      ;; (general-define-key
      ;;  :keymaps mohkale-help-map
      ;;  "T" 'evil-tutor-start
      ;;  )

      ;; (general-define-key
      ;;   ;; depends on dired-x
      ;;   :keymaps emacs-leader-keys-files-map
      ;;   "d" 'dired-jump
      ;;  )

      ;; (general-define-key
      ;;   :keymaps 'mohkale-buffers-map
      ;;   "A" 'persp-add-buffer
      ;;   "a" 'persp-add-current-buffer
      ;;   "R" 'persp-remove-buffer
      ;;   "r" 'persp-remove-current-buffer
      ;;  )
    #+END_SRC

*** helm-descbinds
    #+BEGIN_SRC emacs-lisp
      (use-package helm-descbinds
        :ensure t
        :defer  t
        :commands helm-descbinds
        :init
        ;; (mohkale/declare-prefix*
        ;;   "hdB" "describe-bindings-buffer"
        ;;   "hdb" "describe-bindings")
        (mohkale/set-leader-keys
          ;; "hdB" 'describe-bindings
          ;; "hdb" 'helm-descbinds

          "?" 'helm-descbinds)
        (defalias 'describe-bindings 'helm-descbinds))
    #+END_SRC

*** helm-make
    #+BEGIN_SRC emacs-lisp
      (use-package helm-make
        :ensure t
        :defer  t
        :commands (helm-make
                   helm-make-projectile)
        :init
        (mohkale/set-leader-keys
          "cc" 'helm-make-projectile
          "cm" 'helm-make))
    #+END_SRC

*** ace-jump-helm-line
    #+BEGIN_SRC emacs-lisp
      (use-package ace-jump-helm-line
        :ensure t
        :defer  t
        :commands ace-jump-helm-line
        :bind (:map helm-map
               ("C-q" . ace-jump-helm-line)))
    #+END_SRC

*** helm-projectile
    #+BEGIN_SRC emacs-lisp
      (use-package helm-projectile
        :ensure t
        :defer  t
        :after (projectile helm)
        :commands (helm-projectile-on
                   helm-projectile-switch-project
                   helm-projectile-find-file
                   helm-projectile-find-file-in-known-projects
                   helm-projectile-find-file-dwim
                   helm-projectile-find-dir
                   helm-projectile-recentf
                   helm-projectile-switch-to-buffer
                   helm-projectile-grep
                   helm-projectile-ag
                   helm-projectile-rg)
        :init
        (mohkale/declare-prefix*
          "ps" '("search" . "project-search"))

        (mohkale/set-leader-keys
          "pb" 'helm-projectile-switch-to-buffer
          "pd" 'helm-projectile-find-dir
          "pf" 'helm-projectile-find-file
          "ph" 'helm-projectile
          ;; "pl" 'helm-persp-switch-project
          "pP" 'helm-projectile-switch-project
          "pr" 'helm-projectile-recentf
          "psg" 'helm-projectile-grep
          "psa" 'helm-projectile-ag
          "psr" 'helm-projectile-rg)
        :config
        (helm-projectile-on))
    #+END_SRC

*** helm-yasnippet
    access snippets from helm... really cool tbh

    #+BEGIN_SRC emacs-lisp
      (use-package helm-c-yasnippet
        :ensure t
        :defer  t
        :commands helm-yas-complete
        :init
        (mohkale/set-leader-keys
          "is" 'helm-yas-complete)
        (general-define-key
          :states 'insert
          "C-M-i" 'helm-yas-complete))
    #+END_SRC

*** helm-pydoc
    #+BEGIN_SRC emacs-lisp
      (use-package helm-pydoc
        :ensure t
        :defer  t
        :commands helm-pydoc
        :init
        (with-eval-after-load 'helm
          (mohkale/set-leader-keys-for-major-mode 'python-mode
            "hd" 'helm-pydoc)))
    #+END_SRC

