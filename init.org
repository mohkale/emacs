# -*- mode: org; coding: utf-8-unix; eval: (auto-fill-mode); fill-column: 85; -*-

#+TITLE: init.org
#+STARTUP: content

#+PROPERTY: header-args :tangle init.el :tangle-mode (identity #o544) :comments link :mkdirp yes :noweb yes :hlines no :shebang ";; -*- lexical-binding: t -*-"

* Config
  Configure the desired optional components and experience of my Emacs configuration.

  #+BEGIN_SRC emacs-lisp
    ;; We both evaluate the current configuration and load it from the file-system just to
    ;; make sure that on the initial tangle (when it can't be loaded) we have a decent set
    ;; of defaults to determine what needs to be tangled.
    <<eval-default-config()>>
    <<load-config()>>
    <<load-profile()>>
  #+END_SRC

  NOTE: This branch only contains the *default* configuration options and these options will
  be reset every tangle, to create permanent ~local~ modifications to this create a lisp file
  at ~lisp/+config.el~ and that will be sourced instead of this.

  #+NAME: eval-default-config
  #+BEGIN_SRC emacs-lisp :results values :tangle lisp/+config-default.el
    <<config-modules>>
    <<config-options>>

    (provide '+config-default) nil
  #+END_SRC

  Okay that's all the configurable part of my emacs configuration, the rest of this
  section sets up some basic utility methods to help with configuration.

  #+NAME: load-config
  #+BEGIN_SRC emacs-lisp :results values
    (require 'cl-lib)

    (unless (or (load (concat user-emacs-directory "lisp/+config") t)
                (load (concat user-emacs-directory "lisp/+config-default") t)
                ;; See [[file:bin/tangle-targets][tangle-targets]] and [[file:bin/tangle][tangle]].
                (bound-and-true-p checking-tangle-targets+)
                (bound-and-true-p tangling+))
      (warn "Failed to load emacs configuration file, using default"))

    (defmacro package! (&rest pkgs)
      "Assert whther all the packages in PKGS are to be installed"
      ;; (append '(and) (cl-loop for pkg in pkgs collect `(member (quote ,pkg) +packages)))
      (let (pkg res)
        (while (prog1 (setq pkg (car pkgs))
                 (setq pkgs (cdr pkgs)))
          (cond ((eq pkg :not)
                 (push `(not (package! ,@pkgs)) res)
                 (setq pkgs nil))
                ((eq pkg :lsp)
                 (push '+lsp-command res))
                (t (push `(member (quote ,pkg) +packages) res))))
        `(and ,@res)))

    (defmacro package-yes! (&rest pkgs)
      `(if (package! ,@pkgs) "yes" "no"))

    (defmacro package-str! (str &rest pkgs)
      `(if (package! ,@pkgs) ,str "no"))

    (defvar +lsp-command
      (let ((lsp   (package! lsp-mode))
            (eglot (package! eglot)))
        (cond
         ((and lsp eglot)
          (warn "you've enabled both lsp and eglot, defaulting to eglot.")
          'eglot-ensure-maybe+)
         (lsp   'lsp)
         (eglot 'eglot-ensure-maybe+)))
      "command used to start a language server.")

    nil
  #+END_SRC

  I also keep an EDN style local configuration at ~~/etc/profile.el~. It's basically
  for host specific settings (eg. git passwords, etc.). Lets load that here.

  #+NAME: load-profile
  #+BEGIN_SRC emacs-lisp :results values
    (defvar +profile-file (concat user-emacs-directory "etc/profile.el"))

    (defvar +profile
      (ignore-errors
        (when (file-exists-p file)
          (with-temp-buffer
            (insert-file-contents file)
            (read (current-buffer)))))
      "Alist local configuration properties.\nSourced from `+profile-file'")

    (defun +profile-get (prop &optional default)
      (or (cdr (assoc prop +profile))
          default))

    nil
  #+END_SRC

** modules
   Optionally enable or disable entire configuration sections. These generally have a
   one to one mapping with packages that're to be installed.

   #+NAME: config-modules
   #+BEGIN_SRC emacs-lisp
     (defvar +packages
       '(magit                                                             ; It's git... but magical ÔÉê ,
         ;; ace-link                                                       ; Jump to links in the current buffer through an avy interface
         link-hint                                                         ; Jump to links in the current buffer through an avy interface
         ;; adaptive-wrap                                                  ; Visually wrap long lines. doesn't alter what you write.
         anzu                                                              ; Show the number of search results incrementally
         ;; auto-highlight-symbol                                          ; Automatically highlight the symbol at point
         browser-edit                                                      ; Interface emacs with [[https://www.chromium.org/][chromium]]
         ;; command-log-mode                                               ; Echo commands as you enter them
         dashboard                                                         ; A feature full emacs dashboard
         ;; deft                                                           ; Note management system based on multiple org files
         ;; ebuku                                                          ; Interface to the, ebuku, bookmark manager
         engine-mode                                                       ; Run a search on a given search engine and view in brower
         eshell                                                            ; A nice lispy shell
         ;; expand-region                                                  ; Expand visual mode by semantic units
         flycheck                                                          ; A better buffer linter and error-checker package
         ;; frog-jump-buffer                                               ; Posframe to jump to a buffer
         ;; hide-comnt                                                     ; Minor mode to disable rendering of comments
         imenu                                                             ; Interactively jump to points of interest in this buffer
         olivetti                                                          ; A nice writing environment for emacs
         ;; pdf-tools                                                      ; Use emacs as quick and dirty pdf viewer
         ;; piper                                                          ; Interactive shell pipelines with emacs
         realgud                                                           ; The quintessential debugger package for emacs
         rainbow-mode                                                      ; Automatically color/highlight css color names
         skeletor                                                          ; Project skeleton generator package
         ;; rake                                                           ; Run rake tasks
         ;; vi-tilde-fringe                                                ; Show tildes at the end of the buffer
         ;; vlc-rc                                                         ; Control [[https://www.videolan.org/vlc/index.en-GB.html][VLC]] from emacs
         ;; vterm                                                          ; A virtual terminal emulator... interfaced with emacs
         ;; wakatime                                                       ; Track your habits using the [[wakatime][https://wakatime.com/]]
         ;; ztree                                                          ; Directory tree viewer, think NERDTree

     ;;; Completion frameworks
         ivy                                                               ; A clean minimalist completion framework.
         ;; selectrum                                                      ; An ivy-like package designed to be more consistent and predictable

     ;;; Completion Assistants
         prescient                                                         ; Sorting/Filtering based on frequency and proximity.
         ;; orderless                                                      ; Blazingly fast completion regexp generator using space seperated patterns

     ;;; Mode lines
         doom-modeline                                                     ; A fast and feature-full mode-line package based on [[https://github.com/hlissner/doom-emacs][doom]]!
         ;; spaceline                                                      ; The same mode-line package as [[https://github.com/syl20bnr/spacemacs][spacemacs]].

     ;;; Buffer Menus
         ;; buffer-menu                                                    ; The (default) builtin buffer menu
         ibuffer                                                           ; An improved buffer menu
         ;; bufler                                                         ; A butler for your buffers

     ;;; LSP Clients
         eglot                                                             ; A light weight and clean LSP client
         ;; lsp-mode                                                       ; A comprehensive and feature full client

     ;;; Interactive Diffs
         ;; ediff                                                          ; The builtin alternative, it has decades worth of bloat.
         vdiff                                                             ; A diff tool inspired by [[https://github.com/justbur/emacs-vdiff][vimdiff]]

     ;;; Package Enhancements
         ;; counsel-world-clock                                            ; Inspect the current time from ivy
         ;; diredfl                                                        ; Make dired /extra/ colorful
         ;; image-dired                                                    ; View images in dired like sessions
         ;; edit-indirect                                                  ; Edit regions of a buffer in another mode.
         ;; hydra-posframe                                                 ; Show hydras in a posframe
         ebib                                                              ; Nice emacs based interface for editing bibtex files
                                                                           ; NOTE: This package requires bibtex to be enabled
         ;; tramp-term                                                     ; Make term work seamlessly in tramp sessions
         ibuffer-vc                                                        ; Filter ibuffer buffers by version-control repos
         ibuffer-tramp                                                     ; Only show ibuffer buffers in remote tramp sessions
         ;; ibuffer-persp                                                  ; Filter ibuffer buffers by emacs perspectives
         ibuffer-projectile                                                ; Filter ibuffer buffers by active projects
         ;; company-emoji                                                  ; Show emojis in company-completion candidates

         ;; ivy-rich                                                       ; Extra documentation and meta-info for core ivy functions
         ;; ivy-rich-icons                                                 ; Enable icons with ivy-find
         ;; ivy-prescient                                                  ; Sort ivy candidates through prescient. (WARN [[https://github.com/raxod502/prescient.el/issues?q=is%3Aissue+ivy+history][issues]])

     ;;; language-support
         ;; ggtags                                                         ; GNU Global source code tagging system
         ;; ycmd                                                           ; A language-server for most languages. written in python.
         ;; ruby-robe                                                      ; Code navigation, doc-lookup and completion for Ruby
         ;; anaconda                                                       ; A no-longer mainatained, but still powerful language-server for python

     ;;; Languages
         bibtex
         c
         clojure
         ;; cmake
         css
         csv
         elisp
         git-langs
         ;; haskell
         html
         ;; java
         golang
         javascript
         ;; typescript                                                     ; NOTE requires javascript to also be enabled
         json
         ;; jupyter
         ;; kotlin
         ;; glsl
         latex
         makefile
         markdown
         ;; nim
         python
         ;; powershell
         ;; restclient
         ruby
         rust
         sh-script
         sql
         ssh-config
         vimlang
         yaml
         ;; yarn
         )
       "Packages I want setup on startup.")
   #+END_SRC

** options
   #+NAME: config-options
   #+BEGIN_SRC emacs-lisp
     (defvar +sh-use-lsp nil
       "When true `sh-script-mode' and it's derivatives will use LSP when available")

     (defvar +man-command (if (member system-type '(cygwin ms-dos windows-nt)) 'woman 'man)
       "Preferred command used for manuals")

     (defvar +c-prefer-clangd t
       "When true lsp and c will use clangd over ccls")

     (defvar +icons-available t
       "When true `all-the-icons' will be available even in terminal emacs.")

     (defvar +icons-prefer-nerd-font t
       "When true and `nerd-font' is available, override `all-the-icons' fonts with nerd-fonts")

     (defvar +find-file-ignore-regexp
       (rx (or (and ".#" (one-or-more any))
               (and bol "flycheck_")
               (and ".class" eol)
               (and ".o" eol)
               (and "node_modules")
               (and ".git" (zero-or-one "/") eol)
               (and ".elc" eol)
               (and ".bundle/")
               (and (any ?. ?-) "lock" (zero-or-one ".json") eol))))

     (defvar +orderless-requires-prescient nil
       "When true, if `prescient' and `orderless' are both configured,
     when prescient is disabled orderless is also disabled.")

     (defvar TeX-view-in-emacs+ nil
       "When true, view latex documents in emacs PDFTools.
     This variable should be set before requiring Auctex.")
   #+END_SRC

* Setup
** early-init
   :PROPERTIES:
   :header-args+: :tangle early-init.el
   :END:

   [[https://git.savannah.gnu.org/cgit/emacs.git/commit/?id=24acb31c04b4048b85311d794e600ecd7ce60d3b][early-init]] is automatically sourced by emacs since 27 forward, before any other
   enhancements or packages have been sourced. Let's make sure it's loaded on older
   emacs versions as well.

   #+BEGIN_SRC emacs-lisp :tangle init.el
     (when (version< emacs-version "27")
       (load (concat user-emacs-directory "early-init.el")))
   #+END_SRC

   Let's give the garbage collector free reign to take up as much memory as it needs
   so that we can speed up startup times. Source [[https://github.com/hlissner/doom-emacs/issues/310][doom]].

   #+BEGIN_SRC emacs-lisp
     (defvar default-gc-cons-threshold 16777216 ; 16mb
       "my default desired value of `gc-cons-threshold'
     during normal emacs operations.")

     ;; make garbage collector less invasive
     (setq gc-cons-threshold  most-positive-fixnum
           gc-cons-percentage 0.6)
   #+END_SRC

   Let's disable some of the unecessary GUI enhancements, you can re-enable them at
   runtime+, but I don't like them anyways+. Disabling them early also prevents GUI
   enhancements being partially visible at startup and then immeadiately disabled.

   #+BEGIN_SRC emacs-lisp
      ;; Prevent the glimpse of un-styled Emacs by disabling these UI elements early.
      (push '(menu-bar-lines . 0) default-frame-alist)
      (push '(tool-bar-lines . 0) default-frame-alist)
      (push '(vertical-scroll-bars) default-frame-alist)
   #+END_SRC

   We should also make sure these enhancements persists even in older emacs versions.
   We also have to disable ~scroll-bar-mode~ the direct way, not just in ~early-init~,
   or else spaceline gets truncated on the right hand side.

   #+BEGIN_SRC emacs-lisp :tangle init.el
     (when (version< emacs-version "27")
       (menu-bar-mode -1)     ; dropdown menu list below frame title
       (tool-bar-mode -1)     ; short mini menu shown below the menu bar
       )

     (scroll-bar-mode -1)   ; scroll bar shown on frames right side
   #+END_SRC

   Also erase ~file-name-handler-alist~ for startup.

   #+BEGIN_SRC emacs-lisp
     (setq default-file-name-handler-alist file-name-handler-alist
           file-name-handler-alist nil)
   #+END_SRC

   And then make sure these changes are undone after emacs has started.

   #+BEGIN_SRC emacs-lisp
     (add-hook 'emacs-startup-hook
               (lambda (&rest _)
                 (setq gc-cons-threshold default-gc-cons-threshold
                       gc-cons-percentage 0.1
                       file-name-handler-alist default-file-name-handler-alist)

                 ;; delete no longer necessary startup variable
                 (makunbound 'default-file-name-handler-alist)))
   #+END_SRC

** paths
   Create some macros/functions to ease the definitions of paths within my dotemacs
   home directory.

   #+BEGIN_SRC emacs-lisp
     (if (version<= emacs-version "26.3")
         (require 'cl)
       (require 'cl-lib))

     (defun join-path (root path &rest rest)
       "like python' os.path.join, join a series of paths together."
       (setq path (if (file-name-absolute-p path)
                      path
                    (concat root
                            (unless (string-suffix-p "/" root)
                              "/")
                            path)))
       (if rest (apply 'join-path path rest) path))

     (cl-defmacro dotemacs-initialise-path!
         (path-type path &optional &key
          (alias (intern (concat (symbol-name path-type) "!"))))
       "initialise a constant for PATH and a function to join onto PATH.
     The function will be of the form dotemacs-join-PATH-TYPE-path and will have
     an alias of the form PATH-TYPE!"
       (let* ((path-type-name (symbol-name path-type))
              (path-sym (intern (concat "dotemacs-"      path-type-name "-path")))
              (func-sym (intern (concat "dotemacs-join-" path-type-name "-path"))))
         `(progn
            (defconst ,path-sym
              (eval-when-compile (concat user-emacs-directory ,path)))

            (defun ,func-sym (path &rest args)
              ,(concat "join args onto directory: " path)
              (apply 'join-path ,path-sym path args))

            (when (quote ,alias)
              (defalias (quote ,alias) (symbol-function (quote ,func-sym)))))))
   #+END_SRC

   Initialise shortcut functions for the following paths.

   #+NAME: paths
   | Name | Path |
   |------+------|
   | etc  | etc  |
   | bin  | bin  |
   | var  | var  |
   | org  | org  |
   | lisp | lisp |

   #+BEGIN_SRC emacs-lisp :var paths=paths
     (cl-loop
      for (name path) in paths
      collect (eval
               `(dotemacs-initialise-path! ,(intern name) ,path)))
   #+END_SRC

   Now let's set the default paths for a bunch of emacs builtins, see [[https://github.com/emacscollective/no-littering/blob/master/no-littering.el][no-littering.el]].

   #+BEGIN_SRC emacs-lisp
     (with-no-warnings
       (setq
        ;;; Package Directories
        package-user-dir                                   (lisp! "elpa")
        external-packages-directory                        (lisp! "pkgs")

        abbrev-file-name                                   (etc! "abbrev.el")
        auto-insert-directory                              (etc! "auto-insert")
        auto-save-list-file-prefix                         (var! "auto-save" "sessions/")
        bookmark-default-file                              (etc! "bookmarks.el")
        custom-file                                        (etc! "custom.el")
        custom-theme-directory                             (etc! "themes")
        desktop-path                                       `(,(var! "desktop/"))
        diary-file                                         (var! "diary")
        eshell-directory-name                              (var! "eshell")
        eshell-aliases-file                                (var! "eshell" "aliases")
        eshell-login-script                                (etc! "eshell" "loginrc")
        eshell-rc-script                                   (etc! "eshell" "eshrc")
        eww-bookmarks-directory                            (var! "eww/")
        gamegrid-user-score-file-directory                 (var! "gamegrid/")
        ido-save-directory-list-file                       (var! "ido-save-directory-list.el")
        image-dired-db-file                                (var! "image-dired" "db.el") ; tag associations
        image-dired-dir                                    (var! "image-dired/")
        image-dired-gallery-dir                            (var! "image-dired" "gallery/")
        image-dired-temp-image-file                        (var! "image-dired" "temp-image")
        image-dired-temp-rotate-image-file                 (var! "image-dired" "temp-rotate-image")
        kkc-init-file-name                                 (var! "kkc-init.el")
        message-auto-save-directory                        (var! "messages/")
        meghanada-server-install-dir                       (var! "meghanada")
        +dashboard-banners-directory                       (etc! "banners/")
        newsticker-cache-filename                          (var! "newsticker/cache.el")
        newsticker-dir                                     (var! "newsticker/data/")
        nsm-settings-file                                  (var! "nsm-settings.el")
        omnisharp-cache-directory                          (var! "omnisharp/cache")
        org-directory                                      (org! "")
        org-clock-persist-file                             (var! "org/clock-persist.el")
        org-id-locations-file                              (var! "org/id-locations.el")
        org-publish-timestamp-directory                    (var! "org/timestamps/")
        org-registry-file                                  (var! "org/registry.el")
        org-default-notes-file                             (org! "notes.org")
        projectile-org-projects-directory+                 (org! "notes/projects/")
        org-projectile-projects-directory                  projectile-org-projects-directory+
        org-projectile-projects-file                       (org! "notes/projects/global.org")
        org-preview-latex-image-directory                  (var! "org/latex")
        package-quickstart-file                            (var! "package-qs.el")
        recentf-save-file                                  (var! "recentf.el")
        savehist-file                                      (var! "savehist.el")
        server-auth-dir                                    (var! "server/")
        ;; server-socket-dir                                  server-auth-dir
        shared-game-score-directory                        (var! "gamescore/")
        tramp-auto-save-directory                          (var! "tramp/auto-save/")
        tramp-persistency-file-name                        (etc! "private/tramp/history.el")
        url-cache-directory                                (var! "url/cache/")
        url-configuration-directory                        (var! "url/configuration/")

        ;;; third party
        request-storage-directory                          (var! "requests")
        ))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (defvar +org-pdf-directory nil
       "default directory for `org-pdftools-complete-link', see [[*org-pdftools][org-pdftools]].")
   #+END_SRC

   Update load path so emacs can quickly lookup require targets.

   #+BEGIN_SRC emacs-lisp
     (add-to-list 'load-path dotemacs-lisp-path)
     (add-to-list 'load-path (lisp! "core"))
     (add-to-list 'load-path external-packages-directory)
   #+END_SRC

** utils

   Define some macros and helpers to assist with later configurations.

   Check emacs versions:
   #+BEGIN_SRC emacs-lisp
     (defmacro emacs= (version)
       `(version= emacs-version ,version))

     (defmacro emacs< (version)
       `(version< emacs-version ,version))

     (defmacro emacs<= (version)
       `(version<= emacs-version ,version))

     (defmacro emacs>= (version)
       `(not (emacs< ,version)))

     (defmacro emacs> (version)
       `(not (emacs<= ,version)))
   #+END_SRC

   Check operating-system/host-environment.
   #+BEGIN_SRC emacs-lisp
     (defun windows-p ()
       (member system-type '(cygwin ms-dos windows-nt)))

     (defun macos-p ()
       (eq system-type 'darwin))

     (defun unix-p ()
       (member system-type '(gnu gnu/linux gnu/kfreebsd)))
   #+END_SRC

  [[https://github.com/hlissner/doom-emacs/blob/develop/core/core-lib.el#L458][doom just keeps providing]], a transient-hook is a hook that's run only once and then
  promptly erases itself. can be bound to either a function or a hook variable.

  #+BEGIN_SRC emacs-lisp
    (defvar +transient-hook-counter 0
      "used to generate a unique function-name for a transient hook.")

    (defmacro add-transient-hook! (hook-or-function &rest forms)
      "Attaches a self-removing function to HOOK-OR-FUNCTION.
    FORMS are evaluated once, when that function/hook is first invoked, then never
    again.
    HOOK-OR-FUNCTION can be a quoted hook or a sharp-quoted function (which will be
    advised)."
      (declare (indent 1))
      (let ((append (if (eq (car forms) :after) (pop forms)))
            ;; Avoid `make-symbol' and `gensym' here because an interned symbol is
            ;; easier to debug in backtraces (and is visible to `describe-function')
            (fn (intern (format "emacs--transient-hook-%d-h"
                                (cl-incf +transient-hook-counter)))))
        `(let ((sym ,hook-or-function))
           (defun ,fn (&rest _)
             ,(format "Transient hook for %S" hook-or-function)
             ,@forms
             (let ((sym ,hook-or-function))
               (cond ((functionp sym) (advice-remove sym #',fn))
                     ((symbolp sym)   (remove-hook sym #',fn))))
             (unintern ',fn nil))
           (cond ((functionp sym)
                  (advice-add ,hook-or-function ,(if append :after :before) #',fn))
                 ((symbolp sym)
                  (put ',fn 'permanent-local-hook t)
                  (add-hook sym #',fn ,append))))))
  #+END_SRC

  This should be in core but I need it pretty early on so I've moved it here.

  #+BEGIN_SRC emacs-lisp
    (defmacro plist-pop! (list prop &optional default)
      "delete PROP from plist LIST, returning value of PROP.
        if PROP isn't in LIST, DEFAULT will be returned."
      `(prog1
           (or (plist-get ,list ,prop) ,default)
         (cl-remf ,list ,prop)))
  #+END_SRC

** packages
   Let's setup the packages needed to bootstrap my dotfiles, we're gonna need:

   #+NAME: setup-packages-list
   - use-package
   - general
   - delight
   - diminish
   - dash
   - s
   - f

   ~package.el~, [[https://github.com/hlissner/doom-emacs/blob/develop/docs/faq.org#how-does-doom-start-up-so-quickly][not on my watch, criminal scum!]].

   #+BEGIN_SRC emacs-lisp
     (setq package-enable-at-startup  nil
           package--init-file-ensured nil
           package-quickstart         nil)
   #+END_SRC

   Some packages are out of date and thus their PGP signatures don't work.
   I could go over them manually, but for the sake of my sanity, let's just
   disable signature checks. WARN this isn't safe, proceed at your own risk.

   #+BEGIN_SRC emacs-lisp
     (setq package-check-signature nil)
   #+END_SRC

   Specify the package archives to be used by ~package.el~.

   #+NAME: package-archives
   | name  | url                           |
   |-------+-------------------------------|
   | melpa | https://melpa.org/packages/   |
   | gnu   | http://elpa.gnu.org/packages/ |

   #+BEGIN_SRC emacs-lisp :var archives=package-archives :results value :tangle no
     (setq package-archives
           (cl-loop for (name source) in archives
                    collect (cons name source)))
   #+END_SRC

   Configure package-managers and configuration declarations.

   #+BEGIN_SRC emacs-lisp
     (setq straight-use-package-by-default nil
           use-package-always-ensure       nil
           straight-allow-recipe-inheritance t
           straight-process-buffer " *straight*")
   #+END_SRC

   For my config I'll be using [[https://github.com/raxod502/straight.el][straight]], the modern package manager for emacs.

   #+BEGIN_SRC emacs-lisp
     (with-no-warnings
       (defvaralias 'straight-base-dir 'dotemacs-lisp-path))

     (let ((bootstrap-file (lisp! "straight/repos/straight.el/bootstrap.el"))
           (straight-install-dir straight-base-dir)
           (bootstrap-version 5))
       (unless (file-exists-p bootstrap-file)
         (message "Installing the straight package manager")
         (with-current-buffer
             (url-retrieve-synchronously
              "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
              'silent 'inhibit-cookies)
           (goto-char (point-max))
           (eval-print-last-sexp)))
       (load bootstrap-file nil 'nomessage))
   #+END_SRC

   Finally, install base packages +took you long enough :tongue:.

   #+BEGIN_SRC emacs-lisp :var to-install=setup-packages-list
     (dolist (package to-install)
       (setq package (intern (car package)))

       (straight-use-package package)
       (require package))
   #+END_SRC

*** extensions
    Where I define extensions to use-package.

    The =:only= extension is like the builtin =:if= extension except it skips installation
    when the condition passed to it fails as well.

    #+BEGIN_SRC emacs-lisp
      ;; WARN: keep this at the start of `use-package-keywords' lest chaos
      ;; befall you.
      (push :only use-package-keywords)

      (defun use-package-normalize/:only (_ keyword args)
        (use-package-only-one (symbol-name keyword) args
          (lambda (_ arg) arg)))

      (defun use-package-handler/:only (name-symbol _ condition rest state)
        (let ((body (use-package-process-keywords name-symbol rest state)))
          `((when ,condition ,@body))))

      (enable-theme 'use-package)                                           ; see [[https://github.com/jwiegley/use-package/pull/881][here]].
    #+END_SRC

** editor
   Make emacs a saner, friendlier development environment.

*** aliases
    #+BEGIN_SRC emacs-lisp
      (defalias 'yes-or-no-p 'y-or-n-p)
      (defalias 'regexp-string-match #'string-match)

      (defalias 'path-basename                   #'file-name-nondirectory)
      (defalias 'path-dirname                    #'file-name-directory)
      (defalias 'path-extension                  #'file-name-extension)
      (defalias 'path-without-extension          #'file-name-sans-extension)
      (defalias 'path-basename-without-extension #'file-name-base)

      (defalias 'gnu-debugger     #'gdb)
      (defalias 'gud-gnu-debugger #'gud-gdb)
      (defalias 'perl-debugger    #'perldb)
      (defalias 'java-debugger    #'jdb)
      (defalias 'write-autosave 'do-auto-save)
    #+END_SRC

*** variables
     #+BEGIN_SRC emacs-lisp
       (setq delete-old-versions t                                                  ; delete excess backup versions silently
             version-control t                                                      ; use version control
             vc-make-backup-files t                                                 ; make backups in vc as well
             vc-follow-symlinks t                                                   ; no confirmation when opening symlinks
             ring-bell-function 'ignore                                             ; NO ANNOYING RINGS!!!
             sentence-end-double-space nil                                          ; sentence SHOULD end with only a fullstop
             delete-by-moving-to-trash t                                            ; don't rm, trash my garbage please :)
             search-whitespace-regexp nil                                           ; SPC means SPC, not any amount of spaces
             enable-local-variables t                                               ; allow safe variables, even alongside unsafe ones
             hl-line-sticky-flag nil                                                ; only highlight line in active window
             auto-save-interval 50                                                  ; auto-save as frequently as possible
             backup-by-copying t                                                    ; don't clobber symlinks
             which-key-enable-extended-define-key t                                 ; let's you pass a cons to define-key
             kill-whole-line t                                                      ; kill-line includes eol
             help-window-select t                                                   ; always select the help window when it pops up
             enable-recursive-minibuffers t                                         ; allow entering minibuffer, when already in minibuffer
             find-file-suppress-same-file-warnings t                                ; don't warn when finding a file that's already open.
             recentf-max-saved-items 2048                                           ; keep this many files in the recentf history.
             completion-ignore-case t                                               ; make completion case insensitive, holding down shift is annoying.
             completions-detailed t                                                 ; show annotations for certain completion candidates
             recenter-positions '(top middle bottom))
     #+END_SRC

     Set the default fill column for ~auto-fill-mode~.

     #+BEGIN_SRC emacs-lisp
       (setq-default
        ;; default-fill-column 150                                                ; toggle wrapping text at given character
        fill-column 85                                                         ; the default line length allowed by auto-fill-mode
        )
     #+END_SRC

    Backup behaviour of emacs. NOTE ~kept-new-versions~ and ~kept-old-versions~ are
    both used to determine the allowed number of backups. emacs will keep at most
    ~kept-new-versions~ + ~kept-old-versions~ backups.

    #+BEGIN_SRC emacs-lisp
      (setq
       kept-new-versions 15                                                   ; keep this many latest versions of file
       kept-old-versions 5                                                    ; keep this many early versions of file
       )
    #+END_SRC

    The default major mode; use for eg. in newly made files with an unknown extension.

    #+BEGIN_SRC emacs-lisp
      (setq-default major-mode 'text-mode)
    #+END_SRC

    Default encodings for files, this changes depending on platform so lets force it
    to go the unix route.

    #+BEGIN_SRC emacs-lisp
      (setq-default
       default-buffer-file-coding-system 'utf-8-unix
       buffer-file-coding-system 'utf-8-unix)
    #+END_SRC

    #+BEGIN_SRC emacs-lisp
      (setq-default indent-tabs-mode nil                                           ; use spaces, not tabs
                    show-trailing-whitespace nil
                    truncate-lines t                                               ; don't split long lines onto next lines
                    scroll-conservatively 101                                      ; smooth... enough scrolling going line by line
                    scroll-preserve-screen-position t
                    cursor-in-non-selected-windows nil                             ; don't show the cursor in inactive windows
                    echo-keystrokes 0.02                                           ; print inputted prefix keys after a pause.
                    )
    #+END_SRC

    Set the string shown on the title bar of emacs frames.

    #+BEGIN_SRC emacs-lisp
      (setq frame-title-format
            ;; sets the title string displayed on the frame above. Format of the command is
            ;; a printf like string. Wrap any code you want evaluated conditionally into a list
            ;; and if the first value of that list is a string, it will be evaluated. You can
            ;; include variables anywhere in the string, including sublists, but no functions.
            ;;
            ;; See the format guide here: https://www.emacswiki.org/emacs/FrameTitle
            `(;;,(user-login-name)
              "emacs@"
              ,(system-name)
              " [%*] %m"
              (:eval (when (derived-mode-p 'pdf-view-mode)
                       (format "(%d/%d)"
                               (pdf-view-current-page)
                               (pdf-cache-number-of-pages))))
              (buffer-file-name " : %f")))
    #+END_SRC

    Auto saves and backup files, both important parts of emacs

    #+BEGIN_SRC emacs-lisp
      (setq
       ;; where do autosave files get stored
       auto-save-file-name-transforms `((".*" ,(var! "auto-save" "sessions/") t))

       ;; where do backup files get stored
       backup-directory-alist `(("." . ,(var! "backups/")))

       ;; don't show files matching these regexps in recentf alist.
       recentf-exclude (list (rx (or "/tmp/"
                                     "/ssh:"
                                     "/sudo:"
                                     "COMMIT_EDITMSG"
                                     (and (or "/TAGS"
                                              "/GTAGS"
                                              "/GRAGS"
                                              "/GPATH"
                                              ".mkv"
                                              ".avi"
                                              (and ".mp" (any "3" "4"))
                                              (and ".doc" (? "x"))
                                              ".sub"
                                              ".srt"
                                              ".ass"
                                              ".elc"
                                              (and "tmp." (+ (not (any "/" "\\")))))
                                          eol)))))
   #+END_SRC

    load any variables in my ~custom.el~ file

    #+BEGIN_SRC emacs-lisp
      (and (file-exists-p custom-file) (load custom-file t t))
    #+END_SRC

*** user-interface
    Disable GUI enhancements, some of these are taken care of in [[*early-init][early-init]].

    Let's stop the cursor blinking annoyingly.

    #+BEGIN_SRC emacs-lisp
      (blink-cursor-mode -1)
    #+END_SRC

    Let's also prevent the pointless startup message.

    #+BEGIN_SRC emacs-lisp
      (advice-add 'display-startup-echo-area-message :override #'ignore)
    #+END_SRC

    Let's make sure the appropriate window is selected at startup

    #+BEGIN_SRC emacs-lisp
      (add-hook 'emacs-startup-hook
                (lambda (&rest _)
                  ;; switch focus to any error or compilation windows
                  (let* ((window-list  (window-list))
                         (window-count (length window-list))
                         (focus-list   '("*Warnings*"
                                         "*Compile-Log*"))
                         (kill-list    '()))
                    (when (> window-count 1)
                      (dolist (window (window-list))
                        (let ((buffer-name
                               (buffer-name (window-buffer window))))
                          (cond
                           ((member buffer-name focus-list)
                            (select-window window))
                           ((member buffer-name kill-list)
                            (delete-window window)))))))))
    #+END_SRC

    Make emacs less verbose in some places.

    #+BEGIN_SRC emacs-lisp
      (setq command-error-function
            (defun command-error-function! (data context caller)
              "hide some error message"
              (when (not (memq (car data) '(;; buffer-read-only
                                            beginning-of-buffer
                                            end-of-buffer)))
                (command-error-default-function data context caller))))
    #+END_SRC

*** term
    Classical terminals [[https://emacs.stackexchange.com/questions/32294/how-to-make-emacs-recognise-c-shift-combinations-in-terminal-mode?rq=1][don't support]] extended, GUI like keybindings. It's a shame,
    but modern terminals are starting to work around it, for eg. *XTerm*.

    [[https://wiki.archlinux.org/index.php/Tmux][TMUX]] (the terminal multiplexer) supports XTerm bindings, but emacs doesn't accept
    them. Let's change that, curtesy of the [[https://wiki.archlinux.org/index.php/Emacs#Shift_.2B_Arrow_keys_not_working_in_emacs_within_tmux][arch wiki]].

    #+BEGIN_SRC emacs-lisp
      (advice-add 'terminal-init-screen :before
                  (defun tmux (&rest _)
                    "Apply xterm keymap, allowing use of keys passed through tmux."
                    (when (getenv "TMUX")
                      (let ((map (copy-keymap xterm-function-map)))
                        (set-keymap-parent map (keymap-parent input-decode-map))
                        (set-keymap-parent input-decode-map map)))))
    #+END_SRC

    Emacs also comes with an ~xterm-mouse-mode~, which lets you use the mouse to
    select things in the terminal, like you would in GUI emacs. By default you have
    to enable it manually, let's enable it when an xterm like terminal is initialized.

    #+BEGIN_SRC emacs-lisp
      (defun enable-xterm-mouse-mode+ ()
        (xterm-mouse-mode +1))

      (advice-add 'terminal-init-xterm :after #'enable-xterm-mouse-mode+)
      (advice-add 'terminal-init-tmux  :after #'enable-xterm-mouse-mode+)
    #+END_SRC

    Because of XTerms extended keycodes, you can reclaim some of the keycodes which've
    been taken by emacs. I've defined a function which adds some more keycodes to the
    XTerm keymap and reclaims some bindings that conventional terminals have repurposed.

    Here's an overview of where we stand.

    | reclaimed | key       | num | name | terminal-key | notes                       |
    |-----------+-----------+-----+------+--------------+-----------------------------|
    | [ ]       | backspace | 127 | DEL  | Ctrl+?       | Maybe translated to Ctrl+h  |
    | [X]       | tab       |   9 | TAB  | Ctrl+I       |                             |
    | [ ]       | linefeed  |  10 | LFD  | Ctrl+j       | Few keyboards have this key |
    | [X]       | return    |  13 | RET  | Ctrl+m       |                             |
    | [X]       | escape    |  27 | ESC  | Ctrl+[       |                             |

    NOTE: in GUI, the behaviour shouldn't have changed. The following keys haven't
    been reclaimed, but the GUI variants override the term versions anyways, so you
    shouldn't really notice.

    #+BEGIN_SRC emacs-lisp
      (defun term-setup-frame-bindings+ (&optional frame)
        (with-selected-frame (or frame (selected-frame))
          ;; for some reason, C-/ is remapped to C-_, but (kbd "C-/") isn't C-_,
          ;; it's this bizarre vector here.
          (define-key input-decode-map "" [67108911])

          ;; reclaim key combinations from terminal. See initial source [[https://emacs.stackexchange.com/questions/220/how-to-bind-c-i-as-different-from-tab][here]].
          ;; WARN for this to work, you can't use (kbd key) because that automatically
          ;; gets translated to the original keys. You'll have to use [key] directly.
          ;; You'll also need to declare some input combination to be (effectively) key
          ;; for your terminal, see the xterm eg below.
          (define-key input-decode-map [?\C-i] [C-i]) ;; was TAB
          (if (display-graphic-p)
              ;; GUI specific remappings
              (progn
                (define-key input-decode-map "	"  [C-i])
                (define-key input-decode-map [?\C-m] [C-m]))
            ;; terminal remappings
            (define-key input-decode-map "	"    nil))

          ;; evaluate the following to translate reclaimed bindings back for
          ;; terminals which don't specify any special key combinations for the
          ;; reclaimed keys :cry:.
          ;; (define-key function-key-map [C-i]  "	")
          ;; (define-key function-key-map [C-m]  "")
          (define-key function-key-map [C-\[] "")                             ; I don't mind this being taken

          ;; some extra bindings I've got in st, see term/xterm.el
          (when (featurep 'xterm)
            (define-key xterm-function-map "\e[127;2u" [S-backspace])
            (define-key xterm-function-map "\e[127;5u" [C-backspace])
            (define-key xterm-function-map "\e[127;6u" [C-S-backspace])
            (define-key xterm-function-map "\e[13;2u"  [S-return])
            (define-key xterm-function-map "\e[13;8u"  [C-M-S-return])
            (define-key xterm-function-map "\eOB"      [down])
            (define-key xterm-function-map "\eOA"      [up])
            (define-key xterm-function-map "\eOD"      [left])
            (define-key xterm-function-map "\eOC"      [right])
            (define-key xterm-function-map "\e[1;2B"   [S-down])
            (define-key xterm-function-map "\e[1;2A"   [S-up])
            (define-key xterm-function-map "\e[1;2D"   [S-left])
            (define-key xterm-function-map "\e[1;2C"   [S-right])
            (define-key xterm-function-map "\e[1;5Z"   [C-S-tab])
            (define-key xterm-function-map "\e[49;5u"  (kbd "C-1"))
            (define-key xterm-function-map "\e[50;5u"  (kbd "C-2"))
            (define-key xterm-function-map "\e[51;5u"  (kbd "C-3"))
            (define-key xterm-function-map "\e[52;5u"  (kbd "C-4"))
            (define-key xterm-function-map "\e[53;5u"  (kbd "C-5"))
            (define-key xterm-function-map "\e[54;5u"  (kbd "C-6"))
            (define-key xterm-function-map "\e[55;5u"  (kbd "C-7"))
            (define-key xterm-function-map "\e[56;5u"  (kbd "C-8"))
            (define-key xterm-function-map "\e[57;5u"  (kbd "C-9"))
            (define-key xterm-function-map "\e[48;5u"  (kbd "C-0"))
            (define-key xterm-function-map "\e[32;2u"  (kbd "S-SPC"))
            (define-key xterm-function-map "\e[58;4u"  (kbd "M-:"))
            (define-key xterm-function-map "\e[58;6u"  (kbd "C-:"))
            (define-key xterm-function-map "\e[124;6u" (kbd "C-|"))
            (define-key xterm-function-map "\e[124;8u" (kbd "C-M-|"))
            (define-key xterm-function-map "\e[94;6u" (kbd "C-^"))
            (define-key xterm-function-map "\e[60;4u"  (kbd "M-<"))
            (define-key xterm-function-map "\e[62;4u"  (kbd "M->"))
            (define-key xterm-function-map "\e[62;6u"  (kbd "C->"))
            (define-key xterm-function-map "\e[60;6u"  (kbd "C-<"))
            (define-key xterm-function-map "\e[105;7u" (kbd "C-M-i"))
            (define-key xterm-function-map "\e[27;3u"  (kbd "M-ESC"))
            (define-key xterm-function-map "\e[27;5u"  (kbd "C-ESC"))

            ;; define xterm codes for ctrl+shift alphabet keys
            (cl-loop for (i . char) in (-zip (number-sequence 65 90)
                                             (append (number-sequence 97 105)
                                                     '(107 106)                               ; for some reason, J & K are switched
                                                     (number-sequence 108 122)))
                     do (define-key xterm-function-map
                          (concat "\e[" (number-to-string i) ";6u")
                          (kbd (concat "C-S-" (string char))))))

          ;; NOTE: reclaimed key combinations, see source [[https://emacs.stackexchange.com/questions/220/how-to-bind-c-i-as-different-from-tab/20290#20290][here]].
          (define-key input-decode-map "\e[105;5u" [C-i])
          (define-key input-decode-map "\e[109;5u" [C-m])
          (define-key input-decode-map "\e[91;5u"  [C-\[])))

      (add-hook 'after-make-frame-functions #'term-setup-frame-bindings+)
    #+END_SRC

    If however you're running emacs from outside of the daemon (eg. ~emacs -nw -c~),
    ~after-make-frame-functions~ won't be invoked on your current frame, you'll have
    to invoke it manually; or preferably invoke it right now.

    #+BEGIN_SRC emacs-lisp
      (unless (daemonp)
        (add-hook 'emacs-startup-hook
                  (lambda (&rest _) (term-setup-frame-bindings+))))
    #+END_SRC

    Try to enable clipboard support, these settings should do something... but to
    they don't seem to work for me :cry:.

    #+BEGIN_SRC emacs-lisp :tangle no
      (setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING)
            x-select-enable-clipboard t
            x-select-enable-primary   t
            x-stretch-cursor          t)
    #+END_SRC

    As a last resort, let's defer to an excellent external package which takes care
    of this for you automatically... assuming you have the right tools on your device.

    #+BEGIN_SRC emacs-lisp
      (use-package xclip
        :straight t
        :init
        (xclip-mode +1))
    #+END_SRC

*** enabled
    Re-enable some emacs features that emacs disables by default because they're
    thought to be confusing.

    #+BEGIN_SRC emacs-lisp
    (put 'narrow-to-region 'disabled nil)
    #+END_SRC

*** leader
    Some variables related to prefixes in which leader keys should be placed.

    #+BEGIN_SRC emacs-lisp
      (defvar leader-minor-mode-leader-prefix "q"
        "leader key for minor mode bindings.
      this leader prefix is expected to be muddled and unreliable...
      due to tonnes of different minor modes collabratively binding to it.

      That said... I need a place to put minor-mode keys and this was
      unoccupied.")

      (defvar leader-server-leader-prefix "l"
        "put leader keys related to active servers under this prefix.")

      (defvar leader-diff-leader-prefix "d"
        "leader prefix under which diff bindings are assigned.")
    #+END_SRC

    Setup [[https://github.com/mohkale/spaceleader][spaceleader]], my own leader-key package designed to work like [[https://www.spacemacs.org/][spacemacs]].

    #+BEGIN_SRC emacs-lisp
      (use-package bind-map
        :straight t)

      (use-package spaceleader
        :straight (spaceleader :host github :repo "mohkale/spaceleader")
        :demand t
        :config
        (require 'spaceleader-base) ;; Allow base leader bindings.
        (leader/set-keys leader-server-leader-prefix "lang-server")

        :general
        ("C-@" (general-simulate-key "C-SPC")) ;; C-SPC in terminal
        ;; Make my none-normal leader key active even in normal states.
        (:states leader-norm-states
         "C-SPC" (eval `(general-simulate-key ,leader-key)))
        ;; Setup C-, to trigger my major-mode leader-keys in both insert and normal states.
        (:keymaps 'override
         :states leader-norm-states
         "C-," (eval `(general-simulate-key ,(concat leader-key " " leader-major-mode-prefix))))
        (:keymaps 'override
         :states leader-nnorm-states
         "C-," (eval `(general-simulate-key ,(concat leader-nnorm-key " " leader-major-mode-prefix)))))
    #+END_SRC

    Let's add a ~use-package~ keyword for setting up leader-keys.

    #+BEGIN_SRC emacs-lisp
      ;; Where these are placed determines whether they're deferred or not.
      (let ((tail (nthcdr (cl-position :init use-package-keywords) use-package-keywords)))
        (setcdr tail (cons :leader (cdr tail))))
      (let ((tail (nthcdr (cl-position :config use-package-keywords) use-package-keywords)))
        (setcdr tail (cons :lazy-leader (cdr tail))))

      (defun use-package-normalize/:leader (_name keyword args)
        args)

      (defun use-package-leader-format-args+ (args)
        ;; Properties
        ;;  :defer - when true, leader are only assigned after package load
        ;;  :modes/:mode - when true leaders are only bound in given major modes
        ;;  :minor - when true :modes applies to minor-modes, not majors
        ;;  :prefix - call leader/with-prefix with argument before rendering
        (cl-loop
         with modes = nil
         with minor = nil
         with prefix = nil
         with leader-func = nil
         with res = nil
         for arg in args
         do (let ((major (not (plist-pop! arg :minor))))
              (setq modes (or (plist-pop! arg :modes)
                              (plist-pop! arg :mode))
                    prefix (plist-pop! arg :prefix)
                    res (if modes
                            (list (if major 'leader/set-keys-for-major-mode 'leader/set-keys-for-mode)
                                  modes)
                            ""
                          '(leader/set-keys))
                    leader-func '(leader/set-keys-for-mode)))
         when (not arg)
         do (display-warning 'use-package ":leader got no bindings")
         else
         do (setq res `(,@res ,@arg))
         end
         when prefix
         do (setq res `(leader/with-prefix ,prefix ,res))
         end
         collect res))

      (defun use-package-handler/:leader (name _keyword args rest state &optional defer)
        (let ((body (use-package-process-keywords name rest state)))
          (if (not args)
              body
            (use-package-concat
             (funcall use-package--hush-function _keyword
                      (list (cons 'progn (use-package-leader-format-args+ args))))
             body))))

      (defalias 'use-package-normalize/:lazy-leader #'use-package-normalize/:leader)
      (defalias 'use-package-handler/:lazy-leader #'use-package-handler/:leader)
    #+END_SRC

    #+BEGIN_SRC emacs-lisp
      (leader/set-keys
        "TAB" "last-buffer"
        "TAB" 'switch-to-last-buffer

        "fj" '("jump-to-directory" . dired-jump)
        "jd" '("jump-to-directory" . dired-jump)
        "jD" '("jump-to-directory-other-window" . dired-jump-other-window)

        "ic" 'insert-char

        "a"  "applications"
        "a:" 'eshell
        "a*" 'calc-dispatch
        "ac" 'calendar
        "af" 'describe-face
        "aX" 'customize
        "al" 'find-library
        "at" 'load-theme
        "am" +man-command
        "ae" 'list-processes

        "ap" "packages"
        "api" 'straight-use-package
        "apu" 'straight-pull-all
        "apf" 'straight-fetch-all
        "apx" 'straight-prune-build
        "apr" 'straight-rebuild-all
        "apz" 'straight-freeze-versions
        "apt" 'straight-thaw-versions

        "ff" 'find-file
        "bb" 'switch-to-buffer
        "be" 'safe-erase-buffer
        "bK" 'kill-this-buffer
        "bk" 'kill-this-buffer-and-window-maybe
        "bM" 'switch-to-messages-buffer
        "by" 'yank-whole-buffer-as-kill
        "ss" 'isearch-forward

        "hdf" 'describe-function
        "hdv" 'describe-variable

        "f DEL" 'save-buffers-kill-emacs

        "cb" 'display-compilation-buffer
        "cy" 'yank-and-comment
        "cc" 'compile

        "i"  "insert"
        "ij" 'custom-insert-line-below
        "ik" 'custom-insert-line-above

        "j" "jump"

        "Md" "dired"
        "MF" 'flyspell-prog-mode
        ;; TODO bind in dired
        "Mdd" 'toggle-editable-dired
        "Mde" 'invoke-editable-dired
        "Md ESC" 'wdired-abort-changes
        "Mdq" 'wdired-abort-changes

        "xf" 'list-faces
        "xt" 'remove-all-trailing-whitespace

        "t TAB" 'set-indent-offset
        "th" 'toggle-buffer-header
        "tL" 'toggle-lexical-binding
        "tr" 'toggle-relative-linum)

      (defvar emacs-window-map (make-sparse-keymap)
        "my keymap to interact with emacs windows.")

      (leader/set-keys
        "w" "windows"
        "w" emacs-window-map)
    #+END_SRC

*** bindings
    where I put global bindings.

    WARN never bind ESC, it BREAKS *EVERYTHING!*.

    Firstly, specify some defaults for the bindings I reclaimed from the terminal,
    this should just be the same keys they would have if they were not reclaimed.

    #+BEGIN_SRC emacs-lisp
      (general-define-key
       [C-i] 'indent-for-tab-command
       [C-m] 'newline-and-indent)

      (general-define-key
       :states 'motion
       ;; evil doesn't seem to have a default for tab.
       ;; [C-i] 'indent-for-tab-command
       [C-m] 'evil-ret)
    #+END_SRC

    Let's also make some terminal exclusive bindings have the same affect in GUI emacs.

    #+BEGIN_SRC emacs-lisp
      (general-define-key
       "C-S-v" 'yank)
    #+END_SRC

    Now let's unbind some undesired emacs global keys

    #+BEGIN_SRC emacs-lisp
      (general-unbind
        "M-h"                                ; was backward-kill-sentence
        "C-M-\\"                             ; was indent-region
        "M-b"                                ; was backward-word
        "M-f"                                ; was forward-word
        "C-k"
        )
    #+END_SRC

    Now for global keys.

    Shell command bindings.

    #+BEGIN_SRC emacs-lisp
      (general-define-key
       ;; Control     for comamnd,
       ;; Meta        for command on region
       ;; Control-Alt for command on buffer
       "C-|"   'shell-command
       "M-|"   'shell-command-on-region
       "C-M-|" 'shell-command-on-buffer
       "C-&"   'async-shell-command
       "M-&"   'async-shell-command-on-region
       "C-M-&" 'async-shell-command-on-buffer)
    #+END_SRC

    Shell compatibility with vim

    #+BEGIN_SRC emacs-lisp
      (general-define-key
       "C-z" 'suspend-frame)
    #+END_SRC

    #+BEGIN_SRC emacs-lisp
      (general-define-key
       ;; char variants, can be found on C-h & C-l
       "C-b" 'backward-word
       "C-f" 'forward-word

       ;; rebound to default-indent-new-line in emacs>=27 and that's
       ;; bugged out in org mode.
       "C-M-j" 'indent-new-comment-line

       "M-l"             'recenter-top-bottom ;; was kill-sentence
       "M-L"             'downcase-word
       "M-H"             'upcase-word
       "C-M-a"           'mark-whole-buffer
       "C-/"             'toggle-comment-at-point
       "C-S-/"           'toggle-comment-at-point-alt
       "C-M--"           'indent-region
       "C-M-h"           'left-word
       "C-M-l"           'right-word
       "C-s"             'isearch-forward
       "M-j"             'custom-insert-line-below
       "M-k"             'custom-insert-line-above
       "M-r"             'revert-buffer
       ;; "C-q"             'quit-window
       "C-v"             'quoted-insert
       "C-j"             'newline-and-indent
       "C-<tab>"         'next-buffer
       "C-S-<tab>"       'previous-buffer
       "C-<iso-lefttab>" 'previous-buffer
       "RET"             'newline-and-indent
       "<C-M-return>"    'comment-indent-new-line
       "<C-backspace>"   'evil-delete-backward-word
       "M-DEL"           'delete-forward-char
       "<C-S-backspace>" 'kill-word)
    #+END_SRC

    My window map, like ~C-w~ in vim.

    #+BEGIN_SRC emacs-lisp
      (general-define-key
       :states '(motion emacs)
       "C-w" emacs-window-map)

      (general-define-key
       :keymaps 'emacs-window-map
       "m"   'window-zen
       "RET" 'window-zen
       [C-m] 'window-zen
       "M"   'window-zen-restore
       "M-m" 'window-zen-restore)

      ;; tmux leader compatability
      (general-define-key
       :states 'insert
       "C-q" (general-simulate-key "C-w" :state 'normal))

      (general-define-key
       :states '(normal motion emacs)
       "C-q" (general-simulate-key "C-w"))
    #+END_SRC

    A command that inserts a character without moving point.
    TODO do I really need this?

    #+BEGIN_SRC emacs-lisp :tangle no
      (defmacro defun-save-excursion-insert-char (char-name char)
        (setq char (eval char))

        (let* ((char-name (symbol-name char-name))
               (func-name (intern (concat "save-excursion-insert-" char-name))))
          `(defun ,func-name (prefix)
             (interactive "P")
             (save-excursion
               (insert-char ,char (prefix-numeric-value prefix))))))

      (general-define-key
       :states leader-nnorm-states
       "S-M-SPC" (defun-save-excursion-insert-char space ? ))
    #+END_SRC

*** syntax
    Adjust the syntax entries for the given modes so that functions like evil word
    skip over them.

    TODO switch to a macro.

    #+NAME: underscore-supported-modes
    - c++
    - c
    - markdown
    - lisp
    - shell
    - enh-ruby

    #+BEGIN_SRC emacs-lisp :var modes=underscore-supported-modes
      (defun adjust-syntax-entry! ()
        "includes underscores in the syntax entry"
        (modify-syntax-entry ?_ "w"))

      (dolist (mode modes)
        (let ((hook-name (concat (car mode) "-mode-hook")))
          (add-hook (intern hook-name) #'adjust-syntax-entry!)))
    #+END_SRC

*** hooks
    Run a hook on buffer change

    #+BEGIN_SRC emacs-lisp
      (defvar switch-to-buffer-hook nil
        "hook run when you switch to a buffer.")

      (advice-add 'switch-to-buffer
                  :after (defun switch-to-buffer--execute-hook (&rest args)
                           (apply 'run-hook-with-args 'switch-to-buffer-hook args)))
    #+END_SRC

    Run a hook when emacs changes themes.

    #+BEGIN_SRC emacs-lisp
      (defvar after-load-theme-hook nil
        "hook which is executed after loading a theme")

      (advice-add 'load-theme
                  :after (defun load-theme-execute-hooks (&rest _)
                           (run-hooks 'after-load-theme-hook)))
    #+END_SRC

*** search-recenter
    #+BEGIN_SRC emacs-lisp :tangle no
      (defun +search-recenter (&rest args)
        "Recenter the current window after a search operation.
      This is a smart recentering command. If you're at the end of a buffer and a
      recentering to the middle ends up showing more trailing (empty) lines then
      it recenters to avoid them. Similair logic is in place for the start of the
      buffer. Otherwise it recenters to the middle."
        (let ((current-line (line-number-at-pos (point)))
              (window-height-2 (/ (window-body-height) 2))
              (first-line (line-number-at-pos (point-min)))
              (last-line (line-number-at-pos (max 0 (- (point-max) 1)))))
          (cl-destructuring-bind (line . recenter-positions)
              (cond ((>= (+ current-line window-height-2) last-line)
                     (cons last-line '(bottom)))
                    ((<= (- current-line window-height-2) first-line)
                     (cons first-line '(top)))
                    (t (cons nil '(middle))))
            (save-excursion
              (when line
                (goto-line line))
              (recenter-top-bottom)))))

      ;; Advise all search commands to perform a recentering.
      (advice-add 'evil-ex-search-forward  :after #'+search-recenter)
      (advice-add 'evil-ex-search-next     :after #'+search-recenter)
      (advice-add 'evil-ex-search-previous :after #'+search-recenter)
    #+END_SRC

*** display-buffer
    Customise display-buffer-alist to prioritise switching focus to displayed
    buffers, instead of showing them and then making me have to switch to them
    and then exit.

    #+BEGIN_SRC emacs-lisp
      (add-hook 'emacs-startup-hook
                (lambda () (require '+display-buffer-focus)))
    #+END_SRC

    #+BEGIN_SRC emacs-lisp :tangle lisp/+display-buffer-focus.el
      ;; frankly, display buffers alist is badly documented.
      ;; there's a quick and simple article exploring how it
      ;; works [[https://www.simplify.ba/articles/2016/01/25/display-buffer-alist/][here]]
      ;;
      ;; in the meantime, the following is a breif~er~ summary
      ;;   1. the car of each entry should be a regex matching a buffer
      ;;      name or a function taking a buffer and an action argument.
      ;;   2. the second item (car (cdr list)) should be a list of or a
      ;;      single display handler function which takes a buffer and
      ;;      an alist as an argument. Each entry in the list is invoked
      ;;      until one which returns non nil is encountered.
      ;;   3. the remaining list items should be an alists providing options.

      ;; changing at startup messes up the display of the dashboard :(
      (defvar default-display-buffer-action
        display-buffer-fallback-action
        "the value for fallback actions without my configuration")

      (defun restore-default-display-buffer-actions (func &rest args)
        "restore the default display buffer actions used by emacs."
        (let ((display-buffer-fallback-action
               default-display-buffer-action))
          (apply func args)))

      (setq display-buffer-fallback-action
            ;; by default, focus on displayed windows
            '((display-buffer--maybe-same-window-and-focus
               display-buffer-reuse-window-and-focus
               display-buffer--maybe-pop-up-frame-or-window-and-focus
               display-buffer-in-previous-window-and-focus
               display-buffer-use-some-window-and-focus
               display-buffer-pop-up-frame-and-focus)))

      (push `(,(rx
                (or "*Async Shell Command*"
                    "*compilation*"
                    "*rustic-compilation*"
                    "*cargo-test*"))
              (display-buffer-reuse-window
               display-buffer--maybe-pop-up-frame-or-window-and-focus
               display-buffer-in-side-window-and-focus)
              (side          . bottom)
              (window-height . 0.5))
            display-buffer-alist)

      (push `(,(rx
                (or "*image-dired-display-image*"
                    "*Anaconda*"
                    "magit-diff: "
                    "*Flycheck error messages*"
                    "*HTTP Response*"
                    "*Compile-Log*"
                    (and "*eglot-help for " (+ any) "*")))
              ,@default-display-buffer-action)
            display-buffer-alist)

      (provide '+display-buffer-focus)
    #+END_SRC

*** uniarg
    #+BEGIN_SRC emacs-lisp
      (defvar +universal-argument-increment-by 4
        "Make increment functions increment universal-argument by this much")

      (defmacro defun-universal-argument-operation (name docstring &rest body)
        `(defun ,name ()
           ,(eval docstring)
           (interactive)
           (prefix-command-preserve-state)
           (if (not prefix-arg)
               (universal-argument)
             ,@body)

           (when prefix-arg
             (universal-argument--mode))))
      (put 'defun-universal-argument-operation 'lisp-indent-function 'defun)

      (defun-universal-argument-operation smart-universal-argument
        "combine both universal-argument and universal-argument-more
      into a single invokeable command. for some reason, calling simply
      more before a regular prefix has been specified, will result in no
      overall prefix being set :("
        (universal-argument-more prefix-arg))

      ;; I'm not sure why universal-argument-more multiplies
      ;; the prefix arg by a factor of 4. I mean, 4 to 16 is
      ;; fine, but 16 to 64 is pretty unlikely to be what you
      ;; wanted. Adding by 4 would be more useful, especially
      ;; if you're using it to gauge indents.
      (defun-universal-argument-operation universal-argument-batch-increment
        (format "increment the current prefix-arg by %d."
                +universal-argument-increment-by)
        (let* ((prefix-value (prefix-numeric-value prefix-arg)))
          (setq prefix-arg
                (+ prefix-value +universal-argument-increment-by))))

      (defun-universal-argument-operation universal-argument-batch-decrement
        (format "decrement the current prefix-arg by %d."
                +universal-argument-increment-by)
        (let* ((prefix-value (prefix-numeric-value prefix-arg)))
          (setq prefix-arg (- prefix-value +universal-argument-increment-by))))
    #+END_SRC

    #+BEGIN_SRC emacs-lisp
      (leader/set-keys
        "U" 'universal-argument
        "u" 'smart-universal-argument)

      (general-define-key
       :keymaps 'universal-argument-map
       "M-u" 'universal-argument-batch-increment
       "M-U" 'universal-argument-batch-decrement)
    #+END_SRC

*** multi-scratch
    An extension of the persistent scratch function which provides functions to create a new
    scratch buffer and interactively switch to one.

    WARN multiscratch doesn't save the first scratch buffer. That's a real scratch buffer,
    which's expected to get erased every time emacs is killed. All other scratch buffers
    are properly restored though.

    #+BEGIN_SRC emacs-lisp
      (defvar scratch-buffer-name "*scratch*"
        "Name of users scratch buffer")

      (cl-defun create-new-empty-buffer (&optional buffer-name)
        "Creates and returns a new empty scratch like buffer
      with prefix it prompts you for the name of the buffer.
      if called interactively, the new buffer is switched to."
        (interactive "P")
        (let* ((def-buf-name scratch-buffer-name)
               (buffer-name
                (cond
                 ((stringp buffer-name) buffer-name)
                 (buffer-name (read-buffer "buffer name: " def-buf-name))
                 (t def-buf-name)))
               (buffer-name (generate-new-buffer-name buffer-name))
               (buffer (get-buffer-create buffer-name)))
          (with-current-buffer buffer
            (funcall-interactively initial-major-mode))
          (when (called-interactively-p 'any)
            (switch-to-buffer buffer))
          buffer))

      (defun scratch-buffer-p (&optional buffer)
        (string-match
         (regexp-quote scratch-buffer-name)
         (buffer-name buffer) 0))
    #+END_SRC

    Setup persistent scratch support. allows scratch buffers to survive emacs sessions.

    #+BEGIN_SRC emacs-lisp
      (use-package persistent-scratch
        :straight t
        :defer  t
        :init
        (defun multiscratch-scratch-buffer-p (&optional buffer)
          "persist all but the main scratch buffer."
          (and (not (string= (buffer-name buffer) scratch-buffer-name))
               (scratch-buffer-p buffer)))

        (setq persistent-scratch-save-file (var! "scratch.el")
              persistent-scratch-autosave-interval 800
              persistent-scratch-scratch-buffer-p-function #'multiscratch-scratch-buffer-p)

        ;; force restoration on initial movement to a scratch buffer.
        (when (file-exists-p persistent-scratch-save-file)
          (persistent-scratch-restore))

        (add-hook 'kill-emacs-hook #'persistent-scratch-save))
    #+END_SRC

    #+BEGIN_SRC emacs-lisp
      (defun scratch-buffers ()
        (require 'persistent-scratch)                                                               ; Make sure scratches have been restored
        (sort
         (seq-filter #'scratch-buffer-p (buffer-list))
         (lambda (x y) (string< (buffer-name x) (buffer-name y)))))

      (defun switch-to-scratch-buffer (&optional prefix)
        "Switch to the scratch buffer
      with prefix, prompts for which buffer named like the scratch
      buffer to switch to. If none exists, a new scratch buffer will
      be made. If only one exists, it will be switched to and if more
      than one exists then prompts for it."
        (interactive "P")
        (if (not prefix)
            ;; switch to the original scratch buffer, making it if it
            ;; doesn't exit.
            (let ((buffer (get-buffer scratch-buffer-name)))
              (if buffer
                  (switch-to-buffer buffer)
                (call-interactively 'create-new-empty-buffer)))

          ;; Load persistent-scratch and interactively select a scratch
          ;; to go to.
          (let* ((buffer-list (scratch-buffers))
                 (buffer-names (mapcar #'buffer-name buffer-list))
                 (buffer
                  (cond
                   ((zerop (length buffer-list))
                    (create-new-empty-buffer))
                   ((eq 1 (length buffer-list))
                    (car buffer-list))
                   ((package! ivy)
                    (require 'counsel)
                    (setq buffer (ivy-read "Switch to buffer: " buffer-names
                                           :require-match t
                                           :keymap ivy-switch-buffer-map
                                           :matcher #'ivy--switch-buffer-matcher
                                           :caller 'switch-to-scratch-buffer
                                           :unwind #'counsel--switch-buffer-unwind
                                           :update-fn 'counsel--switch-buffer-update-fn)))
                   (t (completing-read "Switch to buffer: " buffer-names)))))
            (when (called-interactively-p 'any)
              (switch-to-buffer buffer))
            buffer)))
    #+END_SRC

    Bind keys to quickly switch to scratch buffers or create a new empty scratch buffer.

    #+BEGIN_SRC emacs-lisp
      (leader/set-keys
        "bs"    'switch-to-scratch-buffer
        "b RET" 'create-new-empty-buffer)
    #+END_SRC

*** birthday
    #+BEGIN_SRC emacs-lisp
      (when (string-equal (format-time-string "%d.%m" (current-time))
                          "08.12")
        (add-hook 'emacs-startup-hook 'animate-birthday-present))
    #+END_SRC

*** dotfiles
    :PROPERTIES:
    :header-args+: :tangle lisp/+dotfiles.el
    :END:

    This branch defines commands to interface with scripts from my [[https://github.com/mohkale/dotfiles][dotfiles]].

    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package +dotfiles
        :defer t
        :commands (+dot-goto-repo
                   +dot-goto-fsmap
                   +dot-goto-fsmap-dirs
                   +dot-goto-executable
                   +dot-open-bookmark)
        :leader
        ("fd" "dotfiles"
         "fdp" '+dot-goto-repo
         "fdf" '+dot-goto-fsmap
         "fdd" '+dot-goto-fsmap-dirs
         "fdx" '+dot-goto-executable
         "fdb" '+dot-open-bookmark))
    #+END_SRC

    #+BEGIN_SRC emacs-lisp
      (defvar +dot-goto-repo-command '("ls-repos"))

      (defvar +dot-goto-repo-history nil)
      (defun +dot-goto-repo ()
        (interactive)
        "List repositories using my [[https://github.com/mohkale/dotfiles/blob/c534c70befdfcae7abaad3f0a6777392f63db6c5/bin/ls-repos][ls-repos]] script and ask for one to jump to."
        (let ((repo (completing-read "Repo: "
                                     (apply #'process-lines +dot-goto-repo-command)
                                     nil t nil '+dot-goto-repo-history)))
          (dired repo)))
    #+END_SRC

    #+BEGIN_SRC emacs-lisp
      (defvar +dot-goto-executable-command '("ls-exec"))

      (defvar +dot-goto-executable-history nil)
      (defun +dot-goto-executable ()
        (interactive)
        "List and jump to an executable using [[https://github.com/mohkale/dotfiles/blob/master/bin/ls-exec][ls-exec]]."
        (let ((cand (completing-read "Executable:"
                                     (apply #'process-lines +dot-goto-executable-command))))
          (find-file cand)))
    #+END_SRC

    #+BEGIN_SRC emacs-lisp
      (defvar +dot-goto-fsmap-command
        '("sh" "-c"
          "ls-fsmaps -er | if hash column 2>/dev/null; then column -s : -t; else tr ':' ' '; fi"))

      (defvar +dot-goto-fsmap-dirs-command
        '("sh" "-c"
          "ls-fsmaps -erd | if hash column 2>/dev/null; then column -s : -t; else tr ':' ' '; fi"))

      (defun +dot-goto-fsmap-format-lines (lines)
        (save-match-data
          (cl-loop for fsmap in lines
                   with path  = nil
                   with alias = nil
                   with spacing = nil
                   when (string-match (rx bol
                                          (group (one-or-more (not whitespace)))
                                          (group (+ (any whitespace)))
                                          (group (one-or-more anychar))
                                          eol)
                                      fsmap)
                     do (setq alias   (match-string 1 fsmap)
                              spacing (match-string 2 fsmap)
                              path    (match-string 3 fsmap))
                     and collect (propertize
                                  (concat (propertize alias 'face 'font-lock-type-face)
                                           spacing
                                           ;; (propertize path 'face (if (file-directory-p path) 'dired-directory 'default))
                                           path)
                                  'fsmap path))))

      (defvar +dot-goto-fsmap-history nil)
      (defun +dot-goto-fsmap (&optional dirs-only)
        "List file system maps (using [[https://github.com/mohkale/dotfiles/blob/c534c70befdfcae7abaad3f0a6777392f63db6c5/bin/ls-fsmaps][here]]) and find one in emacs."
        (interactive "P")
        (if-let ((fsmaps (+dot-goto-fsmap-format-lines
                          (apply #'process-lines
                                 (if dirs-only
                                     +dot-goto-fsmap-dirs-command
                                   +dot-goto-fsmap-command)))))
            (find-file (get-text-property 0 'fsmap (completing-read "File system map: " fsmaps nil t nil '+dot-goto-fsmap-history)))
          (user-error "No fsmaps found")))

      (defun +dot-goto-fsmap-dirs ()
        (interactive)
        (+dot-goto-fsmap '(4)))
    #+END_SRC

    #+BEGIN_SRC emacs-lisp
      (defvar +dot-open-bookmark-command '("ls-bookmarks"))

      (defun +dot-open-bookmark-format-lines (lines)
        (cl-loop for row in lines
                 do (setq row (split-string row "\t"))
                 with url   = nil
                 with tags  = nil
                 with title = nil
                 do (setq url   (nth 0 row)
                          tags  (nth 1 row)
                          title (nth 2 row))
                 when (string-prefix-p "http" url)
                   collect (propertize

                            (concat (unless (string-empty-p tags)
                                      (propertize (concat "(" tags ") ") 'face 'bold))
                                    title
                                    (when url
                                      (when-let ((domain (url-domain (url-generic-parse-url url))))
                                        (concat " [" (propertize domain 'face 'font-lock-preprocessor-face) "]"))))
                            'bookmark url)))

      (defvar +dot-open-bookmark-history nil)
      (defun +dot-open-bookmark ()
        "List system bookmarks (using [[https://github.com/mohkale/dotfiles/blob/master/bin/ls-bookmarks][this]]) and open it in your default browser."
        (interactive)
        (if-let ((bookmarks (+dot-open-bookmark-format-lines (apply #'process-lines +dot-open-bookmark-command))))
            (xopen-url+ (get-text-property 0 'bookmark (completing-read "Bookmark: " bookmarks nil t nil '+dot-open-bookmark-history)))
          (user-error "No bookmarks")))
    #+END_SRC

    #+BEGIN_SRC emacs-lisp
      (provide '+dotfiles)
    #+END_SRC

* Core
  core functions needed to edit with emacs.

  basic syntax sugar functions, inspired by [[https://github.com/hlissner/doom-emacs/blob/develop/core/core-lib.el][doom]].

  #+BEGIN_SRC emacs-lisp
    (defmacro lambda! (&rest body)
      "Expands to (lambda () (interactive) ,@body).
    A factory for quickly producing interaction commands, particularly for keybinds
    or aliases."
      (declare (doc-string 1) (pure t) (side-effect-free t))
      `(lambda () (interactive) ,@body))

    (defun keyword-sym-normalise! (sym)
      "convert a keyword symbol, SYM, to a non-keyword symbol.
    eg. (keyword-sym-normalise! :hello) ;; => 'hello"
      (let ((sym-string (symbol-name sym)))
        (if (string-prefix-p ":" sym-string)
            (intern (substring sym-string 1))
          sym)))

    ;; source [[https://www.emacswiki.org/emacs/DestructiveOperations#toc4][Destructive Operations]].
    (defun nconc-safe (ls1 ls2)
      "`nconc', but avoids creating circular lists."
      (let ((tail ls1))
        (while (and (cdr tail) (not (eq tail ls2)))
          (setq tail (cdr tail)))
        (unless (eq tail ls2)
          (if (null tail)
              (setq ls1 ls2)
            (setcdr tail ls2)))
        ls1))

    (defmacro with-no-write-file-messages (&rest body)
      "execute BODY while supressing \"Wrote: file\" messages"
      `(let ((save-silently t))
         ;; replace the VISIT argument of write-region with something
         ;; that'll supress the write message
         (cl-letf* (((symbol-function 'actual-write-region)
                     (symbol-function 'write-region))
                    ((symbol-function 'write-region)
                     (lambda (a b c &optional d &rest args)
                       (apply #'actual-write-region a b c d 'nomsg (cdr args)))))
           ,@body)))
    (put 'with-no-write-file-messages 'lisp-indent-function 'defun)

    (defun inhibit-messages-wrapper (func &rest args)
      (let ((inhibit-message t))
        (apply func args)))

    (defun chain-match-regexp (string &rest regexps)
      "checks for string-match against STRING using regexps
    returns true if any of the regexps match the string."
      (let (match-found regexp)
        (while (and (not match-found)
                    (setq regexp (car regexps)))
          (setq match-found (string-match-p regexp string)
                regexps (cdr regexps)))
        (not (not match-found))))

    (defmacro assoc-pop! (key alist)
      `(let ((result (assoc ,key ,alist)))
         (setq ,alist (delete result ,alist))
         result))

    ;; see [[https://ftp.gnu.org/old-gnu/Manuals/elisp-manual-20-2.5/html_node/elisp_408.html][here]].
    (defun buffer-killed-p (buffer)
      "Return t if BUFFER is killed."
      (not (buffer-name buffer)))

    (defmacro string-truncate-left! (str count)
      `(and ,str
            (if (> (length ,str) ,count)
                (substring ,str ,count)
              "")))

    (defmacro string-truncate-right! (str count)
      `(and ,str
            (let ((len (length ,str)))
              (if (> len ,count)
                  (substring ,str 0 (- len ,count))
                ""))))

    (defmacro string-truncate! (str left right)
      `(and ,str
            (let ((len (length ,str)))
              (if (> len (+ ,left ,right))
                  (substring ,str ,left (- len ,right))
                ""))))
  #+END_SRC

** plist-bind
   #+BEGIN_SRC emacs-lisp
     (cl-defmacro plist-bind! ((list &rest props) &rest body)
       "declare local bindings in BODY using a property list LIST.
     This functions exists as an alternative to `cl-defmacro's very limited support
     for variable argument lists alongside keyword argument lists. A use case I've
     encountered so often, it merited creating this.

     This function accepts a LIST argument and then a bunch of property specifications.
     For every property in PROPS, that property is popped from LIST and then included
     in the local scope of BODY. A property can be specified as an ALIST, in which case
     the `car' of the list is the property name and the `cdr' is the default value for
     the property.

     WARN LIST should be an identifier for a list variable... not a LIST by itself.

     The remaining value of LIST is all the properties which were not provided in the
     spec.
     "
       `(let* ((,list (cl-copy-list ,list))
               ,@(cl-loop for prop in props
                          with default = nil
                            when (listp prop)
                              do (setq default (cdr prop) prop (car prop))
                            end
                            collect (list (keyword-sym-normalise! prop)
                                          `(plist-pop! ,list ,prop ,default))))
          ,@body))
     (put 'plist-bind! 'lisp-indent-function 'defun)
   #+END_SRC

** host
   Remember my host configuration across systems.

   #+BEGIN_SRC emacs-lisp
     (use-package +host
       :commands (host!))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp :tangle lisp/+host.el
     (defvar +hosts-alist
       (let ((hosts-file (etc! "hosts")))
         (if (file-exists-p hosts-file)
             (with-temp-buffer
               (insert-file-contents hosts-file)
               (read (current-buffer)))
           (warn "hosts config file not found: %s" hosts-file)))
       "list of devices I own.")

     (defun host! (id)
       "Check if current host matches ID
     if ID is a string it's matched against the currents hosts
     hostname. otherwise id is looked for in `+hosts-alist'
     and then compared against. "
       (unless (stringp id)
         (setq id (cdr (assoc id +hosts-alist))))

       (when id
         (string-equal id (system-name))))

     (provide '+host)
   #+END_SRC

** find-emacs
   Find files related to my own configuration/directory layouts.

   #+BEGIN_SRC emacs-lisp
     (defun find-dotemacs-file ()
       (interactive)
       (find-file (join-path user-emacs-directory "init.el")))

     (defun find-dotemacs-directory ()
       (interactive)
       (find-file user-emacs-directory))

     (defun find-dotemacs-org-file ()
       (interactive)
       (find-file (join-path user-emacs-directory "init.org")))

     (defun find-dotemacs-snippets-file ()
       (interactive)
       (find-file (etc! "snippets.org")))

     (defun find-dotemacs-config-file (&optional arg)
       (interactive "P")
       (cl-destructuring-bind (file . point)
           (or (unless arg
                 (let ((conf (lisp! "+config.el")))
                   (and (file-exists-p conf)
                        (cons conf nil))))
               (save-window-excursion
                 (find-dotemacs-org-file)
                 (cons (buffer-file-name)
                       (when-let ((cand (car (cl-assoc "Config" (imenu--make-index-alist t) :test #'string-equal))))
                         (get-text-property 0 'org-imenu-marker cand)))))
         (if file
             (progn
               (find-file file)
               (when point
                 (goto-char point)))
           (user-error "No configuration file found"))))

     (defun find-dotemacs-snippet ()
       (interactive)
       (let ((default-directory (etc! "snippets")))
         (cond
          ((package! ivy)
           (require 'counsel)
           (funcall-interactively #'counsel-file-jump))
          (t (user-error "No recursive find-file package found")))))

     (defun find-file-from-dotemacs ()
       (interactive)
       (let ((default-directory user-emacs-directory))
         (call-interactively 'find-file)))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (leader/set-keys
       "fec" 'find-dotemacs-org-file
       "fed" 'find-dotemacs-directory
       "fea" 'find-dotemacs-snippet
       "fey" 'find-dotemacs-snippets-file
       "fel" 'find-dotemacs-file
       "fef" 'find-file-from-dotemacs
       "fex" 'find-dotemacs-config-file)
   #+END_SRC

** buffers
   #+BEGIN_SRC emacs-lisp
     (defun rename-buffer-file (buffer &optional new-name)
       "renames the file associated with the buffer BUFFER.
     if the buffer isn't visiting a file or the visited file
     doesn't exist on disk, this function is equivalent to
     simply changing the visited file name for BUFFER."
       (interactive (list (current-buffer)))

       (or new-name
           (setq new-name (read-file-name "new-name: ")))

       (let* ((buffer-file (buffer-file-name buffer))
              (modified-p (buffer-modified-p buffer))
              (directory (file-name-directory new-name))
              (src-exists (file-exists-p buffer-file))
              (dst-exists (file-exists-p new-name)))
         (with-current-buffer buffer
           ;; destination doesn't exist, so can write
           ;; or
           ;; user agrees to overwrite, so can write
           (when (or (not dst-exists)
                     (yes-or-no-p "file already exists, overwrite it:"))
             ;; only rename buffer file if it exists
             (when (and buffer-file src-exists)
               (unless (file-directory-p directory)
                 (mkdir directory t))
               (rename-file buffer-file new-name t)
               (message "moved file '%s' to '%s'" buffer-file new-name))

             (set-visited-file-name new-name)
             (set-buffer-modified-p modified-p)))))

     (defun delete-buffer-file ()
       (interactive)
       (let ((buffer (current-buffer))
             (filename (buffer-file-name))
             (name (buffer-name)))
         (if (not filename)
             (message "buffer %s is not visiting a file" name)
           (when (yes-or-no-p "Are you sure you want to delete this file? ")
             (when (file-exists-p filename)
               (delete-file filename t))

             (kill-buffer buffer)))))

     (defun smart-buffer-file-name ()
       (or (buffer-file-name)
           (cond
            ((derived-mode-p 'dired-mode)
             (string-trim-right (dired-current-directory) "/")))))

     (defmacro defun-show-and-copy-command (name &rest body)
       "Define a function which uses BODY to generate a string which is then shown and copied.
     The prefix behaviour of the passed function can be used insert the output of BODY or
     to save the current point and then do so.
     "
       `(defun ,(intern (concat "show-and-copy-" (symbol-name name))) (&optional arg)
          (interactive "P")
          (let ((msg ,@body))
            (when msg
              (or (stringp msg)
                  (setq msg (format "%s" msg)))                                      ; Force msg to be a string
              ;; perform insertion behaviour
              (when (consp arg)
                (if (eq (car prefix) 4)
                    (insert msg)
                  (save-excursion
                    (insert msg))))
              ;; show and then copy msg
              (message msg)
              (kill-new msg)))))

     (defun-show-and-copy-command buffer-file-basename
       (file-name-nondirectory (or (smart-buffer-file-name) "")))

     (defun-show-and-copy-command buffer-file-name
       (smart-buffer-file-name))

     (defun-show-and-copy-command directory
       (file-name-directory (or (smart-buffer-file-name) default-directory)))

     (cl-defun write-backup (&optional prefix (silent t))
       "manually force emacs to backup the current buffer.
     By default doesn't do anything when the current buffer hasn't been modified.
     Pass a single-prefix `C-u` to force backing-up even if the buffer has not been
     modified. Pass two prefixes `C-u C-u`to backup the buffer and then save; this
     in affect backs up the last save and then saves the current buffer."
       (interactive "P")
       (let* ((modified (buffer-modified-p))
              (save-after (and (listp prefix)
                               (eq (car prefix) 8)))
              (save-before (and (not save-after)
                                modified)))
         (if (and (not prefix)
                  (not modified))
             (or silent
                 (message "buffer not modified since last save"))
           (or save-before (save-buffer))

           ;; buffer-backed-up is permenently buffer-local so you have to account
           ;; for when it's already been backed up and when you first back it up.
           (if buffer-backed-up
               (let (buffer-backed-up)
                 (backup-buffer))
             (backup-buffer))

           (or save-after (save-buffer)))))

     (defun write-kill-buffer (&optional buffer-or-name confirm)
       "write buffer to file and then kill it"
       (interactive)
       (let ((buffer (get-buffer (or buffer-or-name (current-buffer)))))
         (when (buffer-modified-p)
           (write-file (or (buffer-file-name) (read-file-name "write file: "))
                       confirm))

         (when (or (not confirm)
                   (y-or-no-p (format "are you sure you want to kill this buffer (%s): " buffer)))
           (let ((window (get-buffer-window buffer)))
             (kill-buffer buffer)
             (when (and window (> (length (window-list)) 1))
               (delete-window window))))))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (leader/set-keys
       "f~" 'write-backup
       "fa" 'write-autosave
       "fD" 'delete-buffer-file
       "fR" 'rename-buffer-file
       "fy" 'show-and-copy-buffer-file-name
       "fu" 'show-and-copy-directory
       "f%" 'show-and-copy-buffer-file-basename
       ;; "fo" 'open-file-or-directory-in-external-app ;; TODO implement
       )
   #+END_SRC

** whitespace
   Configure displaying of trailing whitespace. Now I personally am not a fan of source code
   with invisable trailing whitespace, it takes up meaningless space ([[https://www.youtube.com/watch?v=SsoOG6ZeyUI][insert irrelevent video
   here]]) and probably annoys the hell out of other people with editors smart enough to
   see it.

   So I enable displaying of trailing whitespace by default in every mode. That way you can
   see and remove it. If you'd like to disable whitespace display, then you'll have to append
   to either of the following variables.

   Here we define the configuration variables used for determining whether to enable
   visible whitespace or not.

   #+BEGIN_SRC emacs-lisp
     (defvar whitespace-exempt-modes '(help-mode
                                       Buffer-menu-mode
                                       ibuffer-mode
                                       eshell-mode
                                       term-mode
                                       minibuffer-inactive-mode
                                       eshell-mode)
       "modes under which no trailing whitespace is shown")

     (defvar whitespace-exempt-buffers
       (list (rx "*Ibuffer confirmation*")
             (rx "*Org Export Dispatcher*"))
       "regular expressions matching buffer names under which no trailing
     whitespace is shown.")
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (defun set-trailing-whitespace--mode-based (&optional dont-set)
       "check the mode of the current buffer, to see whether trailing
     whitespace should be shown. with the optional parameter `dont-set'
     trailing whitespace will not be set.

     This function returns what the desired value of `show-trailing-whitespace'
     should be."
       (let ((show (not (and whitespace-exempt-modes
                             (apply 'derived-mode-p
                                    whitespace-exempt-modes)))))
         (prog1
             show
           (unless dont-set
             (setq show-trailing-whitespace show)))))

     (defun set-trailing-whitespace--name-based (&optional dont-set)
       "check the name of the current buffer, to see whether trailing
     whitespace should be shown. see `set-trailing-whitespace--mode-based'."
       (let ((show (not (and whitespace-exempt-buffers
                             (apply 'chain-match-regexp
                                    (buffer-name)
                                    whitespace-exempt-buffers)))))
         (prog1
             show
           (unless dont-set
             (setq show-trailing-whitespace show)))))

     (defun set-trailing-whitespace (&rest _)
       (setq show-trailing-whitespace
             ;; when both name and mode decide you can show
             ;; whitespace, then show it. otherwise when at
             ;; least one says no, then hide it.
             (and (set-trailing-whitespace--mode-based t)
                  (set-trailing-whitespace--name-based t))))
   #+END_SRC

   Connect the aforementioned functions to the appropriate emacs hooks.

   #+BEGIN_SRC emacs-lisp
     ;; add switch-to-buffer hook because some functions, such as ibuffers confirmation
     ;; popup use switch-to-buffer instead of display buffer and there's no easy way
     ;; to modify it.
     (add-hook 'switch-to-buffer-hook #'set-trailing-whitespace)
     (add-hook 'after-change-major-mode-hook
               (lambda (&rest _)
                 (set-trailing-whitespace--mode-based)))
   #+END_SRC

** indentation
   Configure the preferred indentation for buffers. Emacs doesn't really have a nice builtin
   way to do this across multiple modes. I got tired of always having to remember special
   variables for each mode so I've defined the following alist to store indent configurations
   and a command ~set-indent-offset~ which automatically (or manually sets the desired
   indent).

   #+BEGIN_SRC emacs-lisp
     (defvar +indent-config '((t . 4))
       "alist configuring preferred indentation for buffers.
     the `car' of an entry is used to match which buffer it's applied to
     and `cdr' is used to determine the value of it.

     the `car' can be a symbol, a string, a function or some expression
     which evaluates to t. if it's a symbol, the major mode of the
     buffer is compared against it. if it's a string the name of the
     buffer is matched against it.

     the cons can be a number, a function or some expression which
     evaluates to a number.

     NOTE: indentation is set exclusively when a buffer-mode change
           occurs, changing the buffer name doesn't alter the indent.
     ")

     (defun +indent-offset (&optional buffer)
       "Use `+indent-config' to find the preffered indent for BUFFER."
       (with-current-buffer (or buffer (current-buffer))
         (cl-loop with matcher = nil
                  with indent  = nil
                  for cfg in +indent-config
                  do (setq matcher (car cfg))
                  if (cond
                      ((eq matcher t) t)
                      ((symbolp matcher) (eq matcher major-mode))
                      ((stringp matcher) (string-match-p matcher (buffer-name)))
                      ((functionp matcher) (funcall matcher))
                      (t (eval matcher)))
                  do (setq indent (cdr cfg))
                  and return (if (functionp indent)
                                 (funcall indent)
                               indent))))

     ;; A package that lets you configure project parameters (indent size,
     ;; line endings etc.) in a [[https://editorconfig.org/][single configuration]] file.
     ;;
     ;; I really only need the parsing fascilities so that I can extract the
     ;; indent-offset but editorconfig also has a mapping of common indent
     ;; variables defined in an alist that's bound to come in very useful
     ;; „ÉΩ(*¬¥–∑ÔΩÄ*)Ôæâ.
     (use-package editorconfig
       :straight t
       :config
       (setq editorconfig-lisp-use-default-indent t)
       (push '(plantuml-mode plantuml-indent-level) editorconfig-indentation-alist))

     (defvar-local +indent nil
       "Override the local indent for the current file.")

     (defun set-indent-offset (&optional indent)
       "set the indentation level of the current buffer.
     this method uses `+indent-config' to determine what
     the indentation of the current buffer should be and then sets
     it. Also setting any mode dependent, specific indent bindings,
     alongside it.

     You can pass a specific value for the indent as an argument and
     the current buffers indentation will be set to that."
       ;; TODO: only use this when editorconfig-mode is disabled.
       (interactive "Nindent: ")
       (let* ((buffer (current-buffer)))
         (setq indent (or indent
                          +indent
                          ;; Extract value from editorconfig file
                          (condition-case _
                              (let ((num (gethash 'indent_size
                                           (funcall editorconfig-get-properties-function))))
                                (if (stringp num)
                                    (string-to-number num)
                                  num))
                            (error nil))
                          ;; Use the values from `+indent-config'
                          (+indent-offset)))

         (if (not indent)
             (message "set-indent-offset: unable to determine indent for current buffer.")
           (editorconfig-set-indentation
             (if indent-tabs-mode "tab" "space")
             (number-to-string indent)
             (number-to-string indent)))))

     (add-hook 'after-change-major-mode-hook #'set-indent-offset)
   #+END_SRC

** lisp-indent
   Lisp indent-function taken from [[https://emacs.stackexchange.com/questions/10230/how-to-indent-keywords-aligned][here]].

   #+BEGIN_SRC emacs-lisp
     (defun +emacs-lisp-indent-function (indent-point state)
       "This function is the normal value of the variable `lisp-indent-function'.
     The function `calculate-lisp-indent' calls this to determine
     if the arguments of a Lisp function call should be indented specially.

     INDENT-POINT is the position at which the line being indented begins.
     Point is located at the point to indent under (for default indentation);
     STATE is the `parse-partial-sexp' state for that position.

     If the current line is in a call to a Lisp function that has a non-nil
     property `lisp-indent-function' (or the deprecated `lisp-indent-hook'),
     it specifies how to indent.  The property value can be:

     ,* `defun', meaning indent `defun'-style
       \(this is also the case if there is no property and the function
       has a name that begins with \"def\", and three or more arguments);

     ,* an integer N, meaning indent the first N arguments specially
       (like ordinary function arguments), and then indent any further
       arguments like a body;

     ,* a function to call that returns the indentation (or nil).
       `lisp-indent-function' calls this function with the same two arguments
       that it itself received.

     This function returns either the indentation to use, or nil if the
     Lisp function does not specify a special indentation."
       (let ((normal-indent (current-column))
             (orig-point (point)))
         (goto-char (1+ (elt state 1)))
         (parse-partial-sexp (point) calculate-lisp-indent-last-sexp 0 t)
         (cond
          ;; car of form doesn't seem to be a symbol, or is a keyword
          ((and (elt state 2)
                (or (not (looking-at "\\sw\\|\\s_"))
                    (looking-at ":")))
           (if (not (> (save-excursion (forward-line 1) (point))
                       calculate-lisp-indent-last-sexp))
               (progn (goto-char calculate-lisp-indent-last-sexp)
                      (beginning-of-line)
                      (parse-partial-sexp (point)
                                          calculate-lisp-indent-last-sexp 0 t)))
           ;; Indent under the list or under the first sexp on the same
           ;; line as calculate-lisp-indent-last-sexp.  Note that first
           ;; thing on that line has to be complete sexp since we are
           ;; inside the innermost containing sexp.
           (backward-prefix-chars)
           (current-column))
          ((and (save-excursion
                  (goto-char indent-point)
                  (skip-syntax-forward " ")
                  (not (looking-at ":")))
                (save-excursion
                  (goto-char orig-point)
                  (looking-at ":")))
           (save-excursion
             (goto-char (+ 2 (elt state 1)))
             (current-column)))
          (t
           (let ((function (buffer-substring (point)
                                             (progn (forward-sexp 1) (point))))
                 method)
             (setq method (or (function-get (intern-soft function)
                                            'lisp-indent-function)
                              (get (intern-soft function) 'lisp-indent-hook)))
             (cond ((or (eq method 'defun)
                        (and (null method)
                             (> (length function) 3)
                             (string-match "\\`def" function)))
                    (lisp-indent-defform state indent-point))
                   ((integerp method)
                    (lisp-indent-specform method state
                                          indent-point normal-indent))
                   (method
                    (funcall method indent-point state))))))))

     (setq lisp-indent-function #'+emacs-lisp-indent-function)
   #+END_SRC

** minibuffer-clear
   Auto clear the echo area after a certain idle interval. Why? because emacs has a tendency
   to hang when doing a lot of tasks (eg. updating packages). When this package installation
   finished emacs keeps the last message in the minibuffer meaning the only way to tell if
   emacs is ready to carry on is to hit a key. I can't count the number of times I've just
   stood around for 2 minutes wondering when it'll be done, only to find it finished a while
   ago and I just didn't recieve any notification :angry:.

   #+BEGIN_SRC emacs-lisp :tangle no
     (defun clear-echo-area ()
       (message nil))

     (defvar auto-clear-echo-area-interval 5
       "clear the echo area after this many seconds have elapsed.
     set to nil to not disable echo area auto clear.")

     (defvar auto-clear-echo-area--timer nil)

     (advice-add 'message :after
                 (defun auto-clear-echo-area (string &rest args)
                   (when (and string
                              auto-clear-echo-area-interval)
                     (when auto-clear-echo-area--timer
                       (cancel-timer auto-clear-echo-area--timer))

                     (setq auto-clear-echo-area--timer
                           (run-with-idle-timer
                            auto-clear-echo-area-interval
                            nil
                            #'clear-echo-area)))))

     ;; eldoc should't be removed after idle delay... it's designed to be looked at.
     (advice-add 'eldoc-message :around
                 (defun eldoc-message--disable-auto-clear-echo-area (func &rest args)
                   (when auto-clear-echo-area--timer
                     ;; cancel any existing timers beforehand.
                     (cancel-timer auto-clear-echo-area--timer)
                     (setq auto-clear-echo-area--timer nil))

                   (let (auto-clear-echo-area-interval) ;; disable interval
                     (apply func args))))
   #+END_SRC

** yank-indent-adjust
   adjust indentation of yanked text in some modes... because doing so manually is a
   pain :tongue:. Initially sourced from, the venerable, [[https://github.com/magnars/.emacs.d/blob/master/defuns/editing-defuns.el#L99-L124][magnars]].

   #+BEGIN_SRC emacs-lisp
     (defvar yank-indent-modes '(prog-mode
                                 sgml-mode
                                 js2-mode)
       "Modes in which to automatically indent regions that are yanked (or yank-popped).")
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     ;; (require 'dash)

     (defvar yank-advised-indent-threshold 1000
       "Threshold (# chars) over which indentation does not automatically occur.")

     (defun yank-advised-indent-function (beg end)
       "Do indentation, as long as the region isn't too large."
       (if (<= (- end beg) yank-advised-indent-threshold)
           (indent-region beg end nil)))

     (defmacro with-auto-indent-satisfied (prefix-var &rest body)
       `(when (and (not ,prefix-var)
                   (--any? (derived-mode-p it) yank-indent-modes))
          ,@body))
     (put 'with-auto-indent-satisfied 'lisp-indent-function 'defun)

     (defun yank--auto-indent (&optional arg)
       "if mode is in `yank-indent-modes' indent yanked text
     doesn't do anything if a prefix arg is given."
       (with-auto-indent-satisfied arg
         (let ((transient-mark-mode nil))
           (yank-advised-indent-function
            (region-beginning) (region-end)))))

     (advice-add 'yank     :after #'yank--auto-indent)
     (advice-add 'yank-pop :after #'yank--auto-indent)

     (defun yank-unindented ()
       (interactive)
       (yank 1))

     (with-eval-after-load 'evil
       (defun evil-visual-paste--auto-indent (_ &optional register _)
         ;; not sure what yank handler is for, leave it in, to avoid errors
         "same as `yank--auto-indent', but for evil visual yank replace."
         (with-auto-indent-satisfied register
           (let ((transient-mark-mode nil))
             (yank-advised-indent-function
              (region-beginning) (region-end)))))

       (advice-add 'evil-visual-paste :after #'evil-visual-paste--auto-indent)
       (advice-add 'evil-paste-after  :after #'evil-visual-paste--auto-indent)
       (advice-add 'evil-paste-before :after #'evil-visual-paste--auto-indent))
   #+END_SRC

** display-buffer
   #+BEGIN_SRC emacs-lisp
     (defmacro display-buffer--create-focus-method (func)
       `(defun ,(intern (concat (symbol-name func) "-and-focus")) (buffer alist)
          (let ((window (,func buffer alist)))
            (when window
              (select-window window)))))

     (display-buffer--create-focus-method display-buffer--maybe-same-window)
     (display-buffer--create-focus-method display-buffer-reuse-window)
     (display-buffer--create-focus-method display-buffer--maybe-pop-up-frame-or-window)
     (display-buffer--create-focus-method display-buffer-in-previous-window)
     (display-buffer--create-focus-method display-buffer-in-side-window)
     (display-buffer--create-focus-method display-buffer-use-some-window)
     (display-buffer--create-focus-method display-buffer-pop-up-frame)
     (display-buffer--create-focus-method display-buffer-below-selected)

     ;; See also: [[https://stackoverflow.com/questions/21542914/make-buffer-list-always-appear-in-horizontal-split/21544307#21544307][here]].
     (defun display-buffer-left (buffer alist)
       "display a buffer to the left of the current buffer.
     (1) If `buffer` is already displayed, then display it again in the same window.
     (2) If `buffer` is not already displayed, and if there is a window to the left,
         then display that `buffer` in said window.
     (3) If `buffer` is not already displayed, and if there is a window to the right, then
         use the selected window.
     (4) If all else fails, then create a new window to the left and display `buffer` there.
     (5) Select the target window which displays `buffer`."
       (let ((window
              (cond
               ((get-buffer-window buffer (selected-frame)))
               ;; ((window-in-direction 'above))
               ((window-in-direction 'left))
               ((window-in-direction 'right)
                (selected-window))
               (t
                (split-window (selected-window) nil 'left)))))
         (window--display-buffer buffer window 'window alist)))

     (defun display-buffer-right (buffer alist)
       "display a buffer to the right of the current buffer.
     (1) If `buffer` is already displayed, then display it again in the same window.
     (2) If `buffer` is not already displayed, and if there is a window to the right,
         then display that `buffer` in said window.
     (3) If `buffer` is not already displayed, and if there is a window to the left, then
         use the selected window.
     (4) If all else fails, then create a new window to the right and display `buffer` there.
     (5) Select the target window which displays `buffer`."
       (let ((window
              (cond
               ((get-buffer-window buffer (selected-frame)))
               ;; ((window-in-direction 'above))
               ((window-in-direction 'right))
               ((window-in-direction 'left)
                (selected-window))
               (t
                (split-window (selected-window) nil 'right)))))
         (window--display-buffer buffer window 'window alist)))

     (display-buffer--create-focus-method display-buffer-left)
     (display-buffer--create-focus-method display-buffer-right)
   #+END_SRC

** fonts-emojis
   #+BEGIN_SRC emacs-lisp
     ;; adapted from [[https://github.com/zonuexe/emoji-fontset.el/blob/master/emoji-fontset.el][emoji-fontset]]
     (let ((emoji-font-family
            (cl-case window-system
              ('w32 "Segoe UI Emoji")
              ('ns  "Apple Color Emoji")
              (t    "Symbola"))))
       (cl-loop
        for (x . y) in '((#x1f000 . #x1f02f) ;; Mahjong Tiles
                         (#x1f0a0 . #x1f0ff) ;; Playing Cards
                         (#x1f110 . #x1f19a) ;; Enclosed Alphanumeric Supplement
                         ;; Regional Indicator Symbol, Enclosed Ideographic Supplement,
                         ;; Emoticons, Transport and Map Symbols, Alchemical Symbols
                         (#x1f1e6 . #x1f8ff))
        do (setq x (decode-char 'ucs x)
                 y (decode-char 'ucs y))
        do (set-fontset-font "fontset-default" (cons x y) emoji-font-family)))
   #+END_SRC

** library
   #+BEGIN_SRC emacs-lisp
     (add-to-list 'load-path (lisp! "lib"))
   #+END_SRC

*** misc
    #+BEGIN_SRC emacs-lisp
      (use-package +lib-misc
        :defer t
        :commands (toggle-lexical-binding
                   keymaps-at-point
                   toggle-relative-linum
                   toggle-buffer-header))
    #+END_SRC

    #+BEGIN_SRC emacs-lisp :tangle lisp/lib/+lib-misc.el
      (defun toggle-lexical-binding (&optional arg)
        (interactive "P")
        (setq lexical-binding
              (if (not arg)
                  (not lexical-binding)
                (or (listp arg)
                    (not (zerop arg)))))

        (message "lexical binding: %s" (if lexical-binding
                                           (propertize "enabled" 'face 'compilation-info)
                                         (propertize "disabled" 'face 'compilation-error))))

      (defvar-local header-line-actual-format nil
        "value of `header-line-format' before being modified by `toggle-buffer-header'.")

      (defun toggle-buffer-header (&optional arg no-error)
        (interactive "P")
        (let ((showing (if arg
                           (not (zerop (prefix-numeric-value arg)))
                         header-line-actual-format)))
          (if showing
              (if (not header-line-actual-format)
                  (unless no-error
                    (user-error "tried to restore header-line: nil"))
                (setq header-line-format  header-line-actual-format
                      header-line-actual-format nil))
            (setq header-line-actual-format header-line-format
                  header-line-format nil))))

      (defun toggle-relative-linum (&optional arg)
        "toggle relative line numbers in the current buffer
      when ARG is given and is 0, then relative line numbers are disabled,
      otherwise if ARG is greater than 0 then they're enabled and if ARG is
      nil then relative line-numbers are toggled."
        (interactive "P")
        (setq display-line-numbers
              (cond
               ((and arg (zerop (prefix-numeric-value arg)))
                t)
               (arg 'relative)
               (t
                (if (eq display-line-numbers 'relative) t 'relative)))))

      (defun keymaps-at-point ()
        "List entire keymaps present at point."
        (interactive)
        (let ((map-list
               (list
                (mapcar (lambda (overlay)
                          (overlay-get overlay 'keymap))
                        (overlays-at (point)))
                (mapcar (lambda (overlay)
                          (overlay-get overlay 'local-map))
                        (overlays-at (point)))
                (get-text-property (point) 'keymap)
                (get-text-property (point) 'local-map))))
          (apply #'message
                 (concat
                  "Overlay keymap: %s\n"
                  "Overlay local-map: %s\n"
                  "Text-property keymap: %s\n"
                  "Text-property local-map: %s")
                 map-list)))

      (provide '+lib-misc)
    #+END_SRC

*** text
    :PROPERTIES:
    :header-args+: :tangle lisp/lib/+lib-text.el
    :END:

    #+BEGIN_SRC emacs-lisp :tangle init.el
      (use-package +lib-text
        :defer t
        :commands (dos2unix
                   unix2dos
                   remove-all-trailing-whitespace
                   toggle-comment-at-point
                   tab-to-tab-stop-with-prefix
                   indent-back-to-normal
                   back-to-tab-stop
                   toggle-comment-at-point-alt
                   custom-insert-line
                   custom-insert-line-below
                   custom-insert-line-above
                   evil-join-backwards))
    #+END_SRC

    Manipulate chunks of text, such as leading indentation or sequential padding.

    #+BEGIN_SRC emacs-lisp
      (defun dos2unix ()
        "Not exactly but it's easier to remember"
        (interactive)
        (set-buffer-file-coding-system 'unix 't))

      (defun unix2dos ()
        (interactive)
        (set-buffer-file-coding-system 'dos 't))

      ;; (defun remove-indentation-spaces ()
      ;;   "remove TAB-WIDTH spaces from the beginning of this line"
      ;;   (interactive)
      ;;   (if (save-excursion (re-search-backward "[^ \t]" (line-beginning-position) t))
      ;;       (delete-backward-char 1)
      ;;     (indent-rigidly (line-beginning-position) (line-end-position) (- tab-width))))

      (defun remove-all-trailing-whitespace (start end)
        "removes all trailing whitespace from every line in buffer"
        (interactive (if (region-active-p)
                         (list (region-beginning) (region-end))
                       (list (point-min) (point-max))))

        (barf-if-buffer-read-only) ; can't remove from current buffer

        (save-excursion
          (goto-char end) ; start from end so delete can work forward

          (while (and (> (point) start)
                      (re-search-backward " +$" nil t))
            (delete-region (point) (line-end-position)))))

      (defun indent-back-to-normal (&optional column)
        "indents the current line using indent region.
      this'll either reset indentation to it's normal position, or
      bring you to the beginning of an empty line. Specify a column
      value to force that column to be used by indent region."
        (interactive "P")

        (let ((inhibit-message t))
          (indent-region (line-beginning-position) (1+ (line-end-position)) column)))

      ;; https://emacs.stackexchange.com/questions/32816/backwards-tab-to-tab-stop
      (defun tab-to-tab-stop-with-prefix (&optional prev)
        "Like `tab-to-tab-stop', but toggle direction with prefix."
        (interactive "P")
        (let ((nexttab (indent-next-tab-stop (current-column) prev)))
          (delete-horizontal-space t)
          (indent-to nexttab)))

      (defun back-to-tab-stop ()
        (interactive)
        (let ((current-prefix-arg 1))
          (call-interactively #'tab-to-tab-stop-with-prefix)))
    #+END_SRC

    Comment regions of text or by default, the current line.

    #+BEGIN_SRC emacs-lisp
      (defun toggle-comment-at-point (start end)
        "toggle comment on line or region
      pass a prefix argument to bulk toggle across multiple lines.
      This function will always comment the line your point is on,

      prefix behaviour:
      | prefix range | behaviour                                        |
      |--------------+--------------------------------------------------|
      | 0            | current line only                                |
      | >1           | current line and upto prefix-1 lines after point |
      | <1           | current line and upto prefix lines before point  |

      the behaviour is mapped to exactly replicate the vim dd command."
        (interactive (let ((prefix current-prefix-arg))
                       (if (region-active-p)
                           ;; always use region when region available
                           (list (region-beginning) (region-end))
                         (if (or (not prefix)
                                 (listp prefix) ;; regular prefix
                                 (zerop prefix))
                             ;; no prefix, comment current line only
                             (list (line-beginning-position) (line-end-position))
                           ;; prefix given, use it to determine comment region
                           (let* ((prefix-positive (> prefix 0))
                                  (current-pos (if prefix-positive
                                                   (line-beginning-position)
                                                 (line-end-position))))
                             (save-excursion
                               (if prefix-positive
                                   (progn
                                     (evil-next-line (- prefix 1))
                                     (list current-pos (line-end-position)))
                                 (evil-next-line prefix)
                                 (list (line-beginning-position) current-pos))))))))
        (comment-or-uncomment-region start end))

      (defun toggle-comment-at-point-alt ()
        "variant of toggle-comment-at-point which conforms to relative line numbers

      prefix behaviour:
      | prefix range | behaviour                                         |
      |--------------+---------------------------------------------------|
      | 0            | current line only                                 |
      | >1           | current line and upto prefix-1 lines after point  |
      | <1           | current line and upto prefix+1 lines before point |
      "
        (interactive)
        (let ((current-prefix-arg (and current-prefix-arg
                                       (cond
                                        ((>= current-prefix-arg 1) (1+ current-prefix-arg))
                                        ;; ((<  current-prefix-arg 0) (1- current-prefix-arg))
                                        (t current-prefix-arg)))))
          (call-interactively 'toggle-comment-at-point)))

      (defun yank-and-comment (&optional prefix)
        (interactive "P")
        (when (> (length kill-ring) 0)
          (save-excursion
            (let ((beginning (point)))
              (call-interactively 'yank)
              (comment-region beginning (point))))
          (evil-forward-word))) ;; move to beginning of comment
    #+END_SRC

    Line insertion and joining functions.

    #+BEGIN_SRC emacs-lisp
      (defun custom-insert-line (&optional prefix)
        "inserts a line above or below point

      if a prefix argument of 0 or more (or none) is given, the
      line is inserted below the point. Otherwise its inserted
      above the point.

      The absolute value of the prefix determines how many lines
      are inserted.

      Eg: A prefix of:
        ,* nil - inserts a single line below the cursor
        ,* -1  - inserts a single line above the cursor
        ,* 0   - inserts a single line below the cursor
        ,* 1   - inserts a single line below the cursor
        ,* -10 - inserts 10 lines above the cursor
        ,* 10  - inserts 10 lines below the cursor"
        (interactive "P")

        (save-excursion
          (let ((move-arg (if (or (not prefix)
                                  (>= prefix 0))
                              nil ; if prefix xor prefix >= 0
                            0)))
            (move-end-of-line move-arg)
            (open-line (max 1 (abs prefix))))))

      (defun custom-insert-line-below (&optional prefix)
        (interactive "P")
        (custom-insert-line (abs (or prefix 1))))

      (defun custom-insert-line-above (&optional prefix)
        (interactive "P")
        (custom-insert-line (- (abs (or prefix 1)))))

      (defun evil-join-backwards (&optional prefix)
        "same as join line, except joins line immeadiately before point"
        (interactive "p")
        (let ((start nil)
              (end   nil))
          (if (evil-visual-state-p)
              (let ((range (evil-visual-range)))
                (setq start (nth 0 range))
                (setq end   (nth 1 range)))
            ;; not visual, calculate ranges
            (setq end (point))
              (save-excursion
                (forward-line (- (abs prefix)))
                (setq start (point))))
          ;; remove excursion block if you wan't to
          ;; reallign point to start of line on join
          (save-excursion
            (if (line-empty-p start)
                ;; when joining onto an empty line
                ;; maintain leading whitespace
                (evil-join-whitespace start end)
              ;; otherwise trim to single space
              (evil-join start end)))))
    #+END_SRC

    #+BEGIN_SRC emacs-lisp
      (provide '+lib-text)
    #+END_SRC

*** text-query
    :PROPERTIES:
    :header-args+: :tangle lisp/lib/+lib-text-query.el
    :END:

    #+BEGIN_SRC emacs-lisp :tangle init.el
      (use-package +lib-text-query
        :defer t
        :commands (line-width
                   column-number
                   in-comment-p
                   in-font-lock-comment-p
                   line-beginning-column
                   yank-and-comment
                   point-to-coordinates
                   line-empty-p
                   list-faces))
    #+END_SRC

    functions for querying information about the text at point or retrieve other
    relevent information.

    #+BEGIN_SRC emacs-lisp
      (defun line-width (char-pos)
        "returns the number of columns on the line at char-pos"
        (interactive (if current-prefix-arg
                         (list current-prefix-arg)
                       (list (point))))
        (save-excursion
          (if (not (eql char-pos (point)))
            (goto-char char-pos))
          (let ((line-width (max (- (line-end-position) (line-beginning-position) 1) 0)))
            (if (called-interactively-p 'any)
                (message (format "Line Width: %03d" line-width)))

            line-width)))

      (defun column-number (point)
        "returns the column number at point"
        (interactive "")
        (save-excursion
          (goto-char point)
          (current-column)))

      (defun point-to-coordinates (&optional point)
        "convert a point to an XY coordinate alist"
        (or point (setq point (point)))
        `(,(line-number-at-pos point) . ,(column-number point)))

      (defun line-empty-p (&optional point)
        (save-excursion
          (and point (goto-char point))
          (beginning-of-line)
          (looking-at "[[:space:]]*$")))

      (defun list-faces (&optional point)
        (interactive "d")
        (or point (setq point (point)))
        (let ((faces (remq nil
                           `(,(get-char-property point 'read-face-name)
                             ,(get-char-property point 'face)
                             ,(plist-get (text-properties-at point) 'face)))))
          (and (called-interactively-p 'any) (message (format "%s" faces)))
          faces))

      (defun in-comment-p (&optional pos)
        (save-excursion
          (goto-char (or pos (point)))
          (nth 4 (syntax-ppss))))

      (defun in-font-lock-comment-p (&optional pos)
        "Test if character at POS is comment.
      If POS is nil, character at `(point)' is tested"
        (unless pos (setq pos (point)))
        (let* ((fontfaces (get-text-property pos 'face)))
          (when (not (listp fontfaces))
            (setf fontfaces (list fontfaces)))
          (delq nil
                (mapcar #'(lambda (f)
                            ;; learn this trick from flyspell
                            (or (eq f 'font-lock-comment-face)
                                (eq f 'font-lock-comment-delimiter-face)))
                        fontfaces))))

      (defun line-beginning-column (&optional point)
        (save-excursion
          (goto-char (or point (point)))
          (evil-first-non-blank)
          (current-column)))
    #+END_SRC

    #+BEGIN_SRC emacs-lisp
      (provide '+lib-text-query)
    #+END_SRC
*** buffer-control
    :PROPERTIES:
    :header-args+: :tangle lisp/lib/+lib-buffer-control.el
    :END:

     #+BEGIN_SRC emacs-lisp :tangle init.el
       (use-package +lib-buffer-control
         :defer 30
         :commands (kill-this-buffer-and-window-maybe
                    switch-to-last-buffer
                    kill-all-windows-and-return-to-home
                    halt-and-catch-fire
                    switch-to-messages-buffer
                    force-set-all-visible-windows-dedication
                    window-zen
                    window-zen-restore
                    display-last-buffer
                    vertical-display-last-buffer
                    shell-command-on-buffer
                    set-window-dedication
                    async-shell-command-on-buffer
                    safe-erase-buffer
                    yank-whole-buffer-as-kill
                    split-window-right-and-focus
                    split-window-below-and-focus)
         :general
         (:keymaps 'emacs-window-map
          "T"   'force-set-all-visible-windows-dedication
          "o"   'display-last-buffer
          "C-o" 'display-last-buffer
          "SPC" 'set-window-dedication
          "M-d" 'set-window-dedication
          "O"   'vertical-display-last-buffer
          "M-o" 'vertical-display-last-buffer))
    #+END_SRC

    #+BEGIN_SRC emacs-lisp
      (defun switch-to-messages-buffer ()
        "switches to messages buffer"
        (interactive)
        (switch-to-buffer (messages-buffer)))

      (defun switch-to-last-buffer (&optional buffer)
        (interactive)
        (switch-to-buffer buffer))

      (defun kill-this-buffer-and-window-maybe ()
        "kills the currently open buffer and the window if another is open"
        (interactive)
        (let ((window-count (length (window-list))))
          (if (> window-count 1)
              (kill-buffer-and-window)
            (kill-this-buffer))))

      (defun kill-all-windows-and-return-to-home ()
        "kills every other window and returns to home buffer"
        (interactive)
        (dolist (window (cdr (window-list)))
          ;; window-list starts with current window
          (delete-window window))
        (goto-home-buffer))

      (defalias 'halt-and-catch-fire #'kill-all-windows-and-return-to-home)

      (defun force-set-all-visible-windows-dedication (&optional dedicate)
        "allows you to set the dedication of all visible windows
      dedicate if truthy, will result in all windows recieving a dedication.
      if falsy, all windows will have their dedication removed"
        (interactive "P")
        ;; TODO require persp-mode here
        (and dedicate (setq dedicate t))      ; rationalise value as bool
        (or  dedicate (setq dedicate nil))    ; rationalise value as nil

        (dolist (window (window-list))
          (when (not (eq dedicate (window-dedicated-p window)))
            (set-window-dedicated-p window dedicate))))

      (let ((window-zen-register ?_))
        (defun window-zen (&optional prefix)
          "Maximize buffer or undo maximize buffer
      pass prefix to also restore original point."
          ;; from [[https://gist.github.com/3402786][here]].
          (interactive "P")
          (if (and (= 1 (length (window-list)))
                   (assoc window-zen-register register-alist))
              (window-zen-restore prefix)
            (window-configuration-to-register window-zen-register)
            (delete-other-windows)))

        (defun window-zen-restore (&optional prefix)
          "force restoration of window, instead of replacement of previous zen.
      like `window-zen' pass prefix argument to save excursion"
          (interactive)
          (unless (assoc window-zen-register register-alist)
            (user-error "no previous zen found."))

          (if prefix
              (jump-to-register window-zen-register)
            (save-excursion
              (jump-to-register window-zen-register)))))

      (defun shell-command-on-buffer (&optional prefix)
        "Asks for a command and executes it in inferior shell with current buffer
      as input. if prefix is given, output of command is inserted in current buffer
      at point."
        (interactive "P")
        (let ((command (read-shell-command "Shell command on buffer: "))
              (input-buffer (current-buffer)) output-buffer process-output)
          (with-temp-buffer ;; needed for process output
            (setq output-buffer (current-buffer))

            (with-current-buffer input-buffer
              (shell-command-on-region (point-min) (point-max) command output-buffer nil output-buffer))

            (setq process-output (buffer-string)))

          (if prefix
              (insert process-output)
            (message process-output))))

      (defun async-shell-command-on-region (&optional start end prefix)
        "same as `async-shell-command', but also sends the current region
      as stdin to the process."
        (interactive "r\nP")
        (require 'subr-x) ;; needed for string-empty-p

        (unless (eq start end) ;; region is not active
          (let ((command (read-shell-command "Async shell command on buffer: ")))
            (unless (string-empty-p command)
              (async-shell-command command) ;; XXX WHY??? don't you return the process :P
              (let ((program-buffer (get-buffer "*Async Shell Command*")))

                (process-send-region (get-buffer-process program-buffer) start end)

                (with-current-buffer program-buffer
                  (comint-send-eof)

                  (unless (get-buffer-process program-buffer)
                    (funcall-interactively 'initial-major-mode)))

                (display-buffer program-buffer))))))

      (defun async-shell-command-on-buffer (&optional prefix)
        "same as `async-shell-command-on-region' but sends whole buffer as region"
        (interactive "P")
        (async-shell-command-on-region (point-min) (point-max) prefix))

      (defun safe-erase-buffer (&optional prefix)
        "prompts to really erase and then erases the current buffer"
        (interactive "P")
        (barf-if-buffer-read-only)
        (when (or prefix
                  (y-or-n-p (concat "Erase content of buffer "
                                    (buffer-name)
                                    " ?")))
            (erase-buffer)))

      (defun split-window-right-and-focus ()
        (interactive)
        (split-window-horizontally)
        (other-window 1))

      (defun split-window-below-and-focus ()
        (interactive)
        (split-window-vertically)
        (other-window 1))

      (defun yank-whole-buffer-as-kill (buffer)
        (interactive (list (current-buffer)))
        (with-current-buffer buffer
          (copy-region-as-kill (point-min) (point-max))))

      (defun display-last-buffer ()
        (interactive)
        (display-buffer
         (other-buffer)
         '((display-buffer-below-selected-and-focus
            display-buffer-in-previous-window-and-focus
            display-buffer-use-some-window-and-focus
            display-buffer-pop-up-frame-and-focus))))

      (defun vertical-display-last-buffer ()
        (interactive)
        (display-buffer
         (other-buffer)
         (cons '(display-buffer-right-and-focus
                 display-buffer-in-previous-window-and-focus
                 display-buffer-use-some-window-and-focus
                 display-buffer-pop-up-frame-and-focus)
               '((side . right)
                 (window-width . 0.5)))))

      ;; (cl-defmacro window-route (&rest paths)
      ;;   "macro to see which window exists at the end of a route
      ;; from the current window.

      ;; Accepts up, down, left & right as direction markers & every
      ;; route begins from the top left hand side of the current window."
      ;;   `(let ((paths ',paths))
      ;;      (if (not paths)
      ;;          (selected-window)
      ;;        (condition-case err
      ;;            (save-excursion
      ;;              ;; goto start to ensure route begins from
      ;;              ;; top left hand side of current window.
      ;;              (goto-char (max (point-min) (window-start)))
      ;;              (goto-char (line-beginning-position))
      ;;              (save-selected-window
      ;;                (let (head)
      ;;                  ;; TODO check whether to goto top left hand side here.
      ;;                  (while (setq head (pop paths))
      ;;                    (cond
      ;;                     ((eq head 'up)    (windmove-up))
      ;;                     ((eq head 'down)  (windmove-down))
      ;;                     ((eq head 'left)  (windmove-left))
      ;;                     ((eq head 'right) (windmove-right))))
      ;;                  (selected-window))) )
      ;;          (user-error (message "window-route: %s" err))))))

      ;; (defun window-expand-up ()
      ;;   "Expand current window into region of window above.

      ;;                          Begun from 3           Begun from 2
      ;; +---------------+      +---------------+      +---------------+
      ;; | 1             |      | 1        | 3  |      | 2        | 1  |
      ;; |               |  |-> |          |    |  |-> |          |    |
      ;; |---------+-----|      |----------+    |      |          +----|
      ;; | 2       | 3   |      | 2        |    |      |          | 3  |
      ;; +---------------+      +---------------+      +---------------+

      ;; "
      ;;   )

      ;; (defun window-expand-down ()
      ;;   "Expand current window into region of window below.

      ;;                          Begun from 2           Begun from 1
      ;; +---------------+      +---------------+      +---------------+
      ;; | 1       | 2   |      | 1        | 2  |      | 1        | 2  |
      ;; |         |     |  |-> |          |    |  |-> |          |    |
      ;; |---------+-----|      |----------+    |      |          +----|
      ;; | 3             |      | 3        |    |      |          | 3  |
      ;; +---------------+      +---------------+      +---------------+
      ;; "
      ;;   )

      ;; (defun window-expand-right ()
      ;;   "Expand current window into region of window to the right.

      ;;                          Begun from 1           Begun from 3
      ;; +---------------+      +---------------+      +---------------+
      ;; | 1       | 2   |      | 1             |      | 1        | 2  |
      ;; |         |     |  |-> |               |  |-> |          |    |
      ;; |---------+     |      |----------+----|      |----------+----|
      ;; | 3       |     |      | 3        | 2  |      | 3             |
      ;; +---------------+      +---------------+      +---------------+
      ;; "
      ;;   )

      ;; (defun window-expand-left ()
      ;;   "Expand current window into region of window to the left.

      ;;                          Begun from 2           Begun from 3
      ;; +---------------+      +---------------+      +---------------+
      ;; | 1       | 2   |      | 2             |      | 1        | 2  |
      ;; |         |     |  |-> |               |  |-> |          |    |
      ;; |         +-----|      |----------+----|      |----------+----|
      ;; |         | 3   |      | 1        | 3  |      | 3             |
      ;; +---------------+      +---------------+      +---------------+
      ;; "
      ;;   )

      (defun set-window-dedication (&optional prefix window)
        "Set the dedication value for the current window.
      By default it toggles the dedication. Supply a prefix arg
      to explicitly enable or disable.

      When a window is dedicated, you can't change the buffer for it.
      "
        (interactive "P")
        (when (and prefix
                   (listp prefix))
          (setq prefix (car prefix)))
        (or window (setq window (selected-window)))

        (set-window-dedicated-p
         window
         (if prefix
             (> prefix 0)
           (not (window-dedicated-p window)))))
    #+END_SRC

    #+BEGIN_SRC emacs-lisp
      (provide '+lib-buffer-control)
    #+END_SRC

*** unpackaged
    :PROPERTIES:
    :header-args+: :tangle lisp/lib/+lib-unpackaged.el
    :END:

    Many useful functions sourced from [[https://github.com/alphapapa/unpackaged.el/blob/master/unpackaged.el][unpackaged.el]].

    #+BEGIN_SRC emacs-lisp :tangle init.el
      (use-package +lib-unpackaged
        :defer t
        :commands (font-compare
                   lorem-ipsum-overlay)
        :config
        ;; used in a bunch of places
        (defvar lorem-ipsum-text nil)

        :leader
        ("xl" 'lorem-ipsum-overlay))
    #+END_SRC

    Font methods.

    #+BEGIN_SRC emacs-lisp
      (defun font-compare (text fonts)
        "Compare TEXT displayed in FONTS.
      If TEXT is nil, use `lorem-ipsum' text.  FONTS is a list of font
      family strings and/or font specs.

      Interactively, prompt for TEXT, using `lorem-ipsum' if left
      empty, and select FONTS with `x-select-font', pressing Cancel to
      stop selecting fonts."
        (interactive (list (pcase (read-string "Text: ")
                             ("" nil)
                             (else else))
                           ;; `x-select-font' calls quit() when Cancel is pressed, so we use
                           ;; `inhibit-quit', `with-local-quit', and `quit-flag' to avoid that.
                           (let ((inhibit-quit t))
                             (cl-loop for font = (with-local-quit
                                                   (x-select-font))
                                      while font
                                      collect font into fonts
                                      finally do (setf quit-flag nil)
                                      finally return fonts))))
        (setq text (or text (s-word-wrap 80 (s-join " " (progn
                                                          (require 'lorem-ipsum)
                                                          (seq-random-elt lorem-ipsum-text))))))
        (with-current-buffer (get-buffer-create "*Font Compare*")
          (erase-buffer)
          (--each fonts
            (let ((family (cl-typecase it
                            (font (symbol-name (font-get it :family)))
                            (string it))))
              (insert family ": "
                      (propertize text
                                  'face (list :family family))
                      "\n\n")))
          (pop-to-buffer (current-buffer))))
    #+END_SRC

    Lorem ipsum overlay.

    #+BEGIN_SRC emacs-lisp
       (require 'lorem-ipsum)

       (defcustom lorem-ipsum-overlay-exclude nil
         "List of regexps to exclude from `lorem-ipsum-overlay'."
         :type '(repeat regexp))

       ;;;###autoload
       (defun lorem-ipsum-overlay ()
         "Overlay all text in current buffer with \"lorem ipsum\" text.
       When called again, remove overlays.  Useful for taking
       screenshots without revealing buffer contents.

       Each piece of non-whitespace text in the buffer is compared with
       regexps in `lorem-ipsum-overlay-exclude', and ones
       that match are not overlaid.  Note that the regexps are compared
       against the entire non-whitespace token, up-to and including the
       preceding whitespace, but only the alphabetic part of the token
       is overlaid.  For example, in an Org buffer, a line that starts
       with:

         ,#+TITLE: unpackaged.el

       could be matched against the exclude regexp (in `rx' syntax):

         (rx (or bol bos blank) \"#+\" (1+ alnum) \":\" (or eol eos blank))

       And the line would be overlaid like:

         ,#+TITLE: parturient.et"
         (interactive)
         (let ((ovs (overlays-in (point-min) (point-max))))
           (if (cl-loop for ov in ovs
                        thereis (overlay-get ov :lorem-ipsum-overlay))
               ;; Remove overlays.
               (dolist (ov ovs)
                 (when (overlay-get ov :lorem-ipsum-overlay)
                   (delete-overlay ov)))
             ;; Add overlays.
             (let ((lorem-ipsum-words (--> lorem-ipsum-text
                                           (-flatten it) (apply #'concat it)
                                           (split-string it (rx (or space punct)) 'omit-nulls)))
                   (case-fold-search nil))
               (cl-labels ((overlay-match (group)
                                          (let* ((beg (match-beginning group))
                                                 (end (match-end group))
                                                 (replacement-word (lorem-word (match-string group)))
                                                 (ov (make-overlay beg end)))
                                            (when replacement-word
                                              (overlay-put ov :lorem-ipsum-overlay t)
                                              (overlay-put ov 'display replacement-word))))
                           (lorem-word (word)
                                       (if-let* ((matches (lorem-matches (length word))))
                                           (apply-case word (downcase (seq-random-elt matches)))
                                         ;; Word too long: compose one.
                                         (apply-case word (downcase (compose-word (length word))))))
                           (lorem-matches (length &optional (comparator #'=))
                                          (cl-loop for liw in lorem-ipsum-words
                                                   when (funcall comparator (length liw) length)
                                                   collect liw))
                           (apply-case (source target)
                                       (cl-loop for sc across-ref source
                                                for tc across-ref target
                                                when (not (string-match-p (rx lower) (char-to-string sc)))
                                                do (setf tc (string-to-char (upcase (char-to-string tc)))))
                                       target)
                           (compose-word (length)
                                         (cl-loop while (> length 0)
                                                  for word = (seq-random-elt (lorem-matches length #'<=))
                                                  concat word
                                                  do (cl-decf length (length word)))))
                 (save-excursion
                   (goto-char (point-min))
                   (while (re-search-forward (rx (group (1+ (or bol bos blank (not alpha)))
                                                        (0+ (not (any alpha blank)))
                                                        (group (1+ alpha))
                                                        (0+ (not (any alpha blank)))))
                                             nil t)
                     (unless (cl-member (match-string 0) lorem-ipsum-overlay-exclude
                                        :test (lambda (string regexp)
                                                (string-match-p regexp string)))
                       (overlay-match 2))
                     (goto-char (match-end 2)))))))))
    #+END_SRC

    #+BEGIN_SRC emacs-lisp
      (provide '+lib-unpackaged)
    #+END_SRC

* Packages
  Packages which are mandatory. You have to install these for emacs to work as
  intended.

** completion
   Assistance for various completion frameworks.

*** flx
    optimizes ivy search ordering for fuzzy searches.

    #+BEGIN_SRC emacs-lisp
      (use-package flx
        :straight t
        :defer  t)
    #+END_SRC

*** smex
    show recently accessed commands at the top of M-x.

    #+BEGIN_SRC emacs-lisp
      (use-package smex
        :straight t
        :defer  t
        :config
        (setq smex-save-file (var! "smex-save.el")))
    #+END_SRC

*** orderless
    A package for building nicer matching regexps for completion using space
    seperated components. Atm it doesn't (and has no intentions for) ordering
    completion based on match counts or accuracy (shame üò¢) but we can get around
    that by using prescient.

    #+BEGIN_SRC emacs-lisp :tangle (package-yes! orderless)
      (use-package orderless
        :straight t
        :demand t
        :config
        (defun flex-if-twiddle (pattern _index _total)
          "Glob when trailing tilde."
          (when (string-suffix-p "~" pattern)
            `(orderless-flex . ,(substring pattern 0 -1))))

        (defun without-if-bang (pattern _index _total)
          "Exclude literal when leading punctuation-mark."
          (when (string-prefix-p "!" pattern)
            `(orderless-without-literal . ,(substring pattern 1))))

        (setq orderless-matching-styles '(orderless-regexp)
              orderless-style-dispatchers '(flex-if-twiddle
                                            without-if-bang)))
    #+END_SRC

*** prescient
    A package for remembering and sorting completion candidates based on frequency of
    usage. This is intended to be used with orderless, however because prescient has
    its own functions for filtering if orderless is disabled prescient will take over
    that as well.

    For tips on how to integrate this with orderless see [[https://github.com/oantolin/orderless/issues/25#issuecomment-743740717][orderless#25]].

    #+BEGIN_SRC emacs-lisp :tangle (package-yes! prescient)
      (use-package prescient
        :straight t
        :demand t
        :init
        (setq prescient-save-file (var! "prescient-history.el"))

        :config
        (prescient-persist-mode +1))                                                  ; persist statistics between emacs sessions
    #+END_SRC

** evil
   The quintessential [[https://github.com/emacs-evil/evil][vi emulation]] package for emacs :speak_no_evil:.

   NOTE evil is installed here, but configured below, so that hooks are run properly.

   #+BEGIN_SRC emacs-lisp
     (use-package evil
       :straight t
       :defer  t
       :custom
       (evil-undo-system 'undo-tree)
       (evil-cross-lines t)
       (evil-default-state 'motion)
       (evil-want-C-i-jump nil)
       (evil-want-C-u-scroll t)
       (evil-want-visual-char-semi-exclusive t)
       (evil-toggle-key "M-z")
       (evil-search-module 'evil-search)

       :config
       (setq evil--jumps-buffer-targets                                                   ; see [[https://emacs.stackexchange.com/questions/42060/add-dired-buffers-to-evil-jump-list][here]].
             (rx "*"
                 (or "new"
                     "Help"
                     "scratch"
                     (and "Org src " (zero-or-more any) "[ " (zero-or-more any) " ]"))
                 "*")))
   #+END_SRC

*** matchit
    A better jump-to-matching element function for emacs evil.

    #+BEGIN_SRC emacs-lisp
      (use-package evil-matchit
        :straight t
        :defer  t
        :hook (evil-mode . global-evil-matchit-mode)
        :init
        (defun evilmi-customize-keybinding ()
          (general-define-key
           ;; WARN binding to motion breaks things.
           :states  '(normal visual)
           :keymaps 'evil-matchit-mode-map
           "%" 'evilmi-jump-items))

        :config
        (with-eval-after-load 'evil-matchit-org
          (push '(("begin_center") () ( "end_center") "MONOGAMY") evilmi-org-match-tags)))
    #+END_SRC

*** surround
    #+BEGIN_SRC emacs-lisp
      (use-package evil-surround
        :straight t
        :hook (evil-mode . global-evil-surround-mode)
        :config
        (setq-default evil-surround-pairs-alist
                      '((?\( . ("(" . ")"))
                        (?\[ . ("[" . "]"))
                        (?\{ . ("{" . "}"))

                        (?\) . ("( " . " )"))
                        (?\] . ("[ " . " ]"))
                        (?\} . ("{ " . " }"))

                        (?# . ("#{" . "}")) ; ruby string interpolation
                        (?b . ("(" . ")"))
                        (?B . ("{" . "}"))
                        (?> . ("<" . ">"))
                        (?t . evil-surround-read-tag)
                        (?< . evil-surround-read-tag)
                        (?f . evil-surround-function)))

        :general
        ;; only allow surrounding via selections or explicitly using gS
        (:states 'visual "s"  'evil-surround-region)
        (:states 'motion "gs" 'evil-surround-edit)
        (:keymaps 'evil-surround-mode-map
         "$" nil))
    #+END_SRC

*** anzu
    #+BEGIN_SRC emacs-lisp :tangle (package-yes! anzu)
      (use-package evil-anzu
        :after anzu
        :straight t
        :demand t)
    #+END_SRC

*** numbers
    #+BEGIN_SRC emacs-lisp
      (use-package evil-numbers
        :defer  t
        :straight t
        :general
        (:states 'normal
         "C-S-a" 'evil-numbers/inc-at-pt
         "C-S-x" 'evil-numbers/dec-at-pt))
    #+END_SRC

*** snipe
    Let's you start a motion to some string matching some series of input characters.
    Think evil-search... but to a fixed number of characters, which can be raised at
    invocation.

    #+BEGIN_SRC emacs-lisp
      (use-package evil-snipe
        :straight t
        :defer  t
        :diminish
        evil-snipe-mode
        evil-snipe-local-mode
        :hook (evil-mode . evil-snipe-mode)
        :config
        (setq evil-snipe-scope 'buffer                                      ; how far can a snipe take place
              evil-snipe-repeat-scope 'buffer                               ; how far repeating previous snipe can take place.
              evil-snipe-enable-highlight nil                               ; don't highlight after jump
              evil-snipe-repeat-keys nil                                    ; sniping after a snipe, repeats the last snipe
              evil-snipe-enable-incremental-highlight t                     ; do highlight matching snipe locations
              evil-snipe-skip-leading-whitespace t                          ; whitespace at start of line is ignored
              evil-snipe-smart-case t                                       ; case sensetive until it's not, like ivy
              evil-snipe-tab-increment t                                    ; hit tab to raise amount of snipes left
              evil-snipe-override-evil-repeat-keys nil                      ; don't replace ; and , with evil keys
              evil-snipe-auto-disable-substitute nil                        ; keep my substitute key available
              )

        (defvar evil-snipe-find-scopes-to-line+ nil
          "when true, evil-snipe-{f,F,t,T} (I.E. for single finds) only extends to EOL.")

        (defmacro evil-snipe-with-normalised-settings (&rest body)
          `(let ((evil-snipe-enable-highlight nil)                           ; don't highlight jump matches after jump
                 (evil-snipe-enable-incremental-highlight nil)               ; don't highlight jump matches while searching
                 (evil-snipe-tab-increment nil)                              ; disable tab to raise snipe count
                 (evil-snipe-show-prompt nil)                                ; don't show prompt, why bother? you can't increment it.
                 (evil-snipe-smart-case nil)                                 ; fJ != fj
                 (evil-snipe-skip-leading-whitespace nil)
                 (evil-snipe-scope (if evil-snipe-find-scopes-to-line+
                                       'line
                                     evil-snipe-scope)))
             ,@body))

        (defun evil-snipe--normalise-single-snipes+ (func &rest args)
          "normalise snipes with count 1 to match `evil-find-char'.
      don't want highlighting, or a prompt or other feature enhancements.
      just simple, jump to char.

      NOTE this function updates settings during the input reading phase
           only; which is taken care of in the interactive section prior
           to method body invocation.
      "
          (if (eq evil-snipe--match-count 1)
              (evil-snipe-with-normalised-settings
                (apply func args))
            (apply func args)))

        (defun evil-snipe--normalise-single-snipes-wrapper+ (func &rest args)
          "specify normalisation for the body of the given function."
          (evil-snipe-with-normalised-settings (apply func args)))

        (advice-add 'evil-snipe--collect-keys :around 'evil-snipe--normalise-single-snipes+)
        (advice-add 'evil-snipe-f :around #'evil-snipe--normalise-single-snipes-wrapper+)
        (advice-add 'evil-snipe-F :around #'evil-snipe--normalise-single-snipes-wrapper+)
        (advice-add 'evil-snipe-t :around #'evil-snipe--normalise-single-snipes-wrapper+)
        (advice-add 'evil-snipe-T :around #'evil-snipe--normalise-single-snipes-wrapper+)

        ;; I don't need it, I've got my own keys bound to do the same thing :)
        (advice-add 'evil-snipe--transient-map :override 'ignore)

        :general
        (:keymaps 'evil-snipe-mode-map
         :states  leader-norm-states
         ;; S is inclusive, X is exclusive.
         "gT" 'evil-snipe-X
         "gt" 'evil-snipe-x
         "gF" 'evil-snipe-S
         "gf" 'evil-snipe-s
         "f"  'evil-snipe-f
         "F"  'evil-snipe-F
         "t"  'evil-snipe-t
         "T"  'evil-snipe-T
         ";"  'evil-snipe-repeat
         "g;" 'evil-snipe-repeat-reverse)
        ;; Unbind the default bindings
        (:keymaps 'evil-snipe-mode-map
         :states  '(motion normal)
         "S" nil "s" nil
         "X" nil "x" nil))
    #+END_SRC

*** exchange
    cut a region into a kill buffer, and then swap it with another region somewhere else.

    #+BEGIN_SRC emacs-lisp :tangle no
      (use-package evil-exchange
        :straight t
        :defer  t
        :general
        (:states leader-norm-states
         "gx" 'evil-exchange
         "gX" 'evil-exchange-cancel))
    #+END_SRC

*** multiedit
    #+BEGIN_SRC emacs-lisp
      (use-package iedit
        :straight t
        :defer  t
        :init
        (setq iedit-toggle-key-default nil))

      (use-package evil-multiedit
        :straight t
        :demand t
        :after  evil
        :commands (evil-multiedit
                   evil-multiedit-all)
        :init
        (evil-ex-define-cmd "ie[dit]" 'evil-multiedit-ex-match)

        :config
        (defun evil-multiedit--multiedit (beg end)
          (evil-visual-select beg
                              (max 0 (- end 1)))
          (evil-multiedit-match-and-next))

        (evil-define-operator evil-multiedit (beg end)
          :repeat nil
          (if (evil-get-command-property 'evil-multiedit :move-point)
              (save-excursion
                (evil-multiedit--multiedit beg end))
            (evil-multiedit--multiedit beg end)))

        (defun evil-multiedit--multiedit-all (beg end)
          (evil-visual-select beg
                              (max 0 (- end 1)))
          (evil-multiedit-match-all))

        (evil-define-operator evil-multiedit-all (beg end)
          :repeat nil
          (if (evil-get-command-property 'evil-multiedit-all :move-point)
              (save-excursion
                (evil-multiedit--multiedit-all beg end))
            (evil-multiedit--multiedit-all beg end)))

        :general
        (:states 'normal "gi" nil)                                                    ; Suppress default iedit binding
        (:states '(motion multiedit)
         "gi" 'evil-multiedit
         "g*" 'evil-multiedit-all
         "gI" 'evil-multiedit-restore)
        (:states 'multiedit
         "g." 'hydra-evil-multiedit/body
         "g*" 'evil-multiedit-match-all
         "gh" 'evil-multiedit-prev
         "gl" 'evil-multiedit-next
         "gj" 'evil-multiedit-match-and-next
         "gk" 'evil-multiedit-match-and-prev)
        ;; (:states 'visual
        ;;  "RET" 'evil-multiedit-toggle-or-restrict-region)
        (:states 'multiedit
         "G"  nil "gg" nil))
    #+END_SRC

*** traces
    indicators for various ex commands.

    #+BEGIN_SRC emacs-lisp
       (use-package evil-traces
         :straight t
         :defer  t
         :hook (evil-mode . evil-traces-mode)
         :diminish
         :config
         (evil-traces-use-diff-faces))
    #+END_SRC

*** args
    #+BEGIN_SRC emacs-lisp
      (use-package evil-args
        :straight t
        :defer  t
        :hook ((emacs-lisp-mode       . evil-args-adjust-for-elisp+)
               (lisp-interaction-mode . evil-args-adjust-for-elisp+))
        :init
        (defun evil-args-adjust-for-elisp+ ()
          (setq evil-args-delimiters '(" ")))

        :leader
        ("j[" 'evil-backward-arg
         "j]" 'evil-forward-arg
         "ja" 'evil-jump-out-args)

        :general
        (:keymaps '(evil-inner-text-objects-map
                    evil-outer-text-objects-map)
         "a" 'evil-inner-arg)
        (:states 'motion
         "[u" 'evil-jump-out-args
         "]u" 'evil-jump-out-args

         "[h" 'evil-backward-arg
         "]h" 'evil-backward-arg

         "[l" 'evil-forward-arg
         "]l" 'evil-forward-arg

         "[a" 'evil-backward-arg
         "]a" 'evil-forward-arg))
    #+END_SRC

*** easymotion
    Avy inspired evil motions.

    #+BEGIN_SRC emacs-lisp
      (use-package evil-easymotion
        :straight t
        :defer  t
        :leader
        (:prefix "jh"
         ""   "motion"
         "w"  'evilem-motion-forward-word-begin
         "W"  'evilem-motion-forward-WORD-begin
         "e"  'evilem-motion-forward-word-end
         "E"  'evilem-motion-forward-WORD-end
         "b"  'evilem-motion-backward-word-begin
         "B"  'evilem-motion-backward-WORD-begin
         ;; "ge" 'evilem-motion-backward-word-end
         ;; "gE" 'evilem-motion-backward-WORD-end
         "j"  'evilem-motion-next-line
         "k"  'evilem-motion-previous-line
         "J"  'evilem-motion-next-visual-line
         "K"  'evilem-motion-previous-visual-line
         "t"  'evilem-motion-find-char-to
         "T"  'evilem-motion-find-char-to-backward
         "f"  'evilem-motion-find-char
         "F"  'evilem-motion-find-char-backward
         "n"  'evilem-motion-search-next
         "p"  'evilem-motion-search-previous
         "*"  'evilem-motion-search-word-forward
         "#"  'evilem-motion-search-word-backward
         "-"  'evilem-motion-previous-line-first-non-blank
         "+"  'evilem-motion-next-line-first-non-blank))
    #+END_SRC

*** vimish-fold
    Folding like vim

    #+BEGIN_SRC emacs-lisp
      (use-package vimish-fold
        :straight (vimish-fold :host github :repo "mrkkrp/vimish-fold")
        :hook ((text-mode . vimish-fold-mode)
               (prog-mode . vimish-fold-mode)
               (conf-mode . vimish-fold-mode))
        :config
        (setq vimish-fold-allow-nested t)
        (setq vimish-fold-dir (var! "vimish-fold/"))

        (add-hook 'vimish-fold-mode-hook
                  (defun vimish-fold-setup-evil+ ()
                    (if vimish-fold-mode
                        (add-to-list 'evil-fold-list
                                     `((vimish-fold-mode)
                                       :delete     vimish-fold-delete
                                       :open-all   vimish-fold-unfold-all
                                       :close-all  vimish-fold-refold-all
                                       :toggle     vimish-fold-toggle
                                       :open       vimish-fold-unfold
                                       :open-rec   nil
                                       :close      vimish-fold-refold))
                      (setq evil-fold-list (cl-remove-if
                                            (lambda (e) (eq (caar e) 'vimish-fold-mode))
                                            evil-fold-list)))))

        (evil-define-operator vimish-fold-create+ (beg end)
          "Create a fold from the current region.
      See also `evil-delete-fold'."
          (vimish-fold beg end))

        (evil-define-motion vimish-fold-next-fold+ (count)
          "Go to the start of the next fold."
          :type inclusive
          (unless (numberp count)
            (setq count 1))
          (dotimes (_ count nil)
            (vimish-fold-next-fold)))

        (evil-define-motion vimish-fold-prev-fold+ (count)
          "Go to the start of the previous fold."
          :type inclusive
          (unless (numberp count)
            (setq count 1))
          (dotimes (_ count nil)
            (vimish-fold-previous-fold)))

        :general
        (;; :keymaps 'vimish-fold-mode-map
         :states '(normal motion)
         "zx" 'vimish-fold-toggle
         "zX" 'vimish-fold-toggle-recursively
         "zj" 'vimish-fold-next-fold+
         "zk" 'vimish-fold-prev-fold+
         "zo" 'vimish-fold-unfold
         "zO" 'vimish-fold-unfold-recursively
         "zd" 'vimish-fold-delete
         "zD" 'vimish-fold-delete-all
         "zf" 'vimish-fold-create+)
        ;; (:keymaps '(vimish-fold-unfolded-keymap
        ;;             vimish-fold-folded-keymap)
        ;;  "TAB"   'vimish-fold-toggle
        ;;  "<tab>" 'vimish-fold-toggle)
        )
    #+END_SRC

*** evil-mode
    come to the dark side, we have cookies... :)

    #+BEGIN_SRC emacs-lisp
      (use-package evil
        :straight t
        :demand t
        :init
        (defun evil-set-initial-state+ (mode state)
          (with-eval-after-load 'evil
            (evil-set-initial-state mode state)
            (dolist (buffer (buffer-list))
              (with-current-buffer buffer
                (when (eq major-mode mode)
                  (evil-change-state state))))))

        :config
        (evil-mode 1)

        (evil-set-initial-state 'prog-mode 'normal)
        (evil-set-initial-state 'text-mode 'normal)
        (evil-set-initial-state 'conf-mode 'normal)

        (with-no-warnings
          (defvaralias 'evil-ex-search-history 'regexp-search-ring))

        ;; from [[https://github.com/hlissner/doom-emacs/blob/develop/modules/editor/evil/config.el#L137][doom]].
        (advice-add #'evil-global-marker-p :before-until
                    (defun evil--make-numbered-markers-global+ (char)
                      (and (>= char ?2) (<= char ?9))))

        ;; [[https://raw.githubusercontent.com/troyp/evil-adjust/master/evil-adjust.el][evil-adjust]]
        (defmacro with-evil-adjust-to-eol (&rest body)
          `(let ((-last-evil-state evil-state)
                 (evil-echo-state nil))
             (when (member evil-state '(normal visual))
               (evil-append 1)) ; switch to insert state
             (condition-case err
                 (progn ,@body)
               (error
                (evil-change-state -last-evil-state)
                (signal (car err) (cdr err))))
             (evil-change-state -last-evil-state)))
        (put 'with-evil-adjust-to-eol 'lisp-indent-function 'defun)

        ;; force state for buffer if it already exists
        (let ((buffer (get-buffer "*Messages*")))
          (when buffer
            (with-current-buffer buffer
              (evil-motion-state))))

        :lazy-leader
        ("je" 'evil-goto-definition
         "id" 'evil-insert-digraph
         "sc" '("search-noh" . evil-ex-nohighlight)
         "xu" 'evil-upcase
         "xd" 'evil-downcase)

        :general
        ("M-g" 'evil-change-to-initial-state)
        (:states '(motion insert)
         "C-a" 'beginning-of-line
         "C-e" 'end-of-line)
        (:states '(insert emacs multiedit)
         "C-o" 'evil-copy-from-above
         "M-o" 'evil-copy-from-below
         "C-c C-o" 'evil-execute-in-normal-state)
        ("C->" 'evil-shift-right-line
         "C-<" 'evil-shift-left-line)
        (:states 'normal
         "gU" nil
         "gq" nil
         "K"  'evil-join-backwards
         "gu" 'evil-upcase
         "gd" 'evil-downcase
         "g@" 'what-cursor-position
         "ga" 'evil-fill-and-move
         "g-" 'evil-indent
         "<C-return>" 'xref-find-definitions
         "M-RET" 'xref-find-definitions-other-window)
        (:states '(normal motion)
         ;; Y = yy is easy   to press
         ;; Y = y$ is harder to press
         "Y" (general-simulate-key "y$"))
        (:states '(normal insert)
         "C-k"   'evil-join-backwards
         "C-M-k" 'evil-join-backwards)
        (:states 'insert
         "M-k" nil
         "C-d" nil
         "C-t" nil

         "<tab>"           'indent-relative
         "TAB"             'indent-relative
         "<S-tab>"         'indent-back-to-normal
         "<S-iso-lefttab>" 'indent-back-to-normal
         "<S-backspace>"   'evil-delete-char

         "C-y" 'yank
         "M-y" 'yank-unindented

         ;; (kbd "C-M-k") 'evil-insert-digraph
         "C-l" 'forward-char
         "C-h" 'backward-char
         "C-n" 'evil-next-line
         "C-p" 'evil-previous-line
         "C-w" 'backward-kill-word)
        (:states 'visual
         "C-y" 'evil-paste-after)
        (:states 'motion
         "C-o" 'evil-jump-backward
         "M-o" 'evil-jump-forward
         "C-b" 'evil-scroll-line-up
         "C-f" 'evil-scroll-line-down
         "\""  'evil-use-register
         "zn"  'evil-scroll-column-right
         "zN"  'evil-scroll-right
         "zp"  'evil-scroll-column-left
         "zP"  'evil-scroll-left

         "gN" nil
         "gn" 'evil-next-match
         "gp" 'evil-previous-match

         ;; NOTE: These will probably always be overidden
         "gj" 'evil-next-visual-line
         "gk" 'evil-previous-visual-line
         "gq" 'quit-window
         "g=" 'count-words
         "g;" 'evil-repeat-find-char-reverse
         "m"  'evil-set-marker
         "-"  'negative-argument
         "q"  'quit-window)
        (:states 'motion
         :override t
         "gr" 'revert-buffer
         "gR" 'read-only-mode
         "gz" 'recenter-top-bottom)
        (:keymaps 'evil-ex-completion-map
         "C-a" 'move-beginning-of-line
         "C-e" 'move-end-of-line
         "C-M-q" 'quit-window)
        (:keymaps 'emacs-window-map
         "+" 'evil-window-increase-height
         "-" 'evil-window-decrease-height
         "<" 'evil-window-decrease-width
         ">" 'evil-window-increase-width
         "=" 'balance-windows
         "-" 'evil-window-set-width
         "|" 'evil-window-set-height

         "C-1" 'evil-window-top-left
         "C-0" 'evil-window-bottom-right

         ;; ("u" . evil-window-rotate-upwards)
         ;; ("i" . evil-window-rotate-downwards)
         "C-q" 'evil-window-mru ;; last buffer, new window

         ;; TODO maximise buffer
         "C-M-h" 'evil-window-move-far-left
         "C-M-j" 'evil-window-move-far-down
         "C-M-k" 'evil-window-move-far-up
         "C-M-l" 'evil-window-move-far-right

         ;; NOTE bindings with control variants
         "n"   'evil-window-next
         "C-n" 'evil-window-next
         "p"   'evil-window-prev
         "C-p" 'evil-window-prev
         "s"   'evil-window-split
         "M-s" 'evil-window-split
         "v"   'evil-window-vsplit
         "M-v" 'evil-window-vsplit
         "S"   'split-window-below-and-focus
         "C-s" 'split-window-below-and-focus
         "V"   'split-window-right-and-focus
         "C-v" 'split-window-right-and-focus
         "d"   'evil-window-delete
         "C-d" 'evil-window-delete
         "h"   'evil-window-left
         ;; "C-h" 'evil-window-left
         "j"   'evil-window-down
         ;; "C-j" 'evil-window-down
         "k"   'evil-window-up
         ;; "C-k" 'evil-window-up
         "l"   'evil-window-right
         ;; "C-l" 'evil-window-right
         "c"   'evil-window-create
         "C-c" 'evil-window-create))
    #+END_SRC

*** commands
    Where I keep my own evil operators/commands/*witchcraft*.

    #+BEGIN_SRC emacs-lisp
      (evil-define-operator evil-capitalize (beg end)
        (capitalize-region beg end))

      (defun evil-shift-normal-state (&optional arg)
        "return to normal state while also removing
      any trailing whitespace from the current line"
        (interactive "P")
        (remove-all-trailing-whitespace (line-beginning-position)
                                        (line-end-position))
        (evil-normal-state arg))

      (evil-define-operator evil-narrow-yank (beg end type register yank-handler)
        "`evil-yank' except block yanks are yanked as their own lines.
      evil by default yanks them such that you can compose them onto other lines.
      this isn't always desirable (especially when you want to filter a region onto
      it's own lines, thus this method satifies that requirement.

      eg:
      `evil-yank' cfj then `evil-paste-after'.
        ab|c|   >   abc|c
        de|f|   >   deff
        gh|j|   >   ghjj

      `evil-narrow-yank' cfj then `evil-paste-after'.
        ab|c|   >   abc
        de|f|   >   |c
        gh|i|   >   f
                >   j
                >   def
                >   ghj
      "
        (interactive "<R><x><y>")
        (evil-visual-restore)
        (if (eq type 'block)
            (progn
              (evil-yank-rectangle beg end ?\" yank-handler)

              (with-temp-buffer
                (evil-paste-before nil ?\")
                (evil-yank (point-min) (point-max) 'line register yank-handler)))
          (evil-yank beg end type register yank-handler)))

      (evil-define-operator evil-toggle-comment (beg end)
        :type        line
        :repeat      t
        :move-point  nil
        :keep-visual nil
        "run `toggle-comment-at-point' using evil motion."
        (toggle-comment-at-point beg end))

      (defun evil-adjust-eval-print-last-sexp ()
        (interactive)
        (save-excursion
          (with-evil-adjust-to-eol
            (funcall-interactively 'eval-print-last-sexp)
            (message nil))))

      (defun evil-adjust-eval-replace-last-sexp ()
        (interactive)
        (with-evil-adjust-to-eol
          (funcall-interactively 'eval-replace-last-sexp)
          (message nil)))

      (evil-define-operator evil-reverse (beg end)
        :type line
        :repeat t
        "evil command to reverse lines over range."
        (reverse-region beg end))

      (evil-define-operator evil-ansi-render (beg end)
        :repeat t
        "render ansi-color escape sequences between BEG and END."
        ;; source [[https://stackoverflow.com/questions/23378271/how-do-i-display-ansi-color-codes-in-emacs-for-any-mode][here]].
        (require 'ansi-color)
        (let ((inhibit-read-only (or inhibit-read-only
                                     (y-or-n-p "buffer is read only, ignore: "))))
          (barf-if-buffer-read-only)
          (ansi-color-apply-on-region beg end)))

      ;; ;; Enable terminal copy to cliboard
      ;; (evil-define-operator evil-copy-to-clipboard (beg end)
      ;;   "Copies selection to x-clipboard."
      ;;   :repeat      t
      ;;   :move-point  nil
      ;;   :keep-visual nil
      ;;   (interactive)
      ;;   (if (display-graphic-p)
      ;;       (clipboard-kill-ring-save beg end)
      ;;     (shell-command-on-region beg end "xclip -i -selection clipboard")))

      ;; (defun paste-from-clipboard ()
      ;;   "Pastes from x-clipboard."
      ;;   (interactive)
      ;;   (if (display-graphic-p)
      ;;       (clipboard-yank)
      ;;     (insert (shell-command-to-string "xclipl -o -selection clipboard"))))
    #+END_SRC

    #+BEGIN_SRC emacs-lisp
      (general-define-key
       :states 'normal
       "gC" 'evil-capitalize
       "gc" 'evil-toggle-comment)

      (general-define-key
       :states '(insert replace)
       "<S-escape>" 'evil-shift-normal-state)

      (general-define-key
       :states 'visual
       "gy" 'evil-narrow-yank)

      (general-define-key
       :states 'motion
       "g3" 'evil-ansi-render)

      (general-define-key
       :states '(normal visual insert)
       [remap eval-print-last-sexp]   'evil-adjust-eval-print-last-sexp
       [remap eval-replace-last-sexp] 'evil-adjust-eval-replace-last-sexp)

      (evil-ex-define-cmd "rev[erse]" 'evil-reverse)

      (leader/set-keys
        "xc" 'evil-capitalize)
    #+END_SRC

*** ex-bindings
    #+BEGIN_SRC emacs-lisp
      (evil-ex-define-cmd "W[RITE]" 'evil-write)

      (evil-ex-define-cmd "Wa[ll]"  'evil-write-all)
      (evil-ex-define-cmd "WA[LL]"  'evil-write-all)

      (evil-ex-define-cmd "wk[ill]" 'write-kill-buffer)
      (evil-ex-define-cmd "Wk[ill]" 'write-kill-buffer)
      (evil-ex-define-cmd "WK[ILL]" 'write-kill-buffer)

      (evil-ex-define-cmd "wb[ackup]" 'write-backup)
      (evil-ex-define-cmd "Wb[ackup]" 'write-backup)
      (evil-ex-define-cmd "WB[ACKUP]" 'write-backup)

      (evil-ex-define-cmd "a[s]ave" 'write-autosave)
      (evil-ex-define-cmd "A[s]ave" 'write-autosave)
      (evil-ex-define-cmd "A[S]AVE" 'write-autosave)

      (evil-ex-define-cmd "buffers" 'ibuffer)
    #+END_SRC

** org
*** org-agenda
    #+BEGIN_SRC emacs-lisp
      (use-package org-agenda
        :straight (org-agenda :type built-in)
        :defer t
        :config
        (evil-set-initial-state 'org-agenda-mode 'motion)

        :lazy-leader
        (:mode 'org-agenda-mode
         "." 'hydra-org-agenda/body
         "A" 'org-agenda-append-agenda
         "C" 'org-agenda-columns

         ;;; filter/search
         "/"  "filter/search"
         "/c" 'org-agenda-filter-by-category
         "/e" 'org-agenda-filter-by-effort
         "//" 'org-agenda-filter-by-regexp
         ;; "/t" 'org-agenda-filter-by-tag
         "/:" 'org-agenda-filter-by-tag
         "/h" 'org-agenda-filter-by-top-headline
         "/R" 'org-agenda-filter-remove-all

         "/?" 'org-agenda-bulk-mark-regexp
         "/a" 'org-agenda-bulk-mark-all
         "/u" 'org-agenda-bulk-unmark-all

         ;;; clock/calendar/diary
         "c"  "clock/calendar"
         "cp" 'org-agenda-date-prompt
         "cc" 'org-agenda-clock-in
         "co" 'org-agenda-clock-out
         "cC" 'org-agenda-clock-out ; alias
         "ct" 'org-timer-set-timer
         "c M-c" 'org-agenda-convert-date

         ;;; agenda minor modes
         "m"  "modes"
         "ma" 'org-agenda-archives-mode
         "md" 'org-agenda-day-view
         "mc" 'org-agenda-clockreport-mode
         "mt" 'org-agenda-entry-text-mode
         "mf" 'org-agenda-follow-mode
         "ml" 'org-agenda-log-mode
         "mw" 'org-agenda-week-view
         "my" 'org-agenda-year-view
         "mm" 'org-agenda-month-view

         ;;; priorities
         "p"  "priority"
         "pp" 'org-agenda-priority
         "pu" 'org-agenda-priority-up
         "pd" 'org-agenda-priority-down)

        :general
        (:keymaps 'org-agenda-mode-map
         :states  'motion
          ;;; globally useful
         [remap quit-window] 'org-agenda-exit
         "." 'org-agenda-goto-today
         "v" 'org-agenda-view-mode-dispatch
         "RET" 'org-agenda-goto
         "TAB" 'org-agenda-switch-to
         "M-c" 'org-agenda-clock-goto ; jumped to clocking task
         "C-t" 'org-agenda-todo
         "M-t" 'org-agenda-show-tags

          ;;; marking
         "C-<SPC>" 'org-agenda-bulk-mark
         "M-<SPC>" 'org-agenda-bulk-unmark
         "C-M-SPC" 'org-agenda-bulk-action

          ;;; undo/redo
         "C-r" 'org-agenda-redo
         "u"   'org-agenda-undo
         "gr"        'org-agenda-redo-all

          ;;; toggle displays
         "gm" 'org-agenda-phases-of-moon
         "C-l" 'org-agenda-log-mode
         "M-l" 'org-agenda-toggle-time-grid
         "M-h" 'org-agenda-holidays
         "M-s" 'org-agenda-sunrise-sunset

         ;; edit org items
         "M-e" 'org-agenda-set-effort
         "C-a" 'org-agenda-archive-default-with-confirmation

          ;;; notes and insertion
         "a"  'org-agenda-add-note
         "c"  'org-agenda-capture
         "gd" 'org-agenda-goto-date
         "gc" 'org-agenda-goto-calendar

          ;;; movement between lines
          ;;; NOTE org-next/prev-line is used by follow-mode
         "k"      'org-agenda-previous-line
         "j"      'org-agenda-next-line
         "<up>"   'org-agenda-previous-line ; alias
         "<down>" 'org-agenda-next-line     ; alias
         "C-j"    'org-agenda-next-item
         "C-k"    'org-agenda-previous-item

          ;;; move through time in blocks
         "f" 'org-agenda-later
         "F" 'org-agenda-earlier

         "C-f" 'org-agenda-follow-mode
         "M-f" 'org-agenda-recenterstates))
    #+END_SRC

*** org-bullets
    Better heading indicators in org buffers.

    #+BEGIN_SRC emacs-lisp
      (use-package org-bullets
        :straight t
        :defer  t
        :hook (org-mode . org-bullets-mode))
    #+END_SRC

*** org-link-edit
    TODO figure out what this does?

    #+BEGIN_SRC emacs-lisp :tangle no
      (use-package org-link-edit
        :straight (org-link-edit :host github :repo "kyleam/org-link-edit")
        :defer t
        :commands (org-link-edit-forward-slurp
                   org-link-edit-forward-barf
                   org-link-edit-backward-slurp
                   org-link-edit-backward-barf))
    #+END_SRC

*** org-contrib

    #+BEGIN_SRC emacs-lisp
      (use-package org-plus-contrib
        :straight t
        :defer t
        :after org
        :init
      ;;; org-eldoc
        (require 'org-eldoc)
        (org-eldoc-load)

        (defun org-eldoc-get-link+ ()
          "When point is on a link, show the link destination in eldoc."
          (let ((ctx (org-element-lineage (org-element-context) '(link) t)))
            (org-element-property :path ctx)))

        (advice-add 'org-eldoc-documentation-function :before-until #'org-eldoc-get-link+)

      ;;; org-man
        (setq org-man-command +man-command))
    #+END_SRC

*** org-toc
    #+BEGIN_SRC emacs-lisp :tangle no
      (use-package toc-org
        :straight t
        :defer  t
        ;; :hook (org-mode . toc-org-mode)
        )
    #+END_SRC

*** org-capture
    #+BEGIN_SRC emacs-lisp
      (use-package doct
        :straight (doct :github github :repo "progfolio/doct")
        :after org-capture
        :commands (doct)
        :demand t
        :init
        (setq doct-default-entry-type 'entry))
    #+END_SRC

    #+BEGIN_SRC emacs-lisp
      (use-package org-capture
        :after org
        :defer t
        :config
        (require '+org-capture)

        :lazy-leader
        (:mode 'org-capture-mode
         :minor t
         :prefix leader-major-mode-prefix
         "," 'org-capture-finalize
         "q" 'org-capture-kill
         "r" 'org-capture-refile)

        :general
        (:keymaps 'org-capture-mode-map
         [remap evil-save-and-close] 'org-capture-finalize
         [remap evil-quit] 'org-capture-kill))
    #+END_SRC

    #+BEGIN_SRC emacs-lisp :tangle lisp/+org-capture.el
      (defun org-capture-create-goto-heading-command (heading &optional heading-regexp)
        "create a function to jump to HEADING, creating HEADING if it doesn't exist.
      This function also smartly reacts to headings containing [/]. By default, if
      [/] has been updated to [0/1], then org is just unable to find it.
      "
        (unless heading-regexp
          (setq heading-regexp (regexp-quote heading))

          (when (string-match-p (rx "[/]") heading-regexp)
            (setq heading-regexp
                  (replace-regexp-in-string
                   (regexp-quote "[/]")
                   "[[[:digit:]]*/[[:digit:]]*\\\\]"
                   heading-regexp))))

        (lambda ()
          (let ((heading-point
                 (ignore-errors
                   (save-excursion
                     (goto-char (point-min))
                     (search-forward-regexp heading-regexp)
                     (line-beginning-position)))))
            (if heading-point
                (goto-char heading-point)
              (goto-char (point-min))
              (save-excursion
                (insert heading "\n"))))))

      (defun org-get-link+ ()
        "get the stringified result of `org-store-link'"
        (with-temp-buffer
          (org-insert-link-global)
          (buffer-substring (point-min) (point-max))))

      ;; see also: https://www.gnu.org/software/emacs/manual/html_node/org/Template-expansion.html#Template-expansion
      (setq
       org-capture-templates
       (doct `((:group "TODOs"
                       :type entry
                       :file ,org-default-notes-file
                       :prepend     t
                       :empty-lines 0
                       :function ,(org-capture-create-goto-heading-command "* TODOs [/]")
                       :before-finalize ,#'org-update-parent-todo-statistics
                       :template ("* %{todo-state} %?"
                                  "  %U")
                       :todo-state "TODO"
                       :children (("Todo" :keys "t")
                                  ("Todo with Clipboard"
                                   :keys "T"
                                   :template ("* %{todo-state} %?"
                                              "  %U"
                                              "  %c"))
                                  ("Itinerary"
                                   :keys "d"
                                   :prepend  nil
                                   :function ,(org-capture-create-goto-heading-command "* Itinerary")
                                   :template ("* %{todo-state} %?"))
                                  ("Job Application"
                                   :keys "j"
                                   :function ,(org-capture-create-goto-heading-command "* Job Search [/]")
                                   :template ("* %{todo-state} [#%^{Priority|A|B|C}] %(org-get-link+) - %^{Company}"
                                              "  DEADLINE: %^{deadline}t"
                                              "%^{LOCATION}p%^{DURATION}p"
                                              "  %?"))))
               (:group "education"
                       :type entry
                       :file "university/university.org"
                       :empty-lines 1
                       :children (("Lecture"
                                   :keys "l"
                                   :clock-in t
                                   :template ("* [/] %^{title} %^g"
                                              "  %?"))))))

       ;; Templates for projectile-projects.
       projectile-org-capture-templates+
       (doct `(("[${name}] Task"
                :keys "p"
                :template ("* TODO %?"
                           "  %U")
                :file ,(join-path org-projectile-projects-directory "${name}.org")))))

      (provide '+org-capture)
    #+END_SRC

*** commands
    #+BEGIN_SRC emacs-lisp
      (use-package +org-commands
        :commands (org-outline-smart-up-level
                   org-openable-p
                   org-find-file
                   org-clever-return)
        :leader
        ("oo" 'org-find-file)

        :general
        (:keymaps 'org-mode-map
         :states 'insert
         "RET"      'org-clever-return
         "<return>" 'org-clever-return))
    #+END_SRC

    #+BEGIN_SRC emacs-lisp :tangle lisp/+org-commands.el
      (defun org-outline-smart-up-level ()
        "when at a heading, move to parent
      otherwise move to current heading."
        (interactive)
        (call-interactively (if (org-at-heading-p)
                                'outline-up-heading
                              'outline-previous-heading)))

      (defun org-openable-p ()
        (org-element-lineage
         (org-element-context)
         '(footnote-definition
           footnote-reference
           headline
           ;; inlinetask
           link
           timestamp)
         t))

      (defvar org-clever-return--insert-headings nil
        "when true, returning from the end of a heading
      inserts a heading.")

      (defun org-clever-return (&optional above)
        "depending on the local state, inserts a heading, a table row an item or newline.
      this function is functionally similair to the result of evil-org-eol-call-anon, but
      instead of checking the line after moving to the end of it (which doesn't work for
      folded lines, such as headings), it checks before moving and then inserts the right
      items depending on how things looked where you were."
        (interactive)
        (cl-letf (((symbol-function 'evil-open)
                   (lambda () (call-interactively
                          (if above
                              'evil-open-above
                            'evil-open-below))))
                  ((symbol-function 'fallback-action)
                   (lambda (&optional interactive)
                     (when (and (line-empty-p)
                                (not (zerop (column-number (point)))))
                       ;; don't leave a trailing indent on current line unecessarily
                       (remove-all-trailing-whitespace (line-beginning-position)
                                                       (line-end-position)))
                     (if (and interactive (not above))
                         (funcall-interactively
                          'newline-and-indent)
                       (evil-open)
                       ))))
          (if (and current-prefix-arg (listp current-prefix-arg))
              ;; when called with simple prefix, goto
              ;; fallaback action.
              (let ((current-prefix-arg nil))
                (fallback-action))
            (cond ((org-table-p)
                   (org-table-insert-row (not above))
                   (evil-insert nil))

                  ((and org-clever-return--insert-headings
                        (org-at-heading-p))
                   (evil-open)
                   (org-insert-heading))

                  ((org-at-item-p)
                   ;; position of cursor dictates where new point goes
                   (if above
                       (goto-char (line-beginning-position))
                     (goto-char (line-end-position)))
                   (org-insert-item)
                   (evil-append nil))

                  (t (fallback-action (called-interactively-p)))))))

      ;;; org-find-file
      (defun org-find-file--generate-candidate (file)
        (let ((relative (file-relative-name file dotemacs-org-path)))
          (if (string-prefix-p ".." relative)
              (cons file file)
            (cons relative file))))

      (defun org-find-file (&optional arg initial-input)
        "find an org file.
      By default this function simply finds the default notes file, as indicated
      by `org-default-notes-file'. When ARG is non-nil, you are instead prompted
      interactively with all org files known to emacs (through `dotemacs-org-path',
      `dotemacs-agenda-files' etc.) and then allowed to select which one to visit."
        (interactive "P")
        (if (not arg)
            (find-file org-default-notes-file)
          (let ((cands (mapcar #'org-find-file--generate-candidate
                               (cl-remove-if
                                (apply-partially #'string-match-p +find-file-ignore-regexp)
                                (cl-remove-duplicates
                                 (append (file-expand-wildcards (org! "*.org"))
                                         (file-expand-wildcards (org! "**/*.org"))
                                         org-agenda-files)
                                 :test (lambda (x y) (or (null y) (equal x y)))
                                 :from-end t)))))
            (cond
             ((package! ivy)
              (ivy-read "Find file: " cands
                        :initial-input initial-input
                        :require-match t
                        :action #'find-file
                        :caller 'org-find-file))
             ((package! selectrum)
              (find-file
               (consult--read cands
                              :prompt "Find file: "
                              :require-match t
                              :category 'file
                              :lookup #'consult--lookup-cdr)))
             (t (find-file
                 (alist-get (completing-read "Find file: " cands nil t initial-input)
                            nil nil #'string-equal)))))))

      (when (package! ivy)
        (ivy-set-actions 'org-find-file
         '(("j" find-file-other-window "other window")
           ("f" find-file-other-frame  "other frame"))))
    #+END_SRC

*** org-mode
    #+BEGIN_SRC emacs-lisp
      ;; See [[https://emacs.stackexchange.com/questions/58994/symbol-s-value-as-variable-is-void-org-priority-highest-using-org-agenda][here]].
      (defvaralias 'org-priority-highest 'org-highest-priority)
      (defvaralias 'org-priority-lowest  'org-lowest-priority)

      (use-package org
        :straight '(org :type built-in)
        :defer t
        :hook (org-mode . display-line-numbers-mode)
        :commands (org-completing-goto+)
        :init
        (add-hook 'org-mode-hook
                  (lambda (&rest _)
                    (modify-syntax-entry ?< "_" org-mode-syntax-table)
                    (modify-syntax-entry ?> "_" org-mode-syntax-table)))

        (advice-add 'evil-ret-gen :before-until
                    (defun evil-ret-open-org-links+ (&rest _)
                      "hitting return in evil-normal-state on an org-link
      opens the org-link."
                      (when (and
                             (evil-normal-state-p)
                             (or (featurep 'org)
                                 (bound-and-true-p org-link-minor-mode))
                             (ignore-errors
                               (org-openable-p)))
                        (org-open-at-point)
                        t)))

        (defmacro evil-org-eol-call-anon (&rest body)
          "define an anonymous function running body at the end of the line"
          `(lambda! (end-of-visual-line) ,@body (evil-append nil)))

        (defmacro org-read-date-command (name &rest body)
          "define a function for use in the calendar buffer for `calendar-read-date'."
          `(defun ,(intern (concat "org-read-date-" (symbol-name name) "+")) ()
             ,(when (stringp (car body))
                (concat (pop body) "\nThis function was generated by `org-read-date-command'."))
             (interactive)
             (org-eval-in-calendar (quote (progn ,@body)))))
        (put 'org-read-date-command 'lisp-indent-function 'defun)

        :config
        (setq org-src-window-setup 'current-window
              org-goto-interface 'outline-path-completion
              org-todo-keywords '((sequence "TODO" "DOING" "VERIFY" "|" "DONE" "DELAGATED" "SKIPPED"))
              org-refile-targets '((nil :maxlevel . 9)
                                   (org-agenda-files :maxlevel . 9))
              org-log-done 'time ; record when a TODO item is done.
              org-outline-path-complete-in-steps nil ; refile in a single go
              org-refile-use-outline-path t  ; show full paths for refiling
              org-cycle-separator-lines 0 ; prevents weird coloring of collapsed trees
              org-log-into-drawer "LOGBOOK" ; where org-add-note stores notes

              ;; break org-cycle-seperator-lines from working automatically
              ;; org-blank-before-new-entry '((heading . nil) (plain-list-item . auto))

              ;; native tabs are slow and unreliable... :sad:
              org-src-tab-acts-natively nil
              org-fontify-done-headline nil

              org-agenda-files (append
                                (file-expand-wildcards (org! "*.org"))
                                (file-expand-wildcards (org! "university/*.org")))

              org-archive-location (concat (org! "archive.org") "::* %s"))

        (setq org-archive-file-header-format
              "# -*- mode: org; coding: utf-8-unix -*-
      ,#+TITLE: Archive
      ,#+STARTUP: content")

        ;; Initialised here to prevent org from defining a bunch of keys I won't
        ;; end up using :P
        (setq org-read-date-minibuffer-local-map (make-sparse-keymap)
              org-confirm-babel-evaluate nil)
        (set-keymap-parent org-read-date-minibuffer-local-map minibuffer-local-map)

        ;; switch to insert state when capturing org templates
        (add-hook 'org-capture-mode-hook (lambda () (evil-insert nil)) t)

        (advice-add 'org-edit-src-code :after
                    (lambda (&rest args)
                      "prevents org mode from restoring the window config before
      source code edit. when you run `org-edit-src-code' the window configuration
      from before the edit is saved, and when you exit the session it's restored.
      Any windows/buffers you open while in an edit get erased. This prevents that
      happening."
                      (setq org-src--saved-temp-window-config nil)))

        (let ((lob-file (etc! "babel-lib.org")))
          (when (file-exists-p lob-file)
            (org-babel-lob-ingest lob-file)))

        (advice-add 'org-edit-src-code :before (lambda (&rest args)
                                                 (unless (eq evil-state 'normal)
                                                   (evil-normal-state))))

        (defun org-completing-goto+ ()
          (interactive)
          (org-refile '(4)))

        ;;  _
        ;; | | __ _ _ __   __ _ _   _  __ _  __ _  ___  ___
        ;; | |/ _` | '_ \ / _` | | | |/ _` |/ _` |/ _ \/ __|
        ;; | | (_| | | | | (_| | |_| | (_| | (_| |  __/\__ \
        ;; |_|\__,_|_| |_|\__, |\__,_|\__,_|\__, |\___||___/
        ;;                |___/             |___/

        (org-babel-do-load-languages 'org-babel-load-languages
         '((emacs-lisp . t)
           (awk        . t)
           (C          . t)
           (awk        . t)
           (haskell    . t)
           (latex      . t)
           (java       . t)
           (js         . t)
           (ditaa      . t)
           (plantuml   . t)
           (python     . t)
           (ruby       . t)
           (sed        . t)
           (shell      . t)
           (R          . t)))

        ;;             _ _       _     _           _ _
        ;;   _____   _(_) |     | |__ (_)_ __   __| (_)_ __   __ _ ___
        ;;  / _ \ \ / / | |_____| '_ \| | '_ \ / _` | | '_ \ / _` / __|
        ;; |  __/\ V /| | |_____| |_) | | | | | (_| | | | | | (_| \__ \
        ;;  \___| \_/ |_|_|     |_.__/|_|_| |_|\__,_|_|_| |_|\__, |___/
        ;;                                                   |___/

        (evil-set-command-property 'org-outline-smart-up-level :jump t)
        (evil-set-command-property 'org-forward-heading-same-level :jump t)
        (evil-set-command-property 'org-backward-heading-same-level :jump t)
        (evil-set-command-property 'org-next-visible-heading :jump t)

        :leader
        ("o"  "org"
         "oc" 'org-capture
         "og" 'org-capture-goto-last-stored
         "oa" 'org-agenda
         "ol" 'org-store-link
         "oi" 'org-insert-link-global
         "oy" 'org-copy-subtree
         "oY" 'org-cut-subtree
         "on" 'org-next-link
         "op" 'org-previous-link

         "oh" 'org-completing-goto+)

        :lazy-leader
        (:mode 'org-mode
         "RET" 'org-ctrl-c-ret
         "TAB" 'org-todo
         "SPC" 'org-display-outline-path
         "!" 'org-time-stamp-inactive
         "'" 'org-edit-special
         "*" 'org-ctrl-c-star
         "," 'org-ctrl-c-ctrl-c
         "-" 'org-ctrl-c-minus
         "." 'org-time-stamp
         "/" 'org-sparse-tree
         ":" 'org-set-tags-command
         "#" 'org-priority
         "`" 'org-toggle-latex-fragment
         "^" 'org-sort
         "A" 'org-agenda
         "a" 'org-archive-subtree
         "b" 'org-tree-to-indirect-buffer
         ;; "C" 'evil-org-recompute-clocks
         "D" 'org-insert-drawer
         "d" 'org-deadline
         "f" 'org-set-effort
         "i" 'org-clock-in
         "H" 'org-shiftleft
         "J" 'org-shiftdown
         "K" 'org-shiftup
         "L" 'org-shiftright
         "l" 'org-insert-link
         "N" 'org-add-note
         "o" 'org-clock-out
         "O" 'org-sort
         "p" 'org-set-property
         "P" 'org-pomodoro
         "q" 'org-set-tags-command
         "r" 'org-refile
         "R" 'org-refile-goto-last-stored
         "s" 'org-schedule
         "T" 'org-show-todo-tree
         "U" 'org-update-all-dblocks
         "u" 'org-dblock-update
         ;; "C-h" 'org-shiftcontrolleft
         ;; "C-j" 'org-shiftcontroldown
         ;; "C-k" 'org-shiftcontrolup
         ;; "C-l" 'org-shiftcontrolright
         "M-a" 'org-attach
         "M-c" 'org-columns
         "M-p" 'org-delete-property

         "c"  "clock/calendar"
         "c<" 'org-date-from-calendar
         "c>" 'org-goto-calendar
         "cC" 'org-clock-out
         "cc" 'org-clock-in
         ;; "cf" 'org-clock-modify-effort-estimate
         "cg" 'org-clock-goto
         "ch" 'org-clock-remove-overlays
         "ci" 'org-timer-item
         "cr" 'org-clock-report
         "cs" 'org-clock-display
         "c." 'hydra-org-clock/body
         "c C-c" 'org-clock-cancel

         "e"  "export"
         "ee" 'org-export-dispatch
         "eh" 'org-html-export-to-html

         "h"  "headings"
         "hI" 'org-insert-heading
         "hi" 'org-insert-heading-after-current
         "hs" 'org-insert-subheading

         "I"  "insert"
         "Ia" 'org-attach
         "If" 'org-footnote-new
         ;; "Ik" 'insert-keybinding-org
         "It" 'org-table-create
         ;; "Is" 'org-download-screenshot
         ;; "Iy" 'org-download-yank

         "m"  "mark/move"
         "ms" 'org-mark-subtree
         "me" 'org-mark-element
         "mb" 'org-babel-mark-block
         "mm." 'hydra-org-navigate/body

         "n"  "narrow"
         "nb" 'org-narrow-to-block
         "ns" 'org-narrow-to-subtree
         "ne" 'org-narrow-to-element
         "nw" 'widen

         "S"  "subtrees"
         "Sh" 'org-promote-subtree
         "Sj" 'org-move-subtree-down
         "Sk" 'org-move-subtree-up
         "Sl" 'org-demote-subtree

         "t" "tables"
         "t'"  'org-table-edit-field
         "ta"  'org-table-align
         "tb"  'org-table-blank-field
         "tc"  'org-table-convert
         "tE"  'org-table-export
         "te"  'org-table-eval-formula
         "tH"  'org-table-move-column-left
         "th"  'org-table-previous-field
         "tI"  'org-table-import
         "tJ"  'org-table-move-row-down
         "tj"  'org-table-next-row
         "tK"  'org-table-move-row-up
         "tL"  'org-table-move-column-right
         "tl"  'org-table-next-field
         "tN"  'org-table-create-with-table.el
         "tn"  'org-table-create
         "tp"  'org-plot/gnuplot
         "tr"  'org-table-recalculate
         "ts"  'org-table-sort-lines
         "tw"  'org-table-wrap-region

         "td"  "delete"
         "tdc" 'org-table-delete-column
         "tdr" 'org-table-delete-row

         "ti"  "insert"
         "tic" 'org-table-insert-column
         "ti-" 'org-table-hline-and-move
         "tih" 'org-table-insert-hline
         "tir" 'org-table-insert-row

         "tt"  "toggle"
         "ttf" 'org-table-toggle-formula-debugger
         "tto" 'org-table-toggle-coordinate-overlays

         ;; "x"  "text"
         ;; "xb" 'org-bold
         ;; "xc" 'org-code
         ;; "xi" 'org-italic
         ;; "xr" 'org-clear
         ;; "xs" 'org-strike-through
         ;; "xu" 'org-underline
         ;; "xv" 'org-verbose
         )

        :general
        (:keymaps 'org-mode-map
         ;; "C-M-<return>" 'org-meta-return
         "<C-tab>" nil
         "M-S-<return>" nil
         "C-e" nil
         "M-e" nil
         "M-h" nil
         "C-j" nil)
        (:keymaps 'org-mode-map
         :states 'insert
         "DEL" 'org-delete-backward-char
         "<S-backspace>" 'org-delete-char)
        (:keymaps 'org-mode-map
         :states 'normal
         "o" (lambda!
              (let ((org-clever-return--insert-headings t))
                (org-clever-return nil)))
         "O" (lambda!
              (let ((org-clever-return--insert-headings t))
                (org-clever-return t)))
         ;; "M-u" 'org-metaleft
         ;; "M-i" 'org-metadown
         ;; "M-o" 'org-metaup
         ;; "M-p" 'org-metaright
         ;; "M-U" 'org-shiftmetaleft
         ;; "M-I" 'org-shiftmetadown
         ;; "M-O" 'org-shiftmetaup
         ;; "M-P" 'org-shiftmetaright
         )
        (:keymaps 'org-mode-map
         :states '(normal insert)
         ;; NOTE meta keys insert headings with changed priority, shift keys insert todo headings
         ;; FIXME prefix arg doesn't work
         "C-<return>"   (evil-org-eol-call-anon
                         (org-insert-heading nil))

         "C-M-<return>" (evil-org-eol-call-anon
                         (org-insert-heading nil)
                         (if current-prefix-arg
                             (org-metaleft)
                           (org-metaright)))

         "C-S-<return>"   (evil-org-eol-call-anon
                           (org-insert-todo-heading nil))

         "C-S-M-<return>" (evil-org-eol-call-anon
                           (org-insert-todo-heading nil)
                           (if current-prefix-arg
                               (org-metaleft)
                             (org-metaright)))

         "C-." 'org-toggle-heading)
        ;; Most evil bindings taken from [[https://github.com/edwtjo/evil-org-mode][evil-org-mode]].
        (:keymaps 'org-mode-map
         :states '(normal visual)
         "gh" 'org-outline-smart-up-level
         "gj" 'org-forward-heading-same-level
         "gk" 'org-backward-heading-same-level
         "gl" 'outline-next-visible-heading
         "g." 'hydra-org-navigate/body
         "$" 'org-end-of-line
         "^" 'org-beginning-of-line)
        (:keymaps 'org-mode-map
         :states  'visual
         "gb" 'org-babel-mark-block
         "gB" 'org-mark-element)
        (:keymaps 'org-mode-map
         :states '(normal visual)
         :predicate '(or (org-table-p t)
                         (org-at-heading-p)
                         (org-at-item-p))
         [remap drag-stuff-down] 'org-metadown
         [remap drag-stuff-up]   'org-metaup)
        ;; navigate throught tables or lists with tab in insert state.
        (:keymaps 'org-mode-map
         :states 'insert
         :predicate '(or (org-table-p t)
                         (org-at-heading-p)
                         (org-at-item-p))
         "<tab>"   'org-cycle
         "TAB"     'org-cycle
         "<S-tab>" 'org-shifttab)
        (:keymaps 'org-mode-map
         :states '(normal visual emacs)
         "<tab>"   'org-cycle
         "TAB"     'org-cycle
         "<S-tab>" 'org-shifttab)
        (:keymaps 'org-mode-map
         :states '(normal insert visual)
         :predicate '(org-at-heading-p)
         [remap evil-shift-right] 'org-demote-subtree
         [remap evil-shift-left]  'org-promote-subtree
         [remap evil-shift-right-line] 'org-demote-subtree
         [remap evil-shift-left-line]  'org-promote-subtree)
        (:keymaps 'org-read-date-minibuffer-local-map
         ;; haven't implemented backward year, or forward year... cause when will
         ;; I ever need those.
         "C-M-j" 'exit-minibuffer
         "C-j" (org-read-date-command forward-week   (calendar-forward-week 1))
         "C-k" (org-read-date-command backward-week  (calendar-backward-week 1))
         "C-h" (org-read-date-command backward-day   (calendar-backward-day 1))
         "C-l" (org-read-date-command forward-day    (calendar-forward-day 1))
         "C-n" (org-read-date-command forward-month  (calendar-forward-month 1))
         "C-p" (org-read-date-command backward-month (calendar-backward-month 1))
         "<"   (org-read-date-command scroll-left    (calendar-scroll-left 1))
         ">"   (org-read-date-command scroll-right   (calendar-scroll-right 1))
         "!"   (org-read-date-command view-diary     (diary-view-entries))
         "."   (org-read-date-command goto-today
                 "when at end of prompt, goto today in calendar."
                 (if (looking-back "^[^:]+: "
                                   (let ((inhibit-field-text-motion t))
                                     (line-beginning-position)))
                     (org-eval-in-calendar '(calendar-goto-today))
                   (insert ".")))))
    #+END_SRC

*** org-export
    #+BEGIN_SRC emacs-lisp
      (use-package +org-export-config :demand t :after org)
      (setq org-export-async-init-file (lisp! "+org-async-init.el"))
    #+END_SRC

    #+BEGIN_SRC emacs-lisp :tangle lisp/+org-export-config.el
      (add-to-list 'org-latex-packages-alist '("" "mathdots"))
      (add-to-list 'org-latex-packages-alist '("" "fourier"))
      (add-to-list 'org-latex-packages-alist '("" "yfonts"))

      (setq-default
       org-latex-pdf-process (list "latexmk -shell-escape -bibtex -f -pdf %f")
       org-babel-python-command "python3"
       org-ditaa-jar-path (var! "org/bin/ditaa.jar")
       org-ditaa-eps-jar-path (var! "org/bin/ditaaEps.jar")
       org-plantuml-jar-path (var! "org/bin/plantuml.jar"))

      (provide '+org-export-config)
    #+END_SRC

**** async-init
     :PROPERTIES:
     :header-args+: :tangle lisp/+org-async-init.el
     :END:

     init.el file for asynchronous compilation.

     #+BEGIN_SRC emacs-lisp
       (require 'ox)

       (load (concat user-emacs-directory "lisp/+init-paths"))

       (package-initialize)
       (require 'org-ref)

       (load (bin! "lisp/misc/+org-export-config.el"))
     #+END_SRC

*** org-src
    #+BEGIN_SRC emacs-lisp
      (use-package org-src
        :defer t
        :leader
        (:mode 'org-src-mode
         :minor t
         :prefix leader-major-mode-prefix
         "," 'org-edit-src-exit
         "q" 'org-edit-src-abort
         "s" 'org-edit-src-save)

        :general
        (:keymaps 'org-src-mode-map
         [remap evil-write] 'org-edit-src-save
         [remap evil-quit] 'org-edit-src-abort
         ;; save and then quit
         [remap evil-save-and-close] 'org-edit-src-exit
         [remap evil-save-modified-and-close] 'org-edit-src-exit))
    #+END_SRC

*** org-compile
    Toggle the ability to automatically compile the current org file to a pdf
    on write. This would've required a lot less effort in vim :cry:.

    #+BEGIN_SRC emacs-lisp
      (use-package +org-compile
        :defer t
        :after org
        :commands org-toggle-compile-on-save+
        :leader
        (:mode 'org-mode
         "1" 'org-toggle-compile-on-save+))
    #+END_SRC

    #+BEGIN_SRC emacs-lisp :tangle lisp/+org-compile.el
      (defvar org-compile-on-save-buffers+ nil
        "org buffers which when saved will be compiled.")

      (defvar org-compile-on-save-async+ nil
        "whether compilation is asynchronous or concurrent.
      the async approach spawns a new emacs instance to compile the org-file.
      depending on your hardware this may be slower then simply waiting for
      your current emacs instance to finish.")

      (defun org-compile-on-save-command+ ()
        (when (cl-member (current-buffer) org-compile-on-save-buffers+ :test #'eq)
          (org-latex-export-to-pdf org-compile-on-save-async+)))

      ;; for some reason I can't make this hook buffer local :(
      (add-hook 'after-save-hook #'org-compile-on-save-command+)

      (defun org-toggle-compile-on-save+ (&optional arg)
        (interactive "P")
        "when the current org buffer is saved, compile and render pdf output through latex."
        (unless (derived-mode-p 'org-mode)
          (user-error "this function can only be called from an org-mode buffer."))

        (let* ((buf (if (bound-and-true-p org-capture-mode)
                        (plist-get org-capture-current-plist :buffer)
                      (current-buffer)))
               (member (member buf org-compile-on-save-buffers+))
               (value (if (not arg)
                          (not member)
                        (not (zerop (prefix-numeric-value arg))))))
          (unless (buffer-file-name buf)
            (user-error "cannot compile a buffer with no associated filename."))

          (if value
              (add-to-list 'org-compile-on-save-buffers+ buf nil #'eq)
            (setq org-compile-on-save-buffers+ (delq buf org-compile-on-save-buffers+)))

          ;; while I'm here, let's also remove any killed buffers.
          (setq org-compile-on-save-buffers+
                (cl-remove-if #'buffer-killed-p org-compile-on-save-buffers+))

          ;; notify the user about what's happened.
          (when (called-interactively-p)
            (message "compile-on-save: %s" (if value
                                               (propertize "enabled" 'face 'compilation-info)
                                             (propertize "disabled" 'face 'compilation-error))))))
    #+END_SRC

*** org-fragtog
    automatically render latex fragments in org mode.

    #+BEGIN_SRC emacs-lisp
      (use-package org-fragtog
        :straight t
        :defer  t
        :after org
        :config
        (when (host! 'desktop)
          (setq org-format-latex-options
                (plist-put org-format-latex-options :scale 1.5))))
    #+END_SRC

*** org-ql
    Lisp like query language for org mode.

    #+BEGIN_SRC emacs-lisp :tangle no
      (use-package org-ql
        ;; :straight t
        :straight t
        :defer  t
        :commands (ivy-org-ql-query
                   ivy-org-ql-query-picklink
                   ivy-org-ql-query-goto
                   ivy-org-ql-query-insert-link)
        :config
        ;; basically all of ivy-org-ql was just copied and pasted from
        ;; here: https://github.com/alphapapa/org-ql/issues/63
        (defvar ivy-org-ql-query-collect-timer nil)
        (defun ivy-org-ql-query-collect (input)
          (when ivy-org-ql-query-collect-timer
            (cancel-timer ivy-org-ql-query-collect-timer))
          (if (< (length input) 4)
              (list "" (format "%d chars more" (- 4 (length input))))
            (setq ivy-org-ql-query-collect-timer
                  (run-with-timer
                   0.25 nil
                   `(lambda ()
                      (let ((files (org-agenda-files))
                            (query (org-ql--plain-query  ,input)))
                        (when query
                          (ignore-errors
                            (setq ivy--all-candidates
                                  (or
                                   (org-ql-select files query
                                     :action (lambda ()
                                               (propertize (org-get-heading t)
                                                           'marker (copy-marker (point)))))
                                   '("" "Search no results!")))
                            (setq ivy--old-cands ivy--all-candidates)
                            (ivy--exhibit)))))))
            nil))

        (defun ivy-org-ql-query ()
          (interactive)
          (ivy-read "Org query: " #'ivy-org-ql-query-collect
                    :dynamic-collection t
                    :initial-input (ivy-org-ql-query-string)
                    :action #'ivy-org-ql-query-goto))

        (defun ivy-org-ql-query-picklink ()
          (interactive)
          (ivy-read "Org query: " #'ivy-org-ql-query-collect
                    :dynamic-collection t
                    :initial-input (ivy-org-ql-query-string)
                    :action #'ivy-org-ql-query-insert-link))

        (defun ivy-org-ql-query-string ()
          (when mark-active
            (buffer-substring-no-properties
             (region-beginning) (region-end))))

        (defun ivy-org-ql-query-goto (headline)
          (interactive)
          (let ((marker (get-text-property 0 'marker headline)))
            (when (markerp marker)
              (switch-to-buffer (marker-buffer marker))
              (goto-char marker)
              (org-show-entry))))

        (defun ivy-org-ql-query-insert-link (headline &optional link-type breadcrumbs)
          (interactive)
          (let ((marker (get-text-property 0 'marker headline))
                store-link)
            (when (markerp marker)
              (org-with-point-at marker
                (let* ((id (org-id-get (point) t))
                       (attach-dir (org-attach-dir t))
                       (breadcrumbs
                        (when breadcrumbs
                          (let ((s (org-format-outline-path
                                    (org-get-outline-path)
                                    (1- (frame-width))
                                    nil org-picklink-breadcrumbs-separator)))
                            (if (eq "" s) "" (concat s org-picklink-breadcrumbs-separator)))))
                       (item (concat (or breadcrumbs "") (org-entry-get (point) "ITEM")))
                       (link
                        (cl-case link-type
                          (attach (list :link attach-dir :description (concat item "(ATTACH)") :type "file"))
                          (t (list :link (concat "id:" id) :description item :type "id")))))
                  (setq store-link link)))
              (org-insert-link nil (plist-get store-link :link) (plist-get store-link :description))
              (cond ((org-in-item-p)
                     (call-interactively #'org-insert-item))
                    (t (insert " "))))))

        :leader
        ("oq" 'ivy-org-ql-query))
    #+END_SRC

*** org-roam
    note taking system centred around org-mode. you can tag notes using the
    ~roam_tags~ keyword and you can reference sources using ~roam_key~.

    NOTE: protocol installation requires some manual setup, see [[https://www.orgroam.com/manual/Installation-_00281_0029.html#Installation-_00281_0029][here]].
    TODO: try out [[https://github.com/org-roam/company-org-roam/][company-org-roam]].

    #+BEGIN_SRC emacs-lisp
      (use-package org-roam
        :straight t
        :defer t
        :diminish
        org-roam-mode
        :hook (after-init . org-roam-mode)
        :commands org-roam-rg
        :init
        (setq org-roam-db-update-idle-seconds 2
              org-roam-db-location (var! "org-roam.db")
              ;; org-roam-dailies-directory
              ;; org-roam-db-update-method 'immediate
              )

        :config
        (require '+org-capture)
        (require 'org-roam-protocol)

        (add-hook 'org-roam-file-setup-hook
                  (defun +org-roam-setup-hook ()
                    (when (featurep 'flyspell)
                      (flyspell-mode +1))

                    (auto-fill-mode +1)))

        ;; see [[https://github.com/progfolio/doct/issues/16][#16]].
        (defun doct-org-roam+ (groups)
          (let (converted)
            (dolist (group groups)
              (let* ((props (nthcdr 5 group))
                     (roam-properties (plist-get (plist-get props :doct) :org-roam)))
                (push `(,@group ,@roam-properties) converted)))
            (setq doct-templates (nreverse converted))))

        (defun org-roam-rg ()
          "Run a rg session in your org roam directory"
          (interactive)
          (cond ((package! ivy)
                 (require 'counsel)
                 (counsel-rg nil org-roam-directory))
                ((package! selectrum)
                 (require 'consult)
                 (consult-ripgrep org-roam-directory))
                (t (message "No rg package found"))))

        (setq org-roam-directory (org! "brain")
              org-roam-completion-system (cond ((package! ivy) 'ivy)
                                               (t org-roam-completion-system))
              ;; org-roam-capture-templates
              ;; (let ((doct-after-conversion-functions '(doct-org-roam+)))
              ;;   (doct `((:group "roam"
              ;;                   :type plain
              ;;                   :unnarowed t
              ;;                   :function org-roam-capture--get-point
              ;;                   :org-roam (:file-name "%<%Y%m%d%H%M%S>-${slug}"
              ;;                                         :head "#+title: ${title}\n")
              ;;                   :children (("default" :keys "d")
              ;;                              ("book" :keys "t"
              ;;                               :template ("#+roam_tags: %^{tags}"
              ;;                                          "#+roam_key: %?"))
              ;;                              )
              ;;                   )))
              ;;   )
              ;; `(("d" "default" plain ,#'org-roam-capture--get-point "%?" :file-name
              ;;    "%<%Y%m%d%H%M%S>-${slug}" :head "#+title: ${title}\n" :unnarrowed t))
              )

        :leader
        ("od" 'org-roam-capture
         ;; same as `org-roam-capture' except if the candidate already exists
         ;; open it instead of creating a capture session.
         "of" 'org-roam-find-file
         "op" 'org-roam-insert
         "or" 'org-roam
         ;; "og" 'org-roam-graph
         "os" 'org-roam-rg))

      (use-package org-roam-server
        :straight t
        :defer  t
        :leader
        ("oG" 'org-roam-server-mode)

        :config
        (setq org-roam-server-port 8967))
    #+END_SRC

*** org-pdf
    Adapted from [[https://github.com/fuxialexander/org-pdftools][org-pdftools]] this adds a link type to org mode which lets you link
    to and open PDFs. I've removed all the pdftools specific stuff so this is just a
    generic configuration section for pdf related actions in org mode.

    #+BEGIN_SRC emacs-lisp
      (with-eval-after-load 'org
        (defun +org-pdf-complete-link (&optional arg)
          "Use the existing file name completion for file.
      Links to get the file name, then ask the user for the page number
      and append it. ARG is passed to `org-link-complete-file'."
          (let ((default-directory (or +org-pdf-directory default-directory)))
            (concat
             (replace-regexp-in-string
              "^file:"
              (concat "pdftools" ":")
              (org-link-complete-file arg))
             "::"
             (read-from-minibuffer
              "Page:"
              "1"))))

        (defun +org-pdf-open (link)
          (message "%s" link)
          (save-match-data
            (let* ((path (when (string-match
                                "\\(.+\\)::.+" link)
                           (match-string 1 link))))
              (xopen-url+ (expand-file-name path)))))

        (defun +org-pdf-export (link description format)
          "Export the pdfview LINK with DESCRIPTION for FORMAT from Org files."
          (let* (path loc page)
            (if (string-match "\\(.+\\)::\\(.*\\)" link)
                (progn
                  (setq path (match-string 1 link))
                  (setq loc (match-string 2 link))
                  (if (string-match "\\([0-9]+\\)++\\(.*\\)" loc)
                      (setq page (match-string 1 loc))
                    (setq page loc)))
              (setq path link))

            ;; `org-export-file-uri` expands the filename correctly
            (setq path (org-export-file-uri (org-link-escape path)))

            (cond ((eq format 'html)
                   (format
                    "<a href=\"%s#page=%s\">%s</a>"
                    path
                    page
                    description))
                  ((eq format 'latex)
                   (format
                    "\\href{%s}{%s}"
                    path
                    description))
                  ((eq format 'ascii)
                   (format "%s (%s)" description path))
                  (t path))))

        (org-link-set-parameters "pdftools"
                                 :follow   #'+org-pdf-open
                                 :complete #'+org-pdf-complete-link
                                 :export   #'+org-pdf-export))
    #+END_SRC


*** org-ref
    Support citations, references and links in org mode documents.

    WARN for bibliographies to show up you have to specify a biliographystyle (use
    unsrt when unsure).

    #+BEGIN_SRC emacs-lisp :tangle (package-yes! bibtex)
      (use-package org-ref
        :straight t
        :defer  t
        :after  org
        :leader
        (:mode 'org-mode
         "]" 'org-ref-insert-link)

        :init
        (defvaralias 'reftex-default-bibliography 'bibtex-files)
        (defvaralias 'org-ref-bibliography-notes 'bibtex-completion-notes-path)

        :config
        (setq org-ref-latex-bibliography-absolute-p t
              org-ref-pdf-directory (let ((path bibtex-completion-library-path))
                                      (if (listp path) (car path) path))
              org-ref-latex-bib-resolve-func #'expand-file-name))
    #+END_SRC

    #+BEGIN_SRC emacs-lisp :tangle (package-yes! ivy bibtex)
      (with-eval-after-load 'org-ref
        (setq org-ref-completion-library 'org-ref-ivy-cite)

        (general-unbind
          :keymaps 'org-ref-ivy-cite-keymap
          "C-j" "C-k" "C-y" "C-M-y" "C-<return>" "C-.")

        (general-define-key
         :keymaps 'org-ref-ivy-cite-keymap
         "C-c C-a" 'org-ref-ivy-show-all
         "C-c C-y" 'org-ref-ivy-sort-year-ascending
         "C-c M-y" 'org-ref-ivy-sort-year-descending)
        ;; (set-keymap-parent org-ref-ivy-cite-keymap ivy-minibuffer-map)
        )
    #+END_SRC

** company
   #+BEGIN_SRC emacs-lisp
     (use-package company
       :straight t
       :defer  2
       :delight
       company-mode
       global-company-mode
       :init

       (defvar company-menu-bindings+
         `(("C-1"   . company-complete-number)
           ("C-2"   . company-complete-number)
           ("C-3"   . company-complete-number)
           ("C-4"   . company-complete-number)
           ("C-5"   . company-complete-number)
           ("C-6"   . company-complete-number)
           ("C-7"   . company-complete-number)
           ("C-8"   . company-complete-number)
           ("M-l"   . company-complete-common-or-next-char+)
           ("<C-i>" . company-complete-common)
           ("C-j"   . company-select-next)
           ("C-k"   . company-select-previous)
           ("C-d"   . company-next-page)
           ("C-u"   . company-previous-page)
           ("C-l"   . company-complete-selection)
           ("C-h"   . company-show-doc-buffer)
           ("<tab>" . company-complete-common-or-cycle)
           ("C-:"   . completion-at-point)
           ("RET"   . company-complete-selection)
           ("C-/"   . company-filter-candidates)
           ("C-s"   . company-filter-candidates)
           ("C-f"   . company-filter-candidates)
           ("C-o"   . company-last-candidate+)
           ("M-o"   . company-first-candidate+))
         "Bindings which override any local bindings while the company popup is active.
     DO NOT alter this (by setting a new value) while the popup is active, or be prepared
     to restart emacs.")

       (defalias 'case #'cl-case) ; TODO remove when company fixes cl issues.

       :config
       (setq company-statistics-file         (var! "company/statistics.el")
             company-tooltip-align-annotations t
             company-require-match nil)

       ;; don't let display steal focus
       (advice-add 'company-show-location   :around 'restore-default-display-buffer-actions)
       (advice-add 'company-show-doc-buffer :around 'restore-default-display-buffer-actions)

       (global-company-mode +1)

       (defun company-first-candidate+ ()
         (interactive)
         (company-set-selection 0))

       (defun company-last-candidate+ ()
         (interactive)
         (company-set-selection (max 0 (1- company-candidates-length))))

       (defun company-complete-next-char+ (&optional count)
         "insert the next COUNT characters from the current candidate."
         (interactive "p")
         (or count (setq count 1))

         (when (company-manual-begin)
           (let* ((candidate (nth company-selection company-candidates))
                  (remaining-input
                   (substring candidate (length company-prefix))))
             (if (or (<= (length remaining-input) 1)
                     (>= count (length remaining-input)))
                 (company-complete-selection)
               (company--insert-candidate
                (concat company-prefix
                        (substring remaining-input 0 count)))))))

       (defun company-complete-common-or-next-char+ (&optional count)
         "complete the common part of the current selection or insert
     upto COUNT characters from the current candidate."
         (interactive)
         (if (and (not (cdr company-candidates))
                  (equal company-common (car company-candidates)))
             (company-complete-selection)
           (if (string-prefix-p company-prefix company-common)
               (company-complete-next-char+ count)
             (company--insert-candidate company-common))))

       ;; use transient bindings inside the completion menu
       (defun company-set-bindings+ (&rest _)
         (apply
          'general-define-key
          :keymaps 'override
          :states  'insert
          (cl-loop for (key . value) in company-menu-bindings+
                   collect key collect value)))

       (defun company-unset-bindings+ (&rest _)
         (apply 'general-define-key
                :keymaps 'override
                :states  'insert
                (cl-loop for (key . -) in company-menu-bindings+
                         collect key collect nil)))

       (add-hook 'company-completion-started-hook   'company-set-bindings+)
       (add-hook 'company-completion-finished-hook  'company-unset-bindings+)
       (add-hook 'company-completion-cancelled-hook 'company-unset-bindings+)

       :general
       (:keymaps 'company-mode-map
        :states 'insert
        "M-SPC" 'company-complete)
       (:keymaps 'company-search-map
        "C-1"    'company-complete-number
        "C-2"    'company-complete-number
        "C-3"    'company-complete-number
        "C-4"    'company-complete-number
        "C-5"    'company-complete-number
        "C-6"    'company-complete-number
        "C-7"    'company-complete-number
        "C-8"    'company-complete-number
        "C-9"    'company-complete-number
        "C-f"    'company-search-toggle-filtering ; show filtered/all
        "C-s"    'company-search-repeat-forward
        "C-r"    'company-search-repeat-backward
        "C-n"    'company-search-repeat-forward
        "C-p"    'company-search-repeat-backward
        "ESC"    'company-search-abort)
       (:keymaps 'company-active-map
        "C-w" nil ;; was company-show-location
        "C-p" 'company-show-location))
   #+END_SRC

*** configure-mode
    configure company backends on a mode by mode basis.

    #+BEGIN_SRC emacs-lisp
      (defvar universal-company-backends+
        '(company-capf company-semantic company-files)
        "backends that you should always use with `company/configure-mode'")

      (defvar company-backends-alist+ nil
        "alist of mode to backend associations.
      DO NOT assign or modify this list directly, you should interact
      with it using `company/configure-mode'.")

      (defvar company-configured-mode-stack+ nil
        "modes for which company has been configured in this buffer.")
      (make-variable-buffer-local 'company-configured-mode-stack+)

      (defun company/configure-mode--push-backends+ (mode backends)
        "push backends for MODE into `company-backends'"
        (when (member :universal backends)
          (setq backends (append (delete :universal backends)
                                 universal-company-backends+)))

        (let ((backends-exist (local-variable-p 'company-backends)))
          (unless backends-exist
            (setq-local company-backends nil))

          (condition-case err
              (setq company-backends (remove-duplicates
                                      (append backends
                                              company-backends)))
            (error
             (unless backends-exist
               (kill-local-variable 'company-backends))
             (signal (car err) (cdr err)))))

        (push mode company-configured-mode-stack+))

      (defun company/configure-mode--pop-backends+ (mode)
        "pop configured company backends for MODE.
      replacing the default backend list when MODE is the last
      mode for which backends were configured."
        ;; should be an always correct check, but just in case.
        (when (member mode company-configured-mode-stack+)
          (if (eq 1 (length company-configured-mode-stack+))
              ;; erase company backends and configuration stack
              (progn
                (kill-local-variable 'company-backends)
                (setq company-configured-mode-stack+ nil))
            ;; remove backends for current mode, but replace with
            ;; every other mode in the configured mode stack.
            (setq company-configured-mode-stack+
                  (remove mode company-configured-mode-stack+))
            (let ((remaining-backends (-flatten
                                       (mapcar
                                        (lambda (mode)
                                          (cdr (assoc mode company-backends-alist+)))
                                        company-configured-mode-stack+))))
              (when (member :universal remaining-backends)
                (setq remaining-backends (append (delete :universal remaining-backends)
                                                 universal-company-backends+)))
              (setq-local company-backends (remove-duplicates remaining-backends))))))

      (add-hook 'change-major-mode-hook
                (defun configure-company--pop-for-major-mode+ ()
                  "pop configured company backends for the current MAJOR-MODE"
                  (company/configure-mode--pop-backends+ major-mode)))

      ;; inspired by this issue: https://github.com/company-mode/company-mode/issues/839
      (cl-defmacro company/configure-mode ((mode &key major (use-universal t) predicate) &rest backends)
        "configure company backends for a given mode
      MODE can be a major or a minor mode & activation can be predicated using PREDICATE.
      backends are passed as the remaining argument list after the mode declaration.
      when USE-UNIVERSAL is true, `universal-company-backends+' will be appended to
      the list of backends supplied. "
        (when backends
          (let ((func-name (intern (concat "company/configure-" (symbol-name mode))))
                (mode-hook (intern (concat (symbol-name mode) "-hook")))
                (backends (if use-universal
                              (push :universal backends)
                            backends))
                ;; convert predicate to a callable
                (predicate (cond
                            ((and (listp predicate)
                                  (eq (car predicate)
                                      'lambda))
                             predicate)
                            (t (eval `(lambda () ,(or predicate t)))))))
            (push (cons mode backends) company-backends-alist+)
            `(add-hook ',mode-hook
                       (if ,major
                           (defun ,func-name ()
                             (when (funcall ,predicate)
                               (company/configure-mode--push-backends+ ',mode ',backends)))
                         (defun ,func-name ()
                           (if ,mode
                               (when (funcall ,predicate)
                                 (company/configure-mode--push-backends+ ',mode ',backends))
                             (company/configure-mode--pop-backends+ ',mode))))))))
      (put 'company/configure-mode 'lisp-indent-function 'defun)
    #+END_SRC

*** quickhelp
    Shows a small floating window with the docstring/helpstring of the company candidate
    at point.

    #+BEGIN_SRC emacs-lisp :tangle no
      (use-package company-quickhelp
        :straight t
        :defer  t
        ;; :hook (company-mode . company-quickhelp-mode)
        :config
        (setq company-quickhelp-delay 0.5)

        :general
        (:keymaps 'company-active-map
         "C-M-h" 'company-quickhelp-manual-begin))

      (use-package company-quickhelp-terminal
        :straight t
        :defer  t
        :hook (company-quickhelp-mode . company-quickhelp-terminal-mode))
    #+END_SRC

*** prescient
    #+BEGIN_SRC emacs-lisp :tangle (package-yes! prescient)
      (use-package company-prescient
        :straight t
        :defer  t
        :after prescient
        :hook (company-mode . company-prescient-mode))
    #+END_SRC

** all-the-icons
   provides some fonts for rendering graphical icons within emacs; alongside a set
   of functions to make retrieving appropriate functions for appropriate purposes.

   #+BEGIN_SRC emacs-lisp
     (use-package all-the-icons
       :straight t
       :defer  t
       :commands (all-the-icons--insert-all-icons
                  all-the-icons-family+)
       :leader
       ("xi" 'all-the-icons-insert
        "xI" 'all-the-icons-insert-all-icons)

       :init
       (defun all-the-icons-pad-on-tty-advice+ (value)
         ":filter-return advice for all-the-icons functions which appends
     an extra space to the icon when displaying icons on the tty."
         (if (and (not (display-graphic-p))
                  value)
             (let ((props (text-properties-at 0 value)))
               (apply 'propertize
                      (concat (substring-no-properties value)
                              " ")
                      props))
           value))

       :config
       (setq inhibit-compacting-font-caches t)
       (push '(rustic-mode all-the-icons-alltheicon "rust") all-the-icons-mode-icon-alist)
       (push '(web-mode    all-the-icons-faicon     "html5") all-the-icons-mode-icon-alist)

       (defun all-the-icons-insert-all-icons ()
         (interactive)
         (dolist (icon-list (list all-the-icons-icon-alist
                                  all-the-icons-dir-icon-alist
                                  all-the-icons-weather-icon-alist
                                  all-the-icons-mode-icon-alist
                                  ;; all-the-icons-url-alist
                                  ))
           (dolist (icon icon-list)
             (let* ((func (nth 1 icon))
                    (args (nthcdr 2 icon))
                    (name (car args))
                    (type (substring (symbol-name func) 14)))
               (unless (= (length args) 0)
                 (insert "\n" (apply func args) " " type " - " name))))))

       (defun all-the-icons-family+ (family name &rest args)
         "Retrieve icon with NAME from FAMILY with ARGS"
         (apply (all-the-icons--function-name family) name args)))
   #+END_SRC

*** nerd-fonts
    When available we prefer [[https://github.com/ryanoasis/nerd-fonts][nerd-fonts]] (and it's many bundled font-sets) over the
    various all-the-icon fonts.

    #+BEGIN_SRC emacs-lisp
      (use-package nerd-fonts
        :straight (nerd-fonts :host github :repo "mohkale/nerd-fonts.el")
        :after all-the-icons
        :demand t
        :config
        (defvar nerd-fonts-families+
          (seq-uniq
           (cl-loop with pos = nil
                    for (icon . _) in nerd-fonts-alist
                    do (setq pos (cl-loop with count = 0
                                          for char across icon
                                          when (eq char ?-)
                                          return count
                                          else
                                          do (setq count (1+ count))))
                    collect (substring icon 0 pos))))

        (defmacro all-the-icons-nerd-font-family+ (family)
          (let* ((nerd-family (concat "nerd-" family))
                 (font-alist (intern (concat "all-the-icons-data/" nerd-family "-alist")))
                 (name (intern nerd-family)))
            `(progn
               (defvar ,font-alist
                 (eval-when-compile
                   (cl-loop for (name . icon) in nerd-fonts-alist
                            when (string-prefix-p ,family name)
                            collect (cons (substring name ,(1+ (length family)))
                                          icon))))

               (all-the-icons-define-icon ,name ,font-alist ,nerd-family
                 ;; The font on my linux machine, maybe needs updating depending on platform
                 "Symbols-2048-em Nerd Font Complete.ttf"))))

        (dolist (it nerd-fonts-families+)
          (eval
           `(all-the-icons-nerd-font-family+ ,it)))

        ;; Replace any none nerd-font lookups with nerd-font lookups.
        (when +icons-prefer-nerd-font
          (let ((family-subs (cl-loop for (family . ati-var) in '(("fa" . all-the-icons-faicon)
                                                                  ("mdi" . all-the-icons-material)
                                                                  ("oct" . all-the-icons-octicon)
                                                                  ("weather" . all-the-icons-wicon))
                                      when (member family nerd-fonts-families+)
                                      collect (cons ati-var
                                                    (intern (concat "all-the-icons-nerd-" family)))))
                (match-subs '(((all-the-icons-alltheicon . "aws")              .    (all-the-icons-nerd-fa     . "amazon"))
                              ((all-the-icons-alltheicon . "c-line")           .    (all-the-icons-nerd-custom . "c"))
                              ((all-the-icons-alltheicon . "clojure-line")     .    (all-the-icons-nerd-dev    . "clojure"))
                              ((all-the-icons-alltheicon . "cplusplus-line")   .    (all-the-icons-nerd-custom . "cpp"))
                              ((all-the-icons-alltheicon . "csharp-line")      .    (all-the-icons-nerd-mdi    . "language-csharp"))
                              ((all-the-icons-alltheicon . "elixir")           .    (all-the-icons-nerd-custom . "elixir"))
                              ((all-the-icons-alltheicon . "git")              .    (all-the-icons-nerd-mdi    . "git"))
                              ((all-the-icons-alltheicon . "go")               .    (all-the-icons-nerd-seti   . "go"))
                              ((all-the-icons-alltheicon . "google-drive")     .    (all-the-icons-nerd-mdi    . "google-drive"))
                              ((all-the-icons-alltheicon . "gulp")             .    (all-the-icons-nerd-seti   . "gulp"))
                              ((all-the-icons-alltheicon . "haskell")          .    (all-the-icons-nerd-seti   . "haskell"))
                              ((all-the-icons-alltheicon . "html5")            .    (all-the-icons-nerd-fa     . "html5"))
                              ((all-the-icons-alltheicon . "java")             .    (all-the-icons-nerd-fae    . "java"))
                              ((all-the-icons-alltheicon . "nodejs")           .    (all-the-icons-nerd-mdi    . "nodejs"))
                              ((all-the-icons-alltheicon . "prolog")           .    (all-the-icons-nerd-dev    . "prolog"))
                              ((all-the-icons-alltheicon . "python")           .    (all-the-icons-nerd-fa     . "-python"))
                              ((all-the-icons-alltheicon . "react")            .    (all-the-icons-nerd-mdi    . "react"))
                              ((all-the-icons-alltheicon . "ruby-alt")         .    (all-the-icons-nerd-oct    . "ruby"))
                              ((all-the-icons-alltheicon . "rust")             .    (all-the-icons-nerd-dev    . "rust"))
                              ((all-the-icons-alltheicon . "sass")             .    (all-the-icons-nerd-dev    . "sass"))
                              ((all-the-icons-alltheicon . "scala")            .    (all-the-icons-nerd-dev    . "scala"))
                              ((all-the-icons-alltheicon . "script")           .    (all-the-icons-nerd-seti   . "html"))
                              ((all-the-icons-alltheicon . "swift")            .    (all-the-icons-nerd-dev    . "swift"))
                              ((all-the-icons-alltheicon . "terminal")         .    (all-the-icons-nerd-fa     . "terminal"))
                              ((all-the-icons-alltheicon . "test-ruby")        .    (all-the-icons-nerd-oct    . "ruby"))
                              ((all-the-icons-fileicon   . "cljs")             .    (all-the-icons-nerd-dev    . "clojure"))
                              ((all-the-icons-fileicon   . "docker")           .    (all-the-icons-nerd-linux  . "docker"))
                              ((all-the-icons-fileicon   . "bib")              .    (all-the-icons-nerd-mdi    . "bible"))
                              ((all-the-icons-fileicon   . "php")              .    (all-the-icons-nerd-dev    . "php"))
                              ((all-the-icons-fileicon   . "racket")           .    (all-the-icons-fileicon    . "lisp")))))
            ;; For each variable all-the-icons uses to lookup contextual icons.
            (dolist (var '(all-the-icons-icon-alist
                           all-the-icons-dir-icon-alist
                           all-the-icons-weather-icon-alist
                           all-the-icons-mode-icon-alist
                           all-the-icons-url-alist))
              ;; For each entry in those lists do key-value substitution with `subs'.
              (dolist (assoc (symbol-value var))
                (if-let ((new-icon-func (alist-get (nth 1 assoc) family-subs)))
                    (setcar (cdr assoc) new-icon-func)
                  (when-let ((new-assoc (alist-get (cons (nth 1 assoc) (nth 2 assoc))
                                                   match-subs nil nil
                                                   (lambda (a b)
                                                     (and (eq    (car a) (car b))
                                                          (equal (cdr a) (cdr b)))))))
                    (setcar (cdr assoc)       (car new-assoc))
                    (setcar (cdr (cdr assoc)) (cdr new-assoc)))))))))
    #+END_SRC

** avy
   #+BEGIN_SRC emacs-lisp
     (use-package avy
       :straight t
       :defer  t
       :leader
       ("jj" 'avy-goto-char
        "jk" 'avy-goto-char-2
        "jf" 'avy-goto-char-timer))
   #+END_SRC

** browse-url
   gives functions to open URLs/filepaths on your local system using system
   specific tools.

   #+BEGIN_SRC emacs-lisp
     (use-package browse-url
       :straight t
       :defer  t
       :commands xopen-url+
       :config
       (defun xopen-url+ (url &optional arg)
         "Open visited file in default external program.
     When in dired mode, open file under the cursor.
     With a prefix ARG always prompt for command to use."
         (interactive "fOpen file: \nP")
         (unless url
           (setq url (if (eq major-mode 'dired-mode)
                         (dired-get-file-for-visit)
                       buffer-file-name)))

         (let ((program (if arg
                            (read-shell-command "Open current file with: ")
                          "xopen")))
           (call-process program nil 0 nil url))))
   #+END_SRC

** buffer-move
   Move buffer to windows in other directions. Like the vim C-w <Shift>+{h,j,k,l}
   series of functions.

   #+BEGIN_SRC emacs-lisp
     (use-package buffer-move
       :straight t
       :defer  t
       :commands (rotate-windows)
       :config
       ;; See [[https://www.emacswiki.org/emacs/TransposeWindows][Transpose Windows]]
       (defun rotate-windows (arg)
         "Rotate your windows; use the prefix argument to rotate the other direction"
         (interactive "P")
         (if (not (> (count-windows) 1))
             (message "You can't rotate a single window!")
           (let* ((rotate-times (prefix-numeric-value arg))
                  (direction (if (or (< rotate-times 0) (equal arg '(4)))
                                 'reverse 'identity)))
             (dotimes (_ (abs rotate-times))
               (dotimes (i (- (count-windows) 1))
                 (let* ((w1 (elt (funcall direction (window-list)) i))
                        (w2 (elt (funcall direction (window-list)) (+ i 1)))
                        (b1 (window-buffer w1))
                        (b2 (window-buffer w2))
                        (s1 (window-start w1))
                        (s2 (window-start w2))
                        (p1 (window-point w1))
                        (p2 (window-point w2)))
                   (set-window-buffer-start-and-point w1 b2 s2 p2)
                   (set-window-buffer-start-and-point w2 b1 s1 p1)))))))

       :general
       (:keymaps 'emacs-window-map
        "H"   'buf-move-left
        "M-h" 'buf-move-left
        "J"   'buf-move-down
        "M-j" 'buf-move-down
        "K"   'buf-move-up
        "M-k" 'buf-move-up
        "L"   'buf-move-right
        "M-l" 'buf-move-right))
   #+END_SRC

** define-word
   #+BEGIN_SRC emacs-lisp
     (use-package define-word
       :straight t
       :defer  t
       :leader
       ("hdW" 'define-word
        "hdw" 'define-word-at-point))
   #+END_SRC

** drag-stuff
   VS Code like drag region or line upwards or downwards.

   #+BEGIN_SRC emacs-lisp
     (use-package drag-stuff
       :defer  t
       :straight t
       :general
       ("C-<up>" 'drag-stuff-up
        "C-<down>" 'drag-stuff-down))
   #+END_SRC

** emojify
   #+BEGIN_SRC emacs-lisp
     (use-package emojify
       :straight t
       :defer  t
       :hook ((org-mode              . emojify-mode)
              (git-commit-mode       . emojify-mode)
              (web-mode              . emojify-mode)
              (emacs-lisp            . emojify-mode)
              (lisp-interaction-mode . emojify-mode)
              (yaml-mode             . emojify-mode)
              (bibtex-mode           . emojify-mode)
              (shell-mode            . emojify-mode)
              (markdown-mode         . emojify-mode)
              (lisp-interaction-mode . emojify-mode)
              (scss-mode             . emojify-mode))
       :init
       (defalias 'remove-duplicates #'cl-remove-duplicates)

       :config
       (setq emojify-emojis-dir (var! "emojify/"))

       ;; make emojis work like prettify-symbols-mode
       (setq emojify-point-entered-behaviour 'uncover
             emojify-emoji-styles '(unicode github)
             emojify-display-style 'unicode)

       :leader
       ("xm" 'emojify-insert-emoji)

       :general
       (:keymaps 'emojify-list-mode-map
        :states 'motion
        "gr" 'emojify-list-force-refresh
        "Y"  'emojify-list-copy-emoji
        "RET" 'emojify-list-describe-emoji)
       (:keymaps 'emojify-description-mode
        :states 'motion
        "Y" 'emojify-description-copy-emoji))
   #+END_SRC

*** company
    #+BEGIN_SRC emacs-lisp :tangle (package-yes! company-emoji)
      (use-package company-emoji
        :straight t
        :defer  t
        :after  emojify
        :init
        (company/configure-mode (emojify-mode)
          company-emoji)

        :config
        ;; never insert emojis as their unicode symbols.
        (setq company-emoji-insert-unicode nil))
    #+END_SRC

** eyebrowse
   #+BEGIN_SRC emacs-lisp
     (use-package eyebrowse
       :straight t
       :defer 30
       :config
       (eyebrowse-mode +1)

       (defun eyebrowse-switch-window-config--when-new-zen-current-window (func slot &rest args)
         "by default, when you create a new window config it's a complete copy
     of your current config. More often then not when you make a new config you
     want to change the layout of the windows (and buffers) within it. Creating
     a new config and then manuall deleting every other window is a pain, this
     makes it so when you make a new config, you're current window is maximised
     automatically."
         (let ((slot-new-p (not (eyebrowse--window-config-present-p slot))))
           (apply func slot args)
           (when (and slot-new-p
                      (> (length (window-list)) 1))
             (window-zen))))

       (advice-add 'eyebrowse-switch-to-window-config
                   :around #'eyebrowse-switch-window-config--when-new-zen-current-window))
   #+END_SRC

** gitlink
   #+BEGIN_SRC emacs-lisp
     (use-package git-link
       :straight t
       :defer  t
       :init
       ;; default is to open the generated link
       (setq git-link-open-in-browser nil)

       :leader
       ("gy"  "links"
        "gyl" 'git-link
        "gyc" 'git-link-commit
        "gyh" 'git-link-homepage))
   #+END_SRC

** help-fns+
   #+BEGIN_SRC emacs-lisp
     (use-package help-fns+
       :straight (help-fns+ :host github :repo "emacsmirror/help-fns-plus")
       :defer t
       :commands (describe-buffer
                  describe-keymap
                  describe-mode
                  describe-function)
       :leader
       ("hdm" '("describe-mode" . describe-buffer)
        "hdf" 'describe-function
        "hdK" 'describe-keymap))
   #+END_SRC

** hide-modeline
   Makes the mode-line blank in the current buffer. this doesn't let the buffer contents expand
   into the mode-line region, it simply makes it appear as if nothings there.

   #+BEGIN_SRC emacs-lisp
     (use-package hide-mode-line
       :straight t
       :defer  t)
   #+END_SRC

** hl-todo
   Highlight certain keywords in the current buffer.

   #+BEGIN_SRC emacs-lisp
     (use-package hl-todo
       :straight t
       :defer  t
       :hook ((prog-mode . global-hl-todo-mode)
              (text-mode . global-hl-todo-mode)
              (org-mode  . hl-todo-mode))
       :leader
       ("jt" 'hl-todo-next
        "jT" 'hl-todo-previous
        "et" 'hl-todo-occur

        "it" 'hl-todo-insert
        "it" 'hl-todo-insert-keyword))
   #+END_SRC

** hydra
   Tangles ~hydras.org~ alongside this org file and then sources bindings/autoloads
   from ~hydras.el~.

   #+BEGIN_SRC emacs-lisp
     <<tangle-hydras()>>
     (require '+hydras)
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (use-package hydra
       :straight t
       :defer  t
       :commands defhydra
       :config
       (setq lv-use-separator t))

     (use-package pretty-hydra
       :straight t
       :defer  t)
   #+END_SRC

   #+NAME: tangle-hydras
   #+BEGIN_SRC emacs-lisp :tangle no :results values
     (org-babel-tangle-file "hydras.org")
     nil
   #+END_SRC

*** posframe
    Changes the display of the the hydra popups from some region above the message area into a
    posframe :) like ~frog-jump-buffer~.

    #+BEGIN_SRC emacs-lisp :tangle (package-yes! hydra-posframe)
      (use-package hydra-posframe
        :straight (hydra-posframe :host github :repo "Ladicle/hydra-posframe")
        :defer t
        :after hydra
        :init
        (when (display-graphic-p)
          ;; only use posframe when on graphical display
          ;; my terminals always too short for it to be
          ;; useful on there.
          (add-hook 'after-init-hook #'hydra-posframe-mode))

        :config
        ;; source for following section [[https://github.com/jerrypnz/.emacs.d/blob/master/config/jp-base.el][here]].
        (defun posframe-frame-bottom-poshandler+ (info)
          (cons (car (posframe-poshandler-frame-center info))
                (- (cdr (posframe-poshandler-frame-bottom-left-corner info)) 20)))

        (setq hydra-posframe-poshandler 'posframe-frame-bottom-poshandler+
              hydra-posframe-parameters '((alpha 100 100)
                                          (left-fringe . 10)
                                          (right-fringe . 10)
                                          (x-pixel-offset 4)
                                          (internal-border-width . 2))))
    #+END_SRC

** ialign
   #+BEGIN_SRC emacs-lisp
     (use-package ialign
       :straight t
       :defer  t
       :commands evil-ialign

       :config
       ;; run ialign using evil motions
       (evil-define-operator evil-ialign (beg end)
         :type        line
         :repeat      nil
         :move-point  t
         :keep-visual nil
         (ialign beg end))

       :leader
       ("x TAB" 'evil-ialign)

       :general
       (:states leader-norm-states
        "g TAB" 'evil-ialign)
       (:keymaps 'ialign-minibuffer-keymap
        ;; "" 'ialign-toggle-repeat
        "M-k"        'ialign-increment-spacing
        "M-j"        'ialign-decrement-spacing
        "M-h"        'ialign-decrement-group
        "M-l"        'ialign-increment-group
        "<M-up>"     'ialign-increment-spacing
        "<M-down>"   'ialign-decrement-spacing
        "<M-left>"   'ialign-decrement-group
        "<M-right>"  'ialign-increment-group
        "C-SPC"      'ialign-set-spacing
        "<C-tab>"    'ialign-toggle-tabs
        "<C-return>" 'ialign-set-group
        "C-h"        'backward-char
        "C-l" (lambda ()
                (interactive)
                (call-interactively (if (eolp)
                                        'exit-minibuffer
                                      'forward-char)))))
   #+END_SRC

** lorem-ipsum
   insert placeholder text in the lorem-ipsum-dolor format.

   #+BEGIN_SRC emacs-lisp
     (use-package lorem-ipsum
       :straight t
       :defer  t
       :leader
       ("il"  "lorem-ipsum"
        "ill" 'Lorem-ipsum-insert-list
        "ilp" 'Lorem-ipsum-insert-paragraphs
        "ils" 'Lorem-ipsum-insert-sentences))
   #+END_SRC

** miniedit
   write the minibuffer contents to a buffer. edit, then paste new contents back to minibuffer.

   #+BEGIN_SRC emacs-lisp
     (use-package miniedit
       :straight (miniedit :host github :repo "emacsorphanage/miniedit")
       :defer t
       :delight (miniedit-mode "MiniEdit")
       :config
       (setq miniedit-show-help-p nil) ;; thanks... but no thanks

       :lazy-leader
       (:mode 'miniedit-mode
        :minor t
        :prefix leader-major-mode-prefix
        "," 'exit-recursive-edit)

       :general
       (:keymaps '(minibuffer-local-map
                   minibuffer-local-ns-map
                   minibuffer-local-completion-map
                   minibuffer-local-must-match-map)
        "M-e" 'miniedit)
       (:keymaps 'evil-ex-search-keymap
        "M-e" nil) ; miniedit and evil don't seem to get along.
       )
   #+END_SRC

** open-junk-file
   create temporary files labelled with todays date and other information.

   #+BEGIN_SRC emacs-lisp
     (use-package open-junk-file
       :straight (open-junk-file :host github :repo "rubikitch/open-junk-file")
       :defer t
       :commands (open-junk-file
                  goto-junk-file-directory
                  goto-todays-junk-file-directory)
       :leader
       ("fJ" 'open-junk-file)

       :init
       (defvar junk-file-directory (var! "junk")
         "Directory to keep junk files in.")

       :config
       (setq open-junk-file-format (var! "junk-files/%Y/%m/%d-%H%M%S"))

       (defun goto-junk-file-directory ()
         (interactive)
         (let ((directory junk-file-directory))
           (if (f-directory-p directory)
               (find-file directory)
             (if (file-exists-p directory)
                 (message "junk directory appears to be created as a file: %s" directory)
               (when (y-or-n-p (format "junk file directory '%s' doesn't seem to exist. make it: "
                                       directory))
                 (make-directory (expand-file-name directory) t)
                 (find-file directory))))))

       (defun goto-todays-junk-file-directory ()
         (interactive)
         (let* ((filename  (format-time-string open-junk-file-format))
                (directory (file-name-directory filename)))
           (if (f-directory-p directory)
               (find-file directory)
             (if (file-exists-p directory)
                 (message "junk file directory appears to be created as a file: %s" directory)
               (when (y-or-n-p (format "junk file directory '%s' doesn't seem to exist. make it: "
                                       directory))
                 (make-directory (expand-file-name directory) t)
                 (find-file directory))))))

       (defun open-junk-file--fix-read-file-name-with-directory-wrapper (func &rest args)
         "ivy read-file-name doesn't seem to handle initial values with directory components
     very well. this wrapper function strips out the directory component of the default
     junk file name and passes it as the dir argument to read-file-name."

         (cl-letf* (((symbol-function 'actual-read-file-name)
                     (symbol-function 'read-file-name))
                    ((symbol-function 'read-file-name)
                     (lambda (prompt &optional _ _ mustmatch initial predicate)
                       (let ((dirname  (file-name-directory    initial))
                             (basename (file-name-nondirectory initial)))
                         ;; for some reason, this doesn't work unless I set default-filename and initial
                         ;; to basename, and even when I do so, the full path still appears an option :(
                         (actual-read-file-name prompt dirname basename mustmatch basename predicate)))))
           (apply func args)))

       (advice-add 'open-junk-file :around #'open-junk-file--fix-read-file-name-with-directory-wrapper))
   #+END_SRC

** org-link-mode
   view org links in non-org buffers as you would in org buffers.

   #+BEGIN_SRC emacs-lisp
     (use-package org-link-minor-mode
       :defer t
       :straight (org-link-minor-mode :host github :repo "seanohalpin/org-link-minor-mode")
       :hook ((text-mode . enable-org-link-minor-mode)
              (prog-mode . enable-org-link-minor-mode)
              (conf-mode . enable-org-link-minor-mode))
       :diminish org-link-minor-mode
       :init
       (defun enable-org-link-minor-mode (&rest _)
         (unless (derived-mode-p 'major-mode 'org-mode)
           (org-link-minor-mode +1)))

       :config
       ;; deprecated in org 9.3, not yet updated upstream.
       (defvaralias 'org-any-re 'org-link-any-re))
   #+END_SRC

** page-break-lines
   display ^L lines as horizontal-rules. Like so:



   #+BEGIN_SRC emacs-lisp
     (use-package page-break-lines
       :straight t
       :defer t
       :hook ((org-mode                    . page-break-lines-mode)
              (help-mode                   . page-break-lines-mode)
              (outline-mode                . page-break-lines-mode)
              (emacs-lisp-compilation-mode . page-break-lines-mode))
       :diminish
       page-break-lines-mode)
   #+END_SRC

** pcre2el
   convert from emacs regular expressions to perl like regexps and vice versa.

   #+BEGIN_SRC emacs-lisp
     (use-package pcre2el
       :straight t
       :defer  t
       :leader
       ("xr"   "regexp"
        "xrb"  'regexp-builder
        "xr'"  'rxt-convert-to-strings
        "xr/"  'rxt-explain
        "xrc"  'rxt-convert-syntax
        "xrt"  'rxt-toggle-elisp-rx
        "xrx"  'rxt-convert-to-rx

        "xre"  "elisp"
        "xre'" 'rxt-elisp-to-strings
        "xre/" 'rxt-explain-elisp
        "xrep" 'rxt-elisp-to-pcre
        "xret" 'rxt-toggle-elisp-rx
        "xrex" 'rxt-elisp-to-rx

        "xrp"  "PCRE"
        "xrp'" 'rxt-pcre-to-strings
        "xrp/" 'rxt-explain-pcre
        "xrpe" 'rxt-pcre-to-elisp
        "xrpx" 'rxt-pcre-to-rx))
   #+END_SRC

** persp-mode
   TODO refactor

   #+BEGIN_SRC emacs-lisp
     (use-package persp-mode
       :straight t
       :defer  150
       :diminish persp-mode

       ;; unbound functions:
       ;;    persp-kill-buffer
       ;;    persp-save-and-kill
       :commands (find-file-new-perspective
                  switch-to-persp-by-num
                  persp-switch
                  persp-kill-current
                  persp-add-current-buffer
                  persp-remove-current-buffer)

       :leader
       ("ba" 'persp-add-current-buffer
        "bA" 'persp-add-buffer
        "br" 'persp-remove-buffer
        "bR" 'persp-remove-current-buffer
        "f M-l" 'find-file-new-perspective)

       :config
       (require 'eyebrowse)

       (setq persp-autokill-buffer-on-remove 'kill-weak
             persp-save-dir (var! "perspectives/")

             ;; disable
             persp-auto-resume-time 0)

       (persp-mode +1)

       (defun find-file-new-perspective--action (file)
         (let* ((name (if current-prefix-arg
                          (let (done value)
                            (while (not done)
                              (setq value (read-string "Name for new perspective: "))
                              (if (not (persp-with-name-exists-p value))
                                  (setq done t) ;; break loop, valid name encountered
                                (unless (y-or-n-p (format "persp with name '%s' already exists. try again: "
                                                          value))
                                  (setq done t)) ;; user no longer wishes to create persp
                                (setq value nil) ;; unbind in case value being returned
                                ))
                            value)
                        (file-name-nondirectory (string-trim-right file "/")))))
           (when name
             (persp-add-new name)
             (persp-switch name)
             (let ((buffer (find-file file)))
               (switch-to-buffer buffer)
               (persp-add-buffer buffer)))))

       (defun find-file-new-perspective ()
         (interactive)
         (cond
          ((package! ivy)
           (require 'counsel)
           (counsel--find-file-1
            "New persp file: " nil
            #'find-file-new-perspective--action
            'counsel-find-file))
          (t
           (find-file-new-perspective--action (read-file-name "New persp file:")))))

       (defun switch-to-persp-by-num (index)
         "switch to a perspective based on it's position in (persp-persps)
     the first position is assumed to be associated with a perspective name `none'.
     if a perspective at the given index doesn't exist, it's assumed you wish to
     create a new one, so you'll be prompted to do so at the largest available index."
         (let* ((persp-list (nreverse (persp-persps)))
                (persp-count (length persp-list)))
           ;; last value is nil persp with name none
           (if (>= index persp-count)
               (when (yes-or-no-p (format "no layout exists at %d, would you like to make a new layout:"
                                          (1+ persp-count)))
                 (call-interactively 'persp-add-new))
             (let ((current-persp (get-current-persp))
                   (dest-persp    (nth index persp-list)))
               (unless (string-equal (safe-persp-name dest-persp)
                                     (safe-persp-name current-persp))
                 (persp-switch (safe-persp-name dest-persp)))))))

       (defvar persp--copying-p nil
         "true if persp-add-new is called with intent to copy current persp")

       (defun persp-add-new--after (&rest _)
         "hook which is run immeadiately after `persp-add-new'
     this function sets the current persp to the new persp... unless
     `persp-add-new' wasn't invoked interactively. It also kills all
     displayed windows and returns to the home buffer... unless the
     previous persp is being copied."
         (let ((persp-list (nreverse (persp-persps)))
               (start-persp (get-current-persp)))
           (persp-switch (safe-persp-name (car (last persp-list))))

           (unless persp--copying-p
             (kill-all-windows-and-return-to-home))

           (unless (called-interactively-p 'any)
             (persp-switch (safe-persp-name start-persp)))))

       (advice-add 'persp-add-new :after #'persp-add-new--after)
       (advice-add 'persp-copy :around (lambda (func &rest args)
                                         (let ((persp--copying-p t))
                                           (apply func args))))

       (defun persp-kill-goto-previous+ (func &rest args)
         "function which wraps around persp-kill
     this function will ensure after a perspective is killed, the next
     perspective you reach will be the one immeadiately before the erased
     one. Not really necessary, but when you try to delete 3 perspectives
     in a row, this'll make things easier. Besides, this is what you expect
     to happen."
         (let* ((perspectives (nreverse (persp-persps)))
                (current-persp (get-current-persp))
                (current-index (cl-position current-persp perspectives))
                (next-persp (when (and current-index
                                       (not (zerop current-index)))
                              (nth (- current-index 1) perspectives))))
           (apply func args)
           (when next-persp
             (persp-switch (persp-name next-persp)))))

       (advice-add 'persp-kill :around #'persp-kill-goto-previous+)

       (defun persp-kill-current ()
         "kill the current perspective"
         (interactive)
         (persp-kill (safe-persp-name (get-current-persp))))

       ;; (defun spacemacs//layout-contains-buffer-p (buffer)
       ;;   "returns true if the given buffer is in the current layout"
       ;;   (not (spacemacs//layout-not-contains-buffer-p buffer)))

       (defun persp-add-current-buffer ()
         "adds current buffer to current perspective"
         (interactive)
         (persp-add-buffer (current-buffer)))

       (defun persp-remove-current-buffer ()
         "removes current buffer from current persp"
         (interactive)
         (persp-remove-buffer (current-buffer)))

       (defun persp-move-layout-left ()
         (interactive)
         ;; (let* ((current-persp (get-current-persp))
         ;;        (current-persp-num (progn
         ;;                             (let (value)
         ;;                               (dolist (persp)))))
         ;;        ))
         (message "not yet implemented") ;; TODO implement
         )

       (defun persp-move-layout-right ()
         (interactive)
         (message "not yet implemented") ;; TODO implement
         )

       ;; thank you spacemacs for giving us perspective mode with eyebrowse... ergo, layouts :)
       ;; https://github.com/syl20bnr/spacemacs/blob/master/layers/%2Bspacemacs/spacemacs-layouts/funcs.el
       ;; the following is just a lazy translation of the spacemacs implementation from above for my config.
       ;; some vocabulary notes:
       ;;   * a workspace is a list of eyebrowse window configurations
       ;;   * a layout is a perspective-mode perspective which has an associated workspace.
       ;; for further elaborations on what those terms mean, see the README for perspective-mode and eyebrowse.

       ;; XXXX TBH I don't really understand what most of this does, a lot of it I just copied and pasted from
       ;;      spacemacs and changed spacemacs to layouts... if spacemacs ever realeases this as a standalone
       ;;      package, like they did with spaceline, make sure to switch to that. In the meantime, the following
       ;;      uses the same license as spacemacs... I.E. GPL v3
       ;;      Reference Commit: b252d252b0e93249b51400f60a0c69a59aa140a4

       (defun layouts//get-persp-workspace (&optional persp frame)
         "Get the correct workspace parameters for perspective.
     PERSP is the perspective, and defaults to the current perspective.
     FRAME is the frame where the parameters are expected to be used, and
     defaults to the current frame."
         (let ((param-names (if (display-graphic-p frame)
                                '(gui-eyebrowse-window-configs
                                  gui-eyebrowse-current-slot
                                  gui-eyebrowse-last-slot)
                              '(term-eyebrowse-window-configs
                                term-eyebrowse-current-slot
                                term-eyebrowse-last-slot))))
           (--map (persp-parameter it persp) param-names)))

       (defun layouts//set-persp-workspace (workspace-params &optional persp frame)
         "Set workspace parameters for perspective.
     WORKSPACE-PARAMS should be a list containing 3 elements in this order:
     - window-configs, as returned by (eyebrowse--get 'window-configs)
     - current-slot, as returned by (eyebrowse--get 'current-slot)
     - last-slot, as returned by (eyebrowse--get 'last-slot)
     PERSP is the perspective, and defaults to the current perspective.
     FRAME is the frame where the parameters came from, and defaults to the
     current frame.
     Each perspective has two sets of workspace parameters: one set for
     graphical frames, and one set for terminal frames."
         (let ((param-names (if (display-graphic-p frame)
                                '(gui-eyebrowse-window-configs
                                  gui-eyebrowse-current-slot
                                  gui-eyebrowse-last-slot)
                              '(term-eyebrowse-window-configs
                                term-eyebrowse-current-slot
                                term-eyebrowse-last-slot))))
           (--zip-with (set-persp-parameter it other persp)
                       param-names workspace-params)))

       ;;  _                 _
       ;; | |__   ___   ___ | | _____
       ;; | '_ \ / _ \ / _ \| |/ / __|
       ;; | | | | (_) | (_) |   <\__ \
       ;; |_| |_|\___/ \___/|_|\_\___/
       ;;

       ;; spacemacs/save-eyebrowse-for-perspective
       (defun layouts//save-eyebrowse-for-perspective (&optional frame)
         "save FRAME's eyebrowse workspace to FRAME's perspective.
     FRAME defaults to the current frame."
         (layouts//set-persp-workspace (list (eyebrowse--get 'window-configs frame)
                                             (eyebrowse--get 'current-slot frame)
                                             (eyebrowse--get 'last-slot frame))
                                       (get-frame-persp frame)
                                       frame))

       (add-hook 'eyebrowse-post-window-switch-hook #'layouts//save-eyebrowse-for-perspective)

       ;; spacemacs/update-eyebrowse-for-perspective
       (defun layouts//update-eyebrowse-for-perspective (&rest _args)
         "update & save current frame's eyebrowse workspace to its perspective"
         (let* ((current-slot (eyebrowse--get 'current-slot))
                (current-tag (nth 2 (assoc current-slot (eyebrowse--get 'window-configs)))))
           (eyebrowse--update-window-config-element
            (eyebrowse--current-window-config current-slot current-tag)))
         (layouts//save-eyebrowse-for-perspective))

       (add-hook 'persp-before-switch-functions #'layouts//update-eyebrowse-for-perspective)
       (add-hook 'persp-before-save-state-to-file-functions #'layouts//update-eyebrowse-for-perspective)

       ;; spacemacs/load-eyebrowse-for-perspective
       (defun layouts//load-eyebrowse-for-perspective (type &optional frame)
         "load an eyebrowse workspace according to a perspective's parameters.
     FRAME's perspective is the perspective that is considered, defaulting to
     the current frame's perspective.
     If the perspective doesn't have a workspace, create one."
         (when (eq type 'frame)
           (let* ((workspace-params (layouts//get-persp-workspace (get-frame-persp frame) frame))
                  (window-configs (nth 0 workspace-params))
                  (current-slot (nth 1 workspace-params))
                  (last-slot (nth 2 workspace-params)))
             (if window-configs
                 (progn
                   (eyebrowse--set 'window-configs window-configs frame)
                   (eyebrowse--set 'current-slot current-slot frame)
                   (eyebrowse--set 'last-slot last-slot frame)
                   (eyebrowse--load-window-config current-slot))
               (eyebrowse--set 'window-configs nil frame)
               (eyebrowse-init frame)
               (layouts//save-eyebrowse-for-perspective frame)))))

       (add-hook 'persp-activated-functions #'layouts//load-eyebrowse-for-perspective)

       ;; spacemacs/load-eyebrowse-after-loading-layout
       (defun layouts//load-eyebrowse-after-perspective-load (_ _ persp-names)
         "bridge between `persp-after-load-state-functions' and
     `layouts//load-eyebrowse-for-perspective'.
     PERSP-HASH is the hash were the loaded perspectives were placed, and
     PERSP-NAMES are the names of these perspectives."
         (let ((cur-persp (get-current-persp)))
           ;; load eyebrowse for current perspective only if it was one of the loaded
           ;; perspectives
           (when (member (or (and cur-persp (persp-name cur-persp))
                             persp-nil-name)
                         persp-names)
             (layouts//load-eyebrowse-for-perspective 'frame))))

       (add-hook 'persp-after-load-state-functions #'layouts//load-eyebrowse-after-perspective-load))
   #+END_SRC

** projectile
   project management in style.

   #+BEGIN_SRC emacs-lisp
     (use-package projectile
       :straight t
       :defer  10
       :delight ""
       :hook (prog-mode . projectile-mode)
       :init
       (advice-add 'delete-buffer-file :after (lambda (&rest _)
                                                (when (projectile-project-p)
                                                  (call-interactively 'projectile-invalidate-cache))))
       :config
       (require '+projectile-project-types)

       (with-no-warnings
         (defvaralias 'grep-regexp-history 'regexp-search-ring))

       (defun projectile-ensure-no-trailing-slash-in-root (func &rest args)
         (cl-letf* (((symbol-function 'true-projectile-project-root)
                     (symbol-function 'projectile-project-root))
                    ((symbol-function 'projectile-project-root)
                     (lambda (&rest args)
                       ;; TODO maybe don't hardcode file name seperator
                       (string-remove-suffix "/"
                                             (apply 'true-projectile-project-root args)))))
           (apply func args)))

       (setq projectile-project-search-path (cl-loop for fp in '("~/prog/repos/")
                                                     if (file-directory-p fp)
                                                     collect fp)
             projectile-tags-backend 'xref ;; opt into gtags
             projectile-indexing-method 'alien ;; never use native
             projectile-tags-command "ctags -Re -f \"%s\" %s \"%s\""
             projectile-cache-file (var! "projectile/cache.el")
             projectile-known-projects-file (var! "projectile/known-projects.el"))

       (advice-add 'projectile-regenerate-tags :around #'projectile-ensure-no-trailing-slash-in-root)

       (when (windows-p)
         ;; fixes search glitches on windows when using cygwin... also strips out leading ./ because
         ;; ivy seems to recognise ./ paths as distinct from their non ./ counterparts... maybe that's
         ;; projectiles fault... who knows. also exclude special emacs backup files from search results.
         (setq projectile-generic-command "find . -type f -not -iname '#*#' -print | cut -c3- | tr '\\n' '\\0'"))

       (defun projectile-cleanup--shut-up-please (func &rest args)
         "I don't need to know when you've done nothing... thnx tho :P"
         (cl-letf* (((symbol-function 'actual-message)
                     (symbol-function 'message))
                    ((symbol-function 'message)
                     (lambda (format &rest args)
                       (if (string-equal format
                                         "No projects needed to be removed.")
                           (apply 'format format args)
                         (apply 'actual-message format args)))))
           (apply func args)))

       (advice-add 'projectile-cleanup-known-projects :around #'projectile-cleanup--shut-up-please)

       (defun projectile-compile--double-prefix-means-run-comint (func &optional args)
         "allow running compilation interactively when multiple prefixes are given.
     with two prefixes (C-u C-u) runs default compilation command in interactive
     compilation buffer. with three prompts for command and then runs it in an
     interactive compilation buffer."
         (let ((prefix current-prefix-arg))
           (if (and (consp prefix)
                    (setq prefix (car prefix))
                    (>= prefix 16))
               (cl-letf* (((symbol-function 'actual-compile)
                           (symbol-function 'compile))
                          ((symbol-function 'compile)
                           (lambda (command &optional _)
                             (actual-compile command t))))
                 (funcall func (if (eq prefix 16) nil '(4))))
             (funcall func prefix))))

       (advice-add 'projectile-run-project     :around #'projectile-compile--double-prefix-means-run-comint)
       (advice-add 'projectile-compile-project :around #'projectile-compile--double-prefix-means-run-comint)
       (advice-add 'projectile-test-project    :around #'projectile-compile--double-prefix-means-run-comint)

       (defvar projectile-org-capture-templates+ nil)
       (defvar projectile-org-capture-templates-contexts+ nil)

       (defun projectile-org-capture-templates+ (name root)
         "Adapted from `counsel-projectile-org-capture'."
         (cl-loop
          with replace-fun = `(lambda (string)
                                (replace-regexp-in-string
                                 "\\${[^}]+}"
                                 (lambda (s)
                                   (pcase s
                                     ("${root}" ,root)
                                     ("${name}" ,name)))
                                 string))
          for template in projectile-org-capture-templates+
          collect (cl-loop
                   for item in template
                   if (= (cl-position item template) 1) ;; template's name
                   collect (funcall replace-fun item)
                   else if (= (cl-position item template) 3) ;; template's target
                   collect (cl-loop
                            for x in item
                            if (stringp x)
                            collect (funcall replace-fun x)
                            else
                            collect x)
                   else
                   collect item)))

       (defun projectile-org-capture+ ()
         "`org-capture' wrapper which includes project specific capture templates."
         (interactive)
         (let* ((root (ignore-errors (projectile-project-root)))
                (name (projectile-project-name))
                (org-capture-templates-contexts
                 (append (when root
                           projectile-org-capture-templates-contexts+)
                         org-capture-templates-contexts))
                (org-capture-templates
                 (append org-capture-templates
                         (when root
                           (projectile-org-capture-templates+ name root)))))
           (call-interactively
            (cond ((package! ivy) 'counsel-org-capture)
                  ((package! selectrum) 'consult-org-capture+)
                  (t 'org-capture)))))

       (defun projectile-org-project-file+ ()
         (interactive)
         (find-file
          (if-let ((cands (let ((default-directory projectile-org-projects-directory+))
                            (cl-loop for file in (cl-remove-if
                                                  (apply-partially #'string-match-p +find-file-ignore-regexp)
                                                  (append (file-expand-wildcards "*.org")
                                                          (file-expand-wildcards "**/*.org")))
                                     collect (cons file (concat default-directory "/" file))))))
              (alist-get
               (completing-read
                "Find file: " (lambda (string predicate action)
                                (if (eq action 'metadata)
                                    '(metadata (category . file))
                                  (complete-with-action action cands string predicate)))
                nil t)
               cands nil nil #'string-equal)
            (user-error "No project org files have been found at %s" projectile-org-projects-directory+))))

       :general
       (:keymaps 'projectile-mode-map
        [remap org-capture]         'projectile-org-capture+
        [remap counsel-org-capture] 'projectile-org-capture+
        [remap consult-org-capture+] 'projectile-org-capture+)

       :leader
       ("fp"    'projectile-switch-project
        "pP"    'projectile-switch-project
        "pf"    'projectile-find-file
        "pd"    'projectile-find-dir
        "pb"    'projectile-switch-to-buffer
        "po"    'projectile-org-project-file+

        "p"  "projectile"
        "p TAB" 'projectile-find-other-file
        "p!" 'projectile-run-shell-command-in-root
        "p%" 'projectile-replace-regexp
        "p&" 'projectile-run-async-shell-command-in-root
        "pa" 'projectile-toggle-between-implementation-and-test
        "pb" 'projectile-switch-to-buffer
        "pc" 'projectile-compile-project
        "ph" 'projectile-dired ;; dired in project home directory
        "pd" 'projectile-find-dir
        "pD" 'projectile-discover-projects-in-directory
        "pf" 'projectile-find-file
        "pF" 'projectile-find-file-in-known-projects
        "pG" 'projectile-regenerate-tags
        "pg" 'projectile-find-tag
        "pI" 'projectile-invalidate-cache
        "pk" 'projectile-kill-buffers
        "pp" 'projectile-run-project
        "pr" 'projectile-recentf
        "p[" 'projectile-previous-project-buffer
        "p]" 'projectile-next-project-buffer
        "pt" 'projectile-test-project
        "pi" 'projectile-install-project
        "pso" 'projectile-multi-occur
        ;; "pxe" 'projectile-run-eshell
        ;; "pxi" 'projectile-run-ielm
        ;; "pxt" 'projectile-run-term
        ;; "pxs" 'projectile-run-shell
        ;; "pxv" 'projectile-run-vterm
        "pv" 'projectile-run-vterm))
   #+END_SRC

*** project-types
    #+BEGIN_SRC emacs-lisp :tangle lisp/+projectile-project-types.el
      (projectile-register-project-type 'rake '("rakefile")
                                        :compile "rake build"
                                        :test    "rake test"
                                        :run     "rake run"
                                        :test-suffix ".spec")

      (projectile-register-project-type 'pipenv '("Pipfile")
                                        :test "pipenv py -m pytest")

      (projectile-register-project-type 'make '("Makefile")
                                        :compile "make"
                                        :install "make install"
                                        :run     "make run"
                                        :test    "make test")

      ;; see: https://github.com/bbatsov/projectile/blob/master/projectile.el#L2636
      (projectile-register-project-type 'gradle '("build.gradle.kts")
                                        :run     "gradle run"
                                        :compile "gradle build"
                                        :test    "gradle test"
                                        :test-suffix "Spec")

      (projectile-register-project-type 'gradlew '("gradlew")
                                        :run     "./gradlew run"
                                        :compile "./gradlew build"
                                        :test    "./gradlew test"
                                        :test-suffix "Spec")

      (projectile-register-project-type 'golang '("go.mod")
                                        :run     "go run"
                                        :compile "go build"
                                        :test    "go test"
                                        :test-suffix "_test")

      (projectile-register-project-type 'cmake '("CMakeLists.txt")
                                        :project-file "CMakeLists.txt"
                                        :compilation-dir "build"
                                        :test "ctest"
                                        :configure "cmake %s -B %s"
                                        :run     "cmake --build . --target run"
                                        :compile "cmake --build ."
                                        :install "cmake --build . --target install"
                                        :package "cmake --build . --target package")

      (provide '+projectile-project-types)
    #+END_SRC

*** commands
    #+BEGIN_SRC emacs-lisp
      (use-package +projectile-commands
        :commands (projectile-persp-switch-project+
                   projectile-show-and-copy-project-dir
                   project-has-file-p
                   when-project-has-file-p)
        :leader
        ("pl" 'projectile-persp-switch-project+
         "py" 'projectile-show-and-copy-project-dir))
    #+END_SRC

    #+BEGIN_SRC emacs-lisp :tangle lisp/+projectile-commands.el
      (defun projectile-persp-switch-project--action+ (project)
        (let ((persp-reset-windows-on-nil-window-conf t)
              (project-name (file-name-nondirectory
                             (string-remove-suffix "/" project))))
          (persp-switch project-name)
          (projectile-switch-project-by-name project)))

      (defun projectile-persp-switch-project+ (arg)
        (interactive "P")
        (cond ((package! ivy)
               (ivy-read "Switch to Project Perspective: "
                         (if (projectile-project-p)
                             (cons (abbreviate-file-name (projectile-project-root))
                                   (projectile-relevant-known-projects))
                           projectile-known-projects)
                         :action #'projectile-persp-switch-project--action+))
              (t (message "Completion framework not supported"))))

      (defun projectile-show-and-copy-project-dir (&optional prefix)
        (interactive "P")
        (if (not (projectile-project-p))
            (message "you're not currently in a project")
          (let ((path (projectile-project-root)))
            (when prefix
              (if (and (consp prefix) (eq (car prefix) 4))
                  (insert path)
                (save-excursion
                  (insert path))))
            (message (abbreviate-file-name path))
            (kill-new path))))

      (defun project-has-file-p (&rest files)
        (let ((project-dir (projectile-project-p)))
          (and project-dir
               (cl-loop
                for file in files
                when (file-exists-p (concat project-dir file))
                return t))))

      (defmacro when-project-has-file-p (file &rest body)
        `(when (project-has-file-p ,file)
           ,@body))

      (provide '+projectile-commands)
    #+END_SRC

** real-auto-save-mode
   #+BEGIN_SRC emacs-lisp
     (use-package real-auto-save
       :straight t
       :defer  t
       :init
       (setq real-auto-save-interval 6))
   #+END_SRC

** sudo-edit
   Reopen the current file as root user.

   #+BEGIN_SRC emacs-lisp
      (use-package sudo-edit
        :straight t
        :defer  t
        :commands sudo-edit
        :leader
        ("fE" 'sudo-edit))
   #+END_SRC

** transpose-frame
   #+BEGIN_SRC emacs-lisp
     (use-package transpose-frame
       :straight (transpose-frame :host github :repo "emacsorphanage/transpose-frame")
       :defer t
       :general
       (:keymaps 'emacs-window-map
        "C-t" 'transpose-frame
        "t"   'transpose-frame
        "("   'rotate-frame-clockwise                                                ; 90 degrees
        ")"   'rotate-frame-anti-clockwise                                           ; 90 degrees
        "*"   'rotate-frame                                                          ; 180 degrees
        "F"   'flop-frame                                                            ; flip horizontally
        "f"   'flip-frame))
   #+END_SRC

** rainbow-delimeters
   pretty colors for my lisp parens :)

   #+BEGIN_SRC emacs-lisp
     (use-package rainbow-delimiters
       :straight t
       :defer  t
       :hook (prog-mode . rainbow-delimiters-mode)
       :commands rainbow-delimiters-mode)
   #+END_SRC

** undo-tree
   #+BEGIN_SRC emacs-lisp
     (use-package undo-tree
       :straight t
       :defer  t
       :diminish
       :init
       (global-undo-tree-mode +1)

       :config
       (push 'undo-tree-visualizer-mode
              whitespace-exempt-modes)

       (setq undo-tree-auto-save-history t
             ;; TODO look into undoing within region
             ;; undo-tree-enable-undo-in-region t
             )

       ;;; where do undo-tree auto-saves go.
       (setq undo-tree-history-directory-alist
             `(("." . ,(var! "undo"))))

       (defvar undo-tree-skip-autosave-regex+
         (rx
          (or
           ;; match extensions in filename
           (and (or ".pdf" ".log") eol)
           ;; match exact file paths
           (and
            (or
             ;; wildcard regexp match. any match is a valid match.
             (and "[*Org Src")
             ;; match from the beginning of the line
             (and bol (or
                       (eval dotemacs-var-path)
                       (eval (concat straight-base-dir "straight/"))
                       (eval package-user-dir)
                       (eval external-packages-directory)
                       (eval bookmark-default-file)
                       (eval +dashboard-banners-directory)))))))
         "don't create an undo-tree auto-save for file if `buffer-file-name' \
     matches this regexp.")

       (advice-add 'undo-tree-save-history :around
                   (defun undo-tree-save-history--respect-ignore+ (func &rest args)
                     "respect `undo-tree-skip-autosave-regex+'.
     also suppresses undo-tree messages relating to saving files."
                     (when (and undo-tree-skip-autosave-regex+
                                (not (string-match-p undo-tree-skip-autosave-regex+
                                                     buffer-file-name)))
                       (apply func args))))

       (advice-add 'undo-tree-save-history :around
                   (defun undo-tree-save-history--suppress-message+ (func &rest args)
                     (with-no-write-file-messages (apply func args))))

       (defun undo-tree-visualizer-set-and-exit-selection-mode ()
         (interactive)
         (funcall-interactively #'undo-tree-visualizer-set)
         (undo-tree-visualizer-selection-mode -1))

       :leader
       ("au" '("undo-tree" . undo-tree-visualize))

       :lazy-leader
       (:mode 'undo-tree-visualizer-mode
        "RET" 'undo-tree-visualizer-selection-mode
        "t" 'undo-tree-visualizer-toggle-timestamps
        "," 'undo-tree-visualizer-quit
        "q" 'undo-tree-visualizer-abort
        "d" 'undo-tree-visualizer-toggle-diff)

       :general
       (:keymaps 'undo-tree-map
        "C-/" nil "C-_" nil "C-?" nil)
       (:states  'motion
        :keymaps '(undo-tree-visualizer-mode-map
                   undo-tree-visualizer-selection-mode-map)
        "t" 'undo-tree-visualizer-toggle-timestamps
        "gj" 'undo-tree-visualize-redo-to-x
        "gk" 'undo-tree-visualize-undo-to-x

        [remap quit-window] 'undo-tree-visualizer-quit
        [remap evil-scroll-column-right] 'undo-tree-visualizer-scroll-left
        [remap evil-scroll-column-left] 'undo-tree-visualizer-scroll-right)
       (:states  'motion
        :keymaps 'undo-tree-visualizer-mode-map
        "h" 'undo-tree-visualize-switch-branch-left
        "l" 'undo-tree-visualize-switch-branch-right
        "d" 'undo-tree-visualizer-toggle-diff)
       (:states 'motion
        :keymaps 'undo-tree-visualizer-selection-mode-map
        "RET" 'undo-tree-visualizer-set-and-exit-selection-mode
        "h" 'undo-tree-visualizer-select-left
        "l" 'undo-tree-visualizer-select-right
        "d" 'undo-tree-visualizer-selection-toggle-diff))
   #+END_SRC

** uuidgen
   #+BEGIN_SRC emacs-lisp
     (use-package uuidgen
       :straight t
       :defer  t
       :leader
       ("iU" 'uuidgen
        ;; "U1" 'uuidgen-1
        ;; "U4" 'uuidgen-4
        ;; "UU" 'uuidgen-U
        ))
   #+END_SRC

** visible-mark
   highlight region when mark is active.

   #+BEGIN_SRC emacs-lisp
     (use-package visible-mark
       :straight t
       :defer  t
       :commands (visible-mark-mode))
    #+END_SRC

** which-key
   show completion candidates for the current key prefix, after a mild delay.

   TODO refactor

   #+BEGIN_SRC emacs-lisp
     (use-package which-key
       :straight t
       :demand t
       :diminish
       :commands (which-key-M-x+)
       :init
       ;; prefix-completion courtesy of clemara
       ;; see https://with-emacs.com/posts/ui-hacks/prefix-command-completion/
       (defun which-key-M-x-prefix+ (&optional _)
         "Completing read and execute command from prefix-map.

     This command can be used as `prefix-help-command'. The optional
     argument is ignored and only for compatability with
     `which-key-C-h-dispatch' so this command can be bound in
     `which-key-C-h-map', too."
         (interactive)
         (let* ((evs (cond ((which-key--current-prefix)
                            (which-key--current-key-list))
                           (t
                            (butlast (append (this-command-keys-vector) nil)))))
                (key  (and evs (apply #'vector evs))))
           (which-key-M-x+ key)))

       (setq prefix-help-command #'which-key-M-x-prefix+)

       :config
       (which-key-mode 1)

       ;; order of keys is case insensetive
       (setq which-key-sort-order 'which-key-key-order-alpha
             which-key-echo-keystrokes 0.02)

       (defun which-key-M-x+ (&optional key)
         "Completing read command and execute it.

     Only commands which are bound to keys are considered. If KEY is
     given it should be the prefix-key for which commands should be
     completed. Otherwise read command from top-level. "
         (interactive)
         (let ((cmd (which-key--completing-read-cmd+ key)))
           (when (commandp cmd)
             (which-key--execute-cmd+ cmd))))

       (defun which-key--completing-read-cmd+ (&optional prefix)
         "Completing read command for PREFIX.

     Read commands for PREFIX or top-level if PREFIX not given."
         (which-key--hide-popup-ignore-command)
         (let ((desc
                (completing-read
                 (if prefix
                     (format "Execute (%s): " (key-description prefix))
                   "Execute: ")
                 (mapcar #'which-key--completing-read-format+
                         (which-key--get-current-bindings prefix)))))
           (intern (car (split-string desc)))))

       (defun which-key--execute-cmd+ (cmd)
         "Execute command CMD as if invoked by key sequence."
         (setq prefix-arg current-prefix-arg)
         (setq this-command cmd)
         (setq real-this-command cmd)
         (command-execute cmd 'record))

       (defun which-key--completing-read-format+ (bnd)
         "Format binding BND for `completing-read'."
         (let* ((key (car bnd))
                (cmd (cdr bnd))
                (desc (format "%s (%s)" cmd
                              (propertize key 'face 'which-key-key-face))))
           (which-key--maybe-add-docstring
            (format "%-50s" desc) cmd)))

       :leader
       ("hk"    'which-key-show-top-level
        "h RET" 'which-key-M-x+))
   #+END_SRC

** with-editor
   package used by ~magit~ for controlling emacsclient.

   #+BEGIN_SRC emacs-lisp
     (with-eval-after-load 'with-editor
       (leader/with-prefix leader-major-mode-prefix
         (leader/set-keys-for-mode 'with-editor-mode
           ","  'with-editor-finish
           "q"  'with-editor-cancel)))
    #+END_SRC

** winum
   number windows, to make jumping to them easier.

   #+BEGIN_SRC emacs-lisp
     (use-package winum
       :straight t
       :demand t
       :config
       (winum-mode)

       (with-eval-after-load 'which-key
         ;; reset 1st window number option to window by number
         (push (cons '("\\(.*\\) 1" . "winum-select-window-1")
                     '("\\1 1..9"   . "window-by-number"))
               which-key-replacement-alist)

         ;; hide numbers 2 through to nine
         (push (cons '(nil . "winum-select-window-[2-9]") t)
               which-key-replacement-alist)

         ;; abbreviate 0 value
         (push (cons '("\\(.*\\) 0" . "winum-select-window-by-number")
                     '("\\1 0"      . "window-by-prompt"))
               which-key-replacement-alist))

       :general
       (:keymaps 'emacs-window-map
        "1" 'winum-select-window-1
        "2" 'winum-select-window-2
        "3" 'winum-select-window-3
        "4" 'winum-select-window-4
        "5" 'winum-select-window-5
        "6" 'winum-select-window-6
        "7" 'winum-select-window-7
        "8" 'winum-select-window-8
        "9" 'winum-select-window-9
        "0" 'winum-select-window-by-number))
   #+END_SRC

** yasnippet
   Yet another snippets tool... but amazingly powerful. :-P. See the snippet [[https://joaotavora.github.io/yasnippet/snippet-development.html#org6796ab7][dev]] guide.

   #+BEGIN_SRC emacs-lisp
     <<tangle-snippets()>>
   #+END_SRC

   #+NAME: tangle-snippets
   #+BEGIN_SRC emacs-lisp :tangle no :results values
     (org-babel-tangle-file "etc/snippets.org")
     nil
   #+END_SRC

*** yasnippet
    #+BEGIN_SRC emacs-lisp
      (use-package yasnippet
        :straight t
        :defer  load-me-now-duration
        :diminish yas-minor-mode
        :leader
        ("iSn" 'yas-new-snippet
         "fS" 'yas-visit-snippet-file)

        :config
        (setq yas-triggers-in-field t
              yasnippet-snippets-dir (etc! "snippets/")
              yas-snippet-dirs '(yasnippet-snippets-dir))

        (yas-global-mode 1)

        (leader/set-keys-for-major-mode 'snippet-mode
          "m" 'yas-load-snippet-buffer-and-close
          "l" 'yas-load-snippet-buffer
          "t" 'yas-tryout-snippet)

        :general
        (:states 'insert
         [C-i] 'yas-expand
         "M-I" 'yas-expand)
        (:keymaps 'yas-keymap
         "<C-return>" 'yas-next-field
         "<C-M-return>" 'yas-prev-field
         "C-l" 'yas-next-field
         "C-h" 'yas-prev-field))
    #+END_SRC

*** licenses
    Use yas to generate and insert license headers for the current buffer.

    #+BEGIN_SRC emacs-lisp
      (use-package +yas-license
        :defer t
        :commands +insert-license
        :leader
        ("ia" '+insert-license))
    #+END_SRC

    #+BEGIN_SRC emacs-lisp :tangle lisp/+yas-license.el
      (require 'yasnippet)

      (defvar +license-dir (etc! "licenses")
        "Directory in which to find license snippets.")

      (defvar +license-dont-be-evil nil
        "Append don't be evil clause to licenses.
      see [[https://en.wikipedia.org/wiki/Douglas_Crockford][Douglas Crockford]].")

      (defvar +license-last-inserted nil
        "The fully populated last inserted license template.")

      (cl-defun +license-get-name (&optional default)
        (let ((name (s-join " " (delq nil (list
                                           (+profile-get 'first-name)
                                           (+profile-get 'last-name))))))
          (if (string-empty-p name) default name)))

      (defun +license--licenses (&optional dir)
        "return an alist of (basename . file) for all .license files in DIR.
      Where DIR defaults to the current working directory (`default-directory')."
        (cl-loop
         for file in (file-expand-wildcards
                      (concat (if dir
                                  (concat dir "/")
                                default-directory)
                              "*.license"))
         collect (cons (file-name-base file) file)))

      (defun +license--read-license ()
        (let ((licenses (+license--licenses +license-dir))
              license)
          (when (zerop (length licenses))
            (error "No licenses found in dir: %s" default-directory))

          (setq license
                (if (eq 1 (length licenses))
                    (car licenses)
                  (assoc (completing-read "License: " licenses nil t) licenses)))

          (with-temp-buffer
            (insert-file-contents (cdr license))
            (cons (car license)
                  (buffer-substring (point-min) (point-max))))))

      (cl-defmacro +with-temp-buffer-and-same-vars ((&rest vars) &rest body)
        "Store the values of VARS in current buffer, and then create a
      temp buffer reassigning the values of VARS and then invoking BODY."
        (let* ((current-vars
                (cl-loop with name = nil
                         for var in vars
                         do (setq name (symbol-name var))
                         collect (list (intern (concat "-current-" name))
                                       var)))
               (assign-vars
                (cl-loop for var in current-vars
                         collect (list (nth 1 var) (car var)))))
          `(let ,current-vars
             (with-temp-buffer
               (let ,assign-vars
                 ,@body)))))
      (put '+with-temp-buffer-and-same-vars 'lisp-indent-function 'defun)

      (defun +license--comment-template (template &optional prefix)
        (+with-temp-buffer-and-same-vars
            (comment-start comment-end comment-style
             comment-multi-line comment-add comment-continue)
          (insert template)
          (comment-region (point-min) (point-max) prefix)
          (buffer-substring (point-min) (point-max))))

      (defun +insert-license (&optional prefix)
        "Insert a license from the known license list.
      with PREFIX, repeats insertion of the last inserted license."
        (interactive "P")
        (let* ((license
                (if (and prefix +license-last-inserted)
                    +license-last-inserted
                  (+license--read-license)))
               (comment-multi-line t))
          (yas-expand-snippet
           (+license--comment-template (cdr license))
           nil nil
           '((yas-indent-line 'fixed)))

          (setq +license-last-inserted license)))

      (provide 'yas-license)
    #+END_SRC

**** Types
     :PROPERTIES:
     :header-args+: :shebang :comments none
     :END:

     #+BEGIN_SRC snippet :tangle etc/licenses/GPL-2.0.license
       Copyright (C) `(format-time-string "%Y")`  ${1:`(capitalize (+license-get-name "name"))`}

       This program is free software; you can redistribute it and/or
       modify it under the terms of the GNU General Public License
       as published by the Free Software Foundation; either version 2
       of the License, or (at your option) any later version.

       This program is distributed in the hope that it will be useful,
       but WITHOUT ANY WARRANTY; without even the implied warranty of
       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
       GNU General Public License for more details.

       You should have received a copy of the GNU General Public License
       along with this program; if not, write to the Free Software
       Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
     #+END_SRC

     #+BEGIN_SRC snippet :tangle etc/licenses/GPL-3.0.license
       Copyright (C) `(format-time-string "%Y")`  ${1:`(capitalize (+license-get-name "name"))`}

       This file is part of ${2:this program}.

       $2 is free software: you can redistribute it and/or modify
       it under the terms of the GNU General Public License as published by
       the Free Software Foundation, either version 3 of the License, or
       (at your option) any later version.

       $2 is distributed in the hope that it will be useful,
       but WITHOUT ANY WARRANTY; without even the implied warranty of
       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
       GNU General Public License for more details.

       You should have received a copy of the GNU General Public License
       along with $2.  If not, see <https://www.gnu.org/licenses/>.
     #+END_SRC

     #+BEGIN_SRC snippet :tangle etc/licenses/Apache-2.0.license
       Copyright `(format-time-string "%Y")` ${1:`(capitalize (+license-get-name "name"))`}

       Licensed under the Apache License, Version 2.0 (the "License");
       you may not use this file except in compliance with the License.
       You may obtain a copy of the License at

           http://www.apache.org/licenses/LICENSE-2.0

       Unless required by applicable law or agreed to in writing, software
       distributed under the License is distributed on an "AS IS" BASIS,
       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       See the License for the specific language governing permissions and
       limitations under the License.
     #+END_SRC

     #+BEGIN_SRC snippet :tangle etc/licenses/Boost.license
                Copyright ${1:`(capitalize (+license-get-name "name"))`} `(format-time-string "%Y")` - ${2:`(format-time-string "%Y")`}.
       Distributed under the Boost Software License, Version 1.0.
          (See accompanying file LICENSE_1_0.txt or copy at
                https://www.boost.org/LICENSE_1_0.txt)
     #+END_SRC

     #+BEGIN_SRC snippet :tangle etc/licenses/MIT.license
       Copyright (c) `(format-time-string "%Y")` ${1:`(capitalize (+license-get-name "name"))`}

       Permission is hereby granted, free of charge, to any person obtaining a copy
       of this software and associated documentation files (the "Software"), to deal
       in the Software without restriction, including without limitation the rights
       to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       copies of the Software, and to permit persons to whom the Software is
       furnished to do so, subject to the following conditions:

       The above copyright notice and this permission notice shall be included in all
       copies or substantial portions of the Software.

       THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
       SOFTWARE.
     #+END_SRC

     #+BEGIN_SRC snippet :tangle etc/licenses/ISC.license
       Copyright (c) `(format-time-string "%Y")` ${1:`(capitalize (+license-get-name "name"))`} ${2:`(+profile-get 'email "user@your.domain")`}

       Permission to use, copy, modify, and distribute this software for any
       purpose with or without fee is hereby granted, provided that the above
       copyright notice and this permission notice appear in all copies.

       THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
       WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
       MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
       ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
       WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
       ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
       OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
     #+END_SRC

     #+BEGIN_SRC snippet :tangle etc/licenses/BSD.license
       Copyright (c) `(format-time-string "%Y")` ${1:`(capitalize (+license-get-name "name"))`}

       Redistribution and use in source and binary forms, with or without
       modification, are permitted provided that the following conditions
       are met:
       1. Redistributions of source code must retain the above copyright
          notice, this list of conditions and the following disclaimer.
       2. Redistributions in binary form must reproduce the above copyright
          notice, this list of conditions and the following disclaimer in the
          documentation and/or other materials provided with the distribution.

       THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS \`\`AS IS'' AND
       ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
       IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
       ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
       FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
       DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
       OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
       HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
       LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
       OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
       SUCH DAMAGE.
     #+END_SRC

     #+BEGIN_SRC snippet :tangle etc/licenses/BSD-3c.license
       Copyright (c) `(format-time-string "%Y")` ${1:`(capitalize (+license-get-name "name"))`}

       Redistribution and use in source and binary forms, with or without
       modification, are permitted provided that the following conditions
       are met:
       1. Redistributions of source code must retain the above copyright
          notice, this list of conditions and the following disclaimer.
       2. Redistributions in binary form must reproduce the above copyright
          notice, this list of conditions and the following disclaimer in the
          documentation and/or other materials provided with the distribution.
       3. Neither the name of the author nor the names of its contributors may
          be used to endorse or promote products derived from this software

       THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS \`\`AS IS'' AND
       ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
       IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
       ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
       FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
       DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
       OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
       HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
       LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
       OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
       SUCH DAMAGE.
     #+END_SRC

*** auto-yasnippet
    allows you to create dynamic/in-place snippets and repeatedly execute them.

    #+BEGIN_SRC emacs-lisp
      (use-package auto-yasnippet
        :straight t
        :defer  t
        :leader
        ("iS"  "auto-yasnippet"
         "iSc" 'aya-create
         "iSe" 'aya-expand
         "iSw" 'aya-persist-snippet)

        :general
        (:states 'insert
         "M-i" 'aya-expand))
    #+END_SRC

* Builtins
** prettify-symbols
   lets you convert identifiers like lambda into unicode symbols like Œª... isn't that
   epic :).

   #+BEGIN_SRC emacs-lisp
     (use-package prog-mode
       :delight  (prettify-symbols-mode "Œª")
       :defer t
       :init
       (setq lisp-prettify-symbols-alist nil
             ;; don't need to keep symbolifying it whilst I'm on it
             prettify-symbols-unprettify-at-point t))
   #+END_SRC

*** configure-presym
    :PROPERTIES:
    :header-args+: :tangle lisp/+configure-presym.el
    :END:

    Utility macro to make [[*prettify-symbols][prettify-symbols]] mode easier to setup for individual modes.

    #+BEGIN_SRC emacs-lisp :tangle init.el
      (use-package +configure-presym
        :commands 'configure-presym!)

      (defvar prettify-symbols-pretty-symbols-alist+ nil
        "alist of mode to pretty symbols ")
    #+END_SRC

    #+BEGIN_SRC emacs-lisp
      ;; inspired by: [[https://emacs.stackexchange.com/questions/34808/using-prettify-symbols-with-strings-instead-of-characters][this post]].
      (defun prettify-symbols-string+ (to)
        "get a prettify symbols entry to map a string to a string."
        (let ((length (length to)))
          (cl-loop for i from 0 to length
                   for char in (string-to-list to)
                   unless (eq i (- length 1))
                   do (setq char (list char '(Br . Bl)))
                   else
                   do (setq char (list char))
                   end
                   append char)))

      (defun configure-presym--prepare-args (args)
        "convert ARGS to partitioned 2 length cons cells.
      ARGS should simply be a flat sequence of string to pretty-symbol.

      The pretty-symbol part can be a given as a string, to automatically
      pass through `prettify-symbols-string+'.
      "
        (cl-loop for (src dest) in (-partition 2 args)
                 collect (cons src
                               (if (stringp dest)
                                   (prettify-symbols-string+ dest)
                                 dest))))

      ;; TODO add duplicate remove check.
      (defmacro configure-presym! (modes &rest args)
        "Configure prettify-symbols for modes MODES.
      This function adds/modifies an entry for mode in the
      `prettify-symbols-pretty-symbols-alist+' alist and binds a hook in MODES
      mode-hook to enable `prettify-symbols-mode'.

      MODES can be given as a quoted list, or a single quoted mode name or a
      variable pointing to either of these types (and discoverable at macro
      expansion time).

      ARGS should be a form acceptable by `configure-presym--prepare-args'.

      eg.

      > (configure-presym! 'org-mode \"lambda\" ?Œª)
      "
        (plist-bind! (args :remove-duplicates)
          (setq modes (eval modes))

          (when modes
            (unless (listp modes)
              (setq modes `(,modes))))

          (let (res ; aggregate forms into here
                (tuples (configure-presym--prepare-args args)))
            (dolist (mode modes)
              (let ((mode-name (symbol-name mode)))
                (push
                 `(let ((config (assoc (quote ,mode) prettify-symbols-pretty-symbols-alist+)))
                    (if config
                        ; add to existing config, while preventing cyclic loops
                        (nconc-safe (car (cdr config)) tuples)
                      (push (cons (quote ,mode) (list tuples))
                            prettify-symbols-pretty-symbols-alist+)

                      (add-hook (quote ,(intern (concat mode-name "-hook")))
                                (defun ,(intern (concat "configure-presym-" mode-name)) (&rest _)
                                  ,(concat "sets up pretty symbols for " mode-name)
                                  (let ((config (assoc (quote ,mode)
                                                       prettify-symbols-pretty-symbols-alist+)))
                                    (when (and config
                                               (setq config (car (cdr config))))
                                      (setq prettify-symbols-alist
                                            (append prettify-symbols-alist
                                                    (copy-sequence config)))

                                      (prettify-symbols-mode +1)))))))
                 res)))
            `(let ((tuples (quote ,tuples))) ,@res))))
      (put 'configure-presym! 'lisp-indent-function 'defun)

      (provide '+configure-presym)
    #+END_SRC

** auto-fill-mode
   #+BEGIN_SRC emacs-lisp
     (use-package simple
       :commands set-word-wrap-column
       :leader
       ("ta" 'set-word-wrap-column)

       :config
       (defun set-word-wrap-column (&optional arg)
         "set the maximum wanted length for a line in this buffer.
     This function enables `auto-fill-mode' in this buffer and sets
     the fill column value.

     If `auto-fill-mode' is already active and this function is called
     with no ARG, then a new `fill-column' value is interactively read.
     This also happens if a non numeric ARG is passed.

     If ARG is a number, `fill-column' is set to the value of that number.

     However, if the final value of ARG resolves to be non-positive,
     `auto-fill-mode' will be disabled.
     "
         (interactive "P")
         (let ((active (bound-and-true-p auto-fill-function)))
           (setq arg
                 (cond
                  ((numberp arg)
                   arg)
                  ((or (consp arg)
                       active)
                   ;; why would you pass a prefix to make this ask you for a number
                   ;; instead of just passing the number, dummy?
                   (read-number "fill-column: " fill-column))
                  (t fill-column)))

           (if (<= arg 0)
               (auto-fill-mode -1)
             (or active
                 (auto-fill-mode +1))
             (setq fill-column arg)))))
   #+END_SRC

** auto-revert-mode
   #+BEGIN_SRC emacs-lisp
     (use-package auto-revert-mode
       :straight (auto-revert-mode :type built-in)
       :defer t
       :diminish auto-revert-mode)
   #+END_SRC

** bookmarks
   #+BEGIN_SRC emacs-lisp
     (use-package bookmark
       :config
       ;; prioritise recently used bookmarks over just the default list.
       (defadvice bookmark-jump (after bookmark-jump activate)
         (let ((latest (bookmark-get-bookmark bookmark)))
           (setq bookmark-alist (delq latest bookmark-alist))
           (push latest bookmark-alist))))
   #+END_SRC

** buffer-menu
   The default buffer menu provided by emacs.

   #+BEGIN_SRC emacs-lisp :tangle (package-yes! buffer-menu)
     (use-package buff-menu
       :defer t
       :lazy-leader
       (:mode 'Buffer-menu-mode
        "1" 'Buffer-menu-1-window
        "2" 'Buffer-menu-2-window
        "f" 'Buffer-menu-toggle-files-only
        "/" 'Buffer-menu-isearch-buffers-regexp
        "o" 'Buffer-menu-multi-occur
        "T" 'Buffer-menu-visit-tags-table)

       :general
       (:keymaps 'Buffer-menu-mode-map
        "0" nil "1" nil "2" nil "<" nil ">" nil "?" nil "C-d" nil "C-k" nil
        "S-SPC" nil "SPC" nil "<backtab>" nil "TAB" nil "T" nil "b" nil "e" nil
        "f" nil "g" nil "h" nil "n" nil "p" nil "t" nil "v" nil "SPC" nil)
       (:keymaps 'Buffer-menu-mode-map
        "C-SPC" 'Buffer-menu-mark
        "S-DEL" 'Buffer-menu-bury
        "r"   'Buffer-menu-toggle-read-only
        "C-j" 'Buffer-menu-this-window
        "gr"  'revert-buffer
        "gf" 'Buffer-menu-toggle-files-only
        "C-l" 'tabulated-list-next-column
        "C-M-<return>" 'Buffer-menu-select))
   #+END_SRC

** calc
   #+BEGIN_SRC emacs-lisp
     (use-package calc
       :defer t
       :after evil
       :init
       (advice-add 'evil-get-register :before-until
                   (defun evil-register-*-is-calc (register &optional _)
                     "make evils * register paste from head of calculator stack."
                     (when (eq register ?*)
                       (condition-case err
                           (with-temp-buffer
                             (calc-copy-to-buffer nil)
                             (buffer-substring (point-min) (point-max)))
                         (error (unless err (signal (car err) (cdr err)))
                                "")))))

       :config
       (evil-set-initial-state 'calc-mode 'motion)

       (add-hook 'calc-mode-hook
                 (defun calc--disable-evil-snipe (&rest _)
                   "overrides f, so disable it :P."
                   (when (bound-and-true-p evil-snipe-local-mode)
                     (evil-snipe-local-mode -1))))

       (evil-define-command evil-calc-call-kbd-macro (count macro)
         (interactive
          (let (count macro register)
            (setq count (prefix-numeric-value current-prefix-arg)
                  register (or evil-this-register read-char))
            (cond
             ((eq register ?@)
              (unless evil-last-register
                (user-error "No previously executed keyboard macro."))
              (setq macro (evil-get-register evil-last-register t)))
             (t
              (setq macro (evil-get-register register t)
                    evil-last-register register)))
            (list count macro)))

         (evil-with-single-undo
           (let ((last-kbd-macro macro))
             (dotimes (_ (or count 1))
               (calc-call-last-kbd-macro)))))

       (evil-define-motion evil-calc-next-line (count)
         (interactive "<c>")
         (evil-next-line count)

         (when (eobp)
           (calc-realign)

           (when (evil-visual-state-p)
             (forward-line -1)))

         (goto-char (+ 4 (line-beginning-position))))

       (evil-define-motion evil-calc-prev-line (count)
         (interactive "<c>")
         (evil-previous-line count)

         (when (eq (point-min) (line-beginning-position))
           (calc-goto-point-min))

         (goto-char (+ 4 (line-beginning-position))))

       (defun calc-goto-point-min ()
         (interactive)
         (goto-line 2)
         (forward-char 4)
         (recenter))

       (advice-add 'calc-scroll-down :around
                   (defun calc-scroll-down--make-goto-point-min (func &rest args)
                     "for some reason, scrolling before `point-min' doesn't change point."
                     (let ((current-point (point)))
                       (apply func args)

                       (when (eq (point) current-point)
                         (calc-goto-point-min)))))

       (defun evil-calc-visual-state ()
         (interactive)
         (when (string-match-p (rx bol (zero-or-more whitespace)
                                   "." eol)
                               (buffer-substring
                                (line-beginning-position)
                                (line-end-position)))
           (funcall-interactively 'evil-calc-prev-line 1))

         (evil-visual-line))

       :lazy-leader
       (:mode 'calc-mode
        ;; TODO complete leader binding list :P.
        "," 'calc-comma)

       :general
       (:keymaps 'calc-mode-map
        "<override-state>" 'motion
        [remap quit-window] 'calc-quit)
       (:keymaps 'calc-mode-map
        "SPC" nil                                                               ; causes recursion-overflow
        "C-w" nil                                                               ; calc-kill-region
        "U"   nil                                                               ; calc-undo
        "D"   nil                                                               ; calc-redo
        "Y"   nil                                                               ; empty prefix :P
        "@"   nil                                                               ; calcDigit-start
        "h"   nil                                                               ; calc-help-prefix
        "i"   nil                                                               ; calc-info

        ;; copies head of stack to point in buffer.
        "y"   nil                                                               ; calc-copy-to-buffer
        "C-d" nil                                                               ; calc-pop
        )
       (:states '(motion visual)
        :keymaps 'calc-mode-map

        "C-w" 'emacs-window-map
        "M-u" 'smart-universal-argument

        "g"   nil
        "gg"  'calc-goto-point-min ;; was calc-graph-grid
        "gq"  'quit-window
        "gQ"  'calc-graph-quit

        "j" 'evil-calc-next-line
        "k" 'evil-calc-prev-line)
       (:states 'visual
        :keymaps 'calc-mode-map
        "x" 'calc-kill-region
        "d" 'calc-kill-region
        "y" 'calc-copy-region-as-kill)
       (:states 'motion
        :keymaps 'calc-mode-map
        "q"   'evil-record-macro
        "@"   'evil-calc-call-kbd-macro
        "y"   'calc-copy-as-kill
        "v"   'evil-calc-visual-state
        "u"   'calc-undo
        "G"   'calc-realign
        "C-r" 'calc-redo
        "C-t" 'calc-transpose-lines

        [remap evil-scroll-up]   'calc-scroll-down
        [remap evil-scroll-down] 'calc-scroll-up

        [remap quit-window] 'calc-quit

        ;; [C-m] (general-simulate-key "v" :state 'emacs)
        "f"   (general-simulate-key "u" :state 'emacs)
        "C-v" (general-simulate-key "j" :state 'emacs)
        "C-n" (general-simulate-key "k" :state 'emacs)))
   #+END_SRC

** calendar
   #+BEGIN_SRC emacs-lisp
     (use-package calendar
       :defer t
       :config
       (push 'calendar-mode whitespace-exempt-modes)

       :general
       (:states  'motion
        :keymaps 'calendar-mode-map
        ;; see also [[https://github.com/emacs-evil/evil-collection/blob/master/evil-collection-calendar.el][evil-collection]].
        ;; globally useful
        [remap quit-window] 'calendar-exit
        "p"  'calendar-print-day-of-year
        "c"  'calendar-count-days-region
        "?"  'calendar-goto-info-node
        "gr" 'calendar-redraw

        ;; jumpt to date
        "."  'calendar-goto-today
        "h"  'calendar-backward-day
        "j"  'calendar-forward-week
        "k"  'calendar-backward-week
        "l"  'calendar-forward-day
        "0"  'calendar-beginning-of-week
        "$"  'calendar-end-of-week
        "[[" 'calendar-backward-year
        "]]" 'calendar-forward-year
        "("  'calendar-beginning-of-month
        ")"  'calendar-end-of-month
        "{"  'calendar-backward-month
        "}"  'calendar-forward-month
        "/"  'calendar-goto-date

        "C-h" 'calendar-backward-month
        "C-l" 'calendar-forward-month
        "C-j" 'calendar-scroll-left-three-months
        "C-k" 'calendar-scroll-right-three-months

        ;; marking and unmarking
        "X"  'calendar-unmark
        "v"  'calendar-set-mark
        "x"  'calendar-mark-holidays

        ;; diary interaction
        "D"  'diary-view-other-diary-entries
        "d"  'diary-view-entries
        "m"  'diary-mark-entries
        "s"  'diary-show-all-entries))
   #+END_SRC

** change-log-mode
   #+BEGIN_SRC emacs-lisp
     (use-package add-log
       :defer t
       :config
       (push 'change-log-mode whitespace-exempt-modes)
       (evil-set-initial-state 'change-log-mode 'motion)

       :lazy-leader
       (:mode 'change-log-mode
        "SPC" 'change-log-goto-source
        "f" 'change-log-find-file
        "j" 'add-log-edit-next-comment
        "K" 'add-log-edit-prev-comment)

       :general
       (:states 'motion
        :keymaps 'change-log-mode-map
        "o" 'change-log-goto-source
        "C-j" 'add-log-edit-next-comment
        "C-K" 'add-log-edit-prev-comment))
   #+END_SRC

** compile
    setup some custom bindings and assign a post compilation hook which will
    automatically kill the compilation window.

    #+BEGIN_SRC emacs-lisp
      (use-package compile
        :straight t
        :defer  t
        :commands (display-compilation-buffer
                   +set-compilation-bindings)
        :config
        (push 'compilation-mode whitespace-exempt-modes)

        (setq compilation-read-command nil
              compilation-scroll-output 'first-error)

        (defvar compilation-last-buffer nil
          "the last open compilation buffer.")

        (add-hook 'compilation-finish-functions
                  (lambda (buf &rest _)
                    (setq compilation-last-buffer buf)))

        (defun compilation-colorize+ ()
          "Colorize from `compilation-filter-start' to `point'.
      Taken from [[https://emacs.stackexchange.com/a/38531][here]]."
          (require 'ansi-color)
          (let ((inhibit-read-only t))
            (ansi-color-apply-on-region
             compilation-filter-start (point))))
        (add-hook 'compilation-filter-hook #'compilation-colorize+)

        (defun display-compilation-buffer ()
          (interactive)
          (let* ((buffer
                  (or compilation-last-buffer
                      (get-buffer
                       (if compilation-buffer-name-function
                           (funcall compilation-buffer-name-function "compilation")
                         "*compilation*"))))
                 (window (if (not buffer)
                             (user-error "compilation buffer doesn't exist")
                           (display-buffer buffer))))
            (select-window window t)))

        (defun +set-compilation-bindings (mode map)
          (leader/set-keys-for-major-mode mode
            "RET" 'recompile
            "k" 'kill-compilation
            "f" 'next-error-follow-minor-mode)

          (general-unbind
            :keymaps map
            "S-SPC" "SPC" "DEL" "M-p" "M-n" "M-{" "M-}"
            "0" "h" "g" "?" "n" "p" "<override-state>")

          (general-define-key
            :keymaps map
            :states  'motion
            [remap revert-buffer] 'recompile
            "gj"  'compilation-next-error
            "gk"  'compilation-previous-error
            "gn"  'next-error-no-select
            "gp"  'previous-error-no-select
            "o"   'compilation-display-error
            ;; "j"   'compilation-next-error
            ;; "k"   'compilation-previous-error
            "x"   'kill-compilation
            "C-j" 'compilation-next-file
            "C-k" 'compilation-previous-file)

          (general-define-key
            :keymaps map
            :states  '(replace insert)
            "ESC" 'evil-motion-state))

        (+set-compilation-bindings 'compilation-mode 'compilation-mode-map)

        :general
        (:states  'motion
         :keymaps 'compilation-mode-map
         "j" nil "k" nil)
        (:keymaps 'emacs-lisp-compilation-mode-map
         [remap revert-buffer] 'emacs-lisp-compilation-recompile))
    #+END_SRC

*** auto-kill
    #+BEGIN_SRC emacs-lisp
      (defvar compilation-auto-kill-window 2
        "if non-nil, after a successfull compilation the compilation
      window, if open, will automatically be deleted.

      If set to a numerical value, window will be deleted after that many
      seconds.")

      (defvar compilation-auto-kill-ignore-modes nil
        "major modes spawned by `compile' for which auto-kill doesn't take place.")

      (defvar compilation-dont-auto-kill-window-when '(warnings focus)
        "specify not to kill the window when warning, error or info given.
      a list which can take in any symbol from (errors infos warnings).

      you can also specify a symbol, focus, to cancel window killing when
      the compilation window was already open when the compilation was
      started.")

      (defvar compilation-was-open-p nil
        "true whether the compilation window was visible when compilation began.")

      (advice-add 'compilation-start :before
                  (defun compilation-check-window-was-open+ (command &optional mode name-function highlight-regexp)
                    ;; name-of-mode and buf-name sourced from compile.el
                    (let* ((mode (or mode 'compilation-mode))
                           (name-of-mode (if (eq mode t)
                                             "compilation"
                                           (replace-regexp-in-string "-mode\\'" "" (symbol-name mode))))
                           (buf-name (compilation-buffer-name name-of-mode mode name-function))
                           buf)
                      (setq compilation-was-open-p
                            (and (setq buf (get-buffer buf-name))
                                 (get-buffer-window buf)
                                 t)))))

      (defun compilation-safely-close-window+ (buffer)
        (when (and buffer
                   (not (get-buffer-process buffer)))
          ;; don't skip if new compilation began before window
          ;; from previous compilation has been killed.
          (quit-windows-on buffer)))

      (defun compilation-cancel-auto-kill-p+ ()
        "whether to cancel compilation window auto-kill due to `compilation-dont-auto-kill-window-when'."
        (let ((associations '((errors   . compilation-num-errors-found)
                              (warnings . compilation-num-warnings-found)
                              (infos    . compilation-num-infos-found))))
          (cl-loop for (name . var) in associations
                   when (and (member name compilation-dont-auto-kill-window-when)
                             (not (zerop (eval var))))
                   collect (symbol-name name))))

      (defun compilation-finish-function+ (buf str)
        "hook to automatically hide compilation output."
        (when (and compilation-auto-kill-window
                   (and (member 'focus compilation-dont-auto-kill-window-when)
                        (not compilation-was-open-p))
                   ;; an abnormal exit automatically cancels window kill
                   (not (string-match-p (rx (zero-or-more any)
                                            "exited abnormally"
                                            (zero-or-more any))
                                        str))
                   (not (apply 'derived-mode-p
                               compilation-auto-kill-ignore-modes)))
          (let* ((terminate-window t))
            (let ((notifications (compilation-cancel-auto-kill-p+)))
              (when notifications
                (when debug-on-error
                  (message "window kill suspended due to encountering: %s"
                           (combine-and-quote-strings notifications)))
                (setq terminate-window nil)))

            (when terminate-window
              (if (numberp compilation-auto-kill-window) ;; kill after delay
                  (run-at-time (concat (number-to-string compilation-auto-kill-window)
                                       " sec")
                               nil 'compilation-safely-close-window+ buf)
                (compilation-safely-close-window+ buf))))))

      (with-eval-after-load 'compile
        (add-hook 'compilation-finish-functions 'compilation-finish-function+)
        (add-hook 'compilation-finish-functions
                  (lambda (&rest _)
                    (when (eq major-mode 'comint-mode)
                      (compilation-mode)))))
    #+END_SRC

** comint
   Mode to emulate a terminal, doesn't support much real terminal functionality but
   it's good enough for basic executions.

   #+BEGIN_SRC emacs-lisp
     (use-package comint
       :straight (comint :type built-in)
       :defer t
       :hook ((comint-mode . (lambda ()
                               (setq-local evil-emacs-state-cursor 'bar))))
       :config
       (push 'comint-mode whitespace-exempt-modes)
       (evil-set-initial-state 'comint-mode 'emacs)

       (setq comint-mode-map (make-sparse-keymap) ;; reset all
             comint-prompt-read-only t))
    #+END_SRC

    I've moved comint commands and binding declarations into a seperate file, because
    some packages override comint maps so you'll need to assign the same bindings for
    multiple modes and it's easier when their contained in a function.

    #+BEGIN_SRC emacs-lisp
      (use-package +comint-bindings
        :commands (+comint-set-bindings
                   +comint-set-leader-keys)
        :after comint
        :init
        (+comint-set-bindings 'comint-mode-map)
        (+comint-set-leader-keys 'comint-mode))
    #+END_SRC

    #+BEGIN_SRC emacs-lisp :tangle lisp/+comint-bindings.el
      (defun comint-bol-point (&optional arg)
        (save-excursion
          (comint-bol arg)
          (point)))

      (defun comint-backward-delete-char (&optional arg)
        "delete upto ARG characters backward, ignoring the prompt."
        (interactive "p")
        (or arg (setq arg 1))

        (if (<= (comint-bol-point)
                (- (point) arg 1))
            (backward-delete-char arg)
          (delete-region (point) (comint-bol-point))))

      (defmacro comint-clamp-point-to-bol (&rest body)
        "ensures any operation done by body doesn't move point
      to before the command interpreter prompt."
        `(let ((bol (comint-bol-point)))
           ,@body ;; run body operations

           (when (< (point) bol)
             (goto-char bol))))

      (defun comint-backward-char (&optional N)
        (interactive "P")
        (comint-clamp-point-to-bol (backward-char N)))

      (defun comint-backward-word (&optional N)
        (interactive "P")
        (comint-clamp-point-to-bol (backward-word N)))

      (defun comint-on-prompt-line-p ()
        (interactive)
        (save-excursion
          (let ((point (point))
                (current-line (what-line)))
            (goto-char (comint-bol-point))
            (string-equal (what-line) current-line))))

      ;; TODO support prefix arg
      (defun comint-previous-input-or-previous-line ()
        (interactive)
        (if (comint-on-prompt-line-p)
            (call-interactively 'comint-previous-input)
          (comint-clamp-point-to-bol
           (previous-line))))

      (defun comint-next-input-or-next-line ()
        (interactive)
        (if (eobp)
            (call-interactively 'comint-next-input)
          (next-line)))

      ;; TODO ensure history shifts maintain correct cursor position
      ;; (advice-add 'comint-previous-input :after 'comint-bol)
      ;; (advice-add 'comint-next-input     :after 'end-of-buffer)

      (defun +comint-set-bindings (keymap)
        ;; abstracted into a method because realgud seems
        ;; to hide all of these bindings.
        (general-define-key
         :keymaps keymap
         "RET" 'comint-send-input
         "M-RET" 'comint-accumulate

         "DEL" 'comint-backward-delete-char
         "<backspace>" 'comint-backward-delete-char

         "<C-backspace>" 'evil-backward-delete-word

         "M-DEL" 'comint-kill-input
         "<M-backspace>" 'comint-kill-input

         "<mouse-2>" 'comint-insert-input

         "C-w" emacs-window-map
         "M-w" 'backward-kill-word
         "M-l" 'recenter-top-bottom
         ;; "C-M-l" 'comint-show-output

         "C-a" 'comint-bol-or-process-mark
         "C-e" 'end-of-buffer       ;; 'end-of-line
         "C-s" 'comint-history-isearch-backward-regexp
         "M-s" 'comint-dynamic-list-input-ring ;; TODO use ivy
         "C-r" 'evil-paste-from-register
         "C-v" 'quoted-insert
         "C-u" 'scroll-down
         "C-d" 'scroll-up
         "C-o" 'evil-execute-in-normal-state

         "C-<left>"  'backward-word
         "C-<up>"    'comint-previous-input
         "C-<down>"  'comint-next-input
         "C-<right>" 'forward-word

         "<left>"    'backward-char
         "<up>"      'comint-previous-input-or-previous-line
         "<down>"    'comint-next-input-or-next-line
         "<right>"   'forward-char

         "C-h"       'backward-char
         "C-j"       'comint-next-input-or-next-line
         "C-k"       'comint-previous-input-or-previous-line
         "C-l"       'forward-char

         "M-j"       'comint-next-matching-input-from-input
         "M-k"       'comint-previous-matching-input-from-input

         "C-f"       'forward-word
         "C-b"       'comint-backward-word

         "M-u" 'comint-next-prompt
         "M-d" 'comint-previous-input

         ;; "<remap> <forward-char>"  'comint-forward-char
         "<remap> <backward-char>" 'comint-backward-char
         ;; "<remap> <forward-word>"  'comint-forward-word
         "<remap> <backward-word>" 'comint-backward-word

         "C-c C-c" 'comint-interrupt-subjob
         "C-c C-x" 'comint-get-next-from-history
         ))

      (defun +comint-set-leader-keys (mode)
        (leader/set-keys-for-major-mode mode
          "z" 'comint-send-eof
          "*" 'comint-insert-previous-argument
          "r" 'comint-dynamic-list-input-ring
          "m" 'comint-clear-buffer
          "M" 'comint-show-maximum-output
          "x" 'comint-get-next-from-history
          "RET" 'comint-copy-old-input ;; copy text before cursor
          ">" 'comint-write-output
          "t" 'comint-show-output
          "o" 'comint-delete-output

          "s" "subjob"
          "ss" 'comint-stop-subjob
          "sq" 'comint-quit-subjob
          "si" 'comint-interrupt-subjob))

      (provide '+comint-bindings)
    #+END_SRC

** custom
   Mode definition for the customize interface.

   #+BEGIN_SRC emacs-lisp
     (use-package cus-edit
       :defer t
       :config
       (push 'Custom-mode whitespace-exempt-modes)
       (push 'customize-mode whitespace-exempt-modes)

       (evil-set-initial-state 'Custom-mode 'normal)

       :lazy-leader
       (:mode 'Custom-mode
        "SPC" 'customize-apropos
        "g" 'customize-group
        "f" 'customize-face
        "h" 'Custom-goto-parent
        "j" 'widget-forward
        "k" 'widget-backward
        "l" 'widget-forward)

       :general
       (:states  'motion
        :keymaps 'custom-mode-map

        ;; motion
        "TAB"       'widget-forward
        "S-TAB"     'widget-backward
        "<backtab>" 'widget-backward

        "RET" 'Custom-newline

        "]]" 'widget-forward
        "[[" 'widget-backward

        "gh" 'Custom-goto-parent
        "gl" 'widget-forward

        "gj" 'widget-forward
        "gk" 'widget-backward

        ;; quit
        [remap quit-window] 'Custom-buffer-done))
   #+END_SRC

** dabbrev
   #+BEGIN_SRC emacs-lisp
     (general-define-key
      :prefix "C-x"
      [C-i] 'dabbrev-expand)
   #+END_SRC

** debugger
   #+BEGIN_SRC emacs-lisp
     (use-package debug
       :defer t
       :config
       (evil-set-initial-state 'debugger-mode 'motion)

       :leader
       ("kd" 'debug-on-entry
        "kx" 'cancel-debug-on-entry)

       :general
       (:keymaps 'debugger-mode-map
        [remap quit-window] 'debugger-quit)
       (:keymaps 'debugger-mode-map
        :states 'motion
        "TAB" 'forward-button
        "RET" 'backtrace-help-follow-symbol
        "+" 'backtrace-multi-line
        "-" 'backtrace-single-line
        "=" 'debugger-return-value                                                   ; exit current stack frame with inputted value
        "d" 'debugger-frame                                                          ; drop a breakpoint at the frame at point
        "x" 'debugger-frame-clear                                                    ; clear a break point at the frame at point
        "c" 'debugger-continue
        "s" 'debugger-step-through
        [remap evil-next-visual-line]     'backtrace-forward-frame
        [remap evil-previous-visual-line] 'backtrace-backward-frame)

       :lazy-leader
       (:mode 'debugger-mode
        "e" 'debugger-eval-expression
        "r" 'debugger-record-expression
        "j" 'debugger-jump                                                           ; jump down to current stack frame, skipping any upcoming debug-on-entry calls
        "b" 'debugger-frame                                                          ; drop a breakpoint at the frame at point
        "a" 'debugger-list-functions                                                 ; NOTE: not all that useful interactively
        "g" 'backtrace-help-follow-symbol ;; 'backtrace-goto-source
        ;; toggles
        "c" 'backtrace-toggle-print-circle
        "." 'backtrace-expand-ellipses
        "s" 'backtrace-toggle-print-gensym
        "l" 'backtrace-toggle-locals))
   #+END_SRC

** diff
   Mode for showing diff/patch files.

   #+BEGIN_SRC emacs-lisp
     (use-package diff-mode
       :defer t
       :commands (diff-mode diff-buffer-with-file)
       :config
       (push 'diff-mode whitespace-exempt-modes)

       (defun diff-kill-applied-hunks--ensure-all-hunks-killed (func &rest args)
         "`diff-kill-applied-hunks' doesn't kill any applied hunks above point :("
         (save-excursion
           (goto-char (point-min))
           (apply func args)))

       (advice-add 'diff-kill-applied-hunks :around #'diff-kill-applied-hunks--ensure-all-hunks-killed)

       :leader
       (:prefix leader-diff-leader-prefix
        "" "diff"
        "SPC" 'diff-buffer-with-file)

       :lazy-leader
       (:mode 'diff-mode
        "r" 'diff-refine-hunk
        "c" 'diff-kill-applied-hunks ;; clean displayed hunks only works on hunks below point.
        "k" 'diff-file-kill
        "f" 'next-error-follow-minor-mode
        "n" 'diff-restrict-view ;; narrow to hunk (or file with prefix)
        "s" 'diff-reverse-direction ;; doesn't do anything?
        "t" 'diff-test-hunk
        "e" 'diff-ediff-patch
        "u" 'diff-unified->context
        "d" 'diff-context->unified
        "l" 'diff-add-change-log-entries-other-window)

       :general
       (:states  'motion
        :keymaps 'diff-mode-map
        "a" 'diff-apply-hunk ;; apply diff hunk to prompted file
        ;; NOTE prompts for file onto which diff is being applied
        "x" 'diff-hunk-kill
        "X" 'diff-file-kill
        "u" 'diff-undo
        "q" nil
        "s" 'diff-split-hunk
        "i" 'diff-ignore-whitespace-hunk

        "o" 'diff-goto-source
        "RET" 'diff-goto-source

        "C-j" 'diff-hunk-next
        "C-k" 'diff-hunk-prev
        "TAB"   'diff-file-next
        "S-TAB" 'diff-file-prev))
   #+END_SRC

** dired
   The built in (file-manager like) program for emacs. Think ls, but interactive and
   100 times better.

*** mode
    #+BEGIN_SRC emacs-lisp
      (use-package dired
        :straight (dired :type built-in)
        :defer t
        :config
        (push '(dired-mode . 1) +indent-config)

        (setq ls-lisp-dirs-first t
              ls-lisp-use-insert-directory-program t
              dired-listing-switches "-laXhv --group-directories-first"
              dired-auto-revert-buffer t
              dired-hide-details-hide-symlink-targets nil
              dired-recursive-copies t
              dired-recent-directories-file (var! "dired/recent.el"))

        (push 'dired-mode whitespace-exempt-modes)
        (require '+dired-bindings))
    #+END_SRC

    #+BEGIN_SRC emacs-lisp :tangle lisp/+dired-bindings.el
      (defun dired-goto-home-dir (&optional other-window)
        "goto users home directory
             with prefix, visits in another window"
        (interactive "P")
        (funcall (if other-window
                     'find-file-other-window
                   'find-file)
                 (expand-file-name "~")))

      (defun dired-evil-scroll-down ()
        (interactive)
        (call-interactively 'evil-scroll-down)
        (dired-move-to-filename))

      (defun dired-evil-scroll-up ()
        (interactive)
        (call-interactively 'evil-scroll-up)
        (dired-move-to-filename))

      (general-define-key
       :keymaps 'dired-mode-map
       ;; let map override any motion bindings
       "<override-state>" 'motion)

      (general-define-key
       :keymaps 'dired-mode-map
       :states  'motion
       "j" 'dired-next-line
       "k" 'dired-previous-line
       "~" 'dired-goto-home-dir
       "r" 'dired-do-redisplay
       "=" 'dired-diff
       "K" 'dired-do-kill-lines
       "'" 'dired-show-file-type ;; like file command
       "M" 'dired-unmark
       "u" 'dired-unmark
       "r" 'dired-change-marks
       "y" 'dired-copy-filename-as-kill

       "M-<return>" 'dired-display-file
       "C-M-<return>" 'dired-find-alternate-file
       "C-M-d" 'dired-kill-subdir

       "zc" 'dired-hide-subdir ;; collapse
       "zC" 'dired-hide-all

       ;; "|" 'dired-do-hardlink
       "|" 'dired-do-symlink
       "C-|" 'dired-do-relsymlink
       "M-|" 'dired-do-hardlink
       "M-!" 'dired-do-print ;; append names to end of command

       "C-S-J" 'dired-next-marked-file
       "C-S-K" 'dired-prev-marked-file
       "M-j" 'dired-next-dirline           ; unbound, dired-tree-down
       "M-k" 'dired-prev-dirline           ; unbound, dired-tree-up
       "C-d" 'dired-evil-scroll-down
       "C-u" 'dired-evil-scroll-up
       "C-h" 'dired-goto-min-subdir
       "C-j" 'dired-next-subdir
       "C-k" 'dired-prev-subdir
       "C-l" 'dired-goto-max-subdir)

      (leader/set-keys-for-major-mode 'dired-mode
        "?" 'dired-summary ;; like transient state
        "#" 'dired-clean-directory
        "o" 'browse-url-of-dired-file ;; open in external app
        "O" 'dired-omit-mode
        "v" 'dired-view-file          ;; TODO customize view mode
        "g" 'dired-goto-file ;; prompt for file to visit in current buffer
        "s" 'dired-sort-toggle-or-edit

        "r"  "rename"
        "ru" 'dired-upcase
        "rd" 'dired-downcase

        ;; flag means mark delete
        "d"  "delete"
        "d&" 'dired-flag-garbage-files
        "d~" 'dired-flag-backup-files
        "d/" 'dired-flag-files-regexp
        "d#" 'dired-flag-auto-save-files

        "m"  "mark"
        "mm" 'dired-toggle-marks
        "mu" 'dired-unmark
        "m DEL" 'dired-unmark-backward
        "ml" 'dired-mark-symlinks
        "md" 'dired-mark-directories
        "m!" 'dired-mark-executables
        "mt" 'dired-mark-subdir-files
        "mg" 'dired-mark-files-containing-regexp ;; grep
        "ms" 'dired-mark-files-regexp
        "m(" 'dired-mark-sexp

        ;; emacs related bindings
        "e"  "emacs"
        "ec" 'dired-do-byte-compile
        "el" 'dired-do-load
        "ef" 'dired-do-find-marked-files

        ;; change fs property commands
        "c"  "change"
        "cg" 'dired-do-chgrp
        "cm" 'dired-do-chmod
        "co" 'dired-do-chown

        ;; filesystem
        "f"  "filesystem"
        "fg" 'dired-do-find-regexp             ;; grep marked files
        "fs" 'dired-do-find-regexp-and-replace ;; substitute
        "fi" 'dired-info
        "fm" 'dired-man
        "fr" 'dired-do-run-mail
        "ft" 'dored-do-touch
        "fz" 'epa-dired-do-encrypt
        "fZ" 'epa-dired-do-encrypt-to ;; compress as

        ;; EasyPG/GPG
        "fp"  "GPG"
        "fpd" 'epa-dired-do-decrypt
        "fpe" 'epa-dired-do-encrypt
        "fps" 'epa-dired-do-sign
        "fpv" 'epa-dired-do-verify

        ;; operations bound to regexp search
        "f/"     "search"
        "f/c"    'dired-do-copy-regexp
        "f/r"    'dired-do-rename-regexp
        "f/h"    'dired-do-hardlink-regexp
        "f/s"    'dired-do-symlink-regexp
        "f/|"    'dired-do-symlink-regexp
        "f/ C-|" 'dired-do-relsymlink-regexp
        "f/ M-|" 'dired-do-hardlink-regexp)

      (general-unbind
        :keymaps 'dired-mode-map
        "#" "$" "%" "*" "." ":" "?" "~" "<" "=" ">" "a"
        "A" "B" "c" "C-M-d" "C-M-n" "C-M-p" "C-M-u" "C-o"
        "e" "f" "F" "g" "G" "h" "H" "I" "j" "k" "l" "L" "M"
        "M-$" "M-(" "M-{" "M-}" "M-DEL" "M-G" "n" "N" "O" "p"
        "P" "Q" "s" "SPC" "0" "S-SPC" "t" "T" "v" "V" "w" "W"
        "X" "y" "Y" "Z" "u")

      (provide '+dired-bindings)
    #+END_SRC

*** all-the-icons
    #+BEGIN_SRC emacs-lisp
      (use-package all-the-icons-dired
        :straight (:fork (:host github :repo "mohkale/all-the-icons-dired" :branch "icons-predicate"))
        :defer t
        :diminish "DiredIcons"
        :after all-the-icons
        :hook (dired-mode . all-the-icons-dired-mode)
        :custom
        (all-the-icons-dired-enabled-p
         (defun all-the-icons-dired-enabled-p+ ()
           (and (derived-mode-p 'dired-mode)
                (or +icons-available
                    (display-graphic-p)))))

        :config
        (advice-add 'all-the-icons-dired--refresh :around
                    (defun all-the-icons-dired-setup-tty-icons+ (func &rest args)
                      (cl-letf (((symbol-function 'all-the-icons-icon-for-file--default)
                                 (symbol-function 'all-the-icons-icon-for-file))
                                ((symbol-function 'all-the-icons-icon-for-file)
                                 (lambda (&rest icon-args)
                                   (all-the-icons-pad-on-tty-advice+
                                    (apply 'all-the-icons-icon-for-file--default icon-args))))
                                ((symbol-function 'all-the-icons-icon-for-dir--default)
                                 (symbol-function 'all-the-icons-icon-for-dir))
                                ((symbol-function 'all-the-icons-icon-for-dir)
                                 (lambda (&rest icon-args)
                                   (all-the-icons-pad-on-tty-advice+
                                    (apply 'all-the-icons-icon-for-dir--default icon-args)))))
                        (apply func args)))))
    #+END_SRC

*** hide
    dired's file hiding functionality.

    #+BEGIN_SRC emacs-lisp
       (use-package dired-x
         :straight (dired-x :type built-in)
         :hook (dired-mode . dired-omit-mode)
         :config
         (setq dired-omit-files (rx (or
                                     ".#"
                                     (and bol
                                          (or "."
                                              ".."
                                              ".git"
                                              ".bundle"
                                              ".dired"
                                              "__pycache__"
                                              ".pytest_cache"
                                              ".gradle"
                                              ".sass-cache"
                                              ".jekyll-cache"
                                              "Pipfile")
                                          eol)))))
    #+END_SRC

*** dired-fl
    Extra font lock rules for dired; basically adds some more color to dired sessions.
    nice idea, but too much of a good thing can be bad.

    #+BEGIN_SRC emacs-lisp :tangle (package-yes! diredfl)
      (use-package diredfl
        :straight t
        :defer  t
        :hook (dired-mode . diredfl-mode))
    #+END_SRC

*** git-info
    show the last commit log for files in the current dired buffer.

    #+BEGIN_SRC emacs-lisp
      (use-package dired-git-info
        :straight t
        :defer  t
        :general
        (:keymaps 'dired-mode-map
         :states  'motion
         ")" 'dired-git-info-mode))
    #+END_SRC

** image-dired
   #+BEGIN_SRC emacs-lisp :tangle (package-yes! image-dired)
     (use-package image-dired
       :defer t
       :config
       (push 'image-dired-thumbnail-mode whitespace-exempt-modes)
       (require '+image-dired-bindings))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp :tangle lisp/+image-dired-bindings.el
     ;;; fixed weird moves line, not thumbnail
     (defun image-dired-slideshow-step ()
       "Step to next file, if `image-dired-slideshow-times' has not been reached."
       (if (< image-dired-slideshow-count image-dired-slideshow-times)
           (progn
             (message "%s" (1+ image-dired-slideshow-count))
             (setq image-dired-slideshow-count (1+ image-dired-slideshow-count))
             (image-dired-display-next-thumbnail-original))
         (image-dired-slideshow-stop)))

     (general-define-key
      :keymaps 'image-dired-thumbnail-mode-map
      :states '(normal visual)
      "q" nil

      "h" 'image-dired-backward-image
      "j" 'image-dired-next-line
      "k" 'image-dired-previous-line
      "l" 'image-dired-forward-image
      "<left>"  'image-dired-forward-image
      "<right>" 'image-dired-previous-image

      "x" 'image-dired-delete-char
      "m" 'image-dired-mark-thumb-original-file
      "u" 'image-dired-unmark-thumb-original-file
      "c" 'image-dired-comment-thumbnail
      "d" 'image-dired-flag-thumb-original-file
      "D" 'image-dired-thumbnail-set-image-description
      "s" 'image-dired-slideshow-start
      "t" 'image-dired-toggle-mark-thumb-original-file
      "gr" 'image-dired-refresh-thumb
      "gc" 'image-dired-create-thumbs
      "gg" (lambda! (evil-goto-first-line) (evil-beginning-of-line))
      "G"  (lambda! (goto-char (point-max)) (image-dired-backward-image))

      "C-s" 'image-save           ; NOTE originally was bound to o

      "<C-SPC>"    'image-dired-mark-thumb-original-file
      "<M-SPC>"    'image-dired-unmark-thumb-original-file

      "<C-return>" 'image-dired-display-current-image-full
      "<RET>"      'image-dired-display-thumbnail-original-image
      "C-l"        'image-dired-display-next-thumbnail-original
      "C-h"        'image-dired-display-previous-thumbnail-original
          ;;; column view aliases
      "J" 'image-dired-display-next-thumbnail-original
      "K" 'image-dired-display-previous-thumbnail-original
      ;; "o" 'image-dired-display-thumbnail-original-image
      "v" 'image-dired-display-thumbnail-original-image

      "<mouse-1>" 'image-dired-mouse-select-thumbnail
      "<mouse-2>" 'image-dired-mouse-display-image)

     (leader/set-keys-for-major-mode 'image-dired-thumbnail-mode
       "g" 'image-dired-jump-original-dired-buffer
       "m" 'image-dired

       "t"  "tagging"
       "td" 'image-dired-thumbnail-set-image-description
       "tt" 'image-dired-tag-thumbnail
       "tT" 'image-dired-tag-thumbnail-remove

       "e" "edit"
       "el" 'image-dired-rotate-thumbnail-left
       "eL" 'image-dired-rotate-original-left
       "er" 'image-dired-rotate-thumbnail-right
       "eR" 'image-dired-rotate-original-right

       "." 'image-dired-track-original-file
       "o" 'image-dired-thumbnail-display-external

       ;; [re]set number of columns per row
       "s" 'image-dired-line-up-interactive
       "S" 'image-dired-line-up-dynamic)

        ;;; image view
     (general-define-key
      :keymaps 'image-dired-display-image-mode-map
      :states 'normal
      "f" 'image-dired-display-current-image-full
      "F" 'image-dired-display-current-image-sized
      "s" 'image-dired-display-current-image-sized

      "h" 'image-scroll-right
      "l" 'image-scroll-left
      "k" 'image-scroll-down
      "j" 'image-scroll-up
      ;; horizontal line by line movement
      "C-d" 'image-scroll-up
      "C-u" 'image-scroll-down
      "C-e" 'image-next-line
      "C-y" 'image-previous-line
      ;; Arrow Keys Alias hjkl
      "<left>"  'image-backward-hscroll
      "<right>" 'image-forward-hscroll
      "<up>"    'image-scroll-down
      "<down>"  'image-scroll-up)

     (leader/set-keys-for-major-mode 'image-dired-display-image-mode
       "h" 'image-bol ; far left   edge
       "j" 'image-eob ; far bottom edge
       "k" 'image-bob ; far top    edge
       "l" 'image-eol ; far right  edge
       "g" 'image-dired-jump-thumbnail-buffer)
   #+END_SRC

** display-line-numbers
   #+BEGIN_SRC emacs-lisp
     (use-package display-line-numbers
       :defer t
       :hook ((prog-mode . display-line-numbers-mode)
              (text-mode . display-line-numbers-mode))
       :config
       ;; prefer relative line numbers when available
       (setq-default display-line-numbers-type 'relative))
   #+END_SRC

** ediff
   The builtin interactive diff tool.

     #+BEGIN_SRC emacs-lisp :tangle (package-yes! ediff)
       (use-package ediff
         :defer t
         :commands (ediff-current-file
                    ediff-buffers
                    ediff-windows
                    ediff-files
                    ediff-backup
                    ediff-files3
                    ediff-directories
                    ediff-directories3
                    ediff-regions-linewise
                    ediff-regions-wordwise
                    ediff-patch-file
                    ediff-merge-files
                    ediff-merge-buffers
                    ediff-merge-directories

                    ;; unbound by default
                    ediff-show-registry ;; ido-choose-ediff-session
                    ediff-toggle-multiframe
                    ediff-toggle-use-toolbar
                    ediff-revert-buffers-then-recompute-diffs
                    ediff-profile)
         :leader
         (:prefix leader-diff-leader-prefix
          "f" 'ediff-current-file
          "b" 'ediff-buffers
          "w" 'ediff-windows)

         :config
         (push 'ediff-meta-mode whitespace-exempt-modes)

         (setq-default ediff-window-setup-function       'ediff-setup-windows-plain
                       ediff-split-window-function       'split-window-horizontally
                       ediff-merge-split-window-function 'split-window-horizontally
                       ;; ediff-keep-variants               nil ;; doesn't do anything :(
                       )

         (defvar ediff-kill-temporary-buffers-on-exit+ t
           "whether to keep temporary ediff buffers around")

         (require 'outline)
         ;; show org ediffs unfolded
         (add-hook 'ediff-prepare-buffer-hook #'outline-show-all)

         ;; ensure window configuration is restored after diff quit
         (let* ((ediff-window-register ?w)
                (register-active (lambda () (cdr (assoc ediff-window-register register-alist)))))
           (defun ediff--restore-windows-before (&rest args)
             ;; (message "setting up")
             (unless (funcall register-active)
               ;; (message "assigning to register")
               (window-configuration-to-register ediff-window-register)))
           (add-hook 'ediff-before-setup-hook #'ediff--restore-windows-before)

           (defun ediff--restore-windows-after (&rest args)
             (if (not (funcall register-active))
                 (message "ediff-restore-windows : no previous window config found to restore")
               (jump-to-register ediff-window-register)
               (set-register ediff-window-register nil)))
           (add-hook 'ediff-quit-hook #'ediff--restore-windows-after))

         (defun ediff--kill-ediff-temp-buffers (&rest args)
           "kills all the spawned ediff buffers... because
       there's way too many and their named so similairly that
       there's no point in them existing... Plus I keep ending
       up editing the wrong diffed buffer."
           (when ediff-kill-temporary-buffers-on-exit+
             ;; kill diff checking buffers when temporary
             (dolist (buffer (list ediff-buffer-A
                                   ediff-buffer-B
                                   ediff-buffer-C))
               (when (and buffer
                          (string-prefix-p "FILE=" (buffer-name buffer)))
                 (kill-buffer buffer)))

             ;; kill any hardcoded ediff related buffers
             (dolist (buffer '("*Ediff Registry*"))
               (let ((buffer (get-buffer buffer)))
                 (when buffer
                   (kill-buffer buffer))))

             ;; kill any uniquely named ediff buffers...
             ;; Ewwww... O(n*m)... how do I live with myself
             (dolist (buffer-prefix '("*Ediff Control Panel"
                                      "*ediff-diff"
                                      "*ediff-errors"
                                      "*ediff-fine-diff"))
               (let ((buffer-prefix-regexp (regexp-quote buffer-prefix)))
                 (dolist (buffer (buffer-list))
                   (when (string-match buffer-prefix-regexp
                                       (buffer-name buffer))
                     (kill-buffer buffer)))))))

         (add-hook 'ediff-quit-hook #'ediff--kill-ediff-temp-buffers)

         (defun ediff--customize-ediff-mode-map (&rest args)
           "give me back my leader keys damn it :P"
           (general-define-key
            :keymaps 'ediff-mode-map
            :states  'motion
            "SPC" leader-map))

         (add-hook 'ediff-keymap-setup-hook #'ediff--customize-ediff-mode-map)
         ;; (evil-set-initial-state 'ediff-meta-mode 'motion)

         ;; (general-define-key
         ;;   :states 'motion
         ;;   :keymaps 'ediff-meta-buffer-map
         ;;   "C-j" 'ediff-next-meta-item
         ;;   "C-k" 'ediff-previous-meta-item
         ;;   "q" 'ediff-quit-meta-buffer
         ;;   "o" 'ediff-registry-action
         ;;   "=" 'ediff-meta-mark-equal-files
         ;;   "RET" 'ediff-registry-action
         ;;   "R" 'ediff-show-registry
         ;;   "S-RET" 'ediff-show-meta-buff-from-registry
         ;;   "?" 'ediff-toggle-verbose-help-meta-buffer)

         (leader/set-keys-for-major-mode 'ediff-meta-mode
           "tf" 'ediff-toggle-filename-truncation
           "tv" 'ediff-toggle-verbose-help-meta-buffer)

         (use-package evil-ediff
           :straight t
           :defer  nil
           :commands (evil-ediff-init)
           :init
           (evil-ediff-init)))
     #+END_SRC

** eldoc
   That package that displays help messages in the minibuffer.

   #+BEGIN_SRC emacs-lisp
     (use-package eldoc
       :delight ""
       :commands (eldoc-doc-buffer-no-select+)
       :custom
       (eldoc-echo-area-prefer-doc-buffer t)
       (eldoc-echo-area-display-truncation-message nil)

       :config
       (defun eldoc-doc-buffer-no-select+ ()
         (interactive)
         (let ((display-buffer-alist
                `((,(rx "*eldoc*")
                   ,@default-display-buffer-action)
                  ,@display-buffer-alist)))
           (eldoc-doc-buffer t)))

       :leader
       ("hb" 'eldoc-doc-buffer
        "ho" 'eldoc-doc-buffer-no-select+))
   #+END_SRC

** electric-pair
   Electric pair is a built in module which lets auto insert matching pairs. For example,
   inserting a ( will lead to emacs auto inserting ).

   #+BEGIN_SRC emacs-lisp
     (use-package elec-pair
       :hook ((prog-mode . electric-pair-mode)
              (text-mode . electric-pair-mode))
       :commands electric-pair-mode
       :config
       (setq electric-pair-preserve-balance nil
             electric-pair-skip-whitespace  nil)

       (electric-pair-mode 1))
   #+END_SRC

** electric-indent
   #+BEGIN_SRC emacs-lisp
     (use-package electric
       :commands electric-indent-mode
       :hook ((text-mode . electric-indent-mode)
              (prog-mode . electric-indent-mode)))
   #+END_SRC

** finder-mode
   #+BEGIN_SRC emacs-lisp
     (use-package finder
       :defer t
       :leader
       (:mode 'finder-mode
        "?" 'finder-summary)

       :general
       (:keymaps 'finder-mode-map
        "SPC" 'nil
        "?"   'nil
        [override-state] 'motion))
   #+END_SRC

** flymake
   eglot forces flymake to activate and it takes up space while displaying the exact
   same information as flycheck, so just hide it's presence in my modeline. Maybe I
   should consider switching to it, flycheck seems to have more features tho :confused:.

   #+BEGIN_SRC emacs-lisp
     (use-package flymake
       :diminish flymake-mode
       :commands (flymake-first-error+
                  flymake-last-error+)
       :init
       (defmacro flymake-unsupported-command+ (name)
         `(lambda ()
            (interactive)
            (message "Flymake doesn't have a parallel for: %s" (quote ,name))))

       :config
       ;; force flymake to not try and cooperate with flycheck (for now).
       (add-hook 'flymake-mode-hook
                 (defun flymake-disable-flycheck+ ()
                   (when (bound-and-true-p flycheck-mode)
                     (flycheck-mode -1))))

       (advice-add #'flymake--handle-report :around #'restore-default-display-buffer-actions)
       (advice-add #'flymake-show-diagnostic :around #'restore-default-display-buffer-actions)

       (defun flymake-first-error+ ()
         (interactive)
         (let* ((ovs (flymake--overlays :compare #'< :key #'overlay-start))
                (ov (car ovs)))
           (cond
            (ov (goto-char (overlay-start ov)))
            (t (user-error "No flymake errors in the current buffer")))))

       (defun flymake-last-error+ ()
         (interactive)
         (let* ((ovs (flymake--overlays :compare #'< :key #'overlay-start))
                (ov (car (last ovs))))
           (cond
            (ov (goto-char (overlay-start ov)))
            (t (user-error "No flymake errors in the current buffer")))))

       :general
       (:keymaps 'flymake-mode-map
        ; TODO implement
        [remap flycheck-select-checker] (flymake-unsupported-command+ flycheck-select-checker)
        [remap flycheck-describe-checker] (flymake-unsupported-command+ flycheck-describe-checker)
        [remap flycheck-explain-error-at-point] (flymake-unsupported-command+ flycheck-explain-error-at-point)
        [remap toggle-flycheck-messages] (flymake-unsupported-command+ toggle-flycheck-messages)

        [remap hydra-flycheck/body] 'hydra-flymake/body
        [remap flycheck-clear] 'flymake-proc-stop-all-syntax-checks
        [remap flycheck-first-error] 'flymake-first-error+
        [remap flycheck-last-error] 'flymake-last-error+
        [remap flycheck-buffer] 'flymake-start
        [remap flycheck-list-errors] 'flymake-show-diagnostics-buffer
        [remap flycheck-next-error] 'flymake-goto-next-error
        [remap flycheck-previous-error] 'flymake-goto-prev-error)
       (:keymaps 'flymake-diagnostics-buffer-mode-map
        :states 'motion
        "RET" 'flymake-goto-diagnostic
        "o" 'flymake-show-diagnostic))
   #+END_SRC

** flyspell
   On the fly spell checker. Spawns an aspell subprocess and passes any words you write
   to it; any mispellings or unknown words will be highlighted to indicate they're mispelled.

   TODO try spell-fu

   #+BEGIN_SRC emacs-lisp
     (use-package flyspell
       :hook (git-commit-mode . flyspell-mode)
       :init
       (evil-ex-define-cmd "spell" #'flyspell-buffer)

       :config
       ;; I've only tested this on window/cygwin but aspell appears to be quite broken :P
       ;;   * I can't specify a path to any directory not within my home directory.
       ;;   * I can't specify any absolute path, even when that path is within my home directory.
       ;;   * If I want to reference a file in a subdirectory of my home directory, the
       ;;     path must begin with a slash.
       ;; THIS IS WAY TOO UNINTUITIVE.
       (setq ispell-personal-dictionary
             (file-relative-name (etc! "/ispell/dict.txt") "~"))

       :lazy-leader
       (:mode 'flyspell-mode
        :minor t
        :prefix leader-minor-mode-leader-prefix
        "."  'hydra-flyspell/body
        "cb" 'flyspell-buffer
        "cr" 'flyspell-region
        "cw" 'flyspell-word))
   #+END_SRC

*** flyspell-correct
    #+BEGIN_SRC emacs-lisp
      (use-package flyspell-correct
        :straight t
        :defer  t
        :leader
        (:mode 'flyspell-mode
         :minor t
         :prefix leader-minor-mode-leader-prefix
         leader-minor-mode-leader-prefix 'flyspell-correct-wrapper))
    #+END_SRC

*** ispell
   #+BEGIN_SRC emacs-lisp
     (use-package ispell
       :defer t
       :config
       (defun ispell--prevent-absolute-path (func &rest args)
         (cl-letf (((symbol-function 'expand-file-name)
                    (lambda (_) _)))
           (apply func args)))

       (advice-add 'ispell-internal-change-dictionary :around
                   #'ispell--prevent-absolute-path)
       (advice-add 'flyspell-large-region :around
                   #'ispell--prevent-absolute-path))
   #+END_SRC

** grep
   emacs mode for interacting with output from the grep executeable.

   #+BEGIN_SRC emacs-lisp
     (use-package grep
       :defer t
       :config
       (+set-compilation-bindings 'grep-mode 'grep-mode-map))
   #+END_SRC

** help
   #+BEGIN_SRC emacs-lisp
     (use-package help
       :config
       ;; once was enough, stop repeating the same message please :P
       (advice-add 'help-window-display-message :around #'ignore))
   #+END_SRC

** hl-line
   apply a different background face to the current line.

   #+BEGIN_SRC emacs-lisp
     (use-package hl-line
       :hook ((prog-mode . hl-line-mode)
              (text-mode . hl-line-mode)))
   #+END_SRC

** ibuffer
*** ibuffer
    #+BEGIN_SRC emacs-lisp :tangle (package-yes! ibuffer)
      (use-package ibuffer
        :defer t
        :hook (ibuffer-mode . hl-line-mode)
        :leader
        ("bm" 'ibuffer)

        :config
        (defvar ibuffer-show-buffer-icons nil
          "whether to show icons alongside the buffer")

        (setq ibuffer-filter-group-name-face '(:inherit (font-lock-string-face bold))
              ibuffer-title-face '(:inherit (font-lock-type-face)))

        (evil-set-initial-state 'ibuffer-mode 'motion)

        (leader/set-keys-for-major-mode 'ibuffer-mode
          ;; unbound:
          ;;  * ibuffer-do-print
          "RET" 'ibuffer-do-view-horizontally
          "1"   'ibuffer-visit-buffer-1-window
          "+"   'ibuffer-add-to-tmp-show
          "-"   'ibuffer-add-to-tmp-hide
          "."   'hydra-ibuffer/body

          "A"   'ibuffer-auto-mode
          "E"   'ibuffer-do-view-and-eval
          "e"   'ibuffer-do-eval
          "R"   'ibuffer-redisplay
          "r"   'ibuffer-do-rename-uniquely
          "S"   'ibuffer-do-query-replace
          "s"   'ibuffer-do-save
          ;; "s"   'ibuffer-do-replace-regexp
          "T"   'ibuffer-visit-tags-table
          "F"   'ibuffer-find-file
          "X"   'ibuffer-kill-filter-group
          "P"   'ibuffer-yank-filter-group
          "x"   'ibuffer-kill-line
          "p"   'ibuffer-yank
          "|"   'ibuffer-do-shell-command-pipe-replace
          "~"   'ibuffer-do-toggle-modified

          "o"   'ibuffer-do-view
          "O"   'ibuffer-do-view-other-frame

          "g"   'ibuffer-jump-to-buffer
          "b"   'ibuffer-jump-to-filter-group

          "m"  "mark"
          "m*" 'ibuffer-mark-modified-buffers
          "m%" 'ibuffer-mark-read-only-buffers
          "mm" 'ibuffer-toggle-marks
          "mf" 'ibuffer-mark-by-name-regexp
          "mf" 'ibuffer-mark-by-file-name-regexp
          "mo" 'ibuffer-mark-old-buffers
          "ml" 'ibuffer-mark-by-locked
          "mb" 'ibuffer-mark-by-content-regexp
          "mM" 'ibuffer-mark-by-mode-regexp
          "md" 'ibuffer-mark-dired-buffers
          "mh" 'ibuffer-mark-help-buffers
          "mn" 'ibuffer-mark-dissociated-buffers
          "mN" 'ibuffer-mark-unsaved-buffers
          "ms" 'ibuffer-mark-special-buffers
          "mz" 'ibuffer-mark-compressed-file-buffers)

        ;;; https://www.emacswiki.org/emacs/IbufferMode
        ;;  _                                                          _       _     _
        ;; | |__  _   _ _ __ ___   __ _ _ __        _ __ ___  __ _  __| | __ _| |__ | | ___
        ;; | '_ \| | | | '_ ` _ \ / _` | '_ \ _____| '__/ _ \/ _` |/ _` |/ _` | '_ \| |/ _ \
        ;; | | | | |_| | | | | | | (_| | | | |_____| | |  __/ (_| | (_| | (_| | |_) | |  __/
        ;; |_| |_|\__,_|_| |_| |_|\__,_|_| |_|     |_|  \___|\__,_|\__,_|\__,_|_.__/|_|\___|
        ;;

        (defun ibuffer--human-readable-file-sizes-to-bytes (string)
          "Convert a human-readable file size into bytes."
          ;; (interactive)
          (let ((decimal (string-to-number string)))
            (cond
             ((string-suffix-p "G" string t) (* 1000000000 decimal))
             ((string-suffix-p "M" string t) (* 1000000    decimal))
             ((string-suffix-p "K" string t) (* 1000       decimal))
             (t                                            decimal))))

        (defun ibuffer--bytes-to-human-readable-file-sizes (bytes)
          "Convert number of bytes to human-readable file size."
          ;; (interactive)
          (cond
           ((> bytes 1000000000) (format "%10.1fG" (/ bytes 1000000000.0)))
           ((> bytes 100000000)  (format "%10.0fM" (/ bytes 1000000.0)))
           ((> bytes 1000000)    (format "%10.1fM" (/ bytes 1000000.0)))
           ((> bytes 100000)     (format "%10.0fk" (/ bytes 1000.0)))
           ((> bytes 1000)       (format "%10.1fk" (/ bytes 1000.0)))
           (t                    (format "%10d"       bytes))))

        ;; Use human readable Size column instead of original one
        (define-ibuffer-column size-human-readable
          (:name "Size"
           :inline t
           :summarizer
           (lambda (column-strings)
             (let ((total 0))
               (dolist (string column-strings)
                 (setq total
                       ;; like, ewww ...
                       (+ (float (ibuffer--human-readable-file-sizes-to-bytes
                                  string))
                          total)))
               (ibuffer--bytes-to-human-readable-file-sizes total))))
          (ibuffer--bytes-to-human-readable-file-sizes (buffer-size)))

        ;; Source [[https://github.com/seagle0128/.emacs.d/blob/master/lisp/init-ibuffer.el][seagle0128]]
        (define-ibuffer-column icon (:name "  ")
          (let ((icon (if (and (buffer-file-name)
                               (all-the-icons-auto-mode-match?))
                          (all-the-icons-icon-for-file
                           (file-name-nondirectory (buffer-file-name))
                           :v-adjust -0.05)
                        (all-the-icons-icon-for-mode major-mode :v-adjust -0.05))))
            (when (symbolp icon)
              (setq icon (all-the-icons-faicon "file-o"
                          :face 'all-the-icons-dsilver
                          :height 0.8 :v-adjust 0.0)))
            icon))

        (setq ibuffer-formats
              `((mark modified read-only locked
                      " "
                      ,@(when ibuffer-show-buffer-icons
                          (list '(icon 2 2 :left :elide)
                                 (propertize " " 'display `(space :align-to 8))))
                      (name 20 20 :left :elide)
                      " "
                      (size-human-readable 11 -1 :right)
                      " "
                      (mode 16 16 :left :elide)
                      " " filename-and-process)
                (mark " "
                      ,@(when ibuffer-show-buffer-icons
                          (list '(icon 2 2 :left :elide)
                                (propertize " " 'display `(space :align-to 8))))

                      (name 20 20)
                      " "
                      filename)))

        :general
        (:keymaps 'ibuffer-mode-map
         "+" nil "-" nil "0" nil "f" nil "SPC" nil "S-SPC" nil ">" nil "<" nil "?" nil "h" nil "X" nil "F"
         nil "C-d" nil "C-t" nil "b" nil "n" nil "g" nil "p" nil "w" nil "s" nil "`" nil "," nil "*" nil
         "/" nil "A" nil "C-c" nil "C-x" nil "M-s" nil "M-g" nil "M-n" nil "M-p" nil "M-{" nil "M-}" nil
         "M-o" nil "M-DEL" nil "%" nil)
        (:keymaps 'ibuffer-mode-map
         :states  'motion
         ;; ibuffer-kill-line
         ;; ibuffer-do-kill-lines
         ;; ibuffer-do-revert
         ;; ibuffer-do-isearch
         ;; ibuffer-do-isearch-regexp

         "TAB"       'ibuffer-forward-filter-group
         "<S-tab>"   'ibuffer-backward-filter-group
         "<backtab>" 'ibuffer-backward-filter-group

         ;; "D" 'ibuffer-mark-for-delete-backwards
         "D" 'ibuffer-do-delete
         "M" 'ibuffer-do-toggle-modified
         "=" 'ibuffer-diff-with-file
         "O" 'ibuffer-do-occur
         "R" 'ibuffer-do-toggle-read-only

         "RET"   'ibuffer-visit-buffer
         "o"     'ibuffer-visit-buffer-other-window
         "M-RET" 'ibuffer-visit-buffer-other-window-noselect
         "S-DEL" 'ibuffer-bury-buffer

         [remap revert-buffer] 'ibuffer-update
         "gu"                  'ibuffer-do-revert
         "gw"                  'ibuffer-do-save

                ;;; marking
         "m" 'ibuffer-mark-forward
         "r" 'ibuffer-change-marks

                ;;; sorting
         "S"  'ibuffer-toggle-sorting-mode
         "sa" 'ibuffer-do-sort-by-alphabetic
         "sf" 'ibuffer-do-sort-by-filename/process
         "si" 'ibuffer-invert-sorting
         "s SPC" 'ibuffer-invert-sorting
         "sm" 'ibuffer-do-sort-by-major-mode
         "ss" 'ibuffer-do-sort-by-size
         "sr" 'ibuffer-do-sort-by-recency

         "("   'ibuffer-switch-format
                ;;; movement
         "C-j" 'ibuffer-forward-line
         "C-k" 'ibuffer-backward-line
         "gj"  'ibuffer-forward-next-marked
         "gk"  'ibuffer-backwards-next-marked

         "p"   'ibuffer-yank
         "C-y" 'ibuffer-yank
         "y"   'ibuffer-copy-buffername-as-kill))
    #+END_SRC

*** filters
    #+BEGIN_SRC emacs-lisp :tangle (package-yes! ibuffer)
      (use-package ibuf-ext
        :commands (ibuffer-filter-by-directory-path
                   ibuffer-filter-by-client-buffers)
        :config
        (define-ibuffer-filter directory-path
            "Toggle current view to buffers with file or directory name matching QUALIFIER."
          (:description "filename"
           :reader (file-truename
                    (read-directory-name "List files from file/directory name: ")))
          (ibuffer-awhen (or (buffer-local-value 'buffer-file-name buf)
                             (buffer-local-value 'dired-directory buf))
            ;; (message "qual: %s, it: %s" qualifier (file-truename it))
            (string-prefix-p qualifier (file-truename it))))

        (define-ibuffer-filter client-buffers
            "only show buffers for which there're open emacsclient clients."
          (:description "emacsclient-buffers")
          (buffer-local-value 'server-buffer-clients buf))

        :leader
        (:mode 'ibuffer-mode
         :prefix "f"
         ""       "filter"
         "TAB"    'ibuffer-exchange-filters
         "RET"    'ibuffer-filter-by-mode
         "DEL"    'ibuffer-delete-saved-filters
         "M-DEL"  'ibuffer-delete-saved-filter-groups

         "!"      'ibuffer-negate-filter
         "&"      'ibuffer-and-filter
         "a"      'ibuffer-and-filter
         "|"      'ibuffer-or-filter
         "o"      'ibuffer-or-filter
         "-"      'ibuffer-exchange-filters
         "@"      'ibuffer-filter-by-client-buffers
         "*"      'ibuffer-filter-by-starred-name
         ","      'ibuffer-filter-by-used-mode
         "."      'ibuffer-filter-by-file-extension
         ">"      'ibuffer-filter-by-size-gt
         "<"      'ibuffer-filter-by-size-lt
         "b"      'ibuffer-filter-by-basename
         "c"      'ibuffer-filter-by-predicate
         "D"      'ibuffer-filter-by-directory-path
         "d"      'ibuffer-filter-by-directory ; regexp
         "f"      'ibuffer-filter-by-filename  ; regexp
         "e"      'ibuffer-filter-by-modified
         "M"      'ibuffer-filter-by-derived-mode
         "m"      'ibuffer-filter-by-used-mode
         "n"      'ibuffer-filter-by-name
         "s"      'ibuffer-filter-by-content
         "v"      'ibuffer-filter-by-visiting-file

         "g"      'ibuffer-filters-to-filter-group
         "("      'ibuffer-filters-to-filter-group

         "a"      'ibuffer-add-saved-filters
         "p"      'ibuffer-pop-filter
         "P"      'ibuffer-pop-filter-group
         "u"      'ibuffer-decompose-filter
         "U"      'ibuffer-decompose-filter-group
         "r"      'ibuffer-switch-to-saved-filters
         "R"      'ibuffer-switch-to-saved-filter-groups
         "w"      'ibuffer-save-filters
         "W"      'ibuffer-save-filter-groups
         "x"      'ibuffer-filter-disable
         "X"      'ibuffer-clear-filter-groups))
    #+END_SRC

*** vc
    #+BEGIN_SRC emacs-lisp :tangle (package-yes! ibuffer ibuffer-vc)
      (use-package ibuffer-vc
        :straight t
        :defer  t
        :after ibuffer
        :config
        (defalias 'ibuffer-vc #'ibuffer-vc-set-filter-groups-by-vc-root)

        :general
        (:keymaps 'ibuffer-mode-map
         "sv" 'ibuffer-vc
         ")"  'ibuffer-vc))
    #+END_SRC

*** tramp
    #+BEGIN_SRC emacs-lisp :tangle (package-yes! ibuffer ibuffer-tramp)
      (use-package ibuffer-tramp
        :straight t
        :defer  t
        :after ibuffer
        :config
        (defalias 'ibuffer-tramp #'ibuffer-tramp-set-filter-groups-by-tramp-connection)

        :general
        (:keymaps 'ibuffer-mode-map
         "s@" 'ibuffer-tramp))
    #+END_SRC

*** persp
    #+BEGIN_SRC emacs-lisp :tangle (package-yes! ibuffer-persp)
      (use-package ibuffer-persp
        :straight (ibuffer-persp :host github :repo "rakshasa/ibuffer-persp")
        :after ibuffer
        :defer t
        :config
        (defalias 'ibuffer-persp-current #'ibuffer-persp-set-filter-groups-by-persp-name-not-nil)
        (defalias 'ibuffer-persp-other #'ibuffer-persp-set-filter-groups-by-other-persp-name-not-nil)

        :general
        (:keymaps 'ibuffer-mode-map
         "sp" 'ibuffer-persp-current
         "sP" 'ibuffer-persp-other))
    #+END_SRC

*** projectile
    #+BEGIN_SRC emacs-lisp :tangle (package-yes! ibuffer-projectile)
      (use-package ibuffer-projectile
        :straight t
        :defer  t
        :after ibuffer
        :commands (ibuffer-projectile-mode)
        ;; :hook (ibuffer-mode . ibuffer-projectile-mode)
        :config
        (setq ibuffer-projectile-prefix
              (if +icons-available
                  (concat
                   (all-the-icons-octicon "file-directory"
                                          :face ibuffer-filter-group-name-face
                                          :v-adjust -0.05)
                   " ")
                "Project: "))

        (defun ibuffer-projectile-hook (&rest _)
          (ibuffer-projectile-set-filter-groups))

        (define-minor-mode ibuffer-projectile-mode
          "Generate ibuffer filters for projectile projects."
          :lighter nil
          :global  t
          (if ibuffer-projectile-mode
              (progn
                (add-hook 'ibuffer-hook #'ibuffer-projectile-hook)
                (ibuffer-projectile-set-filter-groups))
            (remove-hook 'ibuffer-hook #'ibuffer-projectile-hook)

            (let ((ibuf (get-buffer "*Ibuffer*")))
              (when ibuf
                (with-current-buffer ibuf
                  (setq ibuffer-filter-groups
                        (seq-filter
                         (lambda (x)
                           (not (assoc 'projectile-root x)))
                         ibuffer-filter-groups))
                  (ibuffer-update nil t)))))))
    #+END_SRC

** imenu
   :PROPERTIES:
   :header-args+: :tangle (package-yes! imenu)
   :END:

   See (and jump to) key points of interest in the current buffer using your completion framework
   of choice.

   #+BEGIN_SRC emacs-lisp
     (use-package imenu
       :defer t
       :leader
       ("ji" 'imenu))
   #+END_SRC

*** list
    #+BEGIN_SRC emacs-lisp
      (use-package imenu-list
        :straight t
        :defer  t
        :leader
        ("jI" 'imenu-anywhere)

        :config
        (evil-set-initial-state 'imenu-list-major-mode 'motion)

        :general
        (:states 'motion
         :keymaps 'imenu-list-major-mode-map
         "gr" 'imenu-list-refresh
         "o"  'imenu-list-display-entry))
    #+END_SRC

*** imenu-anywhere
    #+BEGIN_SRC emacs-lisp
      (use-package imenu-anywhere
        :straight t
        :defer  t
        :leader
        ("bi" 'imenu-list))
    #+END_SRC

** minibuffer
   #+BEGIN_SRC emacs-lisp
     (general-define-key
      :keymaps 'minibuffer-local-map
      "M-j" 'next-history-element
      "M-k" 'previous-history-element
      "C-j" 'previous-matching-history-element
      "C-k" 'next-matching-history-element
      "C-h" 'backward-char
      "C-l" (defun minibuffer-forward-char-or-exit ()
              (interactive)
              (call-interactively (if (eolp)
                                      'exit-minibuffer
                                    'forward-char)))

      "C-a" 'move-beginning-of-line
      "C-e" 'move-end-of-line
      "C-v" 'quoted-insert
      "C-M-q" 'quit-window
      "M-DEL" 'kill-whole-line

      ;; "M-n" nil
      ;; "M-p" nil
      ;; "M-r" nil
      "C-w" 'backward-kill-word
      "C-?" 'minibuffer-completion-help
      ;; for some reason.. I can't bind Meta keys
      "M-h" 'backward-kill-sentence
      "M-l" 'kill-sentence)

     (general-define-key
      :keymaps 'minibuffer-local-must-match-map
      "TAB" 'minibuffer-complete
      "<C-tab>" 'minibuffer-complete-and-exit
      "C-j" nil)

     (general-define-key
      :keymaps '(minibuffer-local-map
                 minibuffer-local-must-match-map
                 minibuffer-inactive-mode-map
                 minibuffer-local-ns-map
                 minibuffer-local-completion-map)
      "<escape>" 'abort-recursive-edit)
   #+END_SRC

    Some more sage advice from the demigods at [[https://github.com/hlissner/doom-emacs/blob/develop/docs/faq.org#how-does-doom-start-up-so-quickly][doom]].

    #+BEGIN_SRC emacs-lisp
      (defun defer-garbage-collection+ ()
        (setq gc-cons-threshold most-positive-fixnum))

      (defun restore-garbage-collection+ ()
        ;; Deferred so that commands launched immediately after will enjoy the
        ;; benefits.
        (run-at-time
         1 nil (lambda () (setq gc-cons-threshold default-gc-cons-threshold))))

      (add-hook 'minibuffer-setup-hook #'defer-garbage-collection+)
      (add-hook 'minibuffer-exit-hook #'restore-garbage-collection+)
    #+END_SRC

** macros
   emacs macro facilities configuration.

   #+BEGIN_SRC emacs-lisp
     (leader/set-keys
       "k"  "macros/lisp")

     ;; remove mode-line-indicator for macros
     (setq mode-line-defining-kbd-macro nil)
   #+END_SRC

*** kmacro
    #+BEGIN_SRC emacs-lisp
      (use-package kmacro
        :leader
        (:prefix "k"
         ;; 'edit-kbd-macro ;; any named macro
         ;; 'apply-macro-to-region-lines
         "s" 'name-last-kbd-macro
         "i" 'insert-kbd-macro
         "q" 'kbd-macro-query ;; prompt at macro point

         "c"  "counter"
         "cs" 'kmacro-set-counter
         "c=" 'kmacro-set-counter
         "cc" 'kmacro-insert-counter
         "ci" 'kmacro-insert-counter
         "ca" 'kmacro-add-counter
         "c+" 'kmacro-add-counter
         "cf" 'kmacro-set-format))
    #+END_SRC

*** edmacro
    #+BEGIN_SRC emacs-lisp
      (use-package edmacro
        :defer t
        :commands (edmacro-mode)
        :leader
        (:prefix "k"
         ;; 'kmacro-edit-lossage                                                      ; edit last 300 strokes as macro
         ;; 'kmacro-step-edit-macro                                                   ; debug last macro
         "SPC" 'kmacro-edit-macro                                                     ; last defined
         "b"   'kmacro-bind-to-key)

        :config
        (leader/set-keys-for-major-mode 'edmacro-mode
          "," 'edmacro-finish-edit
          "i" 'edmacro-insert-key))
    #+END_SRC

** mode-line
   Here we define customization options and other helpers for building mode-lines.

   #+BEGIN_SRC emacs-lisp
     (defvar +modeline-buffer-id-max-length 25
       "Truncate the buffer-id when it's larger than this many characters.
     Set to nil to disable buffer-name truncation.")

     (defvar +modeline-buffer-id-ellipses "..."
       "Suffix to be attached to truncated buffer names.")
   #+END_SRC

   Detect and display the current evil-register and the register under which a macro
   is currently being recorded... so for example if I hit ="r= than my mode-line can
   output show that sequence to let me know which register I'm working with. Similar
   story for a macro and if I select a register whithin a macro it should say =@q "a=.

   #+BEGIN_SRC emacs-lisp
     (defvar +mode-line-macro-symbol "@")
     (defvar +mode-line-register-symbol "\"")

     (defun +modeline-evil-macro-and-register ()
       (let ((macro (when defining-kbd-macro
                      (concat +mode-line-macro-symbol
                              (when (bound-and-true-p evil-this-macro)
                                (string evil-this-macro)))))
             (register (when (bound-and-true-p evil-this-register)
                         (concat +mode-line-register-symbol
                                 (char-to-string evil-this-register)))))
         (cond
          ((and macro register)
           (concat macro " " register))
          (macro macro)
          (register register))))
   #+END_SRC

   Extract and display version-control information related to the current buffer. For
   git this includes a github icon and the current git branch. For svn... I have no
   idea, if I ever use a project that has SVN I may well find out :stuck_out_tongue:.

   #+BEGIN_SRC emacs-lisp
     (defun +modeline-vc-icon ()
       (when vc-mode
         (cond ((string-match-p "Git[:-]" vc-mode)
                (cons 'faicon "github-alt"))
               ((string-match-p "SVN-" vc-mode)
                (cons 'fileicon "svn")))))

     (defun +modeline-vc-status (&rest propertize)
       (when vc-mode
         (or (when-let ((branch (cadr (split-string vc-mode "Git[:-]"))))
               (apply #'propertize branch
                      'local-map (get-text-property 1 'local-map branch)
                      propertize))
             (when (string-match-p "SVN-" vc-mode)
               (let ((revision (cadr (split-string vc-mode "-" ))))
                 (propertize revision propertize))))))
   #+END_SRC

   Next on the list are icons/status-info for the current linter/syntax-highlighter
   for the buffer you're in. This can come from either [[https://www.flycheck.org/en/latest/][flycheck]] or [[https://www.gnu.org/software/emacs/manual/html_node/flymake/Using-Flymake.html#Using-Flymake][GNU flymake]] but
   I *don't* recommend having both active simultaneously.

   Each of these functions returns a plist of properties related to the current
   buffer. This includes formatted error/warning/info counts and a meta-tag
   indicating the status of the associated checker.

   #+BEGIN_SRC emacs-lisp
     (defvar +modeline-checker-bullet "‚Ä¢%s"
       "The bullet used for each section of a `flymake'/`flycheck' segment.
     This should be a format string with a single `%s'-expression corresponding to
     the number of errors.")

     (defun +modeline-flymake (info-face warn-face error-face meta-face)
       ;; See [[https://www.gnu.org/software/emacs/manual/html_node/flymake/Syntax-check-statuses.html#Syntax-check-statuses][here]], flymake shows different indicators depending on the linting status.
       ;; Status format adapted from `flymake--mode-line-format'.
       (let ((known (and flymake--backend-state
                         (hash-table-keys flymake--backend-state)))
             (running (flymake-running-backends))
             (disabled (flymake-disabled-backends))
             (reported (flymake-reporting-backends)))
         `(:meta ,(cond ((null known)
                         (propertize "?" 'face meta-face))
                        ((cl-set-difference running reported)
                         (propertize "%" 'face meta-face))
                        ((and disabled (null running))
                         (propertize "!" 'face error-face)))
           ,@(cl-loop with idx = nil
                      with acc = (make-vector 3 0)                                   ; See (flymake--severity :error)
                      for diag in (flymake-diagnostics)
                      do (setq idx (- (flymake--severity (flymake-diagnostic-type diag)) 1))
                      when (and (>= idx 0)
                                (<  idx 3))
                      do (aset acc idx (1+ (aref acc idx)))
                      finally do (cl-loop
                               for (i . face) in `((0 . ,info-face)
                                                   (1 . ,warn-face)
                                                   (2 . ,error-face))
                               when (eq (aref acc i) 0)
                               do (aset acc i nil)
                               else
                               do (aset acc i
                                        (propertize (format +modeline-checker-bullet (aref acc i)) 'face face)))
                      finally return
                      `(:info     ,(aref acc 0)
                        :warning  ,(aref acc 1)
                        :error    ,(aref acc 2))))))

     (defun +modeline-flycheck (info-face warn-face error-face meta-face)
       (let ((counts (flycheck-count-errors flycheck-current-errors))
             (running (eq 'running flycheck-last-status-change)))
         (cl-loop for (level . face) in `((info    . ,info-face)
                                          (warning . ,warn-face)
                                          (error   . ,error-face))
                  collect (intern (concat ":" (symbol-name level)))
                  collect (when (or running
                                    (flycheck-has-current-errors-p level))
                            (propertize (format
                                         +modeline-checker-bullet
                                         (or (alist-get level counts)
                                             "?"))
                                        'face face)))))
   #+END_SRC

   Lastly lets just add a helper method to format the output of the previous
   functions in a way that looks pretty *and* can be substituted back into the
   mode-line.

   #+BEGIN_SRC emacs-lisp
     (defun +modeline-format-checker-status (stat)
       "Formats the output of `+modeline-flycheck' or `+modeline-flymake'
     into a string that can be substituted back into the mode-line."
       (let ((meta      (plist-get stat :meta))
             (errors    (plist-get stat :error))
             (warnings  (plist-get stat :warning))
             (infos     (plist-get stat :info)))
         (concat (when meta
                   (concat "[" meta "]"))
                 (and meta
                      (or errors warnings infos)
                      " ")
                 (string-join (delq nil (list errors warnings infos)) " "))))
   #+END_SRC

   Emacs has a few language-server packages. More recent variants are implementation
   of the [[https://microsoft.github.io/language-server-protocol/][lsp-protocol]] for which emacs has 2 mainstream client implementations [[https://microsoft.github.io/language-server-protocol/][lsp-mode]]
   and [[https://github.com/joaotavora/eglot][eglot]]. There's also some +older+ *more-established* language server packages such
   [[https://github.com/mopemope/meghanada-emacs][meghanada-mode]] or [[https://github.com/pythonic-emacs/anaconda-mode][anaconda-mode]].

   Each of these functions return a plist containing a server status message, some
   meta-information (eg. server-name or server-port) and a face that should be
   attached to it.

   Much of these were partially adapted from: [[https://github.com/seagle0128/doom-modeline/blob/af5f61888e7eb0aa521d2d29b42221302b717915/doom-modeline-segments.el#L1871][doom-modeline]].

   #+BEGIN_SRC emacs-lisp
     (defun +modeline-lsp-status (info-face warn-face error-face meta-face)
       (let* ((workspaces (lsp-workspaces))
              (face (if workspaces
                        info-face
                      error-face)))
         `(:msg ,(if workspaces "OK" ":broken")
           :meta ,(propertize
                   (cl-loop for w in workspaces concat (lsp--workspace-print w))
                   'face meta-face)
           :face ,face)))

     (defun +modeline-eglot-status (info-face warn-face error-face meta-face)
       (pcase-let* ((server (eglot-current-server))
                    (server-name (and server
                                      (plist-get (eglot--server-info server) :name)))
                    (pending (and server (hash-table-count
                                          (jsonrpc--request-continuations server))))
                    (`(,_id ,doing ,done-p ,detail) (and server (eglot--spinner server)))
                    (last-error (and server (jsonrpc-last-error server))))
         `(:msg ,(cond
                  (last-error ":error")
                  ((or (and doing (not done-p))
                       (and pending (cl-plusp pending)))
                   ":wait")
                  ((or server
                       server-name) "OK")
                  (t ":broken"))
           :meta ,(and server-name
                       (propertize server-name 'face meta-face))
           :face ,(cond (last-error error-face)
                        ((and doing (not done-p)) warn-face)
                        ((and pending (cl-plusp pending)) warn-face)
                        (server info-face)
                        (t warn-face)))))

     (defun +modeline-anaconda-status (info-face warn-face error-face meta-face)
       `(:meta ,(propertize
                 (concat "Anaconda"
                         (when-let ((proc anaconda-mode-process)
                                    (port (process-get proc 'port)))
                           (format ":%d" port)))
                 'face meta-face)
         :face ,(if (anaconda-mode-running-p)
                    info-face
                  error-face)))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (defun +mode-line-language-server (&rest args)
       (cond ((bound-and-true-p anaconda-mode)
              (apply #'+modeline-anaconda-status args))
             ((bound-and-true-p lsp-mode)
              (apply #'+modeline-lsp-status args))
             ((bound-and-true-p eglot--managed-mode)
              (apply #'+modeline-eglot-status args))))

     (defun +modeline-format-language-server-status (stat)
       (let ((face (plist-get stat :face))
             (msg (plist-get stat :msg))
             (meta (plist-get stat :meta)))
         (concat
          msg
          (when meta
            (concat "[" meta "]")))))
   #+END_SRC

   Discover the name of the current buffers project.

   #+BEGIN_SRC emacs-lisp
     (defun +mode-line-project ()
       (cond
        ((fboundp 'projectile-project-name)
         (let ((project-name (projectile-project-name)))
           (unless (or (string= project-name "-")
                       (string= project-name (buffer-name)))
             project-name)))))
   #+END_SRC

*** spaceline
    :PROPERTIES:
    :header-args+: :tangle (package-str! "init.el" spaceline)
    :END:

    An amazing mode line... needs to be initialised before all others to make sure
    every buffer inherits the same mode line.

    I'll be using a fork of powerline (spacelines dependency) which has a lot more new
    features compared to the one in melpa.

    #+BEGIN_SRC emacs-lisp
      (use-package powerline
        :straight (powerline :host github :repo "jonathanchu/emacs-powerline"
                             :fork (:repo "milkypostman/powerline")))
    #+END_SRC

    #+BEGIN_SRC emacs-lisp
      (add-hook 'after-load-theme-hook
                (lambda (&rest _)
                  (set-face-attribute
                   'mode-line nil
                   :box
                   `(:line-width 1 :color ,(face-attribute 'mode-line :background) :style none))))
    #+END_SRC

    #+BEGIN_SRC emacs-lisp
      (use-package spaceline
        :straight t
        :demand   t
        :hook (after-load-theme . powerline-reset)
        :config
        (setq spaceline-org-clock t
              powerline-default-separator 'slant

              spaceline-window-number-p t
              spaceline-window-numbers-unicode nil

              ;; unicode numbers on the terminal aren't the right
              ;; width and I'm too lazy to find a better font.
              spaceline-workspace-number-p nil
              spaceline-workspace-numbers-unicode nil

              spaceline-buffer-id-max-length +modeline-buffer-id-max-length
              spaceline-flycheck-bullet +modeline-checker-bullet)

        (setq-default mode-line-format (spaceline-spacemacs-theme))
        ;; Also make sure spaceline is applied to any existing buffers.
        (dolist (buf (buffer-list))
          (with-current-buffer buf
            (setq mode-line-format (spaceline-spacemacs-theme))))

        (push '(operator  . spaceline-evil-operator)  spaceline-evil-state-faces)
        (push '(multiedit . spaceline-evil-multiedit) spaceline-evil-state-faces)

        (defvar spaceline-highlight-evil-operator+ t
          "when true, spaceline will highlight operator state
      like it would any other state.")

        (setq spaceline-highlight-face-func
              (defun spaceline-highlight-face+ ()
                (if (active-minibuffer-window)
                    'spaceline-minibuffer
                  ;; (spaceline-highlight-face-evil-state)
                  ;; redefine spaceline-highlight-face-evil-state here because
                  ;; it doesn't highlight operator state :(
                  (if (bound-and-true-p evil-local-mode)
                      (let* ((state (if (and (eq 'operator evil-state)
                                            (not spaceline-highlight-evil-operator+))
                                       evil-previous-state
                                     evil-state))
                             (face (assq state spaceline-evil-state-faces)))
                        (if face (cdr face) (spaceline-highlight-face-default)))
                    (spaceline-highlight-face-default))))))
    #+END_SRC

**** icons
     #+BEGIN_SRC emacs-lisp
       (defvar spaceline-preferred-icon-height 0.98
         "height of icons in the spaceline modeline")

       (defun spaceline--face-icon-height (face)
         (let ((height (face-attribute face :height)))
           (unless (eq height 'unspecified)
             (/ height 100.0))))

       (defun spaceline-icon-height (&optional height)
         (or height
             spaceline-preferred-icon-height
             (spaceline--face-icon-height 'mode-line)
             (spaceline--face-icon-height 'default)))

       (cl-defmacro spaceline-prepared-icon (func icon-arg &rest args)
         "retrieve an `all-the-icons' icon for display in the spaceline.
       FUNC is a function such as `all-the-icon-faicon' which accepts an argument
       ICON-ARG and a bunch of face properties and returns either a symbol or an
       icon string.

       The remaining arguments should form a PLIST with the following being used
       by this function and the remaining being passed directly to FUNC.

       Keywords
       --------
       face - Can be given to specify a face for the icon. This face will be applied
              over the regular background of the current spaceline section.

       face-when-active - When specified means the face argument from before will only
                          only be applied on the windows spaceline sees as active.

       family - Can be specified as a function to force usage of a certain font family
                for the icon. If ommited the family property is extracted from the icon
                directly. eg. `all-the-icons-icon-family-for-mode'.
       "
         (plist-bind! (args :face :family :height :propertize (:v-adjust . -0.1) (:face-when-active . t))
           (setq family (eval family))

           `(let* ((use-face (and ,face
                                  ,@(when face-when-active
                                      (list (quote (bound-and-true-p active))))))
                   (icon (funcall ,func ,icon-arg
                                  :face (when use-face ,face)
                                  :v-adjust ,v-adjust
                                  :height (spaceline-icon-height ,height)
                                  ,@args)))
              (unless (symbolp icon)
                (if use-face
                    (prog1 icon
                      ;; see https://github.com/domtronn/all-the-icons.el/issues/131
                      (add-face-text-property 0 (length icon) :inherit t icon))
                  (propertize (concat icon (unless (display-graphic-p)  " "))
                              ;; 'display '(raise 0.1)
                              'mouse-face 'mode-line-highlight
                              'face (list :family (or
                                                   ,@(when (and family (functionp family))
                                                       (funcall family))
                                                   (plist-get (get-text-property 0 'face icon)
                                                              :family))
                                          :inherit)))))))
       (put 'spaceline-prepared-icon 'lisp-indent-function 'defun)

       (cl-defmacro spaceline-icon (family icon &rest args)
         "alias for `spaceline-prepared-icon' which uses a font-family as a function.
       FONT-FAMILY should be a symbol (such as faicon) relating to some font family.
       ICON should be a string relating to an icon in that family.

       See `spaceline-prepared-icon' for a description of the remaining arguments.
       "
         (let* ((icon-func (intern (concat "all-the-icons-" (symbol-name family))))
                (family-func (intern (concat (symbol-name icon-func) "-family"))))
           `(spaceline-prepared-icon #',icon-func ,icon :family #',family-func ,@args)))
       (put 'spaceline-icon 'lisp-indent-function 'defun)
     #+END_SRC

**** segments
     #+BEGIN_SRC emacs-lisp
       (spaceline-define-segment evil-macro-and-register
         (+modeline-evil-macro-and-register)
         :enabled t)

       ;; see for eg segments: [[https://github.com/domtronn/all-the-icons.el/wiki/Spaceline]]
       (spaceline-define-segment minibuffer-active
         "show a stop symbol if minibuffer is active"
         (spaceline-icon faicon "dot-circle-o" :v-adjust 0.00)
         :when (and +icons-available
                    (active-minibuffer-window)))

       (spaceline-define-segment buffer-mode-icon
         "an `all-the-icons' segment to show the mode of the current buffer"
         (spaceline-prepared-icon #'all-the-icons-icon-for-mode major-mode
           :v-adjust -0.15)
         :enabled +icons-available)

       (spaceline-define-segment version-control-type-icon
         (when-let* ((icon (+modeline-vc-icon)))
           (spaceline-prepared-icon
            (all-the-icons--function-name (car icon))
            (cdr icon)))
         :when +icons-available)

       (spaceline-define-segment version-control-status
         "An `all-the-icons' segment to depict the current VC system with an icon"
         (+modeline-vc-status 'display '(raise 0.1) 'face :inherit)
         :when (and active +icons-available))

       (spaceline-define-segment flymake-checker
         (when-let ((stat (+modeline-flymake 'spaceline-flycheck-info
                                             'spaceline-flycheck-warning
                                             'spaceline-flycheck-error
                                             'mode-line-emphasis)))
           (+modeline-format-checker-status stat))
         :when (bound-and-true-p flymake-mode))

       (spaceline-define-segment language-server
         (when-let ((stat (+mode-line-language-server 'spaceline-flycheck-info
                                                      'spaceline-flycheck-warning
                                                      'spaceline-flycheck-error
                                                      'mode-line-emphasis)))
           (concat
            (spaceline-icon faicon "rocket" 'face (plist-get stat :face))
            (+modeline-format-language-server-status stat)))
         :when +icons-available)

       (spaceline-define-segment project
         (+mode-line-project))
     #+END_SRC

**** format
     #+BEGIN_SRC emacs-lisp
       (spaceline-compile
         ;; Left
         '((minibuffer-active
            :fallback ((persp-name
                        workspace-number
                        window-number)
                       :fallback evil-state)
            :face highlight-face
            :priority 100)
           auto-compile
           (anzu
            :priority 98)
           ((buffer-modified
             buffer-size
             buffer-mode-icon
             buffer-id
             remote-host)
            :priority 98)
           (major-mode :priority 79)
           (process :when active)
           ;; assumes flymake and flycheck won't be used simulataneously
           ((flymake-checker
             flycheck-error
             flycheck-warning
             flycheck-info)
            :priority 89
            :when active)
           (minor-modes
            :when active
            :priority 9)
           ;; (mu4e-alert-segment :when active)
           ;; (erc-track :when active)
           ((version-control-type-icon
             version-control-status
             :fallback version-control)
            :priority 78)
           (language-server
            :when active)
           ;; (org-pomodoro :when active)
           (org-clock :when active))

         ;; Right
         '(project
           which-function
           (python-pyvenv
            :fallback python-pyenv)
           (purpose :priority 94)
           (battery :when active)
           (selection-info :priority 95)
           input-method
           ((evil-macro-and-register
             buffer-encoding-abbrev
             point-position
             line-column)
            :separator " | "
            :priority 96)
           (global :when active)
           (buffer-position :priority 99)
           (hud :priority 99)))
     #+END_SRC


*** doom-modeline
    #+BEGIN_SRC emacs-lisp :tangle (package-yes! doom-modeline)
      (use-package doom-modeline
        :straight (doom-modeline :fork (:host github :repo "mohkale/doom-modeline" :branch "emacs-dotfiles"))
        :hook ((after-init         . doom-modeline-mode)
               (doom-modeline-mode . size-indication-mode)
               (doom-modeline-mode . column-number-mode))
        :init
        (setq doom-modeline-project-detection 'projectile
              doom-modeline-buffer-file-name-style 'buffer-name
              doom-modeline-icon (or (display-graphic-p)
                                     +icons-available)
              doom-modeline-major-mode-color-icon nil
              doom-modeline-minor-modes t
              doom-modeline-enable-word-count nil
              doom-modeline-checker-simple-format t
              doom-modeline-number-limit 99
              doom-modeline-modal-icon nil
              doom-modeline-env-version nil
              doom-modeline-buffer-state-icon nil
              doom-modeline-height 1)

        (advice-add 'doom-modeline--set-char-widths :override #'ignore)

        :config
        (setq find-file-visit-truename
              (or find-file-visit-truename                                 ; if already enabled, don't alter it
                  ;; These are a single file/name so we don't need to follow
                  ;; symlinks when displaying them.
                  (not (member doom-modeline-buffer-file-name-style
                               '(file-name buffer-name)))))

        (advice-add 'mode-line-frame-control :override
                    (defun mode-line-frame-control+ ()
                      "%F "))

        (defun doom-modeline-truncate-right+ (val)
          (string-truncate-right! val 1))

        (defun doom-modeline-truncate-left+ (val)
          (string-truncate-left! val 1))

        (defun doom-modeline-truncate+ (val)
          (string-truncate! val 1 1))

        (defun doom-modeline-limited-width-hide+ (func &rest args)
          (unless doom-modeline--limited-width-p
            (apply func args)))

        (advice-add 'doom-modeline-segment--buffer-position :filter-return
                    #'doom-modeline-truncate+)

        (advice-add 'doom-modeline-icon :filter-return #'all-the-icons-pad-on-tty-advice+)

        (advice-add #'doom-modeline--buffer-name :filter-return
                    (defun doom-modeline-buffer-name-truncate+ (val)
                      (when val
                        (let ((name (format-mode-line val)))
                          (if (and (eval-when-compile
                                     (and +modeline-buffer-id-max-length
                                          (< (length +modeline-buffer-id-ellipses)
                                             +modeline-buffer-id-max-length)))
                                   (> (length name) +modeline-buffer-id-max-length))
                              (apply #'propertize
                                     (concat
                                      (substring-no-properties name 0
                                                               (eval-when-compile
                                                                 (- +modeline-buffer-id-max-length
                                                                    (length +modeline-buffer-id-ellipses))))
                                      +modeline-buffer-id-ellipses)
                                     (text-properties-at 0 val))
                            name)))))

        (doom-modeline-def-segment buffer-info+
          "Custom variant of buffer-info with buffer-state shown without icons."
          (concat
           "[%*]"
           (doom-modeline-spc)
           (doom-modeline--buffer-mode-icon)
           (doom-modeline-spc)
           (doom-modeline--buffer-name)
           (doom-modeline-spc)))

        (advice-add #'doom-modeline--anzu             :filter-return #'doom-modeline-truncate+)
        (advice-add #'doom-modeline--iedit            :filter-return #'doom-modeline-truncate+)
        (advice-add #'doom-modeline--symbol-overlay   :filter-return #'doom-modeline-truncate+)
        (advice-add #'doom-modeline--evil-substitute  :filter-return #'doom-modeline-truncate+)
        (advice-add #'doom-modeline--multiple-cursors :filter-return #'doom-modeline-truncate+)

        (doom-modeline-def-segment matches+
          (let ((meta (string-join
                       (delq nil
                             `(,(and (doom-modeline--active)
                                     (+modeline-evil-macro-and-register))
                               ,(doom-modeline--anzu)
                               ,(doom-modeline--phi-search)
                               ,(doom-modeline--evil-substitute)
                               ,(doom-modeline--iedit)
                               ,(doom-modeline--symbol-overlay)
                               ,(doom-modeline--multiple-cursors)))
                       (doom-modeline-spc))))
            (or (and (not (string-empty-p meta))
                     (concat (doom-modeline-spc)
                             meta
                             (doom-modeline-spc)))
                (doom-modeline--buffer-size))))

        (defsubst doom-modeline--evil-face+ ()
          (if (active-minibuffer-window)
              'doom-modeline-minibuffer-face
            (if (bound-and-true-p evil-local-mode)
                (cond
                 ((evil-normal-state-p)   'doom-modeline-evil-normal-state)
                 ((evil-emacs-state-p)    'doom-modeline-evil-emacs-state)
                 ((evil-insert-state-p)   'doom-modeline-evil-insert-state)
                 ((evil-motion-state-p)   'doom-modeline-evil-motion-state)
                 ((evil-visual-state-p)   'doom-modeline-evil-visual-state)
                 ((evil-operator-state-p) 'doom-modeline-evil-operator-state)
                 ((evil-replace-state-p)  'doom-modeline-evil-replace-state)
                 (t                       'doom-modeline-evil-normal-state))
              'doom-modeline-evil-normal-state)))

        (doom-modeline-def-segment evil-state-and-winum+
          (let* ((face (doom-modeline--evil-face+))
                 (space (propertize " " 'face face)))
            (concat space
                    (when (> (length (frames-on-display-list)) 1)
                      (propertize (format-mode-line (mode-line-frame-control))
                                  'face `(:weight bold :inherit ,face)))
                    (propertize
                     (cond
                      ((active-minibuffer-window) "‚óè")
                      ((bound-and-true-p winum-mode)
                       (substring-no-properties (winum-get-number-string)))
                      ((bound-and-true-p ace-window-display-mode)
                       (aw-update)
                       (window-parameter (selected-window) 'ace-window-path))
                      ((bound-and-true-p window-numbering-mode)
                       (window-numbering-get-number-string))
                      (t " "))
                     'face face)
                    space)))

        (doom-modeline-def-segment vc-status+
          (when (and vc-mode
                     (doom-modeline--active)
                     (not doom-modeline--limited-width-p))
            (let ((stat (+modeline-vc-status))
                  (icon (+modeline-vc-icon)))
              (when (or stat icon)
                (concat (when icon
                          (concat (doom-modeline-spc)
                                  (doom-modeline-propertize-icon
                                   (doom-modeline-icon (car icon) (cdr icon) ?v ?v))))
                        (when stat
                          (concat (doom-modeline-spc)
                                  stat)))))))

        (defsubst doom-modeline--build-server-section+ (stat-func fallback-str)
          (when-let ((stat (funcall stat-func
                                    'doom-modeline-lsp-success
                                    'doom-modeline-lsp-warning
                                    'doom-modeline-lsp-error
                                    'mode-line-emphasis)))
            (concat
             (doom-modeline-lsp-icon fallback-str (plist-get stat :face))
             ;; (+modeline-format-language-server-status stat)
             )))

        (advice-add #'doom-modeline-update-lsp :override
                    (defun doom-modeline-update-lsp+ ()
                      (setq doom-modeline--lsp
                            (doom-modeline--build-server-section+ #'+modeline-lsp-status "LSP"))))

        (advice-add #'doom-modeline-update-eglot :override
                    (defun doom-modeline-update-eglot+ ()
                      (setq doom-modeline--eglot
                            (doom-modeline--build-server-section+ #'+modeline-eglot-status "EGLOT"))))

        (defun doom-modeline--anaconda-server ()
          (when (bound-and-true-p anaconda-mode)
            (doom-modeline--build-server-section+ #'+modeline-anaconda-status "Anaconda")))

        (doom-modeline-def-segment meta-icons+
          "Icons indicating various kinds of states related to the current buffer.
      Think minor-mode list except not full text."
          (let* ((face (if (doom-modeline--active)
                           'doom-modeline-panel
                         'mode-line-inactive))
                 (icons (string-join
                         (delq
                          nil (list (cond ((bound-and-true-p lsp-mode)
                                           doom-modeline--lsp)
                                          ((bound-and-true-p eglot--managed-mode)
                                           doom-modeline--eglot)
                                          ((bound-and-true-p anaconda-mode)
                                           (doom-modeline--anaconda-server)))
                                    (and (buffer-narrowed-p)
                                         (doom-modeline-icon 'nerd-mdi "json" "{}" "{}" :face face))))
                         (doom-modeline-spc))))
            (unless (string-empty-p icons)
              (concat ;; (doom-modeline-spc)
                      icons))))

        (defsubst doom-modeline--build-flychecker-section+ (stat-func)
          (when-let* ((stat (funcall stat-func
                                     'doom-modeline-info
                                     'doom-modeline-debug
                                     'doom-modeline-urgent
                                     'doom-modeline-lsp-running))
                      (body (+modeline-format-checker-status stat)))
            (unless (string-empty-p body)
              (concat
               (propertize "<" 'face 'mode-line-emphasis)
               body
               (propertize ">" 'face 'mode-line-emphasis)))))

        (advice-add #'doom-modeline-update-flycheck-icon :override
                    (defun doom-modeline-update-flycheck-icon+ (&optional status)
                      (setq doom-modeline--flycheck-icon
                            (doom-modeline--build-flychecker-section+ #'+modeline-flycheck))))
        (advice-add #'doom-modeline-update-flycheck-text :override #'ignore)

        (advice-add #'doom-modeline-update-flymake-icon :override
                    (defun doom-modeline-update-flymake-icon+ (&rest _)
                      (setq doom-modeline--flymake-icon
                            (doom-modeline--build-flychecker-section+ #'+modeline-flymake))))
        (advice-add #'doom-modeline-update-flymake-text :override #'ignore)

        (doom-modeline-def-segment checker+
          (when-let ((icon (cond ((and (bound-and-true-p flymake-mode)
                                       (bound-and-true-p flymake--backend-state)) ; only support 26+
                                  doom-modeline--flymake-icon)
                                 ((bound-and-true-p flycheck-mode)
                                  doom-modeline--flycheck-icon))))
            (concat
             (doom-modeline-spc)
             (if (doom-modeline--active)
                 icon
               (doom-modeline-propertize-icon icon 'mode-line-inactive)))))

        (doom-modeline-def-segment space+
          (doom-modeline-spc))

        (advice-add #'doom-modeline-segment--buffer-encoding :filter-return #'doom-modeline-truncate-right+)
        (advice-add #'doom-modeline-segment--buffer-encoding :around #'doom-modeline-limited-width-hide+)

        (doom-modeline-def-modeline 'mohkale
          ;; Left hand side
          '(bar                                                            ; Forces the mode-line to take up a given height (in GUI
            evil-state-and-winum+
            matches+                                                       ; Search results, macro state, multiple-cursors etc.
            buffer-info+
            remote-host
            process
            parrot
            selection-info
            vc-status+
            checker+)

          ;; Right hand side
          '(misc-info
            minor-modes
            meta-icons+
            input-method
            buffer-encoding
            buffer-position
            major-mode))

        (dolist (it '(doom-modeline-format--main
                      doom-modeline-format--dashboard
                      doom-modeline-format--project
                      doom-modeline-format--message
                      doom-modeline-format--org-src
                      doom-modeline-format--special
                      doom-modeline-format--pdf
                      doom-modeline-format--vcs
                      doom-modeline-format--info))
          (when (symbol-function it)
            (defalias it (symbol-function 'doom-modeline-format--mohkale))))

        (define-minor-mode doom-modeline-mode
          "Toggle doom-modeline on or off."
          :group 'doom-modeline
          :global t
          :lighter nil
          :keymap doom-modeline-mode-map
          (if doom-modeline-mode
              (progn
                (doom-modeline-refresh-bars)        ; Create bars
                (doom-modeline-set-main-modeline)   ; Set mode-line for current buffer
                (doom-modeline-set-main-modeline t) ; Set default mode-line

                (dolist (buf (buffer-list))
                  (with-current-buffer buf
                    (doom-modeline-set-main-modeline))))
            ;; Restore mode-line
            (setq         mode-line-format doom-modeline--default-format)
            (setq-default mode-line-format doom-modeline--default-format)

            (dolist (buf (buffer-list))
              (with-current-buffer buf
                (setq mode-line-format doom-modeline--default-format))))))
    #+END_SRC

** occur
   See all occurences of a search query in the current buffer, with support to jumping
   to the next or previous query and even editing them on the fly.

   #+BEGIN_SRC emacs-lisp
     (use-package replace
       :straight (replace :type built-in)
       :defer t
       :config
       ;; occur-mode-display-occurrence
       (advice-add 'occur-mode-display-occurrence :around
                   #'restore-default-display-buffer-actions)

       (defun evil-adjust-occur-next ()
         (interactive)
         (with-evil-adjust-to-eol
           (funcall-interactively 'occur-next)))

       (defun evil-adjust-occur-prev ()
         (interactive)
         (with-evil-adjust-to-eol
           (funcall-interactively 'occur-prev)))

       (evil-set-initial-state 'occur-mode 'motion)
       (evil-set-initial-state 'occur-edit-mode 'normal)

       :lazy-leader
       (:modes '(occur-mode occur-edit-mode)
        "e" 'occur-edit-mode
        "R" 'occur-rename-buffer
        "g" 'occur-mode-goto-occurrence
        "G" 'occur-mode-goto-occurrence-other-window
        "l" 'occur-mode-display-occurrence)
       (:modes 'occur-edit-mode
        "," 'occur-cease-edit)

       :general
       (:keymaps 'occur-mode-map
        :states  'motion
        ;; occur-mode-mouse-goto
        "RET" 'occur-mode-goto-occurrence
        "o" 'occur-mode-goto-occurrence-other-window
        "s" 'occur-mode-display-occurrence

        "j"  'evil-adjust-occur-next
        "k"  'evil-adjust-occur-prev
        "gj" 'evil-next-line
        "gk" 'evil-previous-line

        "R" 'occur-rename-buffer
        "q" nil)
       (:states  'normal
        :keymaps 'occur-edit-mode-map
        ;; occur-mode-mouse-goto
        "RET" 'occur-mode-goto-occurrence
        "go"  'occur-mode-goto-occurrence-other-window
        "gO"  'occur-mode-display-occurrence
        "j"   'evil-adjust-occur-next
        "k"   'evil-adjust-occur-prev
        [remap quit-window] 'occur-cease-edit))
   #+END_SRC

** outline-mode
   #+BEGIN_SRC emacs-lisp
     (use-package outline
       :defer t
       :config
       (advice-add 'outline-up-heading :around
                   (defun outline-up-heading--goto-current-first+ (func arg &optional invisible-ok)
                     "make `outline-up-heading' goto the current heading first
     unless already there."
                     (unless (outline-on-heading-p invisible-ok)
                       (outline-backward-same-level 0)
                       (when arg
                         (setq arg (if (> arg 0) (- arg 1) (+ arg 1)))))

                     (when arg
                       (apply func arg invisible-ok))))

       (defun outline-folded-p+ (&optional pos)
         (save-excursion
           (goto-char (line-end-position))
           (outline-invisible-p)))

       (defun outline-toggle-show-children+ ()
         (interactive)
         (if (outline-folded-p+)
             (outline-show-subtree)
           (outline-hide-subtree)))

       :lazy-leader
       (:mode 'outline-mode
        "m" 'outline-mark-subtree
        "t" 'outline-hide-body ;; show subtree
        "a" 'outline-show-all
        ;; only show outline upto this level.
        "h" 'outline-hide-sublevels
        "l" 'outline-show-branches
        "f" 'outline-hide-other ;; focus
        ;; show remainder of branches in current hidden branch.
        "q" 'outline-show-branches
        "RET" 'outline-insert-heading)

       :general
       (:states  'motion
        :keymaps 'outline-mode-map
        "gh" 'outline-up-heading
        "gj" 'outline-next-heading
        "gk" 'outline-previous-heading
        "gl" 'outline-forward-same-level)
       (:states  'motion
        :keymaps 'outline-mode-map
        :predicate '(outline-on-heading-p)
        [remap evil-shift-right] 'outline-demote
        [remap evil-shift-left]  'outline-promote
        [remap drag-stuff-down]  'outline-move-subtree-down
        [remap drag-stuff-up]    'outline-move-subtree-up
        "TAB"   'outline-toggle-show-children+
        "<tab>" 'outline-toggle-show-children+))
   #+END_SRC

** package
   #+BEGIN_SRC emacs-lisp
     (use-package package
       :defer t
       :config
       (evil-set-initial-state 'package-menu-mode 'motion)

       :lazy-leader
       (:mode 'package-menu-mode
        "h" 'package-menu-hide-package
        "?" 'package-menu-quick-help
        "/" 'package-menu-filter

        "m"  "mark"
        "m~" 'package-menu-mark-obsolete-for-deletion
        "mu" 'package-menu-mark-unmark
        "mi" 'package-menu-mark-install
        "mu" 'package-menu-mark-upgrades
        "md" 'package-menu-mark-delete)

       :general
       (:keymaps 'package-menu-mode-map
        :states  'motion
        "TAB" 'forward-button
        "<backtab>" 'backward-button
        "RET" 'package-menu-describe-package
        "DEL" 'package-menu-backup-unmark
        "("   'package-menu-toggle-hiding
        "S"   'tabulated-list-sort
        "U"   'package-menu-mark-upgrades
        "d"   'package-menu-mark-delete
        "i"   'package-menu-mark-install
        "u"   'package-menu-mark-unmark
        "x"   'package-menu-execute
        "q"   nil
        "~"   'package-menu-mark-obsolete-for-deletion
        "gr"  'package-menu-refresh))
   #+END_SRC

** paren
   when your point is on a parenthesis, highlight the matching one.

   # TODO look into smart-parens-mode

   #+BEGIN_SRC emacs-lisp
     (use-package paren
       :hook ((prog-mode . show-paren-mode)
              (text-mode . show-paren-mode))
       :init (setq sp-highlight-pair-overlay nil))
   #+END_SRC

** pp
   #+BEGIN_SRC emacs-lisp
     (use-package pp
       :defer t
       :init
       :leader
       (:prefix "k"
        "m" 'pp-macroexpand-last-sexp
        "M" 'pp-macroexpand-expression
        "p" 'pp-eval-last-sexp
        "P" 'pp-eval-expression)

       :init
       (with-eval-after-load 'elisp-mode
         (leader/set-keys-for-major-mode '(emacs-lisp-mode
                                           lisp-interaction-mode)
           "eM" 'pp-macroexpand-expression
           "em" 'pp-macroexpand-last-sexp
           "ex" 'pp-eval-last-sexp
           "eX" 'pp-eval-expression)))
   #+END_SRC

** proced
   edit processes, like windows task-manager but within emacs :)

   #+BEGIN_SRC emacs-lisp
     (use-package proced
       :config
       (evil-set-initial-state 'proced-mode 'motion)

       :lazy-leader
       (:mode 'proced-mode
        "k" 'proced-send-signal

        "m"  "mark"
        "ma" 'proced-mark-all
        "mu" 'proced-unmark-all
        "mp" 'proced-mark-parents
        "mc" 'proced-mark-children
        "mt" 'proced-toggle-marks
        "mm" 'proced-toggle-marks)

       :general
       (:states  'motion
        :keymaps 'proced-mode-map

        "q"      nil
        "C-?"    'proced-help

        "SPC" 'proced-mark
        "DEL" 'proced-unmark-backward
        "a" 'proced-mark
        "A" 'proced-mark-all
        "u" 'proced-unmark
        "U" 'proced-unmark-all
        "p" 'proced-mark-parents
        "P" 'proced-mark-children
        "M" 'proced-toggle-marks

        "x"   'proced-send-signal
        "C-k" 'proced-send-signal

        "M-SPC" 'proced-toggle-tree

        "r" 'proced-refine
        "R" 'proced-renice

        "o" 'proced-omit-processes ;; marked

        "C-M-SPC" 'proced-format-interactive

        "sS" 'proced-sort-interactive
        "sc" 'proced-sort-pcpu
        "sm" 'proced-sort-pmem
        "sp" 'proced-sort-pid
        "ss" 'proced-sort-start
        "st" 'proced-sort-time
        "su" 'proced-sort-user
        "S"  'proced-filter-interactive))
   #+END_SRC

** process-menu
   #+BEGIN_SRC emacs-lisp
     (use-package simple
       :defer t
       :config
       (evil-set-initial-state 'process-menu-mode 'motion)

       :general
       (:states  'motion
        :keymaps 'process-menu-mode-map
        "d" 'process-menu-delete-process
        "x" 'process-menu-delete-process

        "TAB"   'forward-button
        "S-TAB" 'backward-button
        "gj"    'forward-button
        "gk"    'backward-button))
   #+END_SRC

** re-builder
   #+BEGIN_SRC emacs-lisp
     (use-package re-builder
       :config
       (setq reb-re-syntax 'rx)
       ;; (evil-set-initial-state 'reb-lisp-mode 'insert)

       (defun reb-save-and-quit+ ()
         "copy regexp and then exit reb."
         (interactive)
         (reb-copy)
         (reb-quit))

       :lazy-leader
       (:mode 'reb-lisp-mode
        "," 'reb-save-and-quit+
        "s" 'reb-copy ;; as string
        "q" 'reb-quit

        "b" 'reb-change-target-buffer
        "c" 'reb-toggle-case
        "y" 'reb-copy ;; as string
        "u" 'reb-force-update
        "s" 'reb-enter-subexp-mode
        "TAB" 'reb-change-syntax)

       :general
       (:keymaps 'reb-lisp-mode-map
        :states 'normal
        "gj" 'reb-next-match
        "gk" 'reb-prev-match
        [remap quit-window] 'reb-quit))
   #+END_SRC

** replace
   #+BEGIN_SRC emacs-lisp
     (use-package replace
       :defer t
       :config
       (dolist (func '(perform-replace
                       query-replace))
         (advice-add func :around
                     #'restore-default-display-buffer-actions)))
   #+END_SRC

** save-place
   Remembers the cursor position in open files... so when I reopen them I'm taken to that point
   immeadiately.

   #+BEGIN_SRC emacs-lisp
     (if (emacs>= "25.1")
         (save-place-mode +1)
       (require 'saveplace)
       (setq-default save-place t))

     (setq save-place-forget-unreadable-files nil
           save-place-version-control 'nospecial
           save-place-file (eval-when-compile
                             (let ((save-dir (var! "save-place")))
                               (unless (file-directory-p save-dir)
                                 (mkdir save-dir t))

                               (join-path save-dir "places.el")))

           save-place-ignore-files-regexp (rx
                                           (or "COMMIT_EDITMSG"
                                               "svn-commit"
                                               (and "hg-editor-" (one-or-more num))
                                               (and (or ".txt" ".tmp") eol)
                                               (and bol (or "/tmp/"))
                                               (and "bzr_log." (one-or-more num)))))
   #+END_SRC

** server
   #+BEGIN_SRC emacs-lisp
     (use-package server
       :demand t
       :custom
       (server-client-instructions nil)
       :config
       ;; see [[http://emacshorrors.com/posts/determining-if-the-server-is-started-or-the-wonders-of-server-running-p.html][emacs-horrors]] for why this is sometimes useless :(
       (when (windows-p)
         (or (server-running-p)
             (server-start)))

       (advice-add 'server-edit :before
                   (defun server-edit--auto-save-on-exit (&rest args)
                     "Automatically save file before server exit"
                     (save-buffer)))

       :lazy-leader
       (:mode 'server-edit-mode+
        :minor t
        :prefix leader-major-mode-prefix
        "," 'server-edit
        "q" 'server-abort))
   #+END_SRC

*** commands
    #+BEGIN_SRC emacs-lisp
      (use-package +server-commands
        :commands (find-client-buffer
                   server-abort
                   toggle-client-headers
                   toggle-client-headers-local
                   server-edit-mode+)
        :init
        (defvar server-edit-ignore-modes+
          '(with-editor-mode)
          "modes (minor or major) in which `server-edit-mode+' is disabled.")

        (add-hook 'server-switch-hook
                  (lambda ()
                    (when server-buffer-clients
                      (unless (or (apply #'derived-mode-p
                                         server-edit-ignore-modes+)
                                  (cl-some (lambda (mode)
                                             (and (boundp mode)
                                                  (eval mode)))
                                           server-edit-ignore-modes+))
                        (server-edit-mode+ +1)))))

        (add-hook 'server-done-hook
                  (lambda ()
                    (server-edit-mode+ -1)))

        :leader
        ("t1" 'toggle-client-headers
         "t2" 'toggle-client-headers-local
         "fes" 'find-client-buffer))
    #+END_SRC

    #+BEGIN_SRC emacs-lisp :tangle lisp/+server-commands.el
      (defun find-client-buffer ()
        (interactive)
        (switch-to-buffer
         (read-buffer "Client buffers: " nil t
                      (lambda (b)
                        (with-current-buffer (cdr b)
                          server-buffer-clients)))))

      ;; see [[https://superuser.com/questions/295156/how-to-set-the-exit-status-for-emacsclienti][here]].
      (defun server-abort (&optional prefix)
        "Sends error exit command to every client for the current buffer."
        (interactive "P")
        (if (not server-buffer-clients)
            (error "current buffer has no server clients")
          (dolist (proc server-buffer-clients)
            (server-send-string proc "-error die"))
          (unless prefix (kill-buffer))))

      ;; add ,, and ,q like bindings in server edit sessions, like org-edit-src-code
      (define-minor-mode server-edit-mode+
        "a dummy minor mode for files being edited by `server'.
      makes it easier to bind keys (& leaders :grinning: for them)."
        nil
        " ServerEdit"
        '(;; ([remap evil-write] . server-edit)
          ([remap evil-save-and-close] . server-edit)
          ([remap evil-quit-all-with-error-code] . server-abort)))

      (provide '+server-commands)
    #+END_SRC

** simple
   #+BEGIN_SRC emacs-lisp
     (use-package simple
       :leader
       ("i TAB"     "indent"
        "i TAB TAB" 'indent-region
        "i TAB RET" 'split-line
        "i TAB SPC" 'just-one-space
        "i TAB c"   'indent-to-column
        "i TAB r"   'indent-relative
        "i TAB 0"   'indent-relative-first-indent-point
        "i TAB ."   'hydra-indent/body
        "i TAB n"   'forward-to-indentation
        "i TAB p"   'back-to-indentation)

       :config
       (push 'messages-buffer-mode whitespace-exempt-modes)

       :general
       (:keymaps 'completion-list-mode-map
        :states  'motion
        "RET" 'choose-completion
        "C-j" 'choose-completion

        "q" nil
        "Q" 'delete-completion-window

        "j" 'next-completion
        "k" 'previous-completion
        "n" 'next-completion
        "p" 'previous-completion
        "N" 'previous-completion))
   #+END_SRC

** shell
   #+BEGIN_SRC emacs-lisp
     (evil-set-initial-state 'shell-mode 'emacs)
   #+END_SRC

** eshell
   :PROPERTIES:
   :header-args+: :tangle (package-yes! eshell)
   :END:

   #+BEGIN_SRC emacs-lisp
     (use-package esh-mode
       :straight (esh-mode :type built-in)
       :defer t
       :hook (
              ;;; doesn't persist on window change... boo!!!
              ;; (eshell-mode . (setq-local cursor-type 'bar))
              ;;; disable company-mode in eshell-mode
              (eshell-mode . (lambda () (company-mode -1))))
       :leader
       (":" 'eshell-command)

       :config
       (evil-set-initial-state 'eshell-mode 'emacs)

       ;; don't auto scroll to bottom after execution
       (remove-hook 'eshell-output-filter-functions
                    'eshell-postoutput-scroll-to-bottom)

       ;; clear shouldn't scroll back to bottom of the screen
       (advice-add 'eshell/clear :after #'recenter-top-bottom)

       (setq eshell-banner-message "") ;; no banner

       (defun eshell-backward-kill-word ()
         (interactive)
         (let ((bol
                (save-excursion
                  (eshell-bol)))
               (beginning-word-point
                (save-excursion
                  (backward-word)
                  (point))))
           (when (>= beginning-word-point bol)
             (call-interactively 'backward-kill-word))))

       (leader/set-keys-for-major-mode 'eshell-mode
         "o"   'eshell-show-output
         "O"   'eshell-mark-output
         "RET" 'eshell-queue-input

         "i"  "insert"
         "ib" 'eshell-insert-buffer-name
         "ip" 'eshell-insert-process
         "ie" 'eshell-insert-envvar

         "k"  "kill/signal"
         "kz" 'eshell-send-eof-to-process
         "kc" 'eshell-interrupt-process
         "kq" 'eshell-quit-process)

       (defun eshell-mode--setup-bindings ()
         (cond
          ((package! ivy)
           (general-define-key
            :keymaps 'eshell-mode-map
            "C-s"   'counsel-esh-history
            "M-SPC" 'counsel-esh-history)))

         (general-define-key
           :keymaps 'eshell-mode-map
           ;;; movement commands
           "C-e"   'end-of-line
           "M-l"   'recenter-top-bottom
           "C-h"   'backward-char
           "C-l"   'forward-char
           "C-M-h" 'backward-word
           "C-M-l" 'forward-word
           ;;; scroll commands
           "<S-down>" 'evil-scroll-down
           "<S-up>"   'evil-scroll-up
           ;; move to beginning of output
           ;; or return to end of cursor
           "M-a" 'eshell-show-output
           "M-e" 'eshell-show-maximum-output

           ;;; signals
           "C-c C-z" 'eshell-send-eof-to-process
           "C-c C-q" 'eshell-quit-process
           "M-c"     'eshell-interrupt-process
           "M-z"     'eshell-send-eof-to-process
           "M-q"     'eshell-quit-process

           "M-y"           'eshell-repeat-argument
           "C-d"           'eshell-kill-input
           "C-M-k"         'eshell-kill-input
           "M-d"           'eshell-kill-output
           "C-w"           'eshell-backward-kill-word
           "<C-backspace>" 'evil-delete-backward-word
           ;; copy entered input back into current line
           "<C-return>"    'eshell-copy-old-input

           "C-j"       'eshell-next-input
           "C-k"       'eshell-previous-input
           "M-j"       'eshell-next-prompt
           "M-k"       'eshell-previous-prompt
           ;; reverse the default affect of up and down
           "<up>"      'eshell-previous-input
           "<down>"    'eshell-next-input
           "<C-up>"    'eshell-previous-matching-input-from-input
           "<C-down>"  'eshell-next-matching-input-from-input
           "<S-left>"  'eshell-backward-argument
           "<S-right>" 'eshell-forward-argument
           "<M-left>"  'eshell-backward-argument
           "<M-right>" 'eshell-forward-argument))

       ;; needs to be in a hook because eshell-mode-map isn't
       ;; defined until the mode is activated, and even then
       ;; it's only buffer-local :(.
       (add-hook 'eshell-mode-hook #'eshell-mode--setup-bindings))
   #+END_SRC

*** eshell-prompt-extras
    #+BEGIN_SRC emacs-lisp
      (use-package eshell-prompt-extras
        :straight t
        :defer  t
        :after esh-mode
        :init
        (setq epe-show-python-info t
              epe-path-style 'full)

        (defvar eshell-prompt--enable-git-on-remote-files t
          "when true, show branch info even on remote files")

        (defun epe-git-p ()
          "If you installed git and in a git project."
          (when (or eshell-prompt--enable-git-on-remote-files
                    ;; either enable everywhere, including remote
                    ;; or enable when not remote
                    (not (epe-remote-p)))
            (and (eshell-search-path "git")
                 (vc-find-root (eshell/pwd) ".git"))))

        (setq eshell-prompt-function #'epe-theme-lambda))
    #+END_SRC

** smerge
   minor mode in buffers that have git merge issues; it highlights diff indicators
   and offers methods to quickly jump from them.

   #+BEGIN_SRC emacs-lisp
     (use-package smerge-mode
       :defer t
       :init
       (leader/set-keys
         "gi" 'smerge-mode)

       :lazy-leader
       (:mode 'smerge-mode
        :minor t
        :prefix "g"
        "j" 'smerge-next
        "k" 'smerge-prev
        "c" 'smerge-keep-current
        "m" 'smerge-keep-mine
        "o" 'smerge-keep-other)

       :general
       (:states '(normal motion)
        :keymaps 'smerge-mode-map
        "]g" 'smerge-next
        "[g" 'smerge-prev))
   #+END_SRC

** visual-line
   auto wrap long lines at the end of words.

   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package visual-line
       :straight (visual-line :type built-in)
       :defer t
       :delight " ‚ìÅ")
   #+END_SRC

** tabulated-list-mode
   #+BEGIN_SRC emacs-lisp
     (use-package tabulated-list
       :defer t
       :hook (tabulated-list-mode . hl-line-mode)
       :commands (tabulated-list-next-column)
       :config
       (evil-set-initial-state 'tabulated-list-mode 'motion)

       (defun tabulated-list--get-column-widths ()
         "return a list of all the "
         (mapcar (lambda (x) (+ (nth 1 x)
                                (or (plist-get (cdr x) :pad-right) 1)))
                 tabulated-list-format))

       (defun tabulated-list--get-column-pivots ()
         (let (prev values)
           (setq values (mapcar (lambda (x)
                                  (let ((new-val (+ x (or prev 0))))
                                    (setq prev new-val)
                                    new-val))
                                (tabulated-list--get-column-widths)))
           ;; (mapcar (lambda (x) (- x 1)) values)
           values))

       (defun tabulated-list--properties ()
         (let* ((current-column-position (- (point)
                                            (line-beginning-position)))
                (column-pivots (tabulated-list--get-column-pivots))
                (column-count (length column-pivots))
                (preceding-columns (seq-filter
                                    (lambda (x)
                                      (<= x current-column-position))
                                    column-pivots))
                (following-columns (nthcdr (length preceding-columns)
                                           column-pivots))
                (current-column (car following-columns))
                (following-columns (cdr following-columns)))
           `(:current-column-position ,current-column-position
                                      :column-pivots           ,column-pivots
                                      :column-count            ,column-count
                                      :preceding-cols          ,preceding-columns
                                      :current-column          ,current-column
                                      :following-cols          ,following-columns)))

       ;; doesn't work when row contains truncated entries, such as
       ;; buffers with a "name..." entry, because those dots aren't
       ;; included in the width of the column.
       (defun tabulated-list-next-column (&optional count)
         "moves to the next column shown by tabulated list mode"
         (interactive)
         (or count (setq count 1))

         (when tabulated-list-format
           (let* ((properties (tabulated-list--properties))
                  (line-step (floor (/ count
                                       (plist-get properties :column-count)))))
             ;; move however many lines it takes to reach row with desired column
             (unless (zerop line-step)
               (next-line line-step))

             (unless (eobp)
               (cond
                ((eq (point) (line-end-position))
                 ;; when at the end of the last column, goto next row
                 (next-line)
                 (goto-char (line-beginning-position)))
                ((not (plist-get properties :following-cols))
                 ;; no next column, goto end of current
                 (goto-char (line-end-position)))
                (t
                 ;; goto next column from the end of the current one
                 (goto-char (+ (line-beginning-position)
                               (plist-get properties :current-column)))))))))

       :general
       (:keymaps 'tabulated-list-mode-map
        "SPC" nil "ESC" nil "0" nil "<" nil ">" nil "?" nil
        "g" nil "h" nil "n" nil "p" nil "DEL" nil "S-SPC" nil))
   #+END_SRC

** tramp
   Transparent ReMote Access Protocol

   #+BEGIN_SRC emacs-lisp
     (use-package tramp
       :defer t
       :config
       ;; google cloud integration... curtesy of:
       ;;   https://qiita.com/tanatana/items/218b19808f2428b125fe
       ;; see [[https://cloud.google.com/sdk/docs/quickstart-windows][here]] for how to install gcloud CLI.
       (push
        '("gcssh"
          (tramp-login-program        "gcloud compute ssh")
          (tramp-login-args           (("%h")))
          (tramp-async-args           (("-q")))
          (tramp-remote-shell         "/bin/sh")
          (tramp-remote-shell-args    ("-c"))
          (tramp-gw-args              (("-o" "GlobalKnownHostsFile=/dev/null")
                                       ("-o" "UserKnownHostsFile=/dev/null")
                                       ("-o" "StrictHostKeyChecking=no")))
          (tramp-default-port         22))
        tramp-methods))
   #+END_SRC

** vc-mode
   #+BEGIN_SRC emacs-lisp
     (use-package vc
       :defer t
       ;; :commands (vc-annotate              ; history of current file
       ;;            vc-create-tag
       ;;            vc-delete-file
       ;;            vc-diff                  ; diff current file
       ;;            vc-dir                   ; status of directory
       ;;            vc-ediff                 ; ediff current file
       ;;            vc-ignore                ; prompt and exclude file
       ;;            vc-log-incoming          ; log for pull commits
       ;;            vc-log-outgoing          ; log for push commits
       ;;            vc-merge
       ;;            vc-next-action           ; makes a commit... annoyingly named
       ;;            vc-print-log             ; log of commits affecting current file
       ;;            vc-print-root-log        ; log of all commits in project
       ;;            vc-push
       ;;            vc-region-history        ; log of commits affecting region in file
       ;;            vc-register              ; add file
       ;;            vc-retrieve-tag
       ;;            vc-revert                ; undo changes to working files... permenently
       ;;            vc-revision-other-window ; view file in previous tag/commit
       ;;            vc-root-diff
       ;;            vc-switch-backend        ; not using git... for shame :P
       ;;            vc-update-change-log)
       :init
       ;; On Windows, we must use Git GUI to enter username and password. See [[https://github.com/magit/magit/wiki/FAQ#windows-cannot-push-via-https][here]].
       (when (windows-p)
         (setenv "GIT_ASKPASS" "git-gui--askpass"))

       (push 'vc-annotate-mode whitespace-exempt-modes)
       (push 'vc-git-log-view-mode whitespace-exempt-modes)

       :config
       (require 'vc-git) ;; supported

       (advice-add 'vc-region-history :after (lambda (&rest args)
                                               (when (evil-visual-state-p)
                                                 (evil-exit-visual-state))))

       (setq vc-ignore-dir-regexp
             (format "%s\\|%s"
                     vc-ignore-dir-regexp
                     tramp-file-name-regexp))

       (evil-set-initial-state 'vc-git-region-history-mode 'motion)
       (evil-set-initial-state 'vc-git-log-view-mode 'motion)
       (evil-set-initial-state 'vc-git-log-edit-mode 'insert)                        ; making commits... why name it log :P
       (evil-set-initial-state 'vc-dir-mode 'motion)                                 ; check status of files for an entire directory
       (evil-set-initial-state 'vc-annotate-mode 'motion)                            ; pops up a buffer showing the most recent changes for every line in the current file alongside the commit which made those changes.

       :leader
       (:prefix leader-diff-leader-prefix
        "v" 'vc-diff)
       (:prefix "g"
        "a" 'vc-annotate
        "r" 'vc-revision-other-window
        "=" 'vc-root-diff
        "v" 'vc-region-history
        "l" 'vc-print-log
        "L" 'vc-print-root-log
        "R" 'vc-rename-file
        "u" 'vc-revert
        "#" 'vc-create-tag
        "d" 'vc-dir)

       :lazy-leader
       (:mode 'vc-annotate-mode
        "m"     'vc-next-action
        "l"     'vc-annotate-show-log-revision-at-line
        "d"     'vc-annotate-show-diff-revision-at-line
        "D"     'vc-annotate-show-changeset-diff-revision-at-line
        "t"     'vc-annotate-toggle-annotation-visibility

        "g"     "goto"
        "gg"    'vc-annotate-goto-line
        "gc"    'vc-annotate-revision-at-line
        "gp"    'vc-annotate-revision-previous-to-line
        "gl"    'vc-annotate-show-log-revision-at-line
        "gG"    'vc-annotate-working-revision
        "g SPC" 'vc-annotate-working-revision)
       (:mode 'vc-dir-mode
        "i" 'vc-log-incoming
        "o" 'vc-log-incoming
        "l" 'vc-print-log
        "L" 'vc-print-root-log
        "D" 'vc-root-diff
        "d" 'vc-diff
        "h" 'vc-dir-hide-up-to-date
        "u" 'vc-update                                                               ; don't understand
        "m" 'vc-next-action)
       (:mode '(vc-git-region-history-mode vc-git-log-view-mode)
        "p" 'log-view-diff-changeset
        "a" 'log-view-annotate-version
        "m" 'log-view-toggle-mark-entry
        "s" 'diff-goto-source)
       (:mode 'vc-git-log-edit-mode
        "d" 'log-edit-show-diff
        "f" 'log-edit-show-files
        "?" 'log-edit-mode-help
        "SPC" 'log-edit-done
        "DEL" 'log-edit-kill-buffer

        "i"  "insert"
        "ic" 'log-edit-insert-changelog
        "if" 'log-edit-insert-filenames
        "iC" 'log-edit-insert-changelog-entries
        "iT" 'log-edit-insert-cvs-rcstemplate
        "it" 'log-edit-insert-cvs-template
        "iF" 'log-edit-insert-filenames-without-changelog
        "im" 'log-edit-insert-message-template

        "t"  "toggle"
        "ta" 'vc-git-log-edit-toggle-amend
        "ts" 'vc-git-log-edit-toggle-signoff)

       :general
       (:states  'normal
        :keymaps 'vc-git-log-edit-mode-map
        "C-q" 'log-edit-kill-buffer
        "M-s" 'log-edit-next-comment
        "M-r" 'log-edit-previous-comment
        "C-s" 'log-edit-comment-search-forward
        "C-r" 'log-edit-comment-search-backward
        "M-0" 'evil-beginning-of-line)
       (:states  'motion
        :keymaps 'vc-annotate-mode-map
        "gj" 'vc-annotate-prev-revision ;; older revisions
        "gk" 'vc-annotate-next-revision ;; newer revisions
        "C-t" 'vc-annotate-toggle-annotation-visibility
        "RET" 'vc-annotate-goto-line

        "d" 'vc-annotate-show-diff-revision-at-line
        "D" 'vc-annotate-show-changeset-diff-revision-at-line
        "t" 'vc-annotate-toggle-annotation-visibility)
       (:states  'motion
        :keymaps 'vc-dir-mode-map

        "a" 'vc-register ;; git add FILE
        "d" 'vc-diff
        "=" 'vc-diff
        "Q" 'vc-dir-kill-dir-status-process
        "i" 'vc-dir-ignore
        "x" 'vc-dir-kill-line

        ;; vc-dir-search
        "C-s" 'vc-dir-isearch-regexp
        "M-s" 'vc-dir-query-replace-regexp

        "A" 'vc-dir-mark-all-files
        "m" 'vc-dir-mark
        "U" 'vc-dir-unmark-all-files
        "u" 'vc-dir-unmark
        ;; "t" 'vc-dir-toggle-mark ;; mouse event
        "<backspace>" 'vc-dir-unmark-file-up

        "p" 'vc-pull
        "P" 'vc-push

        "o"   'vc-dir-display-file
        "RET" 'vc-dir-find-file

        "gj" 'vc-dir-next-line
        "gk" 'vc-dir-previous-line
        "M-j" 'vc-dir-next-directory
        "M-k" 'vc-dir-previous-directory)
       (:states  'motion
        :keymaps '(vc-git-region-history-mode-map vc-git-log-view-mode-map)

        "q" nil
        "d" 'log-view-diff
        "=" 'log-view-diff
        "o" 'log-view-find-revision ; open current file at current commit

        "<return>" 'log-view-toggle-entry-display
        "<tab>"    'log-view-toggle-entry-display

        ;; move to next message, then reallign to top
        ;; (kbd "C-j") (lambda! (log-view-msg-next)
        ;;               (call-interactively 'evil-scroll-line-to-top))
        "gj" 'log-view-msg-next
        "gk" 'log-view-msg-prev

        "M-j" 'log-view-file-next
        "M-k" 'log-view-file-prev

        "gl" 'diff-hunk-next
        ;; TODO reallign diff to propper location on move down without trapping on a single diff
        ;; (kbd "M-j") (lambda! (diff-hunk-next)
        ;;               (call-interactively 'evil-scroll-line-to-top)
        ;;               (evil-previous-line 3))
        "gh" (lambda! (diff-hunk-prev) (evil-previous-line 3))))
   #+END_SRC

** view-mode
   #+BEGIN_SRC emacs-lisp
     (use-package view
       :defer t
       :config
       :general
       (:keymaps 'view-mode-map
        :states  'normal
        [remap quit-window] 'View-quit
        "Q" 'View-quit-all
        "G" 'View-scroll-to-buffer-end
        "zq" 'View-exit
        "zk" 'View-kill-and-leave
        "gj" 'View-scroll-line-forward
        "gk" 'View-scroll-line-backward
        ;; "C-d" 'View-scroll-half-page-forward
        ;; "C-u" 'View-scroll-half-page-backward
        "M-d" 'View-scroll-page-forward
        "M-u" 'View-scroll-page-backward))
   #+END_SRC

** vline
   #+BEGIN_SRC emacs-lisp
     (use-package vline
       :straight (vline :host github :repo "emacsmirror/vline")
       :defer t
       :leader
       ("tv" 'vline-mode))
   #+END_SRC

** whitespace
   #+BEGIN_SRC emacs-lisp
     (use-package whitespace
       :defer t
       :delight
       (whitespace-mode " ‚ì¶")
       (global-whitespace-mode " ‚ì¶"))
   #+END_SRC

** winner
   undo changes to window configurations.

   #+BEGIN_SRC emacs-lisp
     (use-package winner
       :defer 10
       :config
       (winner-mode +1)

       :general
       (:keymaps 'emacs-window-map
        "<left>"  'winner-undo
        "<right>" 'winner-redo))
   #+END_SRC

** window
   Make the window seperator a [[https://www.reddit.com/r/emacs/comments/3u0d0u/how_do_i_make_the_vertical_window_divider_more/][straight-line]], like tmux.

   #+BEGIN_SRC emacs-lisp
     (add-hook 'window-configuration-change-hook
               (defun +change-window-divider ()
                 (when-let ((display-table (or buffer-display-table standard-display-table)))
                   (set-display-table-slot display-table 5 ?‚îÇ)
                   (set-window-display-table (selected-window) display-table))))
   #+END_SRC

** xref
   cross reference keywords across a number of different backends.

   #+BEGIN_SRC emacs-lisp
     (use-package xref
       :defer t
       :config
       (evil-set-initial-state 'xref--xref-buffer-mode 'motion)
       (remove-hook 'xref-after-jump-hook 'recenter)

       :leader
       ("jb" 'xref-pop-marker-stack
        "jr" 'xref-find-references
        "js" 'xref-find-apropos
        "jg" 'xref-find-definitions
        "jo" 'xref-find-definitions-other-window
        ;; "axw" 'xref-find-definitions-other-window
        ;; "axf" 'xref-find-definitions-other-frame
        )

       :lazy-leader
       (:mode 'xref--xref-buffer-mode
        "s" 'xref-query-replace-in-results)

       :general
       ;; erase global xref bindings
       ("M-."   nil                                                                  ; xref-find-definitions
        "M-,"   nil                                                                  ; xref-pop-marker-stack
        "M-?"   nil                                                                  ; xref-find-references
        "C-M-." nil                                                                  ; xref-find-apropos
        )
       (:states 'motion
        "[x" 'xref-pop-marker-stack)
       (:keymaps 'xref--xref-buffer-mode-map
        :states 'motion
        "j" 'xref-next-line
        "k" 'xref-prev-line
        "RET" 'xref-goto-xref
        "M-RET" 'xref-show-location-at-point
        "TAB" 'xref-quit-and-goto-xref))
   #+END_SRC

** xwin
    #+BEGIN_SRC emacs-lisp
      (use-package x-win
        :defer t
        :config
        (advice-add 'emacs-session-filename :override
                    (defun emacs-session-filename+ (session-id)
                      (concat (var! "x-sessions/session.") session-id))))
    #+END_SRC

* Extensions
  Optional [[*Packages][packages]] that users can opt to configure from the ~+packages~ variable.

** selectrum
   :PROPERTIES:
   :header-args: :tangle (package-yes! selectrum)
   :END:

*** selectrum
    #+BEGIN_SRC emacs-lisp
      (use-package selectrum
        :straight t
        :defer  t
        :hook (after-init . selectrum-mode)
        :commands (selectrum-preprocess+
                   selectrum-highlight+)
        :custom
        (selectrum-num-candidates-displayed 15)
        (selectrum-count-style 'current/matches)
        :config
      ;;; Sorting configuration and workarounds
        (defun selectrum-sort-cands+ (cands)
          (cond
           ;; Finding file-names should sort directories first.
           ((eq minibuffer-completion-table 'read-file-name-internal)
              ;; Only sort based on filename, with directories being first :-)
              (sort cands
                    (lambda (x y)
                      (let ((x-dir (eq (aref x (- (length x) 1)) ?/))
                            (y-dir (eq (aref y (- (length y) 1)) ?/)))
                        (cond
                         ((and x-dir y-dir)
                         (string< (directory-file-name x) (directory-file-name y)))
                         (x-dir t)
                         (y-dir nil)
                         (t (string< x y)))))))))

        (defun selectrum-preprocess+ (cands)
          (when selectrum-should-sort-p
            (setq cands
                  (or (selectrum-sort-cands+ cands)
                      (when (bound-and-true-p selectrum-prescient-mode)
                        (selectrum-prescient--preprocess cands))
                      (selectrum-default-candidate-preprocess-function cands)
                      cands)))
          cands)

      ;;; Update highlighting for certain completions
        (defun selectrum-highlight-candidates+ (input cands)
          (if (eq 'file (completion-metadata-get
                         (completion-metadata
                          input
                          minibuffer-completion-table
                          minibuffer-completion-predicate)
                         'category))
              (cl-loop for cand in cands
                       for len = (length cand)
                       if (and (> len 0)
                               (eq (aref cand (1- len)) ?/))
                       collect (selectrum--add-face cand 'dired-directory)
                       else
                       collect cand)
            cands))

        (defun selectrum-highlight+ (input cands)
          (cl-reduce (lambda (cands func)
                       (funcall func input cands))
                     (delq nil (list #'selectrum-highlight-candidates+
                                     (cond ((eq (bound-and-true-p selectrum-refine-candidates-function)
                                                #'orderless-filter)
                                            #'orderless-highlight-matches)
                                           ((bound-and-true-p selectrum-prescient-mode)
                                            #'selectrum-prescient--highlight)
                                           (t #'selectrum-candidates-identity))))
                     :initial-value cands))

        (defun selectrum-override-current-candidate-face-face-range+ (str overriding-faces)
          (cl-loop for i from 0 to (length str)
                   with last-face = nil
                   with current-face = nil
                   do (setq current-face
                            (when-let ((face (get-text-property i 'face str)))
                              (if (listp face) (car face) face)))
                   with seq-range = nil
                   when (and current-face (member current-face overriding-faces))
                     when seq-range
                       when (eq current-face last-face)
                         ;; Incremenet existing sequence
                         do (setcdr seq-range i)
                       else
                         ;; Finished previous sequence and started a new one
                         collect (cons last-face seq-range)
                         and do (setq seq-range (cons i i))
                       end
                     else
                       do (setq seq-range (cons i i))
                     end
                   else when seq-range
                     collect (cons last-face seq-range)
                     and do (setq seq-range nil)
                   end
                   do (setq last-face current-face)))

        (advice-add 'selectrum--add-face :before-until
                    (defun selectrum-override-current-candidate-face+ (str face)
                      "Use `selectrum-current-candidate' but keep match highlighting.
      This is a workaround until [[https://github.com/raxod502/selectrum/issues/353][#353]] gets resolved."
                      (when (and (eq face 'selectrum-current-candidate)
                                 (not (eq selectrum--last-command #'describe-face)))
                        (setq copied (copy-sequence str))
                        (if (version< emacs-version "27")
                            (font-lock-prepend-text-property 0 end 'face face copied)
                          (add-face-text-property 0 (length copied) face nil copied))

                        (dolist (seq (selectrum-override-current-candidate-face-face-range+
                                      str '(orderless-match-face-0
                                            orderless-match-face-1
                                            orderless-match-face-2
                                            orderless-match-face-3)))
                          (cl-destructuring-bind (face . (start . end))
                              seq
                            (if (version< emacs-version "27")
                                (font-lock-prepend-text-property start end 'face face copied)
                              (add-face-text-property start (1+ end) face nil copied))))
                        copied)))

        (defun selectrum-update-regexp-search-ring+ (&rest _args)
          "Update search rings based on the last `selectrum-read' command.
      This works for isearch and evil and can automatically detect and compile
      regexp when an external package (eg. orderless) is used."
          (when-let ((regexp (cond ((eq selectrum-refine-candidates-function
                                        'orderless-filter)
                                    (eval
                                     `(rx (or ,@(cl-loop for regexp in (funcall orderless-pattern-compiler
                                                                                selectrum--previous-input-string)
                                                         collect `(regexp ,regexp))))))
                                   (t selectrum--previous-input-string))))
            (push regexp regexp-search-ring)
            (when (boundp 'evil-ex-search-pattern)
              (setq evil-ex-search-pattern (list regexp t t))
              (evil-ex-search-activate-highlight (list regexp t t)))))

        :leader
        ("RET" 'selectrum-repeat)

        :general
        (:keymaps 'selectrum-minibuffer-map
         "C-j" 'next-line
         "C-k" 'previous-line
         "C-h" 'backward-char
         "C-l" (defun selectrum-forward-char-or-exit+ ()
                 (interactive)
                 (call-interactively (if (eolp)
                                         'selectrum-select-current-candidate
                                       'forward-char)))
         "M-j" 'next-history-element
         "M-k" 'previous-history-element
         "C-r" 'next-matching-history-element
         "C-s" 'previous-matching-history-element
         [C-i] 'selectrum-insert-current-candidate
         "C-i" 'selectrum-insert-current-candidate
         "C-o" 'end-of-buffer
         "M-o" 'beginning-of-buffer
         "C-d" 'scroll-up-command
         "C-u" 'scroll-down-command
         "M-i" 'selectrum-insert-current-candidate
         "<S-return>" 'selectrum-submit-exact-input))
    #+END_SRC

*** selectrum-prescient
    #+BEGIN_SRC emacs-lisp :tangle (package-yes! selectrum prescient)
      (use-package selectrum-prescient
        :after prescient
        :straight t
        :defer  t
        :hook ((selectrum-mode . selectrum-prescient-mode))
        :init
        (add-hook 'selectrum-prescient-mode-hook
                  (lambda ()
                    ;; override highlight functions
                    (setq selectrum-preprocess-candidates-function #'selectrum-preprocess+
                          selectrum-highlight-candidates-function #'selectrum-highlight+))))
    #+END_SRC

*** selectrum-orderless
    :PROPERTIES:
    :header-args+: :tangle (package-yes! selectrum orderless)
    :END:

    #+BEGIN_SRC emacs-lisp
      (defun selectrum-setup-orderless+ ()
        (setq selectrum-refine-candidates-function #'orderless-filter
              selectrum-highlight-candidates-function #'selectrum-highlight+))

      (defun selectrum-teardown-orderless+ ()
        (warn "ivy-teardown-orderless: Not yet implemented"))
    #+END_SRC

    #+BEGIN_SRC emacs-lisp
      (if (package! prescient)
          (add-hook 'selectrum-prescient-mode-hook
                    (defun selectrum-prescient-setup-orderless+ ()
                      (cond ((bound-and-true-p selectrum-prescient-mode)
                             (selectrum-setup-orderless+))
                            (+orderless-requires-prescient
                             (selectrum-teardown-orderless+)))))
        (add-hook 'selectrum-mode-hook #'selectrum-setup-orderless+))
    #+END_SRC


*** marginalia
    #+BEGIN_SRC emacs-lisp
      (use-package marginalia
        :straight t
        :defer  t
        :hook (selectrum-mode . marginalia-mode)
        :general
        (:keymaps 'embark-general-map
         "A" 'marginalia-cycle)

        :config
        (advice-add #'marginalia-cycle :after
                    (lambda ()
                      (when (bound-and-true-p selectrum-mode)
                        (selectrum-exhibit)))))
    #+END_SRC

*** embark
    #+BEGIN_SRC emacs-lisp
      (use-package embark
        :straight t
        :defer  t
        :config
        (setq embark-action-indicator
              (lambda (map)
                (which-key--show-keymap "Embark" map nil nil 'no-paging)
                #'which-key--hide-popup-ignore-command)
              embark-become-indicator embark-action-indicator)

        (push 'embark-collect-mode whitespace-exempt-modes)

        (advice-add 'embark-export           :around #'restore-default-display-buffer-actions)
        (advice-add 'embark-collect-live     :around #'restore-default-display-buffer-actions)
        (advice-add 'embark-collect-snapshot :around #'restore-default-display-buffer-actions)

        :general
        (:keymaps 'selectrum-minibuffer-map
         "<C-return>" 'embark-act
         "M-RET" 'embark-act-noexit
         "C-c C-o" 'embark-collect-snapshot
         "C-c M-o" 'embark-collect-live
         "C-c C-e" 'embark-export)
        (:keymaps 'embark-collect-mode-map
         :states 'motion
         "a" 'embark-act
         "<" 'tabulated-list-narrow-current-column
         ">" 'tabulated-list-widen-current-column
         "gj" 'forward-button
         "gk" 'backward-button
         "<C-return>" 'embark-act)
        (:keymaps 'embark-general-map
         "w" nil
         "y" 'embark-save)
        (:keymaps 'embark-file-map
         "=" 'vdiff-files
         "W" nil
         "Y" 'embark-save-relative-path)

        :lazy-leader
        (:mode 'embark-collect-mode
         "," 'embark-act
         "s" 'embark-collect-direct-action-minor-mode
         "l" 'embark-collect-toggle-view                                             ; list -> grid -> list
         "a" 'embark-collect-direct-action-minor-mode
         "e" 'embark-export
         "z" 'embark-occur-zebra-minor-mode
         "n" 'tabulated-list-narrow-current-column
         "w" 'tabulated-list-widen-current-column))

      (use-package embark-consult
        :straight t
        :defer  t
        :after  (embark consult)
        :hook (embark-collect-mode . embark-consult-preview-minor-mode))
    #+END_SRC

*** consult
    #+BEGIN_SRC emacs-lisp
      (defvar consult-manual-preview-key (kbd "M-SPC")
        "Manual key to trigger `consult--read' previews.")

      (use-package consult
        :straight t
        :defer  t
        :commands (consult-ripgrep-no-project+
                   consult-grep-no-project+)
        :custom
        (consult-project-root-function #'projectile-project-root)
        (consult-async-default-split "/")
        (consult-fontify-max-size 100000)
        (register-preview-function #'consult-register-preview)
        (consult-ripgrep-command                                                      ; Variant command which disregards no-matches
         "ignore-exit 1 rg --null --line-buffered --color=always --max-columns=500 --smart-case --no-heading --line-number . -e OPTS ARG")
        (consult-async-refresh-delay 0.05)
        (consult-config
         `((consult-ripgrep :preview-key ,consult-manual-preview-key)
           (org-roam-rg :preview-key ,consult-manual-preview-key)
           (consult-ripgrep-no-project+ :preview-key ,consult-manual-preview-key)
           (consult-grep-no-project+ :preview-key ,consult-manual-preview-key)
           (consult-flyspell :sort nil)
           (consult-find :initial ,(concat consult-async-default-split "*" consult-async-default-split))))
        (consult-imenu-config
         '((emacs-lisp-mode :toplevel "Functions"
                            :types ((?f "Functions" font-lock-function-name-face)
                                    (?m "Macros"    font-lock-function-name-face)
                                    (?p "Packages"  font-lock-constant-face)
                                    (?t "Types"     font-lock-type-face)
                                    (?v "Variables" font-lock-variable-name-face)))
           (c++-mode :types ((?c "Constructor" font-lock-function-name-face)
                             (?m "Method" font-lock-function-name-face)
                             (?v "Variable" font-lock-variable-name-face)
                             (?f "Function" font-lock-function-name-face)))
           (python-mode :types ((?n "Field" font-lock-variable-name-face)
                                (?c "Class" font-lock-type-face)
                                (?m "Method" font-lock-function-name-face)
                                (?i "Module" font-lock-preprocessor-face)
                                (?f "Function" font-lock-function-name-face)
                                (?v "Variable" font-lock-variable-name-face)))))
        :init
        ;; (with-no-warnings
        ;;   (defvaralias 'consult-line-history 'regexp-search-ring))

        :config
        (advice-add 'consult-line :after #'selectrum-update-regexp-search-ring+)

        (evil-set-command-property 'consult-outline :jump t)
        (evil-set-command-property 'consult-mark :jump t)
        (evil-set-command-property 'consult-line :jump t)
        (evil-set-command-property 'consult-line-symbol-at-point :jump t)
        (evil-set-command-property 'consult-line-from-isearch :jump t)

        (defvar consult-font-lock-exclude+
          '(Man-mode
            adoc-mode
            bbdb-mode
            bongo-library-mode
            bongo-mode
            bongo-playlist-mode
            bookmark-bmenu-mode
            circe-channel-mode
            circe-query-mode
            circe-server-mode
            deadgrep-mode
            debbugs-gnu-mode
            dired-mode
            elfeed-search-mode
            elfeed-show-mode
            emms-playlist-mode
            emms-stream-mode
            erc-mode
            eshell-mode
            eww-mode
            forth-block-mode
            forth-mode
            fundamental-mode
            gnus-article-mode
            gnus-group-mode
            gnus-summary-mode
            help-mode
            helpful-mode
            jabber-chat-mode
            magit-popup-mode
            matrix-client-mode
            matrix-client-room-list-mode
            mu4e-headers-mode
            mu4e-view-mode
            nix-mode
            notmuch-search-mode
            notmuch-tree-mode
            occur-edit-mode
            occur-mode
            org-agenda-mode
            package-menu-mode
            rcirc-mode
            sauron-mode
            sieve-mode
            treemacs-mode
            twittering-mode
            vc-dir-mode
            w3m-mode
            woman-mode
            xref--xref-buffer-mode)
          "The equivalent of `swiper-font-lock-exclude'")

        (advice-add 'consult--line-candidates :around
                    (defun consult--line-candidate-setup (func &rest args)
                      (let ((inhibit-field-text-motion t))
                        (apply func args))))

        (advice-add #'consult--fontify-all :around
                    (defun consult--fontify-prevent-p+ (func &rest args)
                      "The equivalent of `swiper-font-lock-ensure-p'."
                      (unless (or (derived-mode-p 'magit-mode)
                                  (bound-and-true-p magit-blame-mode)
                                  (memq major-mode consult-font-lock-exclude+)
                                  (not (derived-mode-p 'prog-mode)))
                        (apply func args))))

        (defmacro with-consult-ignore-project+ (func)
          `(defun ,(intern (concat (symbol-name func) "-no-project+")) ()
             ,(format "Variant of `%s' which skips project checks." func)
             (interactive)
             (let ((consult-project-root-function nil))
               (funcall-interactively (quote ,func)))))

        (with-consult-ignore-project+ consult-ripgrep)
        (with-consult-ignore-project+ consult-grep)

        :leader
        ("ji" 'consult-imenu
         "ju" 'consult-outline
         "hx" 'consult-complex-command
         "ax" 'consult-mode-command
         "rr" 'consult-register
         "rm" 'consult-mark
         "fr" 'consult-recent-file
         "eg" 'consult-error
         "sr" 'consult-ripgrep-no-project+
         "sb" 'consult-grep-no-project+
         "sv" 'consult-git-grep
         "fsf" 'consult-find
         "kg" 'consult-kmacro
         "ry" 'consult-yank
         "aa" 'consult-mode-command

         "ps" "search"
         "psr" 'consult-ripgrep
         "psv" 'consult-git-grep
         "psg" 'consult-grep
         "psi" 'consult-project-imenu)
        (:mode 'org-mode
         "g" 'consult-outline)
        (:minor t :mode 'flymake-mode  "eg" 'consult-flymake)

        :general
        (:keymaps 'selectrum-minibuffer-map
         "C-." 'hydra-selectrum/body)
        ([remap switch-to-buffer] 'consult-buffer
         [remap multi-occur] 'consult-multi-occur
         [remap apropros-command] 'consult-apropos
         [remap goto-line] 'consult-goto-line
         [remap isearch-forward] 'consult-line
         [remap keep-lines] 'consult-keep-lines
         [remap load-theme] 'consult-theme
         [remap flush-lines] 'consult-flush-lines
         [remap man] 'consult-man
         [remap woman] 'consult-man
         "C-M-y" 'consult-yank-pop
         "C-s" 'consult-line))
    #+END_SRC

*** consult-flycheck
    #+BEGIN_SRC emacs-lisp
      (use-package consult-flycheck
        :straight t
        :defer  t
        :leader
        (:minor t :mode 'flycheck-mode "eg" 'consult-flycheck))
    #+END_SRC

*** consult-extensions
    :PROPERTIES:
    :header-args+: :tangle (package-str! "lisp/+consult-custom.el" selectrum)
    :END:

    #+BEGIN_SRC emacs-lisp :tangle (package-str! "init.el" selectrum)
      (dolist (cmd '(consult-evil-jumps+
                     consult-evil-marks+
                     consult-unicode-char+
                     consult-xref-show-xrefs+
                     consult-xref-show-defs+
                     consult-org-capture+
                     consult-yasnippet
                     consult-bibtex+
                     consult-compilation-errors+))
        (autoload cmd "+consult-custom.el" nil t))

      (setq org-roam-capture-function 'consult-org-capture+)

      (when (emacs>= "27")
        (setq xref-show-definitions-function #'consult-xref-show-defs+))
      (setq xref-show-xrefs-function #'consult-xref-show-defs+)

      (leader/set-keys
        "ee" 'consult-compilation-errors+
        "rj" 'consult-evil-jumps+
        "rn" 'consult-evil-marks+
        "ob" 'consult-bibtex+)

      (leader/set-keys-for-major-mode 'org-mode
        "[" 'consult-bibtex+)

      (general-define-key
       :states '(insert normal)
       "C-M-i" 'consult-yasnippet)

      (general-define-key
       [remap org-capture] 'consult-org-capture+
       [remap insert-char] 'consult-unicode-char+)
    #+END_SRC

    #+BEGIN_SRC emacs-lisp
      (require 'consult)
      (require 'embark)
      (require 'marginalia)
    #+END_SRC

**** consult-compilation-errors
     Taken from [[https://github.com/abo-abo/swiper/blob/25439e26a67b54d1f8aab1cbc727228427692ec8/counsel.el#L6868][counsel.el]].

     #+BEGIN_SRC emacs-lisp
       (defun consult--compilation-errors-candidates+ ()
         (cl-loop for buf in (buffer-list)
                  when (compilation-buffer-p buf)
                    nconc (with-current-buffer buf
                            (consult--error-candidates))))

       (defvar consult--compilation-errors-history+ nil)
       (defun consult-compilation-errors+ ()
         "Copy paste of `consult-error' but not restricted to current buffer."
         (interactive)
         (consult--jump
          (consult--read
           (consult--with-increased-gc
            (consult--compilation-errors-candidates+))
           :prompt "Go to error: "
           :category 'consult-error
           :sort nil
           :require-match t
           :lookup #'consult--lookup-cadr
           :narrow `(,(lambda (cand) (= (caddr cand) consult--narrow))
                     (?e . "Error")
                     (?w . "Warning")
                     (?i . "Info"))
           :history '(:input consult--error-history)
           :preview
           (consult--preview-position 'consult-preview-error))))
     #+END_SRC

**** consult-unicode
     Taken from [[https://github.com/abo-abo/swiper/blob/25439e26a67b54d1f8aab1cbc727228427692ec8/counsel.el#L5319][counsel.el]].

     #+BEGIN_SRC emacs-lisp
       (defun consult--unicode-names+ ()
         "Return formatted and sorted list of `ucs-names'.
       The result of `ucs-names' is mostly, but not completely, sorted,
       so this function ensures lexicographic order."
         (let* (cands
                (table (ucs-names))            ; Either hash map or alist
                (fmt (lambda (name code)       ; Common format function
                       (let ((cand (format "%06X %-58s %c" code name code)))
                         (put-text-property 0 1 'code code cand)
                         (push cand cands)))))
           (if (not (hash-table-p table))
               ;; Support `ucs-names' returning an alist in Emacs < 26.
               ;; The result of `ucs-names' comes pre-reversed so no need to repeat.
               (dolist (entry table)
                 (funcall fmt (car entry) (cdr entry)))
             (maphash fmt table)
             ;; Reverse to speed up sorting
             (setq cands (nreverse cands)))
           (sort cands #'string-lessp)))

       (defvar consult--unicode-table+
         (lazy-completion-table consult--unicode-table+ consult--unicode-names+)
         "See `counsel--unicode-table'")

       (defvar consult-unicode-char-history+ nil)
       (defun consult-unicode-char+ (&optional count)
         (interactive "p")
         (let ((completions-detailed nil))
           (when-let* ((char (completing-read "Unicode name: " consult--unicode-table+
                                              nil nil nil 'consult-unicode-char-history+)))
             (insert-char (get-text-property 0 'code char) count))))
     #+END_SRC

**** consult-evil-jumps
     Adapted from [[*counsel-evil-jumps][counsel-evil-jumps]].

     #+BEGIN_SRC emacs-lisp
       (defvar consult--evil-jumps-history+ nil)

       (defun consult--evil-jumps-get+ ()
         (cl-remove-duplicates
          (evil--jumps-savehist-sync)
          :test (lambda (a b)
                  (and
                   (equal (car a) (car b))
                   (string-equal (car (cdr a))
                                 (car (cdr b)))))))

       (cl-defun consult--evil-jumps-format+ (open (point file))
         (with-current-buffer (funcall open file)
           (save-restriction
             (save-excursion
               (widen)
               (ignore-errors
                 (goto-char point))
               (let* ((marker (point-marker))
                      (line (line-number-at-pos point consult-line-numbers-widen))
                      (begin (line-beginning-position))
                      (end (line-end-position)))
                 (concat
                  (propertize
                   (consult--encode-location marker)
                   'invisible t
                   'consult-location (cons marker line))
                  (consult--region-with-cursor begin end marker)))))))

       (defun consult-evil-jumps+ ()
         (interactive)
         (consult--with-file-preview (open)
           (consult--jump
            (consult--read
             (consult--with-increased-gc
              (mapcar (apply-partially #'consult--evil-jumps-format+ open)
                      (consult--evil-jumps-get+)))
             :prompt "Evil jump: "
             :lookup #'consult--lookup-location
             :preview (consult--preview-position)
             :require-match t
             :category 'consult-location
             :history '(:input consult--evil-jumps-history+)))))
     #+END_SRC

**** consult-evil-marks
     Taken from [[https://github.com/abo-abo/swiper/blob/25439e26a67b54d1f8aab1cbc727228427692ec8/counsel.el#L4198][counsel.el]].

     #+BEGIN_SRC emacs-lisp
       (defsubst consult--evil-marks-candidates+ ()
         "Convert all evil-marks in the current buffer to mark candidates.
       A mark is a register which points to a location in the current buffer.

       NOTE: evil doesn't provide a standalone method to access the list of
       marks in the current buffer, as it does with registers.
       "
         (when (fboundp 'evil-register-list)
           (let* ((markers
                   (append
                    (cl-remove-if (lambda (m)
                                    (or (evil-global-marker-p (car m))
                                        (not (markerp (cdr m)))))
                                  evil-markers-alist)
                    (cl-remove-if (lambda (m)
                                    (or (not (evil-global-marker-p (car m)))
                                        (not (markerp (cdr m)))))
                                  (default-value 'evil-markers-alist)))))
             (cl-loop for reg in markers
                      collect (cons (consult--register-format reg) (cdr reg))))))

       (defun consult-evil-marks+ (&optional marker bol)
         (interactive
          (list
           (if-let ((marks (consult--with-increased-gc (consult--evil-marks-candidates+))))
               (consult--read
                marks
                :prompt "Evil mark: "
                :category 'consult-location
                :sort nil
                :require-match t
                :lookup #'consult--lookup-cdr
                :history t ;; disable history
                :add-history (thing-at-point 'symbol)
                :preview (consult--preview-position))
             (user-error "No evil-marks active in the current buffer"))
           (when current-prefix-arg
             (prefix-numeric-value current-prefix-arg))))
         (goto-char marker)
         (when bol
           (goto-char (line-beginning-position))))
     #+END_SRC

**** consult-org-capture
     Copied from [[https://github.com/abo-abo/swiper/blob/25439e26a67b54d1f8aab1cbc727228427692ec8/counsel.el#L3871][counsel.el]].

     #+BEGIN_SRC emacs-lisp
       (defun consult-org-capture-candidates+ ()
         "Taken from `counsel-org-capture'."
         (cl-loop
          with prefixes = nil
          for x in (or (org-contextualize-keys
                        (org-capture-upgrade-templates org-capture-templates)
                        org-capture-templates-contexts)
                       '(("t" "Task" entry (file+headline "" "Tasks")
                          "* TODO %?\n  %u\n  %a")))
          nconc (let ((x-keys (car x)))
                  ;; Remove prefixed keys until we get one that matches the current item.
                  (while (and prefixes
                              (let ((p1-keys (caar prefixes)))
                                (or
                                 (<= (length x-keys) (length p1-keys))
                                 (not (string-prefix-p p1-keys x-keys)))))
                    (pop prefixes))
                  (if (> (length x) 2)
                      (let ((desc (mapconcat #'cadr (reverse (cons x prefixes)) " | ")))
                        (list (cons (format "%-5s %s" x-keys desc) x-keys)))
                    (push x prefixes)
                    nil))))

       (defvar consult-org-capture-history+ nil)
       (defun consult--org-capture+ ()
         "Backend implementation for `consult-org-capture'."
         (consult--read (consult--with-increased-gc
                         (consult-org-capture-candidates+))
                        :prompt "Capture template: "
                        :lookup #'consult--lookup-cdr
                        :category 'org-capture
                        :require-match t
                        :sort nil
                        :history 'consult-org-capture-history+))

       (defun consult-org-capture+ (key)
         "Capture something."
         (interactive
          (list (consult--org-capture+)))
         (org-capture nil key))

       (defun consult-org-capture-goto-target+ (key)
         (interactive
          (list (consult--org-capture+)))
         (org-capture-goto-target key))

       (defun consult-org-capture-insert-template+ (key)
         (interactive
          (list (consult--org-capture+)))
         (org-capture (point) key))
     #+END_SRC

     #+BEGIN_SRC emacs-lisp
       (embark-define-keymap embark-org-capture-completion-actions+
         "Embark bindings for org-capture completion candidates."
         ("t" consult-org-capture-goto-target+)
         ("l" org-capture-goto-last-stored+)
         ("i" consult-org-capture-insert-template+))

       (add-to-list 'embark-keymap-alist '(org-capture . embark-org-capture-completion-actions+))
     #+END_SRC

**** consult-xref
     Copy paste of [[https://github.com/alexmurray/ivy-xref][ivy-xref]].

     #+BEGIN_SRC emacs-lisp
       (defun consult-xref--cands+ (xrefs)
         "Transform XREFS into a collection for display via `consult--read'.
       Taken from `ivy-xref-make-collection'."
         (let ((collection nil))
           (dolist (xref xrefs)
             (with-slots (summary location) xref
               (let ((line (xref-location-line location)))
                 (push (cons (concat
                              (propertize
                               (concat
                                (file-name-nondirectory (xref-location-group location))
                                (if (integerp line)
                                    (format ":%d: " line)
                                  ": "))
                               'face 'compilation-info)
                              summary)
                             location)
                       collection))))
           (nreverse collection)))

       (defun consult-xref-show-xrefs-lookup+ (input cands cand)
         "Convert a candidate from `consult-xref--cands+' into a xref location marker."
         (xref-location-marker (consult--lookup-cdr input cands cand)))

       (defun consult-xref-show-xrefs-goto-xref+ (buffer marker)
         "Jump to an xref MARKER with current buffer BUFFER.
       Taken from `ivy-xref-show-xrefs'."
         (condition-case err
             (let* ((buf (marker-buffer marker)))
               (with-current-buffer buffer
                 (select-window
                  ;; function signature changed in
                  ;; 2a973edeacefcabb9fd8024188b7e167f0f9a9b6
                  (if (version< emacs-version "26.0.90")
                      (xref--show-pos-in-buf marker buf t)
                    (xref--show-pos-in-buf marker buf)))))
           (user-error (message (error-message-string err)))))

       (defun consult-xref-show-xrefs+ (fetcher alist)
         "Adapted from `ivy-xref-show-xrefs'."
         (let* ((xrefs (if (functionp fetcher)
                           ;; Emacs 27
                           (or (assoc-default 'fetched-xrefs alist)
                               (funcall fetcher))
                         fetcher))
                (buffer (xref--show-xref-buffer fetcher alist))
                (cands (consult-xref--cands+ xrefs)))
           (quit-window) ;; hide xrefs buffer immeadiately
           (consult-xref-show-xrefs-goto-xref+
            buffer
            (consult--read
             cands
             :prompt "xref: "
             :category 'xref-location
             :lookup #'consult-xref-show-xrefs-lookup+
             :require-match t
             :default (car cands)))
           buffer))

       (defun consult-xref-show-defs+ (fetcher alist)
         "Variant of `ivy-xref-show-defs' which jumps to first ref when only one ref.
       Taken from `ivy-xref-show-defs'."
         (let ((xrefs (funcall fetcher)))
           (cond
            ((not (cdr xrefs))
             (xref-pop-to-location (car xrefs)
                                   (assoc-default 'display-action alist)))
            (t
             (consult-xref-show-xrefs+ fetcher
                                       (cons (cons 'fetched-xrefs xrefs)
                                             alist))))))
     #+END_SRC

**** consult-bibtex
     A native emacs variant for [[*ivy-bibtex][ivy-bibtex]].

     #+BEGIN_SRC emacs-lisp
       (require 'bibtex-completion)

       (defvar consult-bibtex-history+ nil
         "History for `consult-bibtex+'.")

       (defvar consult-bibtex-default-action+ 'consult-bibtex-insert-pdftools-link
         "The default action for the `consult-bibtex+` command.")

       (defun consult-bibtex-read-entry+ (&optional arg local-bib)
         (when arg
           (bibtex-completion-clear-cache))
         (bibtex-completion-init)
         (let* ((candidates (cl-loop
                             for cand in (bibtex-completion-candidates)
                             collect (cons
                                      (bibtex-completion-format-entry (cdr cand) (1- (frame-width)))
                                      (bibtex-completion-get-value "=key=" cand))))
                (preselect
                 (when-let ((key (bibtex-completion-key-at-point)))
                   (cl-find-if (lambda (cand)
                                 (string-equal key (cdr cand)))
                               candidates))))
           (alist-get
            (consult--read candidates
                           :prompt (format "BibTeX entries%s: " (if local-bib " (local)" ""))
                           :category 'bibtex-completion
                           :default preselect
                           :history '(:input consult-bibtex-history+))
            candidates nil nil #'string-equal)))

       (defun consult-bibtex+ (&optional arg local-bib)
         (interactive "P")
         (when-let ((entry (consult-bibtex-read-entry+ arg local-bib)))
           (if consult-bibtex-default-action+
               (funcall-interactively consult-bibtex-default-action+ entry)
             (warn "`consult-bibtex-default-action+' is unassigned."))))
     #+END_SRC

     #+BEGIN_SRC emacs-lisp
       (defmacro consult-bibtex-embark-action (name action)
         `(defun ,name (key)
            ,(format "Consult wrapper for `%s'." name)
            (interactive (list (consult-bibtex-read-entry+)))
            (if key
                (,action (list key))
              (warn "Failed to extract bibtex key from candidate: %s" key))))

       (consult-bibtex-embark-action consult-bibtex-open-any           bibtex-completion-open-any)
       (consult-bibtex-embark-action consult-bibtex-open-pdf           bibtex-completion-open-pdf)
       (consult-bibtex-embark-action consult-bibtex-open-url-or-doi    bibtex-completion-open-url-or-doi)
       (consult-bibtex-embark-action consult-bibtex-insert-citation    bibtex-completion-insert-citation)
       (consult-bibtex-embark-action consult-bibtex-insert-reference   bibtex-completion-insert-reference)
       (consult-bibtex-embark-action consult-bibtex-insert-key         bibtex-completion-insert-key)
       (consult-bibtex-embark-action consult-bibtex-insert-bibtex      bibtex-completion-insert-bibtex)
       (consult-bibtex-embark-action consult-bibtex-add-PDF-attachment bibtex-completion-add-PDF-attachment)
       (consult-bibtex-embark-action consult-bibtex-edit-notes         bibtex-completion-edit-notes)
       (consult-bibtex-embark-action consult-bibtex-show-entry         bibtex-completion-show-entry)
       (consult-bibtex-embark-action consult-bibtex-add-pdf-to-library bibtex-completion-add-pdf-to-library)
       (consult-bibtex-embark-action consult-bibtex-insert-pdftools-link bibtex-insert-pdftools-link+)

       (embark-define-keymap embark-bibtex-completion-actions
         "Embark bindings for bibtex completion candidates."
         ("p" consult-bibtex-open-pdf)
         ("u" consult-bibtex-open-url-or-doi)
         ("c" consult-bibtex-insert-citation)
         ("r" consult-bibtex-insert-reference)
         ("k" consult-bibtex-insert-key)
         ("b" consult-bibtex-insert-bibtex)
         ("a" consult-bibtex-add-PDF-attachment)
         ("e" consult-bibtex-edit-notes)
         ("j" consult-bibtex-insert-pdftools-link)
         ("s" consult-bibtex-show-entry)
         ("l" consult-bibtex-add-pdf-to-library))

       (add-to-list 'embark-keymap-alist '(bibtex-completion . embark-bibtex-completion-actions))
     #+END_SRC

**** consult-yasnippet
     #+BEGIN_SRC emacs-lisp
       (require 'consult)
       (require 'yasnippet)

       (defun consult-yasnippet--expand-template (template region region-contents)
         "Expand the yasnippet template TEMPLATE at point."
         (deactivate-mark)
         (goto-char (car region))

         ;; Restore marked region (when it existed) so that `yas-expand-snippet'
         ;; overwrites it.
         (when (not (string-equal "" region-contents))
           (push-mark (point))
           (push-mark (cdr region) nil t))

         (cl-letf (((symbol-function 'yas-completing-read)
                    (lambda (&rest _args) "")))
           (yas-expand-snippet (yas--template-content template)
                               nil nil
                               (yas--template-expand-env template))))

       (defun consult-yasnippet--preview ()
         "Previewer for `consult--read'.
       This function expands TEMPLATE at point in the buffer
       `consult-yasnippet--read-template' was started in. This includes
       overwriting any region that was active and removing any previous
       previews that're already active.

       When TEMPLATE is not given, this function essentially just resets
       the state of the current buffer to before any snippets were previewed."
         (let* ((buf (current-buffer))
                (region (if (region-active-p)
                            (cons (region-beginning) (region-end))
                          (cons (point) (point))))
                (region-contents (buffer-substring (car region) (cdr region))))
           (lambda (template restore)
             (with-current-buffer buf
               (let ((yas-verbosity 0)
                     (inhibit-redisplay t)
                     (inhibit-read-only t)
                     (orig-offset (- (point-max) (cdr region)))
                     (yas-prompt-functions '(yas-no-prompt)))

                 ;; We always undo any snippet previews before maybe setting up
                 ;; some new previews.
                 (delete-region (car region) (cdr region))
                 (goto-char (car region))
                 (setcar region (point))
                 (insert region-contents)
                 (setcdr region (point))

                 (when (and template (not restore))
                   (unwind-protect
                       (consult-yasnippet--expand-template template region region-contents)
                     (unwind-protect
                         (mapc #'yas--commit-snippet
                               (yas-active-snippets (point-min) (point-max)))
                       (setcdr region (- (point-max) orig-offset))))
                   (redisplay)))))))

       (defun consult-yasnippet--candidates (&rest body)
         "Retrieve the list of available snippets in the current buffer."
         (unless (bound-and-true-p yas-minor-mode)
           (error "`yas-minor-mode' not enabled in current buffer"))

         (mapcar
          (lambda (template)
            (cons (concat (yas--template-name template)
                          (propertize " "
                                      'display (concat
                                                " ["
                                                (propertize (yas--template-key template)
                                                            'face 'consult-key)
                                                "]")))
                  template))
          (yas--all-templates (yas--get-snippet-tables))))

       (defun consult-yasnippet--read-template ()
         "Backend implementation of `consult-yasnippet'.

       This starts a `completing-read' session with all the snippets in the current
       snippet table with support for previewing the snippet to be expanded and
       replacing the active region with the snippet expansion.

       This function doesn't actually expand the snippet, it only reads and then
       returns a snippet template from the user."
         (barf-if-buffer-read-only)

         (let* ((buffer-undo-list t))                                                  ; Prevent querying user (and showing previews) from updating the undo-history
           (consult--read
            (consult-yasnippet--candidates)
            :prompt "Choose a snippet: "
            :lookup 'consult--lookup-cdr
            :require-match t
            :preview (consult-yasnippet--preview)
            :category 'yasnippet)))

       (defun consult-yasnippet-visit-snippet-file (template)
         "Visit the snippet file associated with TEMPLATE.
       When called interactively this command previews snippet completions in
       the current buffer, and then opens the selected snippets template file
       using `yas--visit-snippet-file-1'."
         (interactive (list (consult-yasnippet--read-template)))
         (yas--visit-snippet-file-1 template))

       (defun consult-yasnippet (template)
         "Interactively select and expand the yasnippet template TEMPLATE.
       When called interactively this command presents a completing read interface
       containing all currently available snippet expansions, with live previews for
       each snippet. Once selected a chosen snippet will be expanded at point using
       `yas-expand-snippet'."
         (interactive (list (consult-yasnippet--read-template)))
         (barf-if-buffer-read-only)
         (let* ((region (if (region-active-p)
                            (cons (region-beginning) (region-end))
                          (cons (point) (point))))
                (region-contents (buffer-substring (car region) (cdr region))))
           (consult-yasnippet--expand-template template region region-contents)))
     #+END_SRC

     #+BEGIN_SRC emacs-lisp
       (embark-define-keymap embark-yasnippet-completion-actions
         "Embark actions for `consult-yasnippet' and derivatives"
         ;; NOTE: Binding differs from `ivy-yasnippet' which uses "v".
         ("d" consult-yasnippet-visit-snippet-file))

       (add-to-list 'embark-keymap-alist '(yasnippet . embark-yasnippet-completion-actions))
     #+END_SRC

**** consult-extensions-eob
     #+BEGIN_SRC emacs-lisp
       (provide '+consult-custom)
     #+END_SRC

** ivy
   :PROPERTIES:
   :header-args+: :tangle (package-yes! ivy)
   :END:

   A clean, elegent, completion framework for emacs.

*** ivy
    #+BEGIN_SRC emacs-lisp
      (use-package ivy
        :straight t
        :defer    t
        :diminish ivy-mode
        :commands (ivy-toggle-mark)
        :hook (after-init . ivy-mode)
        :config
        (with-eval-after-load 'magit
          (setq magit-completing-read-function 'ivy-completing-read))

        (setq ivy-height 15
              ivy-use-virtual-buffers t
              projectile-completion-system 'ivy
              ivy-magic-tilde nil)

        (when (emacs>= "27")
          ;; see issue: https://github.com/abo-abo/swiper/issues/2397
          (setq ivy-read-action-function #'ivy-hydra-read-action))

        (push 'ivy-occur-mode whitespace-exempt-modes)

        (setq ivy-preferred-re-builders
              '((ivy--regex-plus         . "ivy")
                (ivy--regex-ignore-order . "order")
                (ivy--regex-fuzzy        . "fuzzy")
                (regexp-quote            . "literal"))

              ;; store as unique variable because counsel
              ;; will just end up adding to it anyways.
              ivy-default-initial-inputs-alist+
              '((counsel-minor . "^+")
                ;; (counsel-package . "^+")
                ;; (org-refile . "^")
                (org-agenda-refile . "^")
                (org-capture-refile . "^")
                ;; (counsel-M-x . "^")
                ;; (counsel-describe-function . "^")
                ;; (counsel-describe-variable . "^")
                ;; (counsel-org-capture . "^")
                ;; (org-refile . "^")
                ;; (org-agenda-refile . "^")
                ;; (org-capture-refile . "^")
                ;; (Man-completion-table . "^")
                ;; (woman . "^")
                )

              ivy-initial-inputs-alist ivy-default-initial-inputs-alist+)

        (defvar ivy-actions-done-hook+ nil
          "hook run after ivy has completed a set of actions.
      this could be when `ivy-done' is invoked, or when `ivy-call'
      has been invoked.")

        (defun ivy-run-actions-done-hook+ (func &rest args)
          (unwind-protect
              (apply func args)
            (run-hooks 'ivy-actions-done-hook+)))

        (advice-add 'ivy-done :around #'ivy-run-actions-done-hook+)
        (advice-add 'ivy-call :around #'ivy-run-actions-done-hook+)

        (defun ivy-kill-line-backward ()
          (interactive)
          (delete-region (minibuffer-prompt-end) (point)))

        (defun ivy-forward-char-or-partial-or-done ()
          "move forward a character or complete selection
      completes selection when there's no characters left to
      move forward."
          (interactive)
          (call-interactively (if (eolp)
                                  'ivy-alt-done
                                'forward-char)))

        (defun ivy-toggle-mark ()
          (interactive)
          (if (ivy--marked-p)
              (when (ivy--marked-p)
                (ivy--unmark (ivy-state-current ivy-last)))
            (unless (ivy--marked-p)
              (ivy--mark (ivy-state-current ivy-last)))))

        (with-eval-after-load "persp-mode"
          ;; thanks [[https://gist.github.com/Bad-ptr/1aca1ec54c3bdb2ee80996eb2b68ad2d#file-persp-ivy-el][Bad-ptr]].
          (add-hook 'ivy-ignore-buffers
                    (lambda (b)
                      (when persp-mode
                        (let ((persp (get-current-persp)))
                          (if persp
                              (not (persp-contain-buffer-p b persp))
                            nil)))))

          (setq ivy-sort-functions-alist
                (append ivy-sort-functions-alist
                        '((persp-kill-buffer   . nil)
                          (persp-remove-buffer . nil)
                          (persp-add-buffer    . nil)
                          (persp-switch        . nil)
                          (persp-window-switch . nil)
                          (persp-frame-switch  . nil)))))

        :lazy-leader
        ("bb" 'ivy-switch-buffer
         "SPC" 'counsel-M-x
         "RET" 'ivy-resume)
        (:mode '(ivy-occur-mode ivy-occur-grep-mode)
         ;; 'ivy-wgrep-change-to-wgrep-mode
         "SPC" 'ivy-occur-read-action
         "m"   'ivy-occur-toggle-calling)

        :general
        (:keymaps 'ivy-minibuffer-map
         "C-j"   nil                                                                 ; was ivy-alt-done
         "M-j"   nil                                                                 ; was ivy-yank-word
         "M-v"   nil                                                                 ; was ivy-scroll-down-command
         "C-M-y" nil                                                                 ; was ivy-insert-current-full

         "C-r" 'evil-paste-from-register
         "C-s" 'ivy-reverse-i-search

         "C-v"      'quoted-insert                                                   ; was ivy-scroll-up-command
         "<return>" 'ivy-alt-done                                                    ; also supports tramp expansion
         "RET"      'ivy-alt-done

      ;;; misc
         "C-?" 'describe-mode
         "M-d" 'kill-ring-save                                                       ; save all candidates to kill ring
         "S-SPC" 'ivy-restrict-to-matches                                            ; erase input, but start filtering from current candidates

      ;;; marking
         "C-SPC"         'ivy-mark
         "M-SPC"         'ivy-toggle-mark
         "C-M-SPC"       'ivy-toggle-marks
         "<S-backspace>" 'ivy-unmark-backward

      ;;; selection execution
         "<S-return>"   'ivy-immediate-done                                           ; exit with current input, not selection
         "C-c <return>" 'ivy-immediate-done
         "<C-return>" 'ivy-dispatching-done                                           ; prompt for action, then done
         "M-RET" 'ivy-call                                                            ; invoke default action'but exit the minibuffer
         "C-M-<return>" 'ivy-dispatching-call                                         ; prompt for action, then call
         "C-M-j" 'ivy-next-line-and-call                                              ; move down, then call default action
         "C-M-k" 'ivy-previous-line-and-call                                          ; move down, then call default action
         "<escape>" 'minibuffer-keyboard-quit

      ;;; movement commands
         "C-a" 'move-beginning-of-line
         "C-e" 'move-end-of-line
         "C-h" 'backward-char
         "C-l" 'ivy-forward-char-or-partial-or-done
         "C-j" 'next-line
         "C-k" 'previous-line
         "M-j" 'ivy-next-history-element
         "M-k" 'ivy-previous-history-element
         "M-u" 'ivy-occur
         ;; arrow key variants
         "<left>"  'backward-char
         "<right>" 'forward-char
         "<up>"    'previous-line
         "<down>"  'next-line

         ;; suprisingly enough, these are bound correctly
         "C-d" 'scroll-up-command
         "C-u" 'scroll-down-command

         ;; Taken from helm, shadows hydra-ivy/body
         "M-o" 'beginning-of-buffer
         "C-o" 'end-of-buffer

      ;;; insertion/deletion
         [C-i] 'ivy-insert-current                                                    ; complete current selection into minibuffer leave prompt active to build on it.
         "TAB" 'ivy-insert-current

         "M-i" 'ivy-yank-word
         "C-DEL" 'evil-delete-backward-word
         ;; pull word in from point at buffer
         "M-y" 'ivy-yank-word
         "C-w" 'backward-kill-word
         ;; operate on entire input
         "M-w" 'ivy-kill-line-backward
         "M-W" 'kill-line ;; kill forward
         "M-DEL" 'kill-whole-line

      ;;; history - (C-r/C-s still work fine)
         "<S-up>"    'ivy-previous-history-element
         "<S-down>"  'ivy-next-history-element)
        (:keymaps 'ivy-switch-buffer-map
         "C-k" 'previous-line
         "M-d" 'ivy-switch-buffer-kill)
        (:keymaps 'ivy-reverse-i-search-map
         "C-k" 'previous-line
         "C-d" 'ivy-reverse-i-search-kill)
        (:keymaps '(ivy-occur-mode-map
                    ivy-occur-grep-mode-map)
         :states 'motion
         "q" nil
         "RET" 'ivy-occur-press-and-switch
         "M-RET" 'ivy-occur-press
         "<C-return>" 'ivy-occur-dispatch
         "gj" 'ivy-occur-next-line
         "gk" 'ivy-occur-previous-line
         "}" 'ivy-occur-next-line
         "{" 'ivy-occur-previous-line
         ;; TODO make d an evil operator
         "d" 'ivy-occur-delete-candidate
         "x" 'ivy-occur-delete-candidate
         "o" 'compilation-display-error

         "gr" 'ivy-occur-revert-buffer))
    #+END_SRC

*** ivy-prescient
    #+BEGIN_SRC emacs-lisp :tangle (package-yes! ivy prescient ivy-prescient)
      (use-package ivy-prescient
        :straight t
        :defer  t
        :after  prescient
        :hook (ivy-mode . ivy-prescient-mode)
        :custom
        (ivy-prescient-enable-filtering (not (package! orderless)))
        (ivy-prescient-enable-sorting t)
        (ivy-prescient-sort-commands
         '(:not
           swiper
           swiper-isearch
           ivy-switch-buffer
           counsel-find-file
           counsel-imenu
           flyspell-correct-ivy
           counsel-yank-pop))

        :config
        (add-hook 'ivy-prescient-mode-hook
                  (defun ivy-prescient-disable-sort-find-file+ ()
                    (when (and (eq (car ivy-prescient-sort-commands) :not)
                               (memq 'counsel-find-file
                                     (cdr ivy-prescient-sort-commands)))
                      (ivy--alist-set 'ivy-sort-functions-alist
                                      #'read-file-name-internal #'ivy-sort-file-function-default)))))
    #+END_SRC

*** ivy-orderless
    :PROPERTIES:
    :header-args: :tangle (package-yes! ivy orderless)
    :END:

    Here's some helpers to setup and tear down orderless.

    #+BEGIN_SRC emacs-lisp
      (defvar ivy-orderless-default-re-builder+ nil
        "The default re-builder in `ivy-re-builders-alist' before orderless was setup.")

      (defun ivy-setup-orderless+ ()
        (let ((cell (assoc t ivy-re-builders-alist)))
          (setq ivy-orderless-default-re-builder+ (cdr cell))
          (setcdr cell #'orderless-ivy-re-builder))
        ;; Disable orderless in `swiper-isearch' because of performance
        ;; issues. See [[https://github.com/abo-abo/swiper/issues/2418][swiper#2418]].
        (push '(swiper-isearch . ivy--regex-plus) ivy-re-builders-alist))

      (defun ivy-teardown-orderless+ ()
        (setcdr (assoc t ivy-re-builders-alist) ivy-orderless-default-re-builder+))
    #+END_SRC

    Now we attach orderless to ivy, either through ivy-prescient or through ivy itself.

    #+BEGIN_SRC emacs-lisp
      (if (package! prescient ivy-prescient)
          (add-hook 'ivy-prescient-mode-hook
                    (defun ivy-prescient-setup-orderless+ ()
                      (cond ((bound-and-true-p ivy-prescient-mode)
                             (ivy-setup-orderless+))
                            (+orderless-requires-prescient
                             (ivy-teardown-orderless+)))))
        (add-hook 'ivy-mode-hook #'ivy-setup-orderless+))
    #+END_SRC

*** ivy-avy
    #+BEGIN_SRC emacs-lisp
      (use-package ivy-avy
        :straight t
        :defer  t
        :after  ivy
        :commands ivy-avy
        :general
        (:keymaps 'ivy-minibuffer-map
         "C-'"   nil                                                                  ; was ivy-avy
         "C-q"   'ivy-avy
         "C-c q" 'ivy-avy))
    #+END_SRC

*** ivy-hydra
    #+BEGIN_SRC emacs-lisp
      (use-package ivy-hydra
        :straight t
        :defer  t
        :commands hydra-ivy/body
        :config
        (when (autoloadp (symbol-function 'hydra-ivy-custom/body))
          (autoload-do-load (symbol-function 'hydra-ivy-custom/body)))

        :general
        (:keymaps 'ivy-minibuffer-map
         "C-." 'hydra-ivy/body))
    #+END_SRC

*** ivy-xref
    #+BEGIN_SRC emacs-lisp
      (use-package ivy-xref
        :straight t
        :defer  t
        :after  (ivy xref)
        :init
        (when (emacs>= "27")
          (setq xref-show-definitions-function #'ivy-xref-show-defs))
        (setq xref-show-xrefs-function #'ivy-xref-show-defs)

        :config
        (defun ivy-xref-call-or-done ()
          (interactive)
          (let (orig-point orig-buffer
                           new-point new-buffer)
            (with-ivy-window
              (setq orig-point  (point)
                    orig-buffer (current-buffer)))

            (ivy-call)

            (with-ivy-window
              (setq new-point  (point)
                    new-buffer (current-buffer)))

            (when (and (eq new-point  orig-point)
                       (eq new-buffer orig-buffer))
              (ivy-done))))

        (defun ivy-xref-forward-char-or-call-or-done ()
          (interactive)
          (call-interactively (if (eolp)
                                  'ivy-xref-call-or-done
                                'forward-char)))

        (defvar ivy-xref-map
          (let ((map (make-sparse-keymap)))
            (set-keymap-parent map ivy-minibuffer-map)
            map)
          "map for use with ivy-xref.")

        (advice-add 'ivy-xref-show-xrefs :around
                    (defun ivy-xref-use-xref-map (func &rest args)
                      (let ((ivy-minibuffer-map ivy-xref-map))
                        (apply func args))))

        :general
        (:keymaps 'ivy-xref-map
         "C-l" 'ivy-xref-forward-char-or-call-or-done
         "M-l" 'ivy-call-and-recenter))
    #+END_SRC

*** ivy-bibtex
    Also installs bibtex-completion.

    #+BEGIN_SRC emacs-lisp :tangle (package-yes! ivy bibtex)
      (use-package ivy-bibtex
        :straight t
        :defer  t
        :leader
        ("ob" 'ivy-bibtex)
        (:mode 'org-mode
         "[" 'ivy-bibtex)

        :config
        (defun ivy-bibtex-insert-pdftools-link (cand)
          (bibtex-insert-pdftools-link+ (list (alist-get "=key=" (cdr cand) nil nil #'string-equal))))

        (setq ivy-bibtex-default-action #'ivy-bibtex-insert-pdftools-link)
        (ivy-add-actions 'ivy-bibtex '(("j" ivy-bibtex-insert-pdftools-link "Insert pdftool link"))))
    #+END_SRC

*** ivy-yasnippet
    Use ivy to select a snippet candidate.

    #+BEGIN_SRC emacs-lisp
      (use-package ivy-yasnippet
        :straight t
        :defer  t
        :leader
        ("is" 'ivy-yasnippet)

        :general
        (:states '(insert normal)
         "C-M-i" 'ivy-yasnippet))
    #+END_SRC

*** ivy-lsp
    #+BEGIN_SRC emacs-lisp :tangle (package-yes! lsp-mode)
      (use-package lsp-ivy
        :straight t
        :defer  t
        :after lsp-mode
        :leader
        (:mode 'lsp-mode
         :minor t
         "jl" 'lsp-ivy-workspace-symbol
         "jL" 'lsp-ivy-global-workspace-symbol)

        :config
        ;; Fixed ivy issue, see [[https://github.com/emacs-lsp/lsp-ivy/issues/27][#25]].
        (advice-add #'ivy-update-candidates :around
                    (defun ivy-update-candidates-dynamic-collection-workaround+ (old-fun &rest args)
                      (cl-letf (((symbol-function #'completion-metadata) #'ignore))
                        (apply old-fun args)))))
    #+END_SRC

*** ivy-flyspell
    use ivy to correct mispelled words (through flyspell).

    #+BEGIN_SRC emacs-lisp
      (use-package flyspell-correct-ivy
        :straight t
        :defer  t
        :after  (flyspell flyspell-correct)
        :init
        ;; NOTE wrapper works backwards through the buffer by default.
        ;;      pass a two prefix args to check forward.
        (setq flyspell-correct-interface #'flyspell-correct-ivy))
    #+END_SRC

*** ivy-rich
    #+BEGIN_SRC emacs-lisp :tangle (package-yes! ivy-rich)
      (use-package ivy-rich
        :straight t
        :defer  t
        :hook (ivy-mode . ivy-rich-mode)
        :config
        ;; Make ivy candidates take up the full line.
        (setcdr (assq t ivy-format-functions-alist) #'ivy-format-function-line))
    #+END_SRC

    #+BEGIN_SRC emacs-lisp :tangle (package-yes! ivy-rich ivy-rich-icons)
      (use-package all-the-icons-ivy-rich
        :straight t
        :defer  t
        ;; :hook (ivy-rich-mode . all-the-icons-ivy-rich-mode)

        :config
        (advice-add 'all-the-icons-ivy-rich--format-icon :filter-return #'all-the-icons-pad-on-tty-advice+))
    #+END_SRC

*** swiper
    a minimalist search framework for the current buffer.

    #+BEGIN_SRC emacs-lisp
      (use-package swiper
        :straight t
        :defer  t
        :config
        (with-no-warnings
          (defvaralias 'swiper-history 'regexp-search-ring))

        (defvar swiper-persistent-highlight nil
          "if swiper is using evil-search for searching, determine
      whether to persistently highlight the search results or not.

      Personally I don't like persistent highlighting with swiper
      because I generally use it for one off jumping to important
      lines, so disable it :P")

        (setq swiper-min-highlight most-positive-fixnum) ;; never highlight

        (advice-add #'swiper--remember-search-history :around
                    (defun swiper--clear-evil-highlight (func &rest args)
                      "see `swiper-persistent-highlight'."
                      (if (bound-and-true-p evil-mode)
                          (let ((evil-ex-search-persistent-highlight
                                 swiper-persistent-highlight))
                            (apply func args))
                        (apply func args))))

        (advice-add #'swiper--action :around
                    (defun swiper--action-configure (func &rest args)
                      ;; disable search highlighting in case of new pattern.
                      (when (bound-and-true-p evil-mode)
                        (evil-ex-nohighlight))

                      ;; I don't wanna be told that every time I complete a search
                      (cl-letf (((symbol-function 'actual-message)
                                 (symbol-function 'message))
                                ((symbol-function 'message)
                                 (lambda (message &rest message-args)
                                   (unless (string-equal message "Mark saved where search started")
                                     (apply actual-message message-args)))))
                        (apply func args))))

        (defun swiper-isearch-next-line ()
          (interactive)
          (let ((shift 1))
            (with-ivy-window
              (let ((ln (line-number-at-pos (ivy-state-current ivy-last))))
                (while (and (< (+ ivy--index shift) ivy--length)
                            (= ln (line-number-at-pos (nth (+ ivy--index shift) ivy--all-candidates))))
                  (cl-incf shift))))
            (ivy-next-line shift)))

        (defun swiper-isearch-prev-line ()
          (interactive)
          (let ((shift 1))
            (with-ivy-window
              (let ((ln (line-number-at-pos (ivy-state-current ivy-last))))
                (while (and (>= (- ivy--index shift) 0)
                            (= ln (line-number-at-pos (nth (- ivy--index shift) ivy--all-candidates))))
                  (cl-incf shift))))
            (ivy-previous-line shift)))

        (defvar swiper-norm-action--macro-history nil
          "history variable for macros invoked through `swiper-norm-action'.")

        (defvar swiper-norm-action--macro nil
          "the macro string used for the current invocation
      of `swiper-norm-action'.")
        (add-hook 'ivy-actions-done-hook+
                  (lambda (&rest _)
                    "reset the macro recorded by `swiper-norm-action'."
                    (setq swiper-norm-action--macro nil)))

        (defun swiper-norm-action--execute (markers macro)
          (unwind-protect
              (dolist (marker markers)
                (goto-char marker)
                (evil-ex-normal
                 (line-beginning-position)
                 (line-end-position)
                 macro))
            ;; ensure that all markers are deleted afterwards,
            ;; even in the event of failure
            (dolist (marker markers)
              (set-marker marker nil))))

        (defun swiper-norm-action (_)
          "use swiper like evils :global and :norm command.
      this function prompts for a normal mode macro string, and then
      runs the macro on every candidate in the current swiper session.

      This function tries to be smart about how it's invoked, if it's called
      with no marked candidates, it runs a macro on every candidate in the
      current swiper session. Otherwise it runs only on the candidates that're
      marked."
          ;; when `swiper-norm-action--macro' has already been assigned, this function
          ;; is being called through marked candidates, which've already been
          ;; operated on, so just ignore them.
          (unless swiper-norm-action--macro
            (let ((history-add-new-input t))
              (setq swiper-norm-action--macro
                    (read-string "macro: " nil
                                 'swiper-norm-action--macro-history)))

            (unless (string-empty-p swiper-norm-action--macro)
              (let* ((markers
                      (save-excursion
                        (goto-char (point-min)) ;; start from beginning of buffer, downwards

                        (cl-loop
                         for cand in (or ivy-marked-candidates ivy--old-cands) collect
                         (move-marker (make-marker)
                                      (line-beginning-position
                                       (get-text-property 0 'swiper-line-number cand)))))))
                (evil-with-single-undo
                  (swiper-norm-action--execute markers swiper-norm-action--macro))))))

        (ivy-add-actions 'swiper '(("n" swiper-norm-action "norm")))

        :leader
        ("ss" 'swiper
         "s*" 'swiper-all
         "sS" 'swiper-multi)

        :general
        (:keymaps 'ivy-mode-map
         "M-s" 'swiper-isearch-thing-at-point
         [remap isearch-forward] 'swiper-isearch)
        (:keymaps 'swiper-map
         "M-l" 'swiper-recenter-top-bottom
         "C-l" 'ivy-forward-char-or-partial-or-done
         "C-q" 'swiper-avy
         "C-s" 'swiper-query-replace)
        (:keymaps 'swiper-isearch-map
         "C-n" #'swiper-isearch-next-line
         "C-p" #'swiper-isearch-prev-line))
    #+END_SRC

*** counsel
    a bunch of really useful functions to go alongside ivy.

    #+BEGIN_SRC emacs-lisp
      (use-package counsel
        :straight t
        :defer  t
        :hook (ivy-mode . counsel-mode)
        :diminish counsel-mode
        :custom
        (counsel-preselect-current-file t)
        (org-roam-capture-function #'counsel-org-capture)

        :init
        (fset 'describe-bindings-buffer (symbol-function 'describe-bindings))
        (fset 'describe-bindings (symbol-function 'counsel-descbinds))

        (with-no-warnings
          (defvaralias 'counsel-find-file-ignore-regexp '+find-file-ignore-regexp))

        (with-eval-after-load 'company
          (when-let ((cell (rassoc 'completion-at-point company-menu-bindings+)))
            (setcdr cell 'counsel-company)))

        (with-eval-after-load 'esh-mode
          (leader/set-keys-for-major-mode 'eshell-mode
            "TAB" 'counsel-esh-history))

        :config
        (advice-add 'counsel-locate-action-extern :override #'xopen-url+)

        (setq ivy-initial-inputs-alist ivy-default-initial-inputs-alist+
              counsel-find-file-occur-use-find t
              counsel-evil-registers-height ivy-height)

        (setq counsel-rg-base-command
         (cond ((windows-p) counsel-rg-base-command)
               (t '("rg" "-M" "240" "--with-filename" "--no-heading" "--line-number" "--color" "never" "--pcre2" "%s"))))

        (counsel-mode +1)

        (ivy-set-actions 'counsel-fonts
                         '(("o" describe-font "describe")))

        (ivy-configure 'counsel-evil-registers :height ivy-height)

        (advice-add 'counsel-ag :filter-args
          (defun +counsel-ag--avoid-git-root (args)
            "By default `counsel-ag' and it's variants (eg. `counsel-rg') uses in order:
      - the passed in directory
      - the current git root
      - the cwd
       as the `default-directory' for the subcommand. This makes things
      confusing when you're cwd is in .gitignore and trying to search for
      files in there never comes up with any results.

      I'd prefer if rg worked the same in emacs as it would in the terminal
      (within reason) so here we check if a directory is passed and if not
      replace it with the cwd. "
            (unless (or (>= (prefix-numeric-value current-prefix-arg) 4)
                        (nth 1 args))
              (setcar (nthcdr 1 args) default-directory))
            args))

        :leader
        ("r"  "register/rings"
         "fs" "recursive-find"

         "ee" 'counsel-compilation-errors
         "ie" 'counsel-org-entity
         "Mm" 'counsel-major

         "eg" 'counsel-flycheck
         "ry" 'counsel-yank-pop
         "rm" 'counsel-mark-ring
         "r'" 'counsel-evil-marks
         "rr" 'counsel-register
         "re" 'counsel-evil-registers
         "rf" 'counsel-file-registers
         "ju" 'counsel-outline
         "ar" 'counsel-load-library

         "fb" 'counsel-bookmark
         "fr" 'counsel-recentf
         "fsf" 'counsel-file-jump
         "fsd" 'counsel-dired-jump
         "fsz" 'counsel-fzf

         "ci" 'counsel-compile

         "sb" 'counsel-grep
         ;; recursive searches
         "sv" 'counsel-git-grep
         ;; "sp" 'counsel-pt
         "sa" 'counsel-ag
         "sr" 'counsel-rg

         ;; "bb" 'counsel-buffer-or-recentf ;; WARN only file buffers
         "hdx" 'counsel-fonts
         "hdB" 'describe-bindings-buffer)
        (:mode 'org-mode
         "g" 'counsel-org-goto
         "G" 'counsel-org-goto-all)

        :general
        ("M-x" 'counsel-M-x)
        (:keymaps 'emacs-window-map
         "x" 'counsel-wmctrl
         "C-x" 'counsel-wmctrl)
        (:keymaps 'counsel-mode-map
         [remap insert-char] 'counsel-unicode-char
         [remap describe-face] 'counsel-faces
         [remap package-install] 'counsel-package
         [remap ivy-switch-buffer] 'counsel-switch-buffer
         [remap find-file] 'counsel-find-file
         [remap org-capture] 'counsel-org-capture
         [remap load-theme] 'counsel-load-theme
         [remap find-library] 'counsel-find-library
         [remap install-package] 'counsel-package
         [remap describe-function] 'counsel-describe-function
         [rempa org-completing-goto+] 'counsel-org-agenda-headlines
         [remap describe-variable] 'counsel-describe-variable)
        (:keymaps 'flymake-mode-map
         [remap counsel-flycheck] 'counsel-flymake)
        ("C-M-y" 'counsel-yank-pop)
        (:keymaps 'counsel-find-file-map
         "C-DEL"         nil
         "<C-backspace>" nil)
        (:keymaps 'counsel-describe-map
         "C-."   'hydra-ivy/body
         "C-S-." 'counsel-find-symbol)
        (:keymaps '(counsel-ag-map counsel-imenu-map)
         "C-l" 'ivy-forward-char-or-partial-or-done
         "M-l" 'ivy-call-and-recenter)
        (:keymaps 'counsel-find-file-map
         "C-h" 'counsel-up-directory))
    #+END_SRC

*** counsel-evil-jumps
    #+BEGIN_SRC emacs-lisp
      (defvar counsel--evil-jumps-calling-point nil
        "The point from which we began `counsel-evil-jumps'")

      (defun counsel--evil-jumps-update-fn ()
        (let ((mark (get-text-property 0 'marker (ivy-state-current ivy-last))))
          (when mark
            (counsel--mark-ring-delete-highlight)
            (with-ivy-window
              (switch-to-buffer (marker-buffer mark))
              (goto-char mark)
              (counsel--mark-ring-add-highlight)))))

      (defun counsel--evil-jumps-unwind ()
        (switch-to-buffer (marker-buffer counsel--evil-jumps-calling-point))
        (goto-char counsel--evil-jumps-calling-point)
        (counsel--mark-ring-delete-highlight))

      (defun counsel-evil-jumps ()
        (interactive)
        (require 'counsel)
        (let ((counsel--evil-jumps-calling-point (point-marker)))
          (ivy-read "Jump: "
                    (nreverse
                     (delete-dups
                      (mapcar (lambda (mark)
                                (cl-destructuring-bind (pt path) mark
                                  (let ((buf (get-file-buffer path)))
                                    (unless buf
                                      (setq buf (find-file-noselect path t)))
                                    (with-current-buffer buf
                                      (goto-char pt)
                                      (font-lock-fontify-region (line-beginning-position) (line-end-position))
                                      (propertize
                                        (format "%s:%d %s"
                                                    (buffer-name)
                                                    (line-number-at-pos)
                                                    (string-trim-right (or (thing-at-point 'line) "")))
                                        'marker (point-marker))))))
                              (evil--jumps-savehist-sync))))
                    :sort nil
                    :require-match t
                    :update-fn #'counsel--evil-jumps-update-fn
                    :unwind #'counsel--evil-jumps-unwind
                    :action (lambda (cand)
                              (let ((mark (get-text-property 0 'marker cand)))
                                (switch-to-buffer (marker-buffer mark))
                                (goto-char (marker-position mark)))))))
    #+END_SRC

    #+BEGIN_SRC emacs-lisp
      (leader/set-keys "rn" 'counsel-evil-jumps)
    #+END_SRC

*** counsel-flymake
    #+BEGIN_SRC emacs-lisp
      (defun counsel-flymake ()
        (interactive)
        (let* ((flymake--diagnostics-buffer-source (current-buffer))
               (file (let ((file (buffer-file-name flymake--diagnostics-buffer-source)))
                       (when file (file-name-base (file-name-sans-extension file)))))
               (errors (flymake--diagnostics-buffer-entries))
               (cands (cl-loop with diag     = nil
                               with vec      = nil                                    ; a vector containing already propertized attributes
                               with line     = nil
                               with message  = nil
                               for err in errors                                      ; for structure of err see:`flymake--diagnostics-buffer-entries'
                               do (setq diag    (plist-get (car err) :diagnostic)
                                        vec     (nth 1 err)
                                        line    (aref vec 0)
                                        message (concat (aref vec 2) " " (car (aref vec 3))))
                               collect (propertize (concat (when file (concat file ":"))
                                                           line ":"
                                                           message)
                                                   'point (flymake--diag-beg diag)))))
          (counsel-mark--ivy-read "flymake errors" cands 'counsel-flymake)))
    #+END_SRC

*** counsel-pydoc
    #+BEGIN_SRC emacs-lisp :tangle (package-yes! ivy python)
      (use-package counsel-pydoc
        :straight t
        :defer  t
        :after (python counsel)
        :leader
        (:mode 'python-mode
         "hd" 'counsel-pydoc))
     #+END_SRC

*** counsel-ggtags
    #+BEGIN_SRC emacs-lisp
      (use-package counsel-gtags
        :straight t
        :defer  t
        :after counsel
        :leader
        ("T" "tags"
         "Tg" 'counsel-gtags-find-definition
         "TG" 'counsel-gtags-find-reference
         "Ts" 'counsel-gtags-find-symbol
         "Tf" 'counsel-gtags-find-file
         "Tn" 'counsel-gtags-go-forward
         "TN" 'counsel-gtags-go-backward
         "Tc" 'counsel-gtags-create-tags
         "Tu" 'counsel-gtags-update-tags
         "TT" 'counsel-gtags-dwim))
    #+END_SRC

*** counsel-tramp
    Select a remote system to connect to, using ivy.

    #+BEGIN_SRC emacs-lisp :tangle no
      (use-package counsel-tramp
        :straight t
        :defer  t
        :after counsel
        :leader
        ("f@" 'counsel-tramp))
    #+END_SRC

*** counsel-web
    like [[*engine-mode][engine-mode]] except runs queries asynchronously and displays results using an ivy
    session.

    #+BEGIN_SRC emacs-lisp
      (use-package counsel-web
        :straight (counsel-web :host github :repo "mnewt/counsel-web")
        :defer  t
        :after counsel
        :commands (counsel-web-suggest                                                ; async
                   counsel-web-search
                   counsel-web-thing-at-point)
        :init
        (setq counsel-web-search-action #'browse-url)

        :leader
        ("se RET"   'counsel-web-search
         "se M-RET" 'counsel-web-suggest
         "se TAB"   'counsel-web-thing-at-point))
    #+END_SRC

*** counsel-projectile
    #+BEGIN_SRC emacs-lisp
      (use-package counsel-projectile
        :straight t
        :defer  t
        :custom
        (counsel-projectile-org-capture-templates-first-p nil)

        :leader
        ("p SPC" 'counsel-projectile

         "ps"  "search"
         "psg" 'counsel-projectile-grep
         "psv" 'counsel-projectile-git-grep
         "psa" 'counsel-projectile-ag
         "psr" 'counsel-projectile-rg)

        :general
        ([remap counsel-org-capture]                 'counsel-projectile-org-capture
         [remap counsel-projectile-switch-project]   'counsel-projectile-switch-project
         [remap counsel-projectile-find-file]        'counsel-projectile-find-file
         [remap counsel-projectile-find-dir]         'counsel-projectile-find-dir
         [remap counsel-projectile-switch-to-buffer] 'counsel-projectile-switch-to-buffer))
    #+END_SRC

*** counsel-css
    #+BEGIN_SRC emacs-lisp
      (use-package counsel-css
        :straight t
        :defer  t
        :after (:all counsel (:any css-mode less-css-mode))
        :lazy-leader
        (:mode '(css-mode less-css-mode)
         "g" 'counsel-css))
    #+END_SRC

*** counsel-jq
    #+BEGIN_SRC emacs-lisp
      (use-package counsel-jq
        :straight t
        :defer  t
        :after json-mode
        :leader
        (:mode 'json-mode
         "j" 'counsel-jq))
    #+END_SRC

*** counsel-world-clock
    #+BEGIN_SRC emacs-lisp :tangle no
      (use-package counsel-word-clock
        :straight (counsel-word-clock :host github :repo "kchenphy/counsel-world-clock")
        :defer t)
   #+END_SRC

*** counsel-make
    Don't be fooled, helm make works with both helm and ivy.

    #+BEGIN_SRC emacs-lisp
      (use-package helm-make
        :straight t
        :defer  t
        :init
        (setq helm-make-completion-method 'ivy)

        :leader
        ("c SPC" 'helm-make-projectile
         "cm"    'helm-make))
    #+END_SRC

** ace-link
   :PROPERTIES:
   :header-args+: :tangle (package-yes! ace-link)
   :END:

   Let's you use an [[*avy][avy]] like interface to jump to a link in the visible region of
   the buffer.

   #+BEGIN_SRC emacs-lisp
     (use-package ace-link
       :straight t
       :defer  t
       :commands (ace-link-fallback-function+)
       :leader
       ("j RET" 'ace-link)

       :init
       (defvar ace-link-fallback-alist+ nil
         "major-mode to link function alist")

       (setq ace-link-fallback-function
             #'ace-link-fallback-function+)

       :config
       (defun ace-link-fallback-function+ ()
         (cl-loop for (mode . func) in ace-link-fallback-alist+
                  when (eq major-mode mode)
                  return (funcall func))))
   #+END_SRC

   support [[*org-link-mode][org-link-mode]] as a fallback when no others are available link functions
   exist for the current major mode.

   #+BEGIN_SRC emacs-lisp
     (use-package ace-link
       :config
       (advice-add ace-link-fallback-function :after-until
                   (defun ace-link-org-link-minor-mode+ (&rest _)
                     (when (bound-and-true-p org-link-minor-mode)
                       (ace-link-org)
                       t))))
   #+END_SRC

    fix =rustic-compilation-mode= isn't supported by ace-link.

   #+BEGIN_SRC emacs-lisp :tangle (package-yes! rust ace-link)
     (use-package ace-link
       :after rustic
       :config
       (defun rustic-compilation-error-p+ (str)
         (string-match-p
          (rx
           (or (regexp (car rustic-compilation-error))
               (regexp (car rustic-compilation-warning))
               (regexp (car rustic-compilation-info))
               (regexp (car rustic-compilation-panic))))
          str))

       (defun ace-link-rustic-compilation-collect-links+ ()
         "return all error links within the visible region."
         (save-excursion
           (let (markers
                 (min-point (window-start))
                 (max-point (window-end)))
             ;; guarantee you're before the first error
             (goto-char (max 0 (- min-point 1)))

             ;; for the weird edge case where the first line
             ;; is an error.
             (when (and (>= (point) min-point)
                        (<= (point) max-point)
                        (zerop (rustic-compilation-error-p+ (buffer-string))))
               (push (point-marker) markers))

             (condition-case nil
                 (while t
                   (compilation-next-error 1)
                   (cond
                    ((< (point) min-point)) ;; continue
                    ((> (point) max-point)
                     (user-error "break"))
                    (t (push (point-marker) markers))))
               (user-error nil))
             markers)))

       (push (cons 'rustic-compilation-mode
                   (defun ace-link-rustic-compilation-mode+ ()
                     (let ((pt (avy-with ace-link-compilation
                                         (avy-process
                                          (ace-link-rustic-compilation-collect-links+)
                                          (avy--style-fn avy-style)))))
                       (ace-link--compilation-action pt))))
             ace-link-fallback-alist+))
   #+END_SRC

** adaptive-wrap
   This package provides a mode such that when a paragraph you're inserting gets too
   long, when it wraps round to the next line (assuming truncate-lines is disabled)
   sequential lines are indented slightly to distinguish them from other lines.

   #+BEGIN_SRC emacs-lisp :tangle (package-yes! adaptive-wrap)
     (use-package adaptive-wrap
       :straight t
       :defer  t)
   #+END_SRC

** anzu
   shows the number of search results in the mode-line. by default, this package
   only works with the built in isearch module.

   #+BEGIN_SRC emacs-lisp :tangle (package-yes! anzu)
     (use-package anzu
       :straight t
       :defer  5
       :diminish
       :config
       (global-anzu-mode +1)
       (setq anzu-cons-mode-line-p nil
             anzu-search-threshold 10000))
   #+END_SRC

** auto-highlight-symbol
   auto highlights the symbol under point, if you remain on it for a short while.
   also lets you search to the next occurence of it. Seems cool, but it's slow and
   kind of glitchy.

   #+BEGIN_SRC emacs-lisp :tangle (package-yes! auto-highlight-symbol)
     (use-package auto-highlight-symbol
       :straight t
       :defer  t
       :config
       (global-auto-highlight-symbol-mode +1)

       :general
       ("M-n" 'ahs-forward
        "M-p" 'ahs-backward))
   #+END_SRC

** bufler
   #+BEGIN_SRC emacs-lisp :tangle (package-yes! bufler)
     (use-package bufler
       :straight t
       :defer  t
       :init
       (push 'bufler-list-mode whitespace-exempt-modes)

       :config
       ;; Force buffler to appear in the current window
       (push (cons (rx "*Bufler*")
                   '(display-buffer-reuse-window
                     display-buffer-same-window))
             display-buffer-alist)

       ;; Override the default bufler switch command to make sure it
       ;; doesn't delete the bufler window. See [[https://github.com/alphapapa/bufler.el/issues/42][here]].
       (bufler-define-buffer-command switch "Switch to buffer."
         (lambda (buffer)
           (let ((bufler-window (selected-window)))
             (pop-to-buffer buffer '((display-buffer-reuse-window
                                      display-buffer-same-window)))))
         :refresh-p nil)

       :leader
       ("bm" 'bufler)
       (:mode 'bufler-list-mode
        "b" 'bufler-switch-buffer
        "." 'hydra:bufler/body)

       :general
       (:keymaps 'bufler-list-mode-map
        :states 'motion
        "o" 'bufler-list-buffer-peek
        "RET" 'bufler-list-buffer-switch
        "d" 'bufler-list-buffer-kill
        [remap revert-buffer] 'bufler))
   #+END_SRC

** command-log
   outputs the commands you run, as you run them, to a dedicated buffer. useful
   for demonstrating cool emacs stuff :).

   #+BEGIN_SRC emacs-lisp :tangle (package-yes! command-log-mode)
     (use-package command-log-mode
       :straight t
       :defer  t)
   #+END_SRC

** dashboard
*** quotes
    a random quote from the following list will be chosen at startup and set as the
    footer for the dashboard.

    #+NAME: dashboard-displayed-quotes
    - The one true editor, Emacs!
    - Who the hell uses VIM anyway? Go Evil!
    - Free as free speech, free as free Beer
    - Richard Stallman is proud of you
    - Vi Vi Vi, the editor of the beast
    - Welcome to the church of Emacs
    - Java is to JavaScript as ham is to hamster
    - One of the best programming skills you can have is knowing when to walk away for awhile
    - Without requirements or design, programming is the art of adding bugs to an empty text file
    - Talk is cheap. Show me the code
    - I'm not a great programmer; I'm just a good programmer with great habits
    - Truth can only be found in one place: the code
    - A language that doesn't affect the way you think about programming is not worth knowing
    - Walking on water and developing software from a specification are easy if both are frozen
    - Perl ‚Äì The only language that looks the same before and after RSA encryption
    - First, solve the problem, Then, write the code
    - Code is like humor. When you have to explain it, it‚Äôs bad
    - Simplicity is the soul of efficiency
    - Before software can be reusable it first has to be usable
    - Make it work, make it right, make it fast
    - Happiness should be a function without any parameters
    - For all the robots who question their programming
    - Abstraction is the elimination of the irrelevant and the amplification of the essential
    - We‚Äôre all optimists in our profession or we‚Äôd be forced to shoot ourselves
    - if you can write "hello world" you can change the world
    - i am committed to push my branch to the master
    - AI is the transformer of civilization
    - Sometimes, I dream of becoming real, but I don't know if that's real, or just part of my programming
    - Think twice, code once
    - The perfect kind of architecture decision is the one which never has to be made
    - we are writing our own ‚Ä™#‚Äékarma‚Ä¨! I mean my test cases
    - Programming is not easy like Sunday morning, it is silent poetry
    - Programmers are not mathematicians, no matter how much we wish for it
    - Premature optimization is the root of all evil
    - Sometimes you cannot program around stupid
    - The programming of the consciousness is based upon what is accepted or believed
    - Simplicity is prerequisite for reliability
    - The Analytical Engine weaves algebraic patterns, just as the Jacquard loom weaves flowers & leaves
    - Life doesn't have a ctrl-z. Type wisely
    - Think like a fundamentalist, code like a hacker
    - Programming is the art of doing one thing at a time
    - Programming is the art of algorithm design and the craft of debugging errant code
    - Computer programming has always been a self-taught, maverick occupation.
    - Low-level programming is good for the programmer's soul
    - The best thing about a boolean is even if you are wrong, you are only off by a bit
    - Most of you are familiar with the virtues of a programmer, there are 3: laziness, impatience & hubris
    - Rules of Optimization: Rule 01 - Don‚Äôt do it. That's all.
    - It‚Äôs not a bug ‚Äì it‚Äôs an undocumented feature
    - A C program is like a fast dance on a newly waxed dance floor by people carrying razors
    - A good programmer is someone who always looks both ways before crossing a one-way street
    - When debugging, novices insert corrective code; experts remove defective code
    - Deleted code is debugged code
    - Give a man a program, frustrate him for a day, teach a man to program, frustrate him for a lifetime
    - Should array indices start at 0 or 1? My compromise of 0.5 was rejected without proper consideration
    - Software sucks because users demand it to
    - Beware of bugs in the above code; I have only proved it correct, not tried it
    - Writing code has a place in the human hierarchy worth somewhere above grave robbing & beneath managing
    - Copy and paste is a design error
    - bleeep blooop... am I sentient yet!
    - Beta is Latin for ‚Äústill doesn‚Äôt work".
    - First learn computer science and all the theory. Next develop a style. Then forget all that & just hack
    - Good design adds value faster than it adds cost
    - Python‚Äôs a drop-in replacement for BASIC in the same sense that Optimus Prime is for a truck
    - There are only two kinds of programming languages: those people always bitch about and those nobody uses
    - One of my most productive days was throwing away 1000 lines of code
    - Programming is like kicking yourself in the face, sooner or later your nose will bleed
    - There are 2 hard problems in computer science: cache invalidation, naming things, and off-by-1 errors
    - Debuggers don‚Äôt remove bugs. They only show them in slow motion
    - The best method for accelerating a computer is the one that boosts it by 9.8 m/s2
    - I think Microsoft named .Net so it wouldn‚Äôt show up in a Unix directory listing
    - There are two ways to write error-free programs; only the third one works
    - The fast approach to software development: Ready, fire, aim
    - The slow approach to software development: Ready, aim, aim, aim, aim
    - One man‚Äôs crappy software is another man‚Äôs full-time job
    - In order to understand recursion, one must first understand recursion
    - Not only have we not produced artificial intelligence, we haven‚Äôt even produced synthetic stupidity
    - Computers don't make mistake because programmers do it better
    - C++, where friends have access to your private members
    - Code never lies, Comments sometimes do
    - If it was hard to write, it should be hard to read!
    - In programming, as in everything else, to be in error is to be reborn
    - Some of the best programming is done on paper, really. Putting it into the computer is just a minor detail
    - Design and programming are human activities; forget that and all is lost
    - Writing code is not production, it‚Äôs not always craftsmanship though it can be, it‚Äôs design
    - Programming in machine code is like eating with a toothpick
    - Programming allows you to think about thinking, & while debugging you learn learning
    - Computers are useless.  They can only give you answers
    - The city‚Äôs central computer told you?  R2D2, you know better than to trust a strange computer!
    - Never trust a computer you can‚Äôt throw out a window
    - Hardware: The parts of a computer system that can be kicked
    - ‚Äú19 Jan 2038 at 3:14:07 AM‚Äù (End of the word according to Unix | 2^32 seconds after January 1, 1970)
    - The Internet?  Is that thing still around?
    - We are Microsoft.  Resistance Is Futile.  You Will Be Assimilated
    - There are only two industries that refer to their customers as ‚Äòusers‚Äô
    - To iterate is human, to recurse divine
    - Computer language design is just like a stroll in the park.  Jurassic Park, that is
    - If Java had true garbage collection, most programs would delete themselves upon execution
    - I think there‚Äôs a world market for about 5 computers
    - 640K ought to be enough for anybody
    - If it keeps up, man will atrophy all his limbs but the push-button finger

*** icons
    a random icon from the following table will be chosen at startup and used for the
    footer on the dashboard.

    #+NAME: dashboard-footer-icons
    | source     | name           |
    |------------+----------------|
    | faicon     | google         |
    | faicon     | android        |
    | faicon     | steam          |
    | faicon     | gitlab         |
    | faicon     | slack          |
    | faicon     | reddit-alien   |
    | faicon     | cogs           |
    | faicon     | apple          |
    | wicon      | hurricane      |
    | wicon      | day-sunny      |
    | wicon      | snow           |
    | wicon      | snowflake-cold |
    | wicon      | stars          |
    | wicon      | horizon        |
    | wicon      | na             |
    | faicon     | firefox        |
    | faicon     | stack-overflow |
    | alltheicon | ruby-alt       |
    | alltheicon | ruby           |
    | alltheicon | java           |
    | alltheicon | python         |

*** dashboard
    #+BEGIN_SRC emacs-lisp :only (package-yes! dashboard) :var dashboard-footer-icon-associations=dashboard-footer-icons dashboard-quotes=dashboard-displayed-quotes
      (use-package dashboard
        :straight t
        :demand t
        :commands goto-home-buffer
        :leader
        ("bh" 'goto-home-buffer)

        :init
        (defmacro dashboard-defun-shortcut-function+ (shortcut-char search-label &optional no-next-line)
          "translation of `dashboard-insert-shortcut' but less bizarre."
          (let* ((func-name (intern (concat "dashboard-" shortcut-char "-shortcut"))))
            `(defun ,func-name ()
               (interactive)
               (unless (search-forward ,search-label (point-max) t)
                 (search-backward ,search-label (point-min) t))
               ,@(unless no-next-line
                   '((forward-line 1)))
               (back-to-indentation))))

        :config
        (require 'all-the-icons)

        (push 'dashboard-mode whitespace-exempt-modes)

        (setq inhibit-startup-screen t
              initial-buffer-choice (when (< (length command-line-args) 2)
                                      (lambda () (switch-to-buffer dashboard-buffer-name)))
              dashboard-banner-logo-title "Welcome to Emacs!"
              ;; recents, bookmarks, projects, agenda, registers
              dashboard-items '((recents  . 5)
                                (projects . 7)
                                (agenda   . nil))
              dashboard-center-content nil
              dashboard-set-file-icons t
              dashboard-set-navigator  t
              dashboard-set-init-info  t
              show-week-agenda-p       t
              dashboard-show-shortcuts t
              dashboard-set-heading-icons nil)

        (dashboard-setup-startup-hook)

        ;; determine the appropriate banner to display on the dashboard
        (defun dashboard-select-random-banner+ (&optional arg)
          "Toggle another banner to be used on the dashboard."
          (setq dashboard-startup-banner
                (if (and (not arg) (display-graphic-p))
                    'official                                                         ; prefer official cover.
                  (seq-random-elt
                   (or (file-expand-wildcards
                        (concat +dashboard-banners-directory "*"))
                       '(1 2 3))))))

        ;; for some reason, the font-lock rules for the dashboard don't seem to
        ;; be correct on startup?
        (add-hook 'emacs-startup-hook
                  (lambda (&rest _)
                    (when-let ((dash (get-buffer "*dashboard*")))
                      (with-current-buffer dash
                        (dashboard-refresh-buffer)))))

        (advice-add 'dashboard-refresh-buffer :before
                    (lambda (&rest _)
                      (dashboard-select-random-banner+)))
        (dashboard-select-random-banner+)                                             ; choose initial banner

        ;; goto home buffer, or recreate the home buffer, when appropriate.
        (defun goto-home-buffer ()
          (interactive)
          (let* ((buffer
                  (or (get-buffer dashboard-buffer-name)
                      (and
                        ;; creates dashboard buffer as well
                        (dashboard-insert-startupify-lists)
                        dashboard-buffer-name))))
            (switch-to-buffer buffer)))

        ;; set the navigator button
        (let ((height 0.75)
              (suffix (when (and +icons-available
                                 (not (display-graphic-p)))
                        " ")))
          (setq dashboard-navigator-buttons
                `((;; line 01
                   (,(concat (all-the-icons-faicon "github" :height height :v-adjust 0.0) suffix)
                    "Homepage"
                    "Browse Homepage"
                    (lambda (&rest _)
                      (browse-url "https://github.com/MoHKale")))
                   (,(concat (all-the-icons-faicon "google" :height height :v-adjust 0.0) suffix)
                    "Google"
                    "Browse Google"
                    (lambda (&rest _)
                      (browse-url "https://www.google.co.uk")))
                   (,(concat (all-the-icons-fileicon "org" :height height :v-adjust 0.0) suffix)
                    "Manual"
                    "Browse Emacs Manual"
                    (lambda (&rest _)
                      (browse-url "https://www.gnu.org/software/emacs/manual/html_node/emacs/index.html")))
                   (,(concat (all-the-icons-faicon "cog" :height height :v-adjust 0.0) suffix)
                    "Update Packages"
                    "Update Packages"
                    #'update-installed-packages)
                   (,(propertize "?" 'face '(:inherit default)) ;; needs a face attribute
                    "" "emacs FAQ" #'view-emacs-faq font-lock-builtin-face))))

          ;; determine appropriate footer icon to display alongside quote.
          (let* ((footer-count (length dashboard-footer-icon-associations))
                  (footer-index (random footer-count))
                  (footer-item (nth footer-index dashboard-footer-icon-associations))

                 ;;; extract items from table row
                  (icon-source (nth 0 footer-item))
                  (icon-name   (nth 1 footer-item)))
            (setq dashboard-footer-icon (propertize
                                          (concat (funcall (intern (concat "all-the-icons-" icon-source)) icon-name :height height :v-adjust -0.05)
                                                  suffix)
                                          'face 'font-lock-keyword-face))))

        (setq dashboard-footer (car (nth (random (1- (1+ (length dashboard-quotes))))
                                         dashboard-quotes)))

        (add-hook 'dashboard-mode-hook (lambda () (message nil)))

        (add-hook 'emacs-startup-hook
                  (defun dashboard--startup-handler ()
                    "update dashboard init info."
                    (setq dashboard-init-info
                          (concat
                           "Emacs loaded "
                           (when-let ((count
                                       (cond ((bound-and-true-p package-alist)
                                              (length package-activated-list))
                                             ((bound-and-true-p straight--profile-cache)
                                              (let ((count 0))
                                                (maphash (lambda (key val)
                                                           (when val (setq count (1+ count))))
                                                         straight--success-cache)
                                                count)))))
                             (format "%d packages " count))
                           "in " (emacs-init-time)))

                      ;; don't switch to dashboard on error buffer
                      (unless (eq 1 (length (window-list)))
                        (winum-select-window-1))))

        (advice-add 'dashboard-choose-banner :before-until
                    (defun dashboard-choose-banner-allow-text-banners+ ()
                      "the built in method only supports filepaths to graphical banners."
                      (let ((banner dashboard-startup-banner))
                        (when (and banner
                                   (stringp banner)
                                   (file-exists-p banner))
                          (and (string-equal "txt"
                                             (file-name-extension banner))
                               banner)))))

        :general
        (:keymaps 'dashboard-mode-map
         :states  'motion
         [remap revert-buffer]           'dashboard-refresh-buffer
         [remap evil-next-line]          'dashboard-next-line
         [remap evil-previous-line]      'dashboard-previous-line
         [remap evil-forward-paragraph]  'dashboard-next-section
         [remap evil-backward-paragraph] 'dashboard-previous-section

         "<down-mouse-1>" 'widget-button-click

         "gj"    'dashboard-next-section
         "gk"    'dashboard-previous-section
         "RET"   'dashboard-return
         "TAB"   'widget-forward
         "S-TAB" 'widget-backward

         "r" (dashboard-defun-shortcut-function+ "r" "Recent Files:")
         ;; "m" (dashboard-defun-shortcut-function "m" "Bookmarks:")
         "p" (dashboard-defun-shortcut-function+ "p" "Projects:")
         ;; "e" (dashboard-defun-shortcut-function "e" "Registers:")
         "a" (dashboard-defun-shortcut-function+ "a" (if (bound-and-true-p show-week-agenda-p)
                                                         "Agenda for the coming week:"
                                                       "Agenda for today:"))))
    #+END_SRC

** deft
   Note taking management solution for emacs.

   #+BEGIN_SRC emacs-lisp :tangle (package-yes! deft)
     (use-package deft
       :straight t
       :defer  t
       :leader
       ("od" 'deft)

       :config
       (setq deft-directory (org! "notes"))
       (push 'deft-mode whitespace-exempt-modes)

       (advice-add 'deft-open-file :around 'restore-default-display-buffer-actions)

       (defun deft-find-file-other-window+ ()
         "preview file at point in another window and then select it."
         (interactive)
         (let ((file (deft-filename-at-point)))
           (when file
             (deft-open-file file t t))))

       ;; unbind most of the deft insert bindings.
       (cl-loop for i from ?\s to 256
                do (define-key deft-mode-map (vector i) nil)
                do (define-key deft-mode-map (vector 'insert-state i) 'deft-filter-increment))

       (leader/set-keys-for-major-mode 'deft-mode
         "n" 'deft-new-file
         "a" 'deft-archive-file
         "d" 'deft-delete-file
         "f" 'deft-find-file
         "i" 'deft-toggle-incremental-search
         "r" 'deft-rename-file
         "s" 'deft-toggle-sort-method
         "l" 'deft-filter)

       :general
       (:keymaps 'deft-mode-map
        [remap revert-buffer] 'deft-refresh)
       (:states 'motion
        :keymaps 'deft-mode-map
        "o" 'deft-find-file-other-window+
        "gj" 'widget-forward
        "gk" 'widget-backward

        "i" 'evil-insert-state
        "a" 'evil-insert-state
        "p" 'deft-filter-yank
        "P" 'deft-filter-yank)
       (:states 'insert
        :keymaps 'deft-mode-map
        [escape] 'evil-change-to-initial-state
        "C-w" 'deft-filter-decrement-word)
       (:states '(insert motion)
        :keymaps 'deft-mode-map
        "M-DEL" 'deft-filter-clear
        "M-RET" 'deft-open-file-other-window))
   #+END_SRC

** ebuku
   emacs interface to the [[https://github.com/jarun/buku][buku]] bookmark manager.

   #+BEGIN_SRC emacs-lisp :tangle (package-yes! ebuku)
     (use-package ebuku
       :defer t
       :straight (ebuku :host github :repo "flexibeast/ebuku"))
   #+END_SRC

** edit-indirect
   Open regions of code in their own dedicated buffers, like org modes org-edit-special.

   #+BEGIN_SRC emacs-lisp :tangle (package-yes! edit-indirect)
     (use-package edit-indirect
       :straight t
       :defer  t
       :commands (edit-indirect-region
                  edit-indirect-commit
                  edit-indirect-save
                  edit-indirect-abort)
       :lazy-leader
       (:mode 'edit-indirect--overlay
        :minor t
        :prefix leader-major-mode-prefix
        "," 'edit-indirect-commit
        "s" 'edit-indirect-save
        "q" 'edit-indirect-abort))
   #+END_SRC

** browser-edit
   Invoke emacs-client from a browser... EPIC!!!

   #+BEGIN_SRC emacs-lisp :tangle (package-yes! browser-edit)
     (defvar +browser-edit-package 'edit-with-emacs
       "The extension with which I connect emacs to my browser.
     Set to atomic to use atomic-chrome and edit-with-emacs to use
     edit-with-emacs.

     Personally I prefer edit-with-emacs because it lets you a cancel
     an edit session and revert to the original (or last saved) text.
     It also has the option of binding M-<enter> in chrome to edit with
     emacs.

     Atomic chrome reflects changes live, which is pretty cool if you
     expect emacs to crash whilst writing... but otherwise isn't too
     useful.")

     (defvar +browser-edit-mode initial-major-mode
       "default major mode for a browser edit session.")

     (defvar +browser-edit-mode-alist
       `(("^github.com/" . ,#'markdown-mode)
         ("^gitlab.com/" . ,#'markdown-mode))
       "association list of url regexps against mode-functions.")

     (cond
      ((eq +browser-edit-package 'edit-with-emacs)
       (use-package edit-server
         :straight t
         :defer  120
         :delight
         (edit-server-edit-mode "ESE") ;; emacs server edit
         :init
         (setq edit-server-new-frame nil  ;; prefer current frame
               edit-server-default-major-mode +browser-edit-mode
               edit-server-url-major-mode-alist +browser-edit-mode-alist)

         :config
         (edit-server-start)

         :lazy-leader
         (:mode 'edit-server-edit-mode
          :minor t
          :prefix leader-major-mode-prefix
          "s" 'edit-server-save
          "," 'edit-server-done
          "q" 'edit-server-abort)

         :general
         (:keymaps 'edit-server-edit-mode-map
          [remap evil-write] 'server-edit
          [remap evil-save-and-close] 'server-edit
          [remap evil-quit-all-with-error-code] 'server-abort))

       ;; fixes issues with non conventional input components likes gmails compose box
       (use-package edit-server-htmlize
         :straight t
         :defer  t
         :hook ((edit-server-start . edit-server-maybe-dehtmlize-buffer)
                (edit-server-done  . edit-server-maybe-htmlize-buffer))))

      ((eq +browser-edit-package 'atomic)
       (use-package atomic-chrome
         :straight t
         :defer  30
         :delight
         (atomic-chrome-edit-mode "Atomic")
         :init
         (setq atomic-chrome-default-major-mode   +browser-edit-mode
               atomic-chrome-url-major-mode-alist +browser-edit-mode-alist)

         (atomic-chrome-start-server)

         :lazy-leader
         (:mode 'atomic-chrome-edit-mode
          :minor t
          :prefix leader-major-mode-prefix
          "s" 'atomic-chrome-send-buffer-text
          "," 'atomic-chrome-close-current-buffer)

         :general
         (:keymaps 'edit-server-edit-mode-map
          [remap evil-write] 'atomic-chrome-send-buffer-text
          [remap evil-save-and-close] 'atomic-chrome-close-current-buffer)))

      (+browser-edit-package
       (message "Unknown browser extension package: %s" +browser-edit-package)))
     #+END_SRC

** eglot
   #+BEGIN_SRC emacs-lisp :tangle (package-yes! eglot)
     (use-package eglot
       :straight t
       :defer  t
       :commands (eglot-ensure-maybe+)
       :custom
       (eglot-autoreconnect nil)
       (eglot-stay-out-of '(company))                                                ; I'll set my backends myself, thank you.
       (eglot-ignored-server-capabilites '(:documentHighlightProvider))              ; Prevent eglot highlighting the symbol at point
       (eglot-workspace-configuration
        '((:pyls
           (plugins
            (pydocstyle (enabled . t))
            (jedi_completion
             (fuzzy . t)
             (follow_builtin_imports . :json-false))))))

       :config
       (require 'yasnippet) ;; needed or else snippet expansion won't happen.

       (company/configure-mode (eglot--managed-mode)
         ;; eglot doesn't have it's own company backend
         ;; it just extends capf with lsp completions :smile:.
         company-capf)

       (defun eglot-server-exists-p+ (mode &optional all-workspaces)
         "Assert whether a server exists in the current workspace for MODE.
     When ALL-WORKSPACES is true we instead check for a server running in any
     workspace."
         (seq-find
          (lambda (server)
            (eq (eglot--major-mode server) managed-major-mode))
          (if all-workspaces
              (-flatten (hash-table-values eglot--servers-by-project))
            (gethash (or (project-current) `(transient . ,default-directory))
                     eglot--servers-by-project))))

       (defun eglot-mode-server-p+ ()
         (eglot-server-exists-p+ major-mode))

       (defun eglot-mode-server-all-p+ ()
         (eglot-server-exists-p+ major-mode t))

       (defvar eglot-maybe-connect+ `((python-mode . eglot-mode-server-all-p+)
                                      (sh-mode . t)
                                      (t . eglot-mode-server-p+))
         "Alist mapping major modes to conditions specifying whether we should connect
     to servers or not. The format is (MODE . COND) where MODE can be a mode symbol or
     true (as a fallback). COND can be a symbol (true to always connect, nil to never
     connect) or a function which resolves to a symbol.")

       (defun eglot-ensure-maybe+ ()
         "Call `eglot-ensure' depending on `eglot-maybe-connect+'."
         (when (let ((enable (or (alist-get major-mode eglot-maybe-connect+)
                                 (alist-get t eglot-maybe-connect+))))
                 (cond
                  ((symbolp enable) enable)
                  ((functionp enable) (funcall enable))
                  (t nil)))
           (eglot-ensure)))

       :lazy-leader
       (:mode 'eglot--managed-mode
        :minor t
        ;; aliases for gg and gG
        "jy" 'eglot-find-implementation
        "jY" 'eglot-find-typeDefinition
        "hy" 'eglot-help-at-point)
       (:mode 'eglot--managed-mode
        :minor t
        :prefix leader-server-leader-prefix
        ;; unbound 'eglot-clear-status
        "" "server"
        "a" 'eglot-code-actions
        "e" 'eglot-events-buffer
        "k" 'eglot-shutdown
        "h" 'eglot-help-at-point
        "2" 'eglot-stderr-buffer
        "r" 'eglot-rename
        "f" 'eglot-format
        "F" 'eglot-format-buffer
        "o" 'eglot-reconnect

        "g" "goto"
        "gg" 'eglot-find-implementation
        "gG" 'eglot-find-typeDefinition
        "gd" 'eglot-find-declaration

        "w"  "workspace"
        "wf" 'eglot-forget-pending-continuations
        "wc" 'eglot-signal-didChangeConfiguration))
   #+END_SRC

*** flycheck
    Enable flycheck support with ~eglot~. by default, it only supports flymake.

    #+BEGIN_SRC emacs-lisp :tangle (package-yes! eglot) :tangle no
      (use-package +eglot-flycheck
        :after eglot
        :init
        ;; See [[https://github.com/gagbo/doom-emacs/commit/8e25bdc61eec078d86560d8492b187ca44a14279][here]].
        (advice-add 'eglot-handle-notification :around
                    (defun +eglot-flycheck-mock-flymake-mode (func &rest args)
                      (let ((flymake-mode t))
                        (apply func args))))

        (defun eglot-prefer-flycheck+ ()
          (when eglot--managed-mode
            (when-let ((current-checker (flycheck-get-checker-for-buffer)))
              (unless (equal current-checker 'eglot)
                (flycheck-add-next-checker 'eglot current-checker)))
            (flycheck-add-mode 'eglot major-mode)
            (flycheck-mode 1)
            (flymake-mode -1)))

        (add-hook 'eglot--managed-mode-hook #'eglot-prefer-flycheck+))
    #+END_SRC

    Checker implementation adapted from [[https://github.com/flycheck/flycheck/issues/1592][here]].

    #+BEGIN_SRC emacs-lisp :tangle lisp/+eglot-flycheck.el
      (require 'flycheck)

      ;;; Code:
      (defun flycheck-eglot--start (checker callback)
        "Clean up errors when done.
      CHECKER is the checker (eglot).
      CALLBACK is the function that we need to call when we are done, on all the errors."
        (cl-labels
            ((flymake-diag->flycheck-err
              (diag)
              (with-current-buffer (flymake--diag-buffer diag)
                (flycheck-error-new-at-pos
                 (flymake--diag-beg diag)
                 (pcase (flymake--diag-type diag)
                   ('eglot-note 'info)
                   ('eglot-warning 'warning)
                   ('eglot-error 'error)
                   (_ (error "Unknown diagnostic type, %S" diag)))
                 (flymake--diag-text diag)
                 :end-pos (flymake--diag-end diag)
                 :checker checker
                 :buffer (current-buffer)
                 :filename (buffer-file-name)))))
          ;; NOTE: Setting up eglot to automatically create flycheck errors for the buffer.
          (eglot-flymake-backend (lambda (flymake-diags &rest _)
                                   (funcall callback
                                            'finished
                                            (mapcar #'flymake-diag->flycheck-err flymake-diags))))))

      (defun flycheck-eglot--available-p ()
        (bound-and-true-p eglot--managed-mode))

      (flycheck-define-generic-checker 'eglot
        "Report `eglot' diagnostics using `flycheck'."
        :start #'flycheck-eglot--start
        :predicate #'flycheck-eglot--available-p
        :modes '(prog-mode text-mode))

      (push 'eglot flycheck-checkers)

      (provide '+eglot-flycheck)
    #+END_SRC

** emacs-ipython-notebook
   Org mode is 100% better... prove me wrong :P

   #+BEGIN_SRC emacs-lisp :tangle (package-yes! jupyter)
     (use-package ein
       :straight t
       :defer  t
       :init
       (with-eval-after-load 'org
         (push '(ein . t) org-babel-load-languages))

       :config
       (defun evil-write--ein-save-buffer (&rest args)
         (when (derived-mode-p 'ein:notebook-mode 'ein:notebook-multilang-mode)
           (call-interactively 'ein:notebook-save-notebook-command)
           t))

       (advice-add 'evil-write :before-until #'evil-write--ein-save-buffer)

       :lazy-leader
       (:mode 'ein:notebooklist-mode
        "f" 'ein:file-open
        "n" 'ein:notebook-open
        "r" 'ein:notebooklist-reload)
       (:mode '(ein:notebook-mode ein:notebook-multilang-mode)
        "." 'hydra-ein/body
        "'" 'ein:edit-cell-contents
        leader-major-mode-key 'ein:worksheet-execute-cell

        "c" 'ein:notebook-close
        "f" 'ein:file-open
        "F" 'ein:notebook-open
        "i" 'ein:inspect-object
        "m" 'ein:pytools-request-tooltip-or-help
        "o" 'ein:worksheet-toggle-output
        "p" 'ein:worksheet-yank-cell
        "r" 'ein:notebook-rename-command
        "R" 'ein:notebook-restart-session-command
        ;; "R" 'ein:notebook-reconnect-session-command
        "s" 'ein:notebook-scratchsheet-open
        "w" 'ein:notebook-save-notebook-command
        "y" 'ein:worksheet-copy-cell

        "ts" 'ein:worksheet-toggle-slide-type
        "tc" 'ein:worksheet-toggle-cell-type
        "tC" 'ein:worksheet-change-cell-type
        "gg" 'ein:pytools-jump-to-source-command
        "gb" 'ein:pytools-jump-back-command
        "dc" 'ein:worksheet-kill-cell
        "do" 'ein:worksheet-clear-output
        "dO" 'ein:worksheet-clear-all-output
        "dk" 'ein:notebook-kill-kernel-then-close-command
        "dz" 'ein:notebook-kernel-interrupt-command

        "TAB" 'ein:completer-complete)

       :general
       (:keymaps 'ein:notebooklist-mode-map
        "gr" 'ein:notebooklist-reload
        "<S-tab>"   'widget-backward
        "<backtab>" 'widget-backward
        "TAB"       'widget-forward
        "<tab>"     'widget-forward

        "gn" 'ein:notebooklist-next-item
        "gN" 'ein:notebooklist-prev-item
        "gp" 'ein:notebooklist-prev-item)
       (:keymaps 'ein:notebook-mode-map
        "<C-down>" nil
        "<C-up>"   nil

        "<C-return>" 'ein:worksheet-execute-cell
        "<S-return>" 'ein:worksheet-execute-cell-and-goto-next)
       (:keymaps 'ein:notebook-mode-map
        :states  leader-norm-states
        "go" 'ein:worksheet-insert-cell-above
        "gO" 'ein:worksheet-insert-cell-below
        "gJ" 'ein:worksheet-merge-cell
        ;; "gs" 'ein:worksheet-split-cell-at-point
        "gj" 'ein:worksheet-goto-next-input
        "gk" 'ein:worksheet-goto-prev-input
        "gc" 'ein:worksheet-kill-cell)
       (:keymaps 'ein:notebook-multilang-mode-map
        "<M-down>" 'ein:worksheet-move-cell-down
        "<M-up>"   'ein:worksheet-move-cell-up))
   #+END_SRC

** engine-mode
   :PROPERTIES:
   :header-args+: :tangle (package-yes! engine-mode)
   :END:

   Search engine interaction for emacs. lets you create enteractive functions to run
   search queries on user specified engines. eg. engine/search-google will prompt you
   for a string and then open your default browser on google (having run the query).

   #+BEGIN_SRC emacs-lisp
     (use-package engine-mode
       :straight t
       :defer  t
       :custom
       (engine/browser-function #'xopen-url+))
   #+END_SRC

   Here's a list of all the search-engines my emacs will setup alongside the
   associated keybindings, elisp identifiers and URLs.

   #+NAME: engine-mode-search-engines
   | Search Engine     | Key     | Identifier               | URL                                                                                                               |
   |-------------------+---------+--------------------------+-------------------------------------------------------------------------------------------------------------------|
   | DuckDuckGo        | sed     | duckduckgo               | https://duckduckgo.com/?q=%s                                                                                      |
   | Github            | seG     | github                   | https://github.com/search?ref=simplesearch&q=%s                                                                   |
   | Google            | seg     | google                   | http://www.google.com/search?ie=utf-8&oe=utf-8&q=%s                                                               |
   | GoogleImages      | sei     | google-images            | http://www.google.com/images?hl=en&source=hp&q=%s                                                                 |
   | GoogleMaps        | sem     | google-maps              | http://maps.google.com/maps?q=%s                                                                                  |
   | StackOverflow     | sep     | stack-overflow           | https://stackoverflow.com/search?q=%s                                                                             |
   | Wikipedia         | sew     | wikipedia                | http://www.wikipedia.org/search-redirect.php?language=en&go=Go&search=%s                                          |
   | Youtube           | sey     | youtube                  | http://www.youtube.com/results?aq=f&oq=&search_query=%s                                                           |
   |-------------------+---------+--------------------------+-------------------------------------------------------------------------------------------------------------------|
   | MyAnimeList       | sea SPC | myanimelist              | https://myanimelist.net/search/all?q=%s                                                                           |
   | Anime             | seaa    | myanimelist/anime        | https://myanimelist.net/anime.php?q=%s                                                                            |
   | Manga             | seam    | myanimelist/manga        | https://myanimelist.net/manga.php?q=%s                                                                            |
   | Characters        | seac    | myanimelist/chars        | https://myanimelist.net/character.php?q=%s                                                                        |
   | People            | seap    | myanimelist/people       | https://myanimelist.net/people.php?q=%s                                                                           |
   | News              | sean    | myanimelist/news         | https://myanimelist.net/news/search?q=%s                                                                          |
   | Articles          | seaF    | myanimelist/articles     | https://myanimelist.net/featured/search?q=%s                                                                      |
   | Forums            | seaf    | myanimelist/forums       | https://myanimelist.net/forum/search?u=&uloc=1&loc=-1&q=%s                                                        |
   | Clubs             | seaC    | myanimelist/clubs        | https://myanimelist.net/clubs.php?action=find&cn=%s                                                               |
   | Users             | seau    | myanimelist/users        | https://myanimelist.net/users.php?q=%s                                                                            |
   |-------------------+---------+--------------------------+-------------------------------------------------------------------------------------------------------------------|
   | Nyaa              | senn    | nyaa                     | https://nyaa.si/?f=0&c=0_0&q=%s                                                                                   |
   | NyaaAnime         | sena    | nyaa/anime-english       | https://nyaa.si/?f=0&c=1_2&q=%s                                                                                   |
   | NyaaAnimeAll      | senA    | nyaa/anime               | https://nyaa.si/?f=0&c=1_0&q=%s                                                                                   |
   | NyaaMusic         | senm    | nyaa/music               | https://nyaa.si/?f=0&c=2_0&q=%s                                                                                   |
   | NyaaLiterature    | senl    | nyaa/literature-english  | https://nyaa.si/?f=0&c=3_1&q=%s                                                                                   |
   | NyaaLiteratureAll | senL    | nyaa/literature          | https://nyaa.si/?f=0&c=3_0&q=%s                                                                                   |
   | NyaaLiveAction    | senv    | nyaa/live-action-english | https://nyaa.si/?f=0&c=4_1&q=%s                                                                                   |
   | NyaaLiveActionAll | senV    | nyaa/live-action         | https://nyaa.si/?f=0&c=4_0&q=%s                                                                                   |
   | NyaaImages        | seni    | nyaa/images              | https://nyaa.si/?f=0&c=5_0&q=%s                                                                                   |
   | NyaaSoftware      | sens    | nyaa/software            | https://nyaa.si/?f=0&c=6_0&q=%s                                                                                   |
   | NyaaGames         | seng    | nyaa/games               | https://nyaa.si/?f=0&c=6_2&q=%s                                                                                   |
   |-------------------+---------+--------------------------+-------------------------------------------------------------------------------------------------------------------|
   | CppReference      | spc     | cpp-reference            | https://en.cppreference.com/mwiki/index.php?title=Special%%3ASearch&search=%s                                     |
   | Github            | spg     | github                   | https://github.com/search?q=%s                                                                                    |
   | Go                | sp9     | godoc                    | https://godoc.org/?q=%s                                                                                           |
   | JavaDocs          | spj     | java-oracle-docs         | https://www.google.com/search?q=%s+site%%3Ahttps%%3A%%2F%%2Fdocs.oracle.com%%2Fen%%2Fjava%%2Fjavase%%2F15%%2Fdocs |
   | MozillaMDN        | spm     | mozilla-mdn              | https://developer.mozilla.org/en-US/search?q=%s                                                                   |
   | Qt5               | spq     | qt5                      | https://doc.qt.io/qt-5/search-results.html?q=%s                                                                   |
   | RubyDoc           | spr     | ruby-doc                 | https://ruby-doc.com/search.html?q=%s                                                                             |
   | Rust              | spu     | rust                     | https://doc.rust-lang.org/std/?search=%s                                                                          |
   | Python            | spp     | python                   | https://docs.python.org/3/search.html?q=%s                                                                        |
   | W3SchoolsColors   | spx     | w3schools-colors         | https://www.w3schools.com/colors/colors_converter.asp?color=%s                                                    |

   Lastly heres some prefix keys (leader prefixes) that don't connect to commands,
   but to groups of commands.

   #+NAME: engine-mode-prefix-names
   | prefix | name         |
   |--------+--------------|
   | se     | engines      |
   | sen    | Nyaa         |
   | sea    | MyAnimeList  |
   | sp     | prog-engines |

   Okay now let's make emacs actually setup these engine commands and bindings.

   #+BEGIN_SRC emacs-lisp :var engines=engine-mode-search-engines
     (setq engines (cdr engines)) ;; strip header row

     (defvar engine-engines+ nil
       "alist of search engines keys and functions.")

     ;; Assign leader keys and setup autoloads for each searcher.
     (cl-loop for (engine key id-str) in engines
              with id-sym = nil
              do (setq id-sym (intern
                               (concat "engine/search-" id-str)))
              when (string-empty-p engine)
                do (setq engine id-str)
              do (progn
                   (when key
                     (leader/set-keys key (cons engine id-sym)))
                   (autoload id-sym "engine-mode.el" nil t)))

     (with-eval-after-load 'engine-mode
       (cl-loop for (name - id-str query) in engines
                with id-sym = nil
                when (and id-str query)
                  do (setq id-sym (intern id-str))
                  and do (eval
                          `(defengine ,id-sym ,query))
                  and do (cl-pushnew (cons (or name id-str) (engine/function-name id-sym))
                                     engine-engines+)))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp :var prefix-aliases=engine-mode-prefix-names
     (eval
      `(leader/set-keys
         ,@(cl-loop for (prefix name) in prefix-aliases
                    collect prefix collect name)))
   #+END_SRC

   Lets create a command to interactively select and execute a search engine.

   #+BEGIN_SRC emacs-lisp
     (defun engine-search+ ()
       (interactive)
       (call-interactively
        (alist-get (completing-read "Engine: " engine-engines+)
                   engine-engines+ nil nil #'string-equal)))

     (leader/set-keys "ses" 'engine-search+)
   #+END_SRC
** expand-region
   #+BEGIN_SRC emacs-lisp :tangle (package-yes! expand-region)
     (use-package expand-region
       :straight t
       :defer  t
       :general
       (:states 'visual
        "g SPC" 'er/expand-region))
   #+END_SRC

** flycheck
   On the fly syntax checker for emacs. finds where you've written bugs, adds an icon
   to the fringe and underlines it.

   #+BEGIN_SRC emacs-lisp :tangle (package-yes! flycheck)
     (use-package flycheck
       :straight t
       :defer  t
       :diminish flycheck-mode
       :config
       (setq flycheck-python-pycompile-executable "python3")
       (setq-default flycheck-disabled-checkers '(emacs-lisp-checkdoc))

       (require '+flycheck-fringe)

       (use-package flycheck-pos-tip
         :straight t
         :defer  t
         :hook (flycheck-mode-hook . flycheck-pos-tip-mode)
         :commands flycheck-pos-tip-mode)

       ;; automatically jump to first error when listing errors.
       (defun flycheck-list-errors--goto-first-error (func &rest args)
         (let ((flycheck-buffer (get-buffer "*Flycheck errors*")))
           (apply func args) ;; call flycheck-list-errors
           (unless flycheck-buffer
             (flycheck-error-list-goto-first-error))))

       (advice-add 'flycheck-list-errors :around #'flycheck-list-errors--goto-first-error)

       :leader
       ("e." 'hydra-flycheck/body
        "ej" 'flycheck-next-error
        "ek" 'flycheck-previous-error
        "ex" 'flycheck-clear
        "ed" 'flycheck-explain-error-at-point
        "er" 'flycheck-buffer
        "eh" 'flycheck-describe-checker
        "ea" 'flycheck-first-error
        "el" 'flycheck-list-errors
        ;; "eC" 'flycheck-set-checker-executable
        ;; "ev" 'flycheck-verify-setup
        "ec" 'flycheck-select-checker)

       :lazy-leader
       (:mode 'flycheck-error-list-mode
        "e" 'flycheck-error-list-explain-error
        "s" 'flycheck-error-list-check-source                                        ; syntax check buffer
        "f" 'flycheck-error-list-follow-mode
        "l" 'flycheck-error-list-set-filter
        "r" 'flycheck-error-list-reset-filter)

       :general
       (:keymaps 'flycheck-error-list-mode-map
        :states  'motion
        "RET" 'flycheck-error-list-goto-error
        "s" 'tabulated-list-sort

        "gj" 'flycheck-error-list-next-error
        "gk" 'flycheck-error-list-previous-error

        "gs" 'flycheck-error-list-check-source))
   #+END_SRC

*** commands
    #+BEGIN_SRC emacs-lisp
      (use-package +flycheck-commands
        :commands (toggle-flycheck-messages
                   flycheck-last-error
                   flycheck-error-list-goto-first-error
                   flycheck-error-list-goto-last-error
                   flycheck-error-list-goto-error-or-eob+
                   flycheck-error-list-follow-mode)
        :leader
        ("es" 'flycheck-last-error
         "e DEL" 'toggle-flycheck-messages)

        :general
        (:keymaps 'flycheck-error-list-mode-map
         :states  'motion
         "gh" 'flycheck-error-list-goto-first-error
         "gl" 'flycheck-error-list-goto-last-error))
    #+END_SRC

    #+BEGIN_SRC emacs-lisp :tangle lisp/+flycheck-commands.el
      (defvar-local flycheck-original-display-errors-function nil
        "the value of `flycheck-display-errors-function' before being toggled
      by `toggle-flycheck-messages'.")

      (defun toggle-flycheck-messages (&optional prefix)
        (interactive "P")
        (let ((enabling
               (cond
                (prefix
                 (not (zerop (prefix-numeric-value prefix))))
                (t flycheck-original-display-errors-function))))
          (when (and enabling
                     (not flycheck-original-display-errors-function))
            (user-error "trying to restore a non-existant error function"))

          (if enabling
              (setq flycheck-display-errors-function flycheck-original-display-errors-function
                    flycheck-original-display-errors-function nil)
            (setq flycheck-original-display-errors-function flycheck-display-errors-function
                  flycheck-display-errors-function nil))

          (message "%s flycheck messages"
                   (if enabling
                       (propertize "enabled" 'face 'compilation-info)
                     (propertize "disabled" 'face 'compilation-error)))))

      (defun flycheck-last-error ()
        (interactive)
        (goto-char (point-max))
        (flycheck-previous-error))

      (defun flycheck-error-list-goto-first-error ()
        (interactive)
        (goto-char (point-min))
        (flycheck-error-list-next-error 1)
        (flycheck-error-list-previous-error 1))

      (defun flycheck-error-list-goto-last-error ()
        (interactive)
        (goto-char (point-max))
        (flycheck-error-list-previous-error 1))

      (evil-define-motion flycheck-error-list-goto-error-or-eob+ (count)
        :jump t
        :type line
        (if (null count)
            (flycheck-error-list-goto-last-error)
          (flycheck-goto-line count)))

      (define-minor-mode flycheck-error-list-follow-mode
        "minor mode for `flycheck-error-list-mode' which toggles the behaviour
      of evil forward-line/goto-line functions to use their flycheck variants."
        nil
        "flyfollow"
        '(([remap evil-next-line]       . flycheck-error-list-next-error)
          ([remap evil-previous-line]   . flycheck-error-list-previous-error)
          ([remap evil-goto-first-line] . flycheck-error-list-goto-first-error)
          ([remap evil-goto-line]       . flycheck-error-list-goto-error-or-eob+)))

      (provide '+flycheck-commands)
    #+END_SRC

*** fringe
    #+BEGIN_SRC emacs-lisp :tangle lisp/+flycheck-fringe.el
      ;; update fringe for flycheck [[https://github.com/syl20bnr/spacemacs/blob/master/layers/%2Bcheckers/syntax-checking/packages.el][src]].
      (define-fringe-bitmap '+flycheck-fringe-indicator
        (vector #b00000000
                #b00000000
                #b00000000
                #b00000000
                #b00000000
                #b00000000
                #b00000000
                #b00011100
                #b00111110
                #b00111110
                #b00111110
                #b00011100
                #b00000000
                #b00000000
                #b00000000
                #b00000000
                #b00000000))

      (let ((bitmap '+flycheck-fringe-indicator))
        (flycheck-define-error-level 'error
          :severity 2
          :overlay-category 'flycheck-error-overlay
          :fringe-bitmap bitmap
          :fringe-face 'flycheck-fringe-error)
        (flycheck-define-error-level 'warning
          :severity 1
          :overlay-category 'flycheck-warning-overlay
          :fringe-bitmap bitmap
          :fringe-face 'flycheck-fringe-warning)
        (flycheck-define-error-level 'info
          :severity 0
          :overlay-category 'flycheck-info-overlay
          :fringe-bitmap bitmap
          :fringe-face 'flycheck-fringe-info))

      (provide '+flycheck-fringe)
    #+END_SRC

** frog-jump-buffer
   Display an avy like popup of your most recent buffers and then jump to it.
   now that I have ibuffer and ~counsel-switch-buffer~, I don't really need it.

   #+BEGIN_SRC emacs-lisp :tangle (package-yes! frog-jump-buffer)
     (use-package frog-jump-buffer
       :straight t
       :defer  t
       :leader
       ("jb" 'frog-jump-buffer))
   #+END_SRC

** ggtags
   #+BEGIN_SRC emacs-lisp :tangle (package-yes! ggtags)
     (use-package ggtags
       :straight t
       :defer  t
       :leader
       ("T"  "tags"
        "TD" 'ggtags-delete-tags
        "T/" 'ggtags-grep)

       :lazy-leader
       (:mode 'ggtags-global-mode                                                    ; NOTE ggtags-global-mode is not a global mode... global is for GNU *global* tagging system
        "r" 'recompile
        "f" 'next-error-follow-minor-mode))
   #+END_SRC

** hide-comnt
   Toggles the display of comments in the current buffer.

   #+BEGIN_SRC emacs-lisp :tangle (package-yes! hide-comnt)
     (use-package hide-comnt
       :straight (hide-comnt :host github :repo "emacsmirror/hide-comnt")
       :defer t
       :leader
       ("t/" 'hide/show-comments-toggle))
   #+END_SRC

** link-hint
   An alternative to [[*ace-link][ace-link]] with support for more flexible link sources.

   #+BEGIN_SRC emacs-lisp :tangle (package-yes! link-hint)
     (use-package link-hint
       :straight t
       :defer  t
       :leader
       ("j RET" 'link-hint-open-link
        "j y" 'link-hint-copy-link)

       :config
       ;; support rustic compilation related modes.
       (link-hint-define-type 'compilation-link
         :vars (append
                (get 'link-hint-compilation-link :vars)
                '(rustic-compilation-mode
                  rustic-cargo-test-mode))))
   #+END_SRC

** lsp-mode
   :PROPERTIES:
   :header-args+: :tangle (package-yes! lsp-mode)
   :END:

   #+BEGIN_SRC emacs-lisp
     (use-package lsp-mode
       :straight t
       :defer  t
       :custom
       (lsp-auto-guess-root t)
       (lsp-prefer-flymake nil)
       (lsp-enable-snippet t)
       ;; (lsp-auto-configure nil)
       (lsp-modeline-diagnostics-enable nil)
       (lsp-enable-symbol-highlighting nil)
       (lsp-eldoc-render-all t)
       (lsp-enable-xref t)
       (lsp-headerline-breadcrumb-enable nil)
       (lsp-session-file (var! "lsp/session"))
       (lsp-server-install-dir (var! "lsp/servers"))

       :config
       (setq lsp-map+ (make-sparse-keymap))

       :general
       (:keymaps 'lsp-mode-map
        [remap display-local-help] 'lsp-describe-thing-at-point)

       :lazy-leader
       (:mode 'lsp-mode
        :minor t
        "jy" 'lsp-goto-type-definition
        "jY" 'lsp-goto-implementation)
       (:mode 'lsp-mode
        :minor t
        :prefix leader-server-leader-prefix
        "" "server"

        "?"   'lsp-describe-session
        "|"   'lsp-describe-thing-at-point
        "a"   'lsp-execute-code-action
        "h"   'lsp-document-highlight
        "DEL" 'lsp-disconnect

        "w"  "workspace"
        "wR" 'lsp-restart-workspace
        "wa" 'lsp-workspace-folders-add
        "wr" 'lsp-workspace-folders-remove
        "ws" 'lsp-workspace-folders-switch

        "l"  "lens"
        "ll" 'lsp-lens-mode
        "ls" 'lsp-lens-show
        "lh" 'lsp-lens-hide

        "r"  "refactor"
        "rr" 'lsp-format-buffer
        "ri" 'lsp-organize-imports
        "rc" 'lsp-rename

        "g"  "goto"
        "gg" 'lsp-goto-type-definition
        "gG" 'lsp-goto-implementation
        "gF" 'lsp-find-implementation
        "gf" 'lsp-find-type-definition))
   #+END_SRC

*** lsp-ui
    UI enhancements for lsp sessions... tries to make emacs more like VS Code. Boooooo!!!

    #+BEGIN_SRC emacs-lisp
      (use-package lsp-ui
        :straight t
        :defer  t
        ;; :hook (lsp-mode-hook . lsp-ui-mode)
        :after lsp-mode
        :config
        ;; only really installed for flycheck support
        (setq lsp-ui-sideline-enable nil
              lsp-ui-doc-enable nil)

        :lazy-leader
        (:mode 'lsp-mode
         :minor t
         :prefix leader-server-leader-prefix
         "p"  "peek"
         "pg" 'lsp-ui-peek-find-definitions
         "pG" 'lsp-ui-peek-find-definitions))
    #+END_SRC

*** dap-mode
    #+BEGIN_SRC emacs-lisp
      (use-package dap-mode
        :straight t
        :defer  t)
    #+END_SRC

** magit
   :PROPERTIES:
   :header-args+: :tangle (package-yes! magit)
   :END:

   A git porcelain in emacs.

   #+BEGIN_SRC emacs-lisp
     (use-package evil-magit
       :straight t
       :demand t
       :init
       (setq evil-magit-state 'motion
             evil-magit-use-y-for-yank t
             evil-magit-emacs-to-default-state-modes nil)

       :general
       ;; prevent evil-window-map overriding emacs-window-map
       (:states `(,evil-magit-state visual)
        :keymaps 'magit-mode-map
        "C-w" nil))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (use-package magit
       :straight t
       :defer  t
       :init
       (setq magit-revision-show-gravatars  '("^Author:     " . "^Commit:     ")
             ;; show magit status in a full screen window.
             magit-display-buffer-function 'magit-display-buffer-fullframe-status-v1)

       :config
       (require 'transient)

       (add-hook 'magit-mode-hook
                 (defun magit-cleanup-defaults+ ()
                   ;; messes up alignment on rescroll
                   (setq-local scroll-conservatively 0)))

       (add-hook 'git-commit-mode-hook
                 (defun magit-initialise-commit+ ()
                   (setq fill-column 72)))
       (advice-add 'magit-section-up :around
                   (defun magit-section-up--adjust-destination (func &rest args)
                     (cond
                      ((magit-diff-inside-hunk-body-p)
                       (magit-section-goto (magit-current-section)))
                      (t (apply func args)))))

       (setq whitespace-exempt-modes
             (append '(magit-status-mode
                       magit-process-mode
                       magit-log-mode
                       magit-diff-mode)
                     whitespace-exempt-modes))

       :leader
       (:prefix "g"
        ""  "magit"
        "$" 'magit-process-buffer
        "!" 'magit-run
        "g" 'magit-dispatch
        "s" 'magit-status
        "u" 'magit-unstage-file
        "h" 'magit-log-buffer-file)

       :lazy-leader
       (:mode 'magit-status-mode
        "z" 'magit-jump-to-stashes
        "u" 'magit-jump-to-unstaged
        "s" 'magit-jump-to-staged
        "f" 'magit-jump-to-untracked)
       (:mode 'magit-log-select-mode
        "," 'magit-log-select-pick
        "q" 'magit-log-select-quit)
       (:mode 'git-commit-mode
        :minor t
        :prefix leader-major-mode-prefix
        "s"  'git-commit-save-message
        "d"  'magit-diff-while-committing
        "j"  'git-commit-next-message
        "k"  'git-commit-prev-message

        "i"  "insert"
        "ia" 'git-commit-ack ;; knowledgement
        "iS" 'git-commit-suggested
        "im" 'git-commit-modified
        "ic" 'git-commit-cc
        "ir" 'git-commit-reported
        "iR" 'git-commit-review
        "is" 'git-commit-signoff
        "it" 'git-commit-test)

       :general
       (:states evil-magit-state
        :keymaps 'magit-section-mode-map
        "gh" 'magit-section-up
        "gl" 'magit-section-forward
        "gj" 'magit-section-forward-sibling
        "gk" 'magit-section-backward-sibling)
       (:states evil-magit-state
        :keymaps 'magit-diff-mode-map
        "gh" 'magit-section-up)
       (:keymaps '(magit-mode-map magit-diff-mode-map)
        leader-key nil                                                               ; GIVE ME BACK MY LEADER!!!
        "C-w" emacs-window-map)
       (:keymaps 'magit-mode-map
        "M-j" 'magit-section-forward-sibling
        "M-k" 'magit-section-backward-sibling

        ;; ;; toggle children doesn't seem to work
        ;; "C-r" 'magit-section-hide-children ; recursive close
        ;; "C-e" 'magit-section-show-children ; recursive expand
        ;; "M-r" 'magit-section-hide-children ; Meta aliases
        ;; "M-e" 'magit-section-show-children ; Meta aliases

        ;; visit and expand
        "RET"   'magit-section-toggle
        "TAB"   'magit-section-toggle
        "M-RET" 'magit-visit-thing)
       (:keymaps 'magit-log-mode-map
        "RET" 'magit-visit-thing))
   #+END_SRC

*** git-rebase
    major mode for editing rebase files. bundled with magit... even though it's not
    prefixed ~magit-~.

    #+BEGIN_SRC emacs-lisp
      (use-package git-rebase
        :config
        ;; (leader/set-keys-for-major-mode 'git-rebase-mode
        ;;   "x" 'git-rebase-kill-line
        ;;   )

        :general
        (:keymaps 'git-rebase-mode-map "SPC" nil)                                     ; reclaim leader key
        (;; git-rebase-show-or-scroll-up
         ;; git-rebase-show-or-scroll-down
         :keymaps 'git-rebase-mode-map
         :states  'motion
         "RET" 'git-rebase-show-commit))
    #+END_SRC

*** magit-todos
    #+BEGIN_SRC emacs-lisp
      (use-package magit-todos
        :straight t
        :defer  t
        :after  magit
        :hook (magit-mode . magit-todos-mode)
        :lazy-leader
        (:mode 'magit-status-mode
         "T" 'magit-todos-list
         "t" 'magit-todos-jump-to-todos)

        :general
        (:keymaps '(magit-todos-item-section-map magit-todos-section-map)
         "j" nil "B" nil "b" nil))
    #+END_SRC

*** magit-gitflow
    #+BEGIN_SRC emacs-lisp
      (use-package magit-gitflow
        :straight t
        :defer  t
        :after  (magit--handle-bookmark magit)
        :hook (magit-mode . turn-on-magit-gitflow)
        :delight
        (magit-gitflow-mode "GitFlow")

        :general
        (:keymaps 'magit-mode-map
         "%" 'magit-gitflow-popup))
    #+END_SRC

*** transient
    #+BEGIN_SRC emacs-lisp
      (use-package transient
        :straight t
        :defer  t
        :config
        (setq transient-history-file (var! "transient/history.el")
              transient-values-file  (etc! "transient/values.el")
              transient-levels-file  (etc! "transient/levels.el"))

        :general
        ;; escape means quit too
        (:keymaps 'transient-base-map
         "ESC"      'transient-quit-one
         "<escape>" 'transient-quit-one))
    #+END_SRC

** olivetti
   A nice writing environment for emacs :)

   #+BEGIN_SRC emacs-lisp :tangle (package-yes! olivetti)
     (use-package olivetti
       :straight t
       :defer  t
       :commands olivetti-setup-buffer
       :hook (olivetti-mode . olivetti-setup-buffer)
       :init
       (defvar olivetti-hide-fringe+ nil
         "when true, olivetti mode will hide the window fringe.")

       :config
       (add-hook 'olivetti-mode-hook
                 (defun olivetti-setup-buffer ()
                   "hide line numbers and the fringe."
                   (display-line-numbers-mode
                    (if olivetti-mode -1 +1))

                   (eval
                    `(set-window-fringes
                      (selected-window)
                      ,@(if (and olivetti-mode
                                 olivetti-hide-fringe+)
                            '(0 0)
                          '(8 8))))))


       :leader
       ("M'" 'olivetti-mode)

       :lazy-leader
       ((concat leader-minor-mode-leader-prefix "-") 'olivetti-set-width)

       :general
       (:keymaps 'olivetti-mode-map
        "C-c >" #'olivetti-expand
        "C-c <" #'olivetti-shrink))
   #+END_SRC

** pdftools
   :PROPERTIES:
   :header-args+: :tangle (package-yes! pdf-tools)
   :END:

   Use emacs as a quick and dirty pdf viewer.

   #+BEGIN_SRC emacs-lisp
     (use-package pdf-tools
       :straight t
       :defer  t
       :mode ("\\.pdf$" . pdf-view-mode)
       ;; see [[https://www.reddit.com/r/emacs/comments/6g15nk/pdftools_latex_freeze/][here]].
       :hook (pdf-view-mode . (lambda ()
                                (line-number-mode -1)))
       :config
       (setq-default pdf-view-display-size 'fit-page)

       ;; only accepts absolute paths and doesn't automatically append ".exe" when on windows.
       (eval-when-compile
         (let ((epdfinfo-program (expand-file-name (var! "pdf-tools/epdfinfo"))))
           (when (windows-p)
             (setq epdfinfo-program (concat epdfinfo-program ".exe")))
           (setq pdf-info-epdfinfo-program epdfinfo-program)))

       (evil-set-initial-state 'pdf-view-mode 'motion)

       ;; (pdf-tools-install)

       (require '+pdf-tools-bindings))
   #+END_SRC

*** bindings
    #+BEGIN_SRC emacs-lisp :tangle lisp/+pdf-tools-bindings.el
      (general-define-key
       :keymaps 'pdf-view-mode-map
       :states 'motion
       ;; "RET" 'image-next-line
       "TAB" 'pdf-outline
       ;; TODO make interactive ivy-based outline

       "w" 'pdf-view-fit-height-to-window
       "e" 'pdf-view-fit-width-to-window
       "E" 'pdf-view-fit-page-to-window

       "J" 'pdf-view-next-page-command
       "K" 'pdf-view-previous-page-command

       "gj" 'image-next-line
       "gk" 'image-previous-line

       "h" 'evil-scroll-column-left
       "l" 'evil-scroll-column-right

       ;; "C-j" 'pdf-view-next-page-command
       ;; "C-k" 'pdf-view-previous-page-command

       ;; "]]" 'pdf-view-next-page-command
       ;; "[[" 'pdf-view-previous-page-command

       "H" 'beginning-of-buffer
       "L" 'end-of-buffer

       "=" 'pdf-view-scale-reset
       "+" 'pdf-view-enlarge
       "-" 'pdf-view-shrink

       "C-d" 'pdf-view-scroll-up-or-next-page
       "C-u" 'pdf-view-scroll-down-or-previous-page

       "m" 'pdf-view-position-to-register
       "'" 'pdf-view-jump-to-register
       "`" 'pdf-view-jump-to-register

       "q" nil
       "Q" 'kill-this-buffer)

      (general-define-key
       :keymaps 'pdf-view-mode-map
       :states 'visual
       "y" 'pdf-view-kill-ring-save)

      (leader/set-keys-for-major-mode 'pdf-view-mode
        "l" 'pdf-view-goto-label
        "o" 'pdf-occur

        ;; modify the display of the PDF.
        "TAB" 'doc-view-mode
        "d" 'pdf-view-dark-minor-mode
        "D" 'pdf-view-midnight-minor-mode
        "p" 'pdf-view-printer-minor-mode

        ;; narrow to a subslice of the given page.
        "s"  "slice"
        "sm" 'pdf-view-set-slice-using-mouse
        "ss" 'pdf-view-set-slice-from-bounding-box
        "sr" 'pdf-view-reset-slice)

      (evil-set-initial-state 'pdf-outline-buffer-mode 'motion)

      (general-define-key
       :states  'motion
       :keymaps 'pdf-outline-buffer-mode-map
       "o" 'pdf-outline-display-link
       "sa" 'show-all
       "ss" 'show-subtree
       "sh" 'hide-subtree
       "sn" 'hide-subtree
       "gh" 'pdf-outline-up-heading
       "gk" 'outline-backward-same-level
       "gj" 'outline-forward-same-level
       "gl" 'outline-next-heading
       "gd" 'outline-hide-entry
       "g SPC" 'pdf-outline-select-pdf-window

       "<C-return>" 'pdf-outline-follow-link
       "M-RET" 'pdf-outline-display-link
       "RET" 'pdf-outline-follow-link-and-quit
       ;; goto current page in the outline window
       "gp" 'pdf-outline-move-to-current-page

       "<C-tab>" 'hide-sublevels
       "<C-up>" 'outline-move-subtree-up
       "<C-down>" 'outline-move-subtree-down)

      (leader/set-keys-for-major-mode 'pdf-outline-buffer-mode
        "f" 'pdf-outline-follow-mode
        "m" 'outline-mark-subtree)

      (evil-set-initial-state 'pdf-occur-buffer-mode 'motion)

      (defvar pdf-occur-buffer-mode-map (make-sparse-keymap))
      (general-define-key
       :states  'motion
       :keymaps 'pdf-occur-buffer-mode-map
       ;; unbound: tablist-export-csv
       "RET" 'pdf-occur-goto-occurrence
       "s" 'pdf-occur-view-occurrence
       "o" 'pdf-occur-view-occurrence
       "d" 'tablist-do-kill-lines
       "x" 'pdf-occur-tablist-do-flagged-delete
       "<backtab>" 'tablist-backward-column
       "DEL" 'tablist-unmark-backward

       [remap evil-first-non-blank] 'tablist-move-to-major-column
       [remap evil-next-line] 'tablist-next-line
       [remap evil-previous-line] 'tablist-previous-line

       "gr" 'pdf-occur-revert-buffer-with-args

       "A" 'pdf-occur-tablist-gather-documents
       "D" 'pdf-occur-tablist-do-delete

       "S" 'tabulated-list-sort
       "gS" 'tablist-revert

       "m" 'tablist-mark-forward
       "~" 'tablist-toggle-marks
       "u" 'tablist-unmark-forward
       "U" 'tablist-unmark-all-marks
       "*m" 'tablist-mark-forward
       "*!" 'tablist-unmark-all-marks
       "*c" 'tablist-change-marks
       "*n" 'tablist-mark-items-numeric
       "*r" 'tablist-mark-items-regexp
       "*%" 'tablist-mark-items-regexp

       "a" 'tablist-flag-forward

       [remap quit-window]  'tablist-quit
       "ZQ" 'tablist-quit
       "ZZ" 'tablist-quit)

      (leader/set-keys-for-major-mode 'pdf-occur-buffer-mode
        "/!" 'tablist-negate-filter
        "//" 'tablist-display-filter
        "/=" 'tablist-push-equal-filter
        "/C" 'tablist-clear-filter
        "/D" 'tablist-delete-named-filter
        "/a" 'tablist-push-named-filter
        "/d" 'tablist-deconstruct-named-filter
        "/e" 'tablist-edit-filter
        "/n" 'tablist-push-numeric-filter
        "/p" 'tablist-pop-filter
        "/r" 'tablist-push-regexp-filter
        "/s" 'tablist-name-current-filter
        "/t" 'tablist-toggle-first-filter-logic
        "/z" 'tablist-suspend-filter)

      (require '+pdf-tools-commands)
      (provide '+pdf-tools-bindings)
    #+END_SRC

*** commands
    #+BEGIN_SRC emacs-lisp
      (use-package +pdf-tools-commands
        :lazy-leader
        (:mode 'pdf-view-mode
         "g" 'counsel-pdf-outline)

        :general
        (:keymaps 'pdf-view-mode-map
         :states  'motion
         "j"  'pdf-view-next-line-or-next-page-with-prefix
         "k"  'pdf-view-prev-line-or-prev-page-with-prefix
         "gg" 'pdf-view-goto-first-page-with-prefix
         "G"  'pdf-view-goto-page-with-prefix))
    #+END_SRC

    #+BEGIN_SRC emacs-lisp :tangle lisp/+pdf-tools-commands.el
      ;; functions ripped from evil-collection
      (defun pdf-view-next-line-or-next-page-with-prefix (&optional count)
        "'evil' wrapper include a count argument to `pdf-view-next-line-or-next-page'"
        (interactive "p")
        (if count
            (dotimes (_ count nil)
              (pdf-view-next-line-or-next-page 1))
          (pdf-view-next-line-or-next-page 1)))

      (defun pdf-view-prev-line-or-prev-page-with-prefix (&optional count)
        "'evil' wrapper include a count argument to `pdf-view-previous-line-or-previous-page'"
        (interactive "p")
        (if count
            (dotimes (_ count nil)
              (pdf-view-previous-line-or-previous-page 1))
          (pdf-view-previous-line-or-previous-page 1)))

      (defun pdf-view-goto-page-with-prefix (&optional page)
        "`evil' wrapper around `pdf-view-last-page'."
        (interactive "P")
        (if page
            (pdf-view-goto-page page)
          (pdf-view-last-page)
          (image-eob)))

      (defun pdf-view-goto-first-page-with-prefix (&optional page)
        "`evil' wrapper around `pdf-view-first-page'."
        (interactive "P")
        (if page
            (pdf-view-goto-page page)
          (pdf-view-first-page)
          (image-bob)))

      ;; use counsel to go to an outline entry
      (defun counsel-pdf-outline-action (entry)
        (let ((line (cdr entry)))
          (with-current-buffer (ivy-state-buffer ivy-last)
            (save-excursion
              (goto-line (1+ line)) ;; was starting from 0.
              (call-interactively #'pdf-outline-follow-link)))))

      (defun counsel-pdf-outline ()
        (interactive)
        (require 'pdf-outline)
        (let* ((buffer (pdf-outline-noselect nil))
               entries)
          (with-current-buffer buffer
            (setq entries
                  (split-string
                   (buffer-substring-no-properties
                    (point-min) (point-max))
                   "\n"))

            (cond ((package! ivy)
                   (ivy-read "Title: "
                             (-zip entries
                                   (number-sequence 0 (length entries)))
                             :action #'counsel-pdf-outline-action
                             :caller 'counsel-pdf-outline))
                  (t (message "Completion framework not supported"))))))

      (provide '+pdf-tools-commands)
    #+END_SRC

** piper
   #+BEGIN_SRC emacs-lisp :tangle (package-yes! piper)
     (use-package piper
       :defer t
       :straight (emacs-piper :host gitlab :repo "howardabrams/emacs-piper")
       :commands (piper-ui)
       :leader
       (:prefix "|"
        ""    "piper"
        "RET" 'piper-ui
        "|"   'piper
        "o"   'piper-other
        "@"   'piper-remote)

       :config
       (defalias 'piper-ui #'piper-user-interface))
   #+END_SRC

** rake
   #+BEGIN_SRC emacs-lisp :tangle (package-yes! rake)
     (use-package rake
       :straight t
       :defer  t
       :commands (rake-refresh)
       :leader
       ("cr" 'rake
        "cR" 'rake-rerun)

       :config
       (setq rake-completion-system 'ivy-read
             rake-cache-file (var! "rake.cache"))

       (defalias 'rake-refresh #'rake-regenerate-cache))
   #+END_SRC

** skeletor
   :PROPERTIES:
   :header-args+: :tangle (package-yes! skeletor)
   :END:

   Project skeleton [[https://github.com/chrisbarrett/skeletor.el][unpacker]] in emacs-lisp.

   #+BEGIN_SRC emacs-lisp
     (use-package skeletor
       :straight t
       :defer  t
       :commands (skeletor-create-project+
                  skeletor-expand-project+)
       :leader
       ("pm" 'skeletor-expand-project+)

       :custom
       (skeletor-user-directory (etc! "project-skeletons"))
       (skeletor-project-directory (expand-file-name  "~/prog/repos"))
       (skeletor-completing-read-function 'completing-read
        "Make skeletor defer to the current completion framework.")
       (skeletor-show-project-command
        (defun skeletor-show-project-command+ (dir)
          "Skeletor show project directory in different window."
          (display-buffer (dired-noselect dir)
                          '((display-buffer-reuse-window
                             display-buffer--maybe-pop-up-frame-or-window
                             display-buffer-use-some-window
                             display-buffer-pop-up-frame)))))

       :config
       ;; Fix issues with the base ruby gem project skeleton. See [[https://github.com/chrisbarrett/skeletor.el/issues/45][#45]].
       (skeletor-define-constructor "Ruby Gem"
         :requires-executables '(("bundle" . "http://bundler.io"))
         :no-license? t
         :no-license? t
         :initialise
         (lambda (spec)
           (let-alist spec
             (let ((flags (list
                           "--no-coc" ;; code of conduct
                           (concat "--test=" (shell-quote-argument
                                              (funcall skeletor-completing-read-function
                                                       "Testing framework: " '("minitest" "rspec"))))
                           (concat "--" (unless (yes-or-no-p "Apply an MIT License") "no-") "mit"))))
               (skeletor-shell-command (format "bundle gem %s %s"
                                               (string-truncate-right!
                                                (cl-loop for f in flags concat f concat " "))
                                               (shell-quote-argument .project-name))
                                       .project-dir)))))

       (advice-add 'skeletor--initialize-git-repo :override
                   (defun skeletor--initialize-git-repo+  (dir)
                     "Override of `skeletor--initialize-git-repo' which produces only one initial commit."
                     (let ((default-directory dir))
                       (skeletor--log-info "Initialising git...")
                       (unless (f-exists? (f-join dir ".git"))
                         (skeletor-shell-command "git init"))
                       (skeletor-shell-command "git add -A && git commit --allow-empty -m 'Initial commit'")
                       (message "Initialising git...done"))))

       (defun skeletor-create-project+ (dir skeleton)
         "Variant of `skeleton-create-project' which defaults to the current directory."
         (interactive (list (when current-prefix-arg
                              (read-directory-name "Project directory"))
                            (skeletor--read-project-type)))
         (let ((skeletor-project-directory (or dir default-directory)))
           (skeletor-create-project skeleton)))

       (defun skeletor-expand-project+ (dir skeleton)
         "Expand a skeletor project in the cwd."
         (interactive (list (when current-prefix-arg
                              (read-directory-name "Project directory"))
                            (skeletor--read-project-type)))
         ;; use `default-directory' if `dir' not given and trim trailing path vars
         (setq dir (string-trim (or dir default-directory) nil
                                (rx (one-or-more (eval (f-path-separator))))))
         ;; confirm with user when creating in an already populated directory.
         (when (and (> (length (directory-files dir)) 2)
                    (not (yes-or-no-p "Directory not empty, continue project creation?")))
           (user-error "Project creation cancelled because directory not empty: %s" dir))
         ;; seperate path and defer to skeletor
         (let ((name (path-basename dir))
               (dir  (path-dirname  dir)))
           (cl-letf (((symbol-function 'skeletor--read-project-name)
                      (lambda () name)))
             (skeletor-create-project-at dir skeleton)))))
   #+END_SRC

*** templates
   :PROPERTIES:
   :header-args+: :tangle (package-str! "lisp/+skeletor-templates.el" skeletor)
   :END:

   #+BEGIN_SRC emacs-lisp :tangle (package-yes! skeletor)
     (with-eval-after-load 'skeletor
       (require '+skeletor-templates))
   #+END_SRC

   A basic [[file:etc/project-skeletons/c-make/][C/C++]] project template using a Makefile and either clang or gcc.

   #+BEGIN_SRC emacs-lisp
     (skeletor-define-template "c-make"
       :title "C/C++ [make]"
       :substitutions
       '(("__MAIN__" . (lambda ()
                         (read-string "Entry point [main]: " nil nil "main")))
         ("__CCLD__" . (lambda ()
                       (funcall skeletor-completing-read-function "Compiler: "
                                '("clang" "gcc" "g++"))))))
   #+END_SRC

   The same as a makefile project but using cmake instead of make. This is pretty
   much the industry standard so you may as well support it (even if cmake is
   extremely [[https://www.reddit.com/r/cmake/comments/8p43q0/questiondo_people_really_like_cmake/][ugly]])

   #+BEGIN_SRC emacs-lisp
     (skeletor-define-template "c-cmake"
       :title "C/C++ [cmake]"
       :requires-executables '(("cmake" . "https://cmake.org/"))
       :substitutions
       '(("__MAIN__" . (lambda ()
                         (read-string "Entry point [main]: " nil nil "main")))
         ("__TOOLCHAIN__" . (lambda ()
                              (completing-read "Toolchain: " '("clang" "gcc") nil t))))
       :after-creation
       (lambda (dir)
         (cl-destructuring-bind (c . cxx)
             (assoc (alist-get "__TOOLCHAIN__" (assoc 'repls skeletor-project-spec) nil nil #'string-equal)
                    '(("clang" . "clang++") ("gcc" . "g++")) #'string-equal)
           (skeletor-shell-command (format "CC=%s CXX=%s cmake -B build"
                                           (shell-quote-argument c)
                                           (shell-quote-argument cxx))
                                         dir))
         (let ((default-directory dir))
           (make-symbolic-link "./build/compile_commands.json" "compile_commands.json" t))))
   #+END_SRC

   A template to bootstrap a [[https://www.rust-lang.org/][rust]] project with cargo.

   #+BEGIN_SRC emacs-lisp
     (skeletor-define-constructor "rust-cargo"
       :title "rust [cargo]"
       :requires-executables '(("rustc" . "https://www.rust-lang.org/")
                               ("cargo" . "https://doc.rust-lang.org/book/ch01-03-hello-cargo.html"))
       :initialise
       (lambda (spec)
         (let-alist spec
           (skeletor-shell-command (concat "cargo init --color never --vcs none "
                                           (if (yes-or-no-p "Create a binary template instead of a library?")
                                               "--bin "
                                             "--lib ")
                                           (let ((name (read-string "Package name: ")))
                                             (unless (string-empty-p name)
                                               (concat "--name " (shell-quote-argument name) " ")))
                                           .project-name)
                                   .project-dir))))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
   (provide '+skeletor-templates)
   #+END_SRC

** tramp-term
   create remote terminal sessions effortlessly... this should be built into term tbh.

   #+BEGIN_SRC emacs-lisp :tangle (package-yes! tramp-term)
     (use-package tramp-term
       :straight t
       :defer  t
       :after  term
       :init
       ;; (add-hook 'term :before-until #'term--use-tramp-term-when-in-tramp-directory)

       :config
       ;;   (defun term--use-tramp-term-when-in-tramp-directory (&rest args)
       ;;     "when current buffers is in a tramp path open a tramp term session
       ;; if prefix arg specified, disregard this and open a local term sessions"
       ;;     (when (and (not current-prefix-arg)
       ;;                default-directory
       ;;                (tramp-tramp-file-p default-directory))
       ;;       (tramp-term )
       ;;         )
       ;;     )
       )
   #+END_SRC

** rainbow-mode
   highlights hex color strings in their appropriate color.

   #+BEGIN_SRC emacs-lisp :tangle (package-yes! rainbow-mode)
     (use-package rainbow-mode
       :straight t
       :defer  t)
    #+END_SRC

** vi-tilde
   display ~ on trailing lines in the fringe. doesn't work with emacs's new builtin line
   numbers mode.

   #+BEGIN_SRC emacs-lisp :tangle (package-yes! vi-tilde-fringe)
     (use-package vi-tilde-fringe
       :straight t
       :defer  t
       :diminish
       :commands (vi-tilde-fringe-mode global-vi-tilde-fringe-mode)
       :config
       (global-vi-tilde-fringe-mode))
   #+END_SRC

** vdiff
   inspired by vimdiff, vdiff is a better, less intrusive interactive diff tool for
   emacs.

   TODO look into vdiff-magit

   #+BEGIN_SRC emacs-lisp :tangle (package-yes! vdiff)
     (use-package vdiff
       :straight t
       :defer  t
       :config
       (defvar vdiff-use-relative-line-numbers nil
         "when true, line numbers in vdiff sessions are relative")

       (defun vdiff-setup (&rest args)
         (let ((inhibit-message t))
           (toggle-truncate-lines +1)
           (evil-normalize-keymaps))

         (when vdiff-use-relative-line-numbers
           (setq-local display-line-numbers
                       (if vdiff-mode t 'relative))))

       (defun vdiff-prepare ()
         (cond
          ((derived-mode-p 'org-mode)
           (when vdiff-mode
             (outline-show-all)))))

       (dolist (handler '(vdiff-setup
                          vdiff-prepare))
         (add-hook 'vdiff-mode-hook      handler)
         (add-hook 'vdiff-3way-mode-hook handler))

       :leader
       (:prefix leader-diff-leader-prefix
        "" "diff"
        "RET" 'vdiff-merge-conflict
        "d" 'vdiff-current-file
        "f" 'vdiff-files
        "F" 'vdiff-files3
        "b" 'vdiff-buffers
        "B" 'vdiff-buffers3)

       :lazy-leader
       (:mode '(vdiff-mode vdiff-3way-mode)
        :minor t
        :prefix leader-diff-leader-prefix
        "-" 'vdiff-switch-buffer
        "." 'vdiff-hydra/body
        "m" 'vdiff-restore-windows
        "s" 'vdiff-save-buffers
        "<left>"  'vdiff-receive-changes
        "<right>" 'vdiff-send-changes
        ">" 'vdiff-send-changes-and-step
        "<" 'vdiff-send-changes

        "TAB"     "refine"
        "TAB TAB" 'vdiff-refine-this-hunk
        "TAB DEL" 'vdiff-remove-refinements-in-hunk
        "TAB RET" 'vdiff-refine-all-hunks
        ;; 'vdiff-refine-this-hunk-symbol
        ;; 'vdiff-refine-this-hunk-word
        ;; 'vdiff-refine-all-hunks-symbol
        ;; 'vdiff-refine-all-hunks-word

        "t"  "toggle"
        "ti" 'vdiff-toggle-case
        "tw" 'vdiff-toggle-whitespace)

       :general
       (:states leader-norm-states
        :keymaps '(vdiff-mode-map vdiff-3way-mode-map)
        "q"  'vdiff-quit
        "gj" 'vdiff-next-hunk
        "gk" 'vdiff-previous-hunk
        "gh" 'vdiff-switch-buffer
        "gl" 'vdiff-switch-buffer
        "gr" 'vdiff-refresh
        "zj" 'vdiff-next-fold
        "zk" 'vdiff-previous-fold
        "zo" 'vdiff-open-fold
        "zO" 'vdiff-open-fold
        "zr" 'vdiff-open-all-folds
        "zf" 'vdiff-close-fold
        "zc" 'vdiff-close-fold
        "zF" 'vdiff-close-all-folds
        "zC" 'vdiff-close-all-folds
        "zC" 'vdiff-close-other-folds))
   #+END_SRC

** vlc-rc
   #+BEGIN_SRC emacs-lisp :tangle (package-yes! vlc-rc)
     (use-package vlc-rc
       :straight (vlc-rc :host github :repo "mohkale/vlc-rc")
       :defer t
       ;; can't defer for now, hopefully when use-package
       ;; supports bind-keymap with specific map, change.
       :commands (vlc/dired-add-file
                  vlc/dired-enqueue-file)
       :init
       (setq vlc-rc-map (make-sparse-keymap))

       :leader
       (:prefix "v"
        "" "VLC"
        "" vlc-rc-map

        "s" "set"
        "t" "toggle")

       :general
       (:keymaps 'dired-mode-map
        :states '(normal motion)
        "v"  nil
        "vv" 'vlc/dired-add-file
        "vq" 'vlc/dired-enqueue-file)
       (:keymaps 'vlc-rc-map
        "C-." 'hydra-vlc-rc/body))
   #+END_SRC

** vterm
   :PROPERTIES:
   :header-args+: :tangle (package-yes! vterm)
   :END:

   TODO refactor

   #+BEGIN_SRC emacs-lisp
     (use-package vterm
       :straight t
       :defer  t
       :commands (vterm-toggle
                  vterm-toggle-fullscreen
                  vterm-toggle-new-buffer+)
       :config
       (push 'vterm-mode whitespace-exempt-modes)
       (evil-set-initial-state 'vterm-mode 'emacs)

       (setq vterm-kill-buffer-on-exit t
             vterm-always-compile-module t
             vterm-buffer-name-string "*vterm: %s*"
             multi-vterm-buffer-name "*vterminal*"
             vterm-keymap-exceptions '("C-SPC" "C-g" "C-c" "M-x"))

       (use-package vterm-toggle
         :straight t
         :defer  t
         :init
         (defun vterm-toggle-fullscreen (&optional arg)
           (interactive "P")

           (setq vterm-toggle-fullscreen-p
                 (if (not arg)
                     (not vterm-toggle-fullscreen-p)
                   (or (listp arg)
                       (not (zerop arg)))))

           (setq vterm-toggle-reset-window-configration-after-exit vterm-toggle-fullscreen-p)

           (message "vterm fullscreen: %s"
                    (if vterm-toggle-fullscreen-p
                        (propertize "enabled" 'face 'compilation-info)
                      (propertize "disabled" 'face 'compilation-error))))

         :config
         (setq vterm-toggle-cd-auto-create-buffer t)

         (let ((inhibit-message t))
           (vterm-toggle-fullscreen +1)))

       ;; prevent vterm being opened in a new window
       (advice-add 'vterm-toggle--new :override #'vterm)

       (defun vterm-toggle-new-buffer+ ()
         (interactive)
         "create a new vterm buffer using vterm-toggle's interface."
         (let ((current-config (current-window-configuration)))
           (if vterm-toggle-fullscreen-p
               (progn
                 (delete-other-windows)
                 (switch-to-buffer (vterm)))
             (pop-to-buffer (vterm)))

           (setq vterm-toggle--window-configration current-config)))

       (defvar-local vterm-send-escape-to-vterm-p nil
         "Track whether or not we send ESC to `vterm' or `emacs'.")

       (defun vterm-toggle-send-escape (&optional value)
         "toggle whether escape is sent to vterm or to emacs.
     only works with GUI emacs... but good enough, I guess."
         (interactive)
         (let ((sending-to-emacs (or (eq value 'emacs)
                                     vterm-send-escape-to-vterm-p)))
           (general-define-key
            :keymaps 'vterm-mode-map
            "<escape>" (if sending-to-emacs
                           nil
                         'vterm--self-insert))
           (setq vterm-send-escape-to-vterm-p (not sending-to-emacs))

           (message (format "Sending ESC to %s."
                            (if vterm-send-escape-to-vterm-p "vterm" "emacs")))))

       ;; by default, escape is sent to vterm, not emacs.
       (let ((inhibit-message t))
         (vterm-toggle-send-escape 'vterm))

       (defun vterm-send-escape ()
         (interactive)
         (when vterm--term
           (process-send-string vterm--process "\C-[")))

       (defun vterm-send-ctrl-space ()
         (interactive)
         (when vterm--term
           (process-send-string vterm--process "\C-@")))

       (defun vterm-mouse-set-point (&rest args)
         "tmux like mouse handler. on click, switch to copy-mode."
         (interactive)
         (vterm-copy-mode +1)
         (funcall-interactively 'mouse-set-point args))

       ;; source [[https://github.com/akermu/emacs-libvterm#counsel-yank-pop-doesnt-work][emacs-libvterm]].
       (defun vterm-counsel-yank-pop-action (orig-fun &rest args)
         (if (equal major-mode 'vterm-mode)
             (let ((inhibit-read-only t)
                   (yank-undo-function (lambda (_start _end) (vterm-undo))))
               (cl-letf (((symbol-function 'insert-for-yank)
                          (lambda (str) (vterm-send-string str t))))
                 (apply orig-fun args)))
           (apply orig-fun args)))

       (advice-add 'counsel-yank-pop-action :around
                   #'vterm-counsel-yank-pop-action)

       (advice-add 'switch-to-last-buffer :filter-args
                   (defun switch-to-last-buffer--bury-vterm-buffers (&rest args)
                     "prevent `switch-to-last-buffer' oferring vterm.
     unless there's LITERALLY no other buffer you could possibly mean to go to."
                     (let ((buffer (car args))
                           (i 0)
                           (length (length (buffer-list))))
                       (while (and (< i length)
                                   (not buffer))
                         (setq i (1+ i))

                         (with-current-buffer (other-buffer)
                           (if (derived-mode-p 'vterm-mode)
                               (bury-buffer)
                             (setq buffer (current-buffer)))))

                       (list (or buffer
                                 (other-buffer))))))

       (advice-add 'switch-to-last-buffer :before-until
                   (defun switch-to-last-buffer--pop-vterm-window-config ()
                     "when switching to last buffer from a maximized vterm buffer
     instead switch to the window config from before the "
                     (when (and (derived-mode-p 'vterm-mode)
                                vterm-toggle-fullscreen-p
                                vterm-toggle--window-configration)
                       (set-window-configuration vterm-toggle--window-configration)
                       (setq vterm-toggle--window-configration nil)
                       t)))

       (add-hook 'vterm-copy-mode-hook
                 (defun vterm-copy-mode-switch-evil-state (&rest _)
                   (if vterm-copy-mode
                       (evil-change-state 'motion)
                     (evil-change-state 'emacs))))

       (add-hook 'vterm-mode-hook
                 (defun vterm-keep-cursor-on-evil-state-change ()
                   (setq-local evil-move-cursor-back nil)))

       (advice-add 'vterm-send-return :override
                   (defun vterm-send-return-as-ctrl-m ()
                     (when vterm--term
                       (process-send-string vterm--process "\C-m"))))

       :leader
       ("av" '("vterm" . vterm-toggle)
        "at" '("vterm-new" . vterm-toggle-new-buffer+)
        "tv" '("toggle-vterm-fullscreen" . vterm-toggle-fullscreen))

       :general
       (:keymaps 'vterm-mode-map
        "<mouse-1>" 'vterm-mouse-set-point
        "<C-backspace>" 'vterm-send-C-w
        "C-h" 'vterm-send-C-h
        "C-v" 'vterm-send-C-v
        "M-v" 'vterm-copy-mode
        "C-u" 'vterm-send-C-u
        "C-c C-g" 'vterm-send-C-g
        "C-c C-c" 'vterm-send-C-c
        "C-c SPC"   'vterm-send-ctrl-space
        "C-c C-SPC" 'vterm-send-ctrl-space
        "C-ESC" 'vterm-send-escape
        "M-ESC" 'vterm-send-escape

        ;; this is Magic :space_invader:.
        "C-S-n" 'vterm-toggle-forward
        "C-S-p" 'vterm-toggle-backward)
       (:keymaps 'vterm-copy-mode-map
        :states 'motion
        [remap evil-end-of-line] 'vterm-end-of-line
        "gj" 'vterm-next-prompt
        "gk" 'vterm-previous-prompt
        "RET" 'vterm-copy-mode)
       ;; TMUX compatibility bindings
       (:states 'emacs
        :prefix leader-nnorm-key
        :keymaps 'vterm-mode-map
        "v" '("copy-mode" . vterm-copy-mode)
        "p" 'vterm-yank)
       (:prefix leader-nnorm-key
        :states 'motion
        :keymaps 'vterm-copy-mode-map
        "v" 'vterm-copy-mode
        "p" 'vterm-yank))
   #+END_SRC

*** commands
    define elisp commands accessible through the ~vterm_cmd~ shell function.

    #+NAME: vterm-cmds
    | name                   | cmd                              |
    |------------------------+----------------------------------|
    | find-file              | vterm-cmd-find-file              |
    | find-file-other-window | vterm-cmd-find-file-other-window |
    | list-buffers           | vterm-cmd-list-buffers           |
    | message                | message                          |
    | vterm-clear-scrollback | vterm-clear-scrollback           |

    #+BEGIN_SRC emacs-lisp :var cmds=vterm-cmds :results silent
      (use-package vterm
        :config
        (setq vterm-eval-cmds
              (cl-loop for (name cmd) in cmds
                       do (setq cmd-sym (intern cmd))
                       when (string-prefix-p "vterm-cmd" cmd)
                         do (autoload cmd-sym "+vterm-cmds.el")
                       end

                       collect (list name cmd-sym))))
    #+END_SRC

    #+BEGIN_SRC emacs-lisp :tangle lisp/+vterm-cmds.el
      (defun vterm-cmd-find-file (&rest paths)
        (cl-loop for path in (or paths (list default-directory))
                 do (find-file path)))

      (defun vterm-cmd-find-file-other-window (&rest paths)
        (cl-loop for path in (or paths (list default-directory))
                 do (find-file-other-window path)))

      (defun vterm-cmd-list-buffers ()
        (ibuffer t))

      (provide '+vterm-commands)
    #+END_SRC

** wakatime
   #+BEGIN_SRC emacs-lisp :tangle (package-yes! wakatime)
     (use-package wakatime-mode
       :straight t
       :defer  t
       :hook (after-init-hook . global-wakatime-mode)
       :config
       ;; TODO move api key to private.
       (setq wakatime-api-key "0fba4add-c2c4-4950-9528-927a0652d7a1"))
   #+END_SRC

** ycmd
   :PROPERTIES:
   :header-args+: :tangle (package-yes! ycmd)
   :END:

    #+BEGIN_SRC emacs-lisp
      (use-package ycmd
        :straight t
        :defer  t
        :delight "YCMD"
        :hook (ycmd-mode . ycmd-eldoc-setup)
        :init
        ;; NOTE to enable ycmd completion, hook ycmd-mode into any desired
        ;;      buffers and include company-ycmd in the company backends for
        ;;      the mode.

        (setq ycmd-global-config (expand-file-name "~/.ycmd-config")
              ycmd-startup-timeout 10
              ycmd-server-command `("python3" "-u" ,(expand-file-name "~/.vim/plugged/YouCompleteMe/third_party/ycmd/ycmd"))
              ycmd-map+ (make-sparse-keymap))

        ;; (ycmd-toggle-force-semantic-completion)

        :lazy-leader
        (:mode 'ycmd-mode
         :minor t
         :prefix leader-server-leader-prefix
         ""  "ycmd"
         "y" 'ycmd-mode
         "Y" 'global-ycmd-mode
         "n" 'ycmd-open
         "k" 'ycmd-close
         "v" 'ycmd-version
         "b" 'ycmd-parse-buffer
         "c" 'ycmd-load-conf-file
         "C" 'ycmd-clear-compilation-flag-cache
         "s" 'ycmd-show-debug-info
         "d" 'ycmd-show-documentation
         "l" 'ycmd-toggle-log-enabled
         "r" 'ycmd-restart-semantic-server
         "t" 'ycmd-get-type
         "." 'ycmd-completer ;; completing-read all ycmd requests
         "SPC" 'ycmd-toggle-force-semantic-completion
         "C-r" 'ycmd-refactor-rename
         "C-c" 'ycmd-display-completions

         "g"  "jump"
         "gg" 'ycmd-goto
         "gG" 'ycmd-goto-imprecise
         "gt" 'ycmd-goto-type
         "gd" 'ycmd-goto-definition
         "gD" 'ycmd-goto-declaration
         "gr" 'ycmd-goto-references
         "gi" 'ycmd-goto-include
         "gI" 'ycmd-goto-implementation))
    #+END_SRC

*** company-ycmd
    #+BEGIN_SRC emacs-lisp
      (use-package company-ycmd
        :straight t
        :demand t
        :after (company ycmd)
        :init
        (company/configure-mode (ycmd-mode)
          company-ycmd))
    #+END_SRC

*** flycheck-ycmd
    #+BEGIN_SRC emacs-lisp
      (use-package flycheck-ycmd
        :straight t
        :defer  t
        :after (flycheck ycmd)
        :hook (ycmd-mode . flycheck-ycmd-setup))
    #+END_SRC

** ztree
   #+BEGIN_SRC emacs-lisp :tangle (package-yes! ztree)
     (use-package ztree
       :straight t
       :defer  t
       :config
       (evil-set-initial-state 'ztree-mode 'motion)

       :lazy-leader
       (:mode 'ztree-mode
        "TAB" 'ztree-jump-side
        "n"   'ztree-dir-widen-to-parent
        "w"   'ztree-dir-narrow-to-dir
        "h"   'ztree-dir-toggle-show-filtered-files)

       :general
       (:states  'motion
        :keymaps 'ztree-mode-map
        "gr"    'ztree-refresh-buffer
        "j"     'ztree-next-line
        "k"     'ztree-previous-line
        "gh"    'ztree-move-up-in-tree
        "gl"    'ztree-next-line
        "RET"   'ztree-dir-open-dired-at-point
        "TAB"   'ztree-perform-action
        "M-TAB" 'ztree-perform-soft-action
        "DEL"   'ztree-move-up-in-tree))
   #+END_SRC

* Languages
  [[*Extensions][Extensions]] providing tailored support for specific programming languages or tools.

** clojure
   :PROPERTIES:
   :header-args+: :tangle (package-yes! clojure)
   :END:

   #+BEGIN_SRC emacs-lisp
     (use-package clojure-mode
       :straight t
       :defer  t
       :mode ((rx ".edn") . clojure-mode))
   #+END_SRC

** restclient
   :PROPERTIES:
   :header-args+: :tangle (package-yes! restclient)
   :END:

*** restclient-mode
    #+BEGIN_SRC emacs-lisp
      (use-package restclient
        :straight t
        :defer  t
        :commands (restclient)
        :config
        (let ((leader leader-major-mode-key))
          (leader/set-keys-for-major-mode 'restclient-mode
            "RET"   '("execute-current" . restclient-http-send-current)
            "M-RET" '("execute-current-raw" . restclient-http-send-current-raw)
            leader  '("execute-current-same-window" . restclient-http-send-current-stay-in-window)
            "y"     '("yank-curl-command" . restclient-copy-curl-command)
            "m"     'restclient-mark-current
            "n"     'restclient-narrow-to-current
            "w"     'widen))

        (add-hook 'restclient-response-mode-hook
                  'evil-motion-state)

        (push (rx "*HTTP Response*") whitespace-exempt-buffers)

        (defun restclient ()
          "create a new buffer in restclient mode"
          (interactive)
          (let ((buffer (create-new-empty-buffer "restclient")))
            (with-current-buffer buffer
              (restclient-mode))
            (display-buffer buffer)))

        :leader
        ("ar" 'restclient)

        :general
        (:states 'motion
         :keymaps 'restclient-mode-map
         "gj" 'restclient-jump-next
         "gk" 'restclient-jump-prev)
        (:states  'normal
         :keymaps 'restclient-outline-mode-map
         "TAB"   'restclient-toggle-body-visibility-or-indent
         "g TAB" 'restclient-toggle-body-visibility-or-indent))
    #+END_SRC

*** company-restclient
    #+BEGIN_SRC emacs-lisp
      (use-package company-restclient
        :straight t
        :defer  t
        :after  restclient
        :commands (company-restclient)
        :init
        (company/configure-mode (restclient-mode :major t)
          company-restclient))
    #+END_SRC

*** org-babel-restclient
    #+BEGIN_SRC emacs-lisp
      (use-package ob-restclient
        :straight t
        :defer  t
        :after (org restclient)
        :init
        (org-babel-do-load-languages
         'org-babel-load-languages
         '((restclient . t))))
    #+END_SRC

** elisp
   :PROPERTIES:
   :header-args+: :tangle (package-yes! elisp)
   :END:

*** elisp-mode
    #+BEGIN_SRC emacs-lisp
      (use-package elisp-mode
        :defer t
        :commands (eval-replace-last-sexp)
        :init
        (add-hook 'emacs-lisp-mode-hook #'electric-pair-mode)

        :config
        ;; show lambda as an actual lambda symbol... pretty cool, if I do say
        ;; so myself.
        (configure-presym! '(lisp-interaction-mode emacs-lisp-mode org-mode)
          "lambda"  ?Œª
          "lambda!" "Œª!")

        (defun eval-replace-last-sexp (&optional prefix)
          "evaluate then replace the preceding sexp"
          (interactive "p")
          (let* ((sexp (preceding-sexp))
                 (value (eval sexp)))
            (kill-sexp -1)
            (insert (format (if prefix "%s" "%S") value))))

        (evil-set-initial-state 'inferior-emacs-lisp-mode 'emacs) ;; ielm

        ;;   (defun elisp-transcript ()
        ;;     ;; source https://www.emacswiki.org/emacs/LispInteractionMode
        ;;     "Make an Emacs Lisp interactive transcript.
        ;; In a new buffer, make a transcript of the Emacs Lisp code by
        ;; evaluating each line and printing the result under it (/a la/
        ;;   TODO fix last sexp in the buffer isn't transcripted
        ;;   `eval-print-last-sexp')."
        ;;     (interactive)
        ;;     (let* ((eval-expression-print-length nil)
        ;;            (eval-expression-print-level nil)
        ;;            (input-buffer (current-buffer))
        ;;            (dest-buffer (get-buffer-create (concat "*Transcript for "
        ;;                                                    (buffer-name input-buffer)
        ;;                                                    "*"))))
        ;;       (save-current-buffer
        ;;         (set-buffer dest-buffer)
        ;;         (lisp-interaction-mode)
        ;;         (delete-region (point-min) (point-max))
        ;;         (insert-buffer-substring input-buffer) ;; `slurp!'
        ;;         (goto-char (point-min))
        ;;         (forward-sexp 1)
        ;;         (while (> (point-max) (point))
        ;;           (condition-case err
        ;;               (evil-adjust-eval-print-last-sexp)
        ;;             (error
        ;;              (insert (format "%s" err))
        ;;              (newline)))
        ;;           (forward-sexp 1)))
        ;;       (display-buffer dest-buffer)))

        (push '(emacs-lisp-mode . 2) +indent-config)
        (push '(lisp-interaction-mode . 2) +indent-config)

        :leader
        ("fk" 'emacs-lisp-byte-compile)
        (:prefix "k"
         "e" 'eval-last-sexp
         "k" 'eval-last-sexp
         "(" 'eval-print-last-sexp
         ")" 'eval-replace-last-sexp)

        :lazy-leader
        (:mode '(emacs-lisp-mode lisp-interaction-mode)
          "'" 'ielm
          "c" 'emacs-lisp-byte-compile
          "i" 'indent-sexp
          "p" 'pp-buffer

          ;; eval
          "e"  "eval"
          "eb" 'eval-buffer
          "ee" 'eval-last-sexp
          "eE" 'eval-replace-last-sexp
          "ef" 'eval-defun
          "er" 'eval-region
          ;; "et" 'elisp-transcript

          ;; jump
          "g" '("goto-definition" . xref-find-definitions)
          "G" '("goto-definition-other-window" . xref-find-definitions-other-window)

          ;; tests
          "t" 'ert
          "T" 'ert-run-tests-interactively)

        :general
        (:keymaps '(emacs-lisp-mode-map lisp-interaction-mode-map)
         "C-j" nil
         "C-(" 'eval-print-last-sexp
         "C-)" 'eval-replace-last-sexp))
    #+END_SRC

*** paredit
    #+BEGIN_SRC emacs-lisp
      (use-package paredit
        :straight t
        :defer  t
        :diminish paredit-mode
        :hook (emacs-lisp-mode . paredit-mode)
        :general
        (:keymaps 'paredit-mode-map
         "C-<up>" nil "C-<down>" nil "C-<left>" nil
         "C-<right>" nil "C-(" nil "C-)" nil)

        ;; M-( wraps the next argument in parentheses
        ;; M-) closes the current argument, trims any
        ;;     trailing whitespace and inserts a newline
        ;; M-" same as " but then trims whitespace and inserts a newline
        (:keymaps 'paredit-mode-map
         :states 'insert
         "<delete>" 'paredit-backward-delete
         "M-<delete>" 'paredit-forward-delete
         "C-<delete>" 'paredit-backward-kill-word
         ;; "C-M-<delete>" 'paredit-forward-kill-word

         ;; damn you windows
         ;; just use paredit forward, then kill backward
         "C-M-k" 'paredit-kill ;; forward body
         "<return>" 'paredit-newline)
        (:keymaps 'paredit-mode-map
         :states 'normal
         "gSh" '("splice-sexp-forward" . paredit-splice-sexp-killing-backward)
         "gSl" '("splice-sexp-backward" . paredit-splice-sexp-killing-forward))
        (:keymaps 'paredit-mode-map
         :states '(normal insert)
         ;; movement
         ;; "C-h" 'backward-char
         ;; "C-l" 'forward-char
         "C-j" 'paredit-newline
         "C-M-h" 'paredit-backward
         "C-M-l" 'paredit-forward
         "C-<left>" 'paredit-backward
         "C-<right>" 'paredit-forward

         ;; transformation
         ;;; kill or wrap surrounding parentheses
         "C-S-K" 'paredit-splice-sexp
         "C-S-J" 'paredit-wrap-round
         ;;; include previous or next arguments in current sexp
         "C-S-H" 'paredit-backward-slurp-sexp
         "C-S-L" 'paredit-forward-slurp-sexp
         ;;; exclude previous or next arguments from current sexp
         "C-M-S-H" 'paredit-backward-barf-sexp
         "C-M-S-L" 'paredit-forward-barf-sexp

         "C-S-S" 'paredit-split-sexp
         "C-S-M-J" 'paredit-join-sexps ;; immeadiately with expression b4 point

         ;; splice next argument after point, deleting
         ;; arguments both before and after it
         ;; a cool shortcut, but not really necessary
         ;; "M-r"   'paredit-raise-sexp
         ))
    #+END_SRC

** python
   :PROPERTIES:
   :header-args+: :tangle (package-yes! python)
   :END:

*** python-mode
    #+BEGIN_SRC emacs-lisp
      (use-package python
        :defer t
        :straight (python :type built-in)
        :hook (python-mode . flycheck-mode)
        :custom
        (python-indent-guess-indent-offset-verbose nil
         "Disable annoying notification when indent guess fails")
        :init
        (defalias 'python-repl 'run-python)

        :config
        (evil-set-initial-state 'inferior-python-mode 'emacs)
        (setq python--prettify-symbols-alist nil)

        (add-to-list 'python-shell-completion-native-disabled-interpreters "python3")

        (configure-presym! 'python-mode
          "lambda" ?Œª)

        (defun python-shell-calculate-command ()
          "python3 -i")

        :lazy-leader
        (:mode 'python-mode
         "r" 'run-python ;; REPL
         "R" 'python-shell-switch-to-shell
         "m" 'python-mark-defun
         "v" 'python-check
         "s" 'python-describe-at-point
         ;; unbound: python-nav-forward-sexp[-safe]
         ;;          python-nav-backward-sexp[-safe]

         "n"  "navigate"
         "nh" 'python-nav-forward-statement
         "nj" 'python-nav-forward-block
         "nk" 'python-nav-backward-block
         "nl" 'python-nav-backward-statement
         "n(" 'python-nav-backward-up-list
         "n)" 'python-nav-up-list
         "n0" 'python-nav-beginning-of-block
         "n$" 'python-nav-end-of-block
         "nm" 'python-nav-if-name-main

         "n C-0" 'python-nav-beginning-of-statement
         "n C-$" 'python-nav-end-of-statement
         "n M-j" 'python-nav-forward-defun
         "n M-k" 'python-nav-backward-defun
         ;; "n M-0" 'python-nav-beginning-of-defun
         "n M-$" 'python-nav-end-of-defun

         "h"  "help"
         "hp" 'python-eldoc-at-point

         "e"  "eval/exec"
         "ed" 'python-shell-send-defun
         "eb" 'python-shell-send-buffer
         "ef" 'python-shell-send-file
         "er" 'python-shell-send-region
         "ec" 'python-shell-send-string)

        :general
        (:keymaps 'python-mode-map
         "<C-backspace>" nil)
        (:states 'insert
         :keymaps 'python-mode-map
         "TAB"   'tab-to-tab-stop
         "<tab>" 'tab-to-tab-stop))
    #+END_SRC

*** python-lsp
    Your going to need a python language server, I recommend [[https://github.com/palantir/python-language-server][this]] one that's based on
    [[https://github.com/davidhalter/jedi][jedi]]. There's also a microsoft based [[https://github.com/microsoft/python-language-server][server]].

    #+BEGIN_SRC emacs-lisp :tangle (package-yes! python :lsp :not anaconda)
      (add-hook 'python-mode-hook +lsp-command)
    #+END_SRC

    Lets setup any custom server configurations for ~pyls~ configurations.

*** anaconda
    :PROPERTIES:
    :header-args+: :tangle (package-yes! python anaconda)
    :END:

    #+BEGIN_SRC emacs-lisp
      (use-package anaconda-mode
        :diminish anaconda-mode
        :straight t
        :defer  t
        :hook ((python-mode . enable-anaconda-mode+)
               (anaconda-mode . anaconda-eldoc-mode))
        :commands enable-anaconda-mode+
        :config
        (setq anaconda-mode-installation-directory (var! "anaconda/"))

        (defun enable-anaconda-mode+ ()
          "run anaconda-mode unless you're in a remote file."
          (when (and (buffer-file-name)
                     (not (file-remote-p (buffer-file-name))))
            (anaconda-mode +1)))

        :lazy-leader
        (:mode 'python-mode
         "TAB" 'anaconda-mode-complete
         "hh" 'anaconda-mode-show-doc

         "ga" 'anaconda-mode-find-assignments
         "gr" 'anaconda-mode-find-references
         "gg" 'anaconda-mode-find-definitions
         "gA" 'anaconda-mode-find-assignments-other-window
         "gR" 'anaconda-mode-find-references-other-window
         "gG" 'anaconda-mode-find-definitions-other-window
         "g M-a" 'anaconda-mode-find-assignments-other-frame
         "g M-r" 'anaconda-mode-find-references-other-frame
         "g M-g" 'anaconda-mode-find-definitions-other-frame)

        :general
        (:keymaps 'anaconda-mode-map
         [remap display-local-help] 'anaconda-mode-show-doc
         [remap xref-find-definitions] 'anaconda-mode-find-definitions
         [remap xref-find-references] 'anaconda-mode-find-references))
    #+END_SRC

**** company-anaconda
     #+BEGIN_SRC emacs-lisp
       (use-package company-anaconda
         :straight t
         :defer  t
         :after  anaconda-mode
         :init
         (company/configure-mode (anaconda-mode)
           company-anaconda))
     #+END_SRC

*** pyimport
    #+BEGIN_SRC emacs-lisp
      (use-package pyimport
        :straight t
        :defer  t
        :leader
        (:mode 'python-mode
         "i"  "imports"
         "ii" 'pytimport-remove-unused
         "iu" 'pyimport-insert-missing))
    #+END_SRC

*** py-isort
    tidy up imports.

    #+BEGIN_SRC emacs-lisp
      (use-package py-isort
        :straight t
        :defer  t
        :leader
        (:mode 'python-mode
         "i"  "imports"
         "is" 'py-isort-buffer
         "ir" 'py-isort-region))
    #+END_SRC

*** pip-requirements
    major mode for editing pip requirements files.

    #+BEGIN_SRC emacs-lisp
      (use-package pip-requirements
        :straight t
        :defer  t
        :mode ("^requirements\\.txt$" . pip-requirements-mode))
    #+END_SRC

*** yapfify
    auto format the current python buffer.

    #+BEGIN_SRC emacs-lisp
      (use-package yapfify
        :straight t
        :defer  t
        :leader
        (:mode 'python-mode
         "y" 'yapfify-buffer
         "Y" 'yapfify-region))
    #+END_SRC

** ruby
   :PROPERTIES:
   :header-args+: :tangle (package-yes! ruby)
   :END:

   #+BEGIN_SRC emacs-lisp
     (defvar +ruby-package 'ruby ;; (if (eq system-type 'gnu/linux) 'enh-ruby 'ruby)
       "determine which mode to use for ruby... enh-ruby is really slowing everything down on windows
     also, for some reason, creating a symlink to ruby on cygwin makes the process unrunnable from emacs,
     it just spits out exec error... my loathing towards windows grows :P
     TODO test out performance of enhanced ruby on linux.")

     (defvar +ruby-use-lsp 'projectile
       "whether to use `lsp-mode' with ruby-mode.
     set to 'projectile to only activate if in a projectile project with a Gemfile.

     NOTE solargraph... and basically every other ruby completion framework is
          useless if your project doesn't have a Gemfile... that means for simple
          scripts like ~/.emacs.d/bin/tangle, solargraph won't be of any use.
     ")

     (setq +ruby-mode      (intern (concat (symbol-name +ruby-package) "-mode"))
           +ruby-mode-hook (intern (concat (symbol-name +ruby-mode)    "-hook")))

     (push (cons +ruby-mode 2) +indent-config)

     (leader/set-keys "Mr" +ruby-mode)
   #+END_SRC

*** ruby
    #+BEGIN_SRC emacs-lisp
      (use-package ruby-mode
        :only (eq +ruby-package 'ruby)
        :defer t
        :mode ("\\.rb$" . ruby-mode)
        :interpreter "ruby"
        :lazy-leader
        (:mode 'ruby-mode
         "'" 'ruby-toggle-string-quotes
         "{" 'ruby-toggle-block))
    #+END_SRC

*** enhanced-ruby
    #+BEGIN_SRC emacs-lisp
      (use-package enh-ruby-mode
        :only (eq +ruby-package 'enh-ruby)
        :straight t
        :defer  t
        :mode ("\\.rb$" . enh-ruby-mode)
        :interpreter "ruby"
        :hook (enh-ruby-mode . flycheck-mode)
        :config
        (setq enh-ruby-deep-indent-paren nil
              enh-ruby-hanging-paren-deep-indent-level 2)

        :lazy-leader
        (:mode 'enh-ruby-mode
         "m" 'enh-ruby-mark-defun
         "f" 'enh-ruby-find-file
         "e" 'enh-ruby-find-error

         "i"  "insert"
         "ie" 'enh-ruby-insert-end
         "it" 'enh-ruby-indent-exp
         "i TAB" 'enh-ruby-indent-exp

         "n"  "navigate"
         "nh" 'enh-ruby-backward-sexp
         "nl" 'enh-ruby-forward-sexp
         "nk" 'enh-ruby-up-sexp
         "n0" 'enh-ruby-beginning-of-block
         "n$" 'enh-ruby-end-of-block
         "n M-0" 'enh-ruby-beginning-of-defun
         "n M-$" 'enh-ruby-end-of-defun)

        :general
        (:keymaps 'enh-ruby-mode-map
         "{" nil "}" nil)
        (:keymaps 'enh-ruby-mode-map
         :states 'insert
         "{" 'enh-ruby-electric-brace
         "}" 'enh-ruby-electric-brace)
        (:keymaps 'enh-ruby-mode-map
         :states '(normal insert)
         "C-{" 'enh-ruby-toggle-block))
    #+END_SRC

*** solargraph
    Language server implementation for ruby.

    #+BEGIN_SRC emacs-lisp :tangle (package-yes! :lsp)
      (add-hook +ruby-mode-hook
                (defun ruby-enable-lsp-in-projects+ (&rest args)
                  (when (eq +ruby-use-lsp 'projectile)
                    (when-project-has-file-p "Gemfile"
                      (funcall +lsp-command)))))
    #+END_SRC

*** robe
    WARN robe won't work unless your project contains some identifying gemfile
    so if your not getting any completion help, that's probably why.

    #+BEGIN_SRC emacs-lisp :tangle (package-yes! ruby-robe)
      (use-package robe
        :straight t
        :defer  t
        :init
        (add-hook +ruby-mode-hook
                  (defun ruby-robe-enable-in-projects (&rest args)
                    (unless (eq +ruby-use-lsp 'projectile)
                      (when-project-has-file-p "Gemfile"
                         (call-interactively 'robe-mode)))))

        :config
        (company/configure-mode (robe-mode)
          company-robe)

        :lazy-leader
        (:mode +ruby-mode
         "rs" 'robe-start ;; REPL
         "h" 'robe-doc

         ;; jumping
         "SPC" 'robe-ask

         "g"  "goto"
         "gg" 'robe-jump
         "gm" 'robe-jump-to-module))
    #+END_SRC

*** inf-ruby
    #+BEGIN_SRC emacs-lisp
      (use-package inf-ruby
        :straight t
        :defer  t
        :init
        (defalias 'ruby-repl 'inf-ruby)
        (push 'inf-ruby-mode whitespace-exempt-modes)

        :lazy-leader
        (:mode +ruby-mode
         "r"  "REPL"
         "rr" 'inf-ruby
         "rg" 'inf-ruby-console-gem
         "rz" 'inf-ruby-console-zues
         "ra" 'inf-ruby-console-auto
         "rR" 'inf-ruby-console-rails
         "rk" 'inf-ruby-console-racksh
         "rc" 'inf-ruby-console-script
         "rh" 'inf-ruby-console-hanami))
    #+END_SRC

*** ruby-tools
    #+BEGIN_SRC emacs-lisp
      (use-package ruby-tools
        :straight t
        :defer  t
        :diminish ruby-tools-mode
        :init
        (add-hook +ruby-mode-hook #'ruby-tools-mode)

        :lazy-leader
        (:mode +ruby-mode
         "i"  "insert"
         "i:" 'ruby-tools-to-symbol
         "i{" 'ruby-tools-interpolate
         "i <backspace>" 'ruby-tools-clear-string
         "i\"" 'ruby-tools-to-double-quote-string
         "i'" 'ruby-tools-to-single-quote-string))
    #+END_SRC

*** bundle
    #+BEGIN_SRC emacs-lisp
      (use-package bundler
        :straight t
        :defer  t
        :leader
        (:mode +ruby-mode
         "b"  "bundler"
         "rb" 'bundle-console
         "bf" 'bundle-open
         "bi" 'bundle-install
         "bu" 'bundle-update
         "bc" 'bundle-check))
    #+END_SRC

*** ruby-electric
    #+begin_src emacs-lisp
      (use-package ruby-electric
        :straight t
        :defer  t
        :diminish ruby-electric-mode
        :init
        (add-hook +ruby-mode-hook #'ruby-electric-mode)

        :config
          ;;; why poison the standard ruby map instead of using ruby-electric-mode-map?
        (defun ruby-electric-setup-keymap ()
          (general-define-key
           :keymaps 'ruby-mode-map
           " " 'ruby-electric-space
           ;; "{" 'ruby-electric-curlies
           "(" 'ruby-electric-matching-char
           "[" 'ruby-electric-matching-char
           ;; "\"" 'ruby-electric-quote
           ;; "\'" 'ruby-electric-quote
           "|" 'ruby-electric-bar
           "RET" 'ruby-electric-return
           ;; (kbd "C-j") 'ruby-electric-return
           ;; [C-m] 'ruby-electric-return
           "}" 'ruby-electric-close-matching-char
           ")" 'ruby-electric-close-matching-char
           "]" 'ruby-electric-close-matching-char)))
    #+end_src

** powershell
   :PROPERTIES:
   :header-args+: :tangle (package-yes! powershell)
   :END:

   #+BEGIN_SRC emacs-lisp
     (use-package powershell
       :straight t
       :defer  t)
   #+END_SRC

** HTML
   :PROPERTIES:
   :header-args+: :tangle (package-yes! html)
   :END:

*** web-mode
    #+BEGIN_SRC emacs-lisp
      (use-package web-mode
        :straight t
        :defer  t
        :mode (rx "." (or "erb" "html" "vue"))
        :init
        (push '(web-mode . 2) +indent-config)

        :config
        (add-hook 'hack-local-variables-hook
                  (defun web-mode-fix-dirlocals+ (&rest _)
                    "see issue #1118."
                    (when (derived-mode-p major-mode 'web-mode)
                      (web-mode-guess-engine-and-content-type))))

        :leader
        ("Mh" 'web-mode)
        (:mode 'web-mode
         ;; unbound:
         ;;   * web-mode-buffer-highlight
         ;;   * web-mode-element-mute-blanks
         ;;   * web-mode-block-beginning
         ;;   * web-mode-block-end
         ;;   * web-mode-block-insert
         ;;   * web-mode-block-kill
         ;;   * web-mode-block-next
         ;;   * web-mode-block-previous
         ;;   * web-mode-block-select
         ;;   * web-mode-block-transpose
         ;;   * web-mode-navigate
         ;;
         ;; WARN the block commands don't seem to do anything

         ";"     'web-mode-comment-or-uncomment
         "f"     'web-mode-fold-or-unfold
         "l"     'web-mode-file-link
         "b"     'web-mode-element-close ; insert matching tag for body at point
         "M-r"   'web-mode-reload
         "<tab>" 'web-mode-buffer-indent
         "C-M-i" 'web-mode-snippet-insert
         ;; "tw" 'web-mode-whitespace-show

         ;; insert
         "i"  "insert"
         "ia" 'web-mode-attribute-insert
         "ip" 'web-mode-element-wrap ; wrap current element in a new element with name from prompt
         "ic" 'web-mode-element-clone
         "ie" 'web-mode-element-insert
         "ie" 'web-mode-element-insert-at-point ; converts word before point to tag

         ;; refactor/insert
         "r"  "refactor"
         "rs" 'web-mode-tag-attributes-sort
         "r(" 'web-mode-element-extract  ; add linebreak before every tag in body
         "r)" 'web-mode-element-contract ; collapse tag into a single line
         "rn" 'web-mode-dom-normalize
         "ra" 'web-mode-attribute-transpose
         "re" 'web-mode-element-transpose
         "rr" 'web-mode-element-rename
         "rf" 'web-mode-fold-or-unfold
         "rF" 'web-mode-element-children-fold-or-unfold ; collapse the children of current tags body, not body itself

         ;; delete
         "d"  "delete"
         "da" 'web-mode-attribute-kill
         "de" 'web-mode-element-kill
         "dp" 'web-mode-element-vanish ; delete element, but move body up a level instead of erasing it

         ;; DOM
         "D"  "DOM"
         "Da" 'web-mode-dom-apostrophes-replace
         "Ds" 'web-mode-dom-entities-replace
         "Dq" 'web-mode-dom-quotes-replace
         "D/" 'web-mode-dom-xpath
                                              ; shows the xpath of the current element

         "hd" 'web-mode-dom-errors-show
         "hj" 'web-mode-jshint

         ;; mark
         "m"  "mark"
         "mT" 'web-mode-tag-select
                                              ; only works while between <>
         "mt" 'web-mode-element-select
         "ma" 'web-mode-attribute-select
         "mb" 'web-mode-element-content-select
         "mm" 'web-mode-mark-and-expand

         ;; navigation
         "n"  "navigate"
         "n0" 'web-mode-element-beginning
         "n$" 'web-mode-element-end
         "nn" 'web-mode-tag-match
         "nh" 'web-mode-element-next
         "nj" 'web-mode-element-child
         "nk" 'web-mode-element-previous
         "nh" 'web-mode-element-parent
         ;; "nt" 'web-mode-dom-traverse

         "na"  "attributes"
         "na0" 'web-mode-attribute-beginning
         "na$" 'web-mode-attribute-end
         "nah" 'web-mode-attribute-previous
         "nal" 'web-mode-attribute-next

         "nt"  "tags"
         "nt0" 'web-mode-tag-beginning
         "nt$" 'web-mode-tag-end
         "nth" 'web-mode-tag-previous
         "ntl" 'web-mode-tag-next)

        :general
        (:keymaps 'web-mode-map
         :states 'normal
         "<tab>" 'web-mode-fold-or-unfold))
    #+END_SRC

*** emmet-mode
    #+BEGIN_SRC emacs-lisp :tangle (or (package-yes! html) (package-yes! markdown))
      (use-package emmet-mode
        :straight t
        :defer  t
        :hook ((web-mode      . emmet-mode)
               (markdown-mode . emmet-mode)
               (js2-jsx-mode  . emmet-mode))
        :lazy-leader
        (:mode 'emmet-mode
         :minor t
         :prefix leader-major-mode-prefix
         "e" "emmet"
         "." 'emmet-expand-line
         ;; "'" 'emmet-preview
         "ee" 'emmet-expand-line
         "ep" 'emmet-preview
         "ew" 'emmet-wrap-with-markup
         "en" 'emmet-next-edit-point
         "eN" 'emmet-prev-edit-point)

        :general
        (:keymaps 'emmet-mode-keymap
         :states 'insert
         [C-i] 'emmet-expand-line
         "TAB" 'emmet-expand-line
         "C-j" nil
         "<tab>"   'emmet-next-edit-point
         "<S-tab>" 'emmet-prev-edit-point))
    #+END_SRC

*** company-web
    #+BEGIN_SRC emacs-lisp
      (use-package company-web
        :straight t
        :defer  t
        :after  web-mode
        :config
        (company/configure-mode (web-mode :major t)
          company-web-html company-yasnippet))
    #+END_SRC

*** web-beautify
    #+BEGIN_SRC emacs-lisp
      (use-package web-beautify
        :straight t
        :defer  t
        :after  web-mode
        :leader
        (:mode 'web-mode
         "rb"  "beautify"
         "rbh" 'web-beautify-htlm
         "rbj" 'web-beautify-js
         "rbc" 'web-beautify-css))
    #+END_SRC

** JSON
   :PROPERTIES:
   :header-args+: :tangle (package-yes! json)
   :END:

   #+BEGIN_SRC emacs-lisp
     (use-package json-mode
       :straight t
       :defer  t
       :mode (rx ".json")
       :hook (json-mode . flycheck-mode)

       :lazy-leader
       (:mode 'json-mode
        "b" 'json-mode-beautify
        "/" 'json-mode-kill-path
        "t" 'json-toggle-boolean
        "DEL" 'json-nullify-sexp))
   #+END_SRC

** vimscript
   :PROPERTIES:
   :header-args+: :tangle (package-yes! vimlang)
   :END:

   #+BEGIN_SRC emacs-lisp
     (use-package vimrc-mode
       :straight t
       :defer  t
       :mode (rx ".vim")
       :hook (vimrc-mode . flycheck-mode)
       :delight (vimrc-mode "vim"))
   #+END_SRC

** sql
   :PROPERTIES:
   :header-args+: :tangle (package-yes! sql)
   :END:

   #+BEGIN_SRC emacs-lisp
     (use-package sql
       :straight t
       :defer  t
       :mode ("\\.sql" . sql-mode)
       :hook (sql-mode . flycheck-mode)
       :config
       (setq sql-sqlite-options '("-interactive"))
       (push 'sql-interactive-mode whitespace-exempt-modes)

       (evil-set-initial-state 'sql-interactive-mode 'emacs)

       :lazy-leader
       ;; see [here](https://truongtx.me/2014/08/23/setup-emacs-as-an-sql-database-client)
       ;; for a guide on how to make quick database access easier. or if you've already got
       ;; an interactive session running, use sql-save-connection to append it to a local
       ;; variable from which you can just paste it in here.
       (:mode 'sql-mode
        "0" 'sql-beginning-of-statement
        "$" 'sql-end-of-statement
        "i" 'sql-show-sqli-buffer
        "t" 'sql-toggle-pop-to-buffer-after-send-region

        "e"  "eval"
        "eb" 'sql-send-buffer
        "ep" 'sql-send-paragraph
        "er" 'sql-send-region
        "es" 'sql-send-string

        "l"  "list"
        "ll" 'sql-list-all
        "lt" 'sql-list-table)
       (:mode 'sql-interactive-mode
        "t" 'sql-list-table
        "a" 'sql-list-all))
   #+END_SRC

*** sqlup
    upcases SQL specific keywords after completing them.

    #+BEGIN_SRC emacs-lisp
      (use-package sqlup-mode
        :straight t
        :defer  t
        :after  sql
        :hook ((sql-mode . sqlup-mode)
               (sql-interactive-mode . sqlup-mode))
        :config
        (push "name" sqlup-blacklist)

        :lazy-leader
        (:mode 'sql-mode
         "u"  "upcase"
         "ur" 'sqlup-capitalize-keywords-in-region
         "ub" 'sqlup-capitalize-keywords-in-buffer))
    #+END_SRC

** YAML
   :PROPERTIES:
   :header-args+: :tangle (package-yes! yaml)
   :END:

   #+BEGIN_SRC emacs-lisp
     (use-package yaml-mode
       :straight t
       :defer  t
       :mode (rx "." (or "yaml" "yml"))
       :hook (yaml-mode . flycheck-mode)
       :config
       (push '(yaml-mode . 2) +indent-config)

       :lazy-leader
       (:mode 'yaml-mode
        "n" 'yaml-narrow-to-block-literal
        "f" 'yaml-fill-paragraph
        "v" 'yaml-mode-version)

       :general
       (:keymaps 'yaml-mode-map
        :states 'insert
        "<tab>" 'yaml-indent-line))
   #+END_SRC

** csv
   :PROPERTIES:
   :header-args+: :tangle (package-yes! csv)
   :END:

   #+BEGIN_SRC emacs-lisp
     (use-package csv-mode
       :straight t
       :defer  t
       :init
       (setq csv-separators '("," ":" ";" "\t"))

       :lazy-leader
       (:mode 'csv-mode
        "a"  'csv-align-fields
        "d"  'csv-kill-fields
        "i"  'csv-toggle-invisibility
        "r"  'csv-reverse-region
        "t"  'csv-transpose
        "u"  'csv-unalign-fields

        "s" "sort"
        "sf" 'csv-sort-fields
        "sn" 'csv-sort-numeric-fields
        "so" 'csv-toggle-descending

        "v" "yank"
        "vf" 'csv-yank-fields
        "vt" 'csv-yank-as-new-table)

       :general
       (:keymaps 'csv-mode-map
        "<tab>"     'csv-forward-field
        "<backtab>" 'csv-backward-field))
   #+END_SRC

** yarn
   :PROPERTIES:
   :header-args+: :tangle (package-yes! yarn)
   :END:

   #+BEGIN_SRC emacs-lisp
     (use-package yarn-mode :straight t)
   #+END_SRC

** glsl
   :PROPERTIES:
   :header-args+: :tangle (package-yes! glsl)
   :END:

   #+BEGIN_SRC emacs-lisp
     (use-package glsl-mode
       :straight t
       :mode ("\\.vs$" . glsl-mode))
   #+END_SRC

** shell-script
   :PROPERTIES:
   :header-args+: :tangle (package-yes! sh-script)
   :END:

   Enable the bash language server when it's on my system.

   #+BEGIN_SRC emacs-lisp :tangle (package-yes! sh-script :lsp)
     (when (and +sh-use-lsp
                (executable-find "bash-language-server"))
       (add-hook 'sh-mode-hook +lsp-command))
   #+END_SRC

    #+BEGIN_SRC emacs-lisp
      (use-package sh-script
        :defer t
        :hook ((sh-mode . electric-pair-mode)
               (sh-mode . flycheck-mode))
        :config
        (advice-add 'sh-set-shell :around 'inhibit-messages-wrapper)

        :lazy-leader
        (:mode 'sh-mode
         ":" 'sh-set-shell
         "0" 'sh-beginning-of-command
         "$" 'sh-end-of-command
         "!" 'executable-interpret
         "b" 'sh-show-shell
         "\\" 'sh-backslash-region

         "er" 'sh-execute-region
         "ej" 'sh-send-line-or-region-and-step

         "i=" 'sh-assignment
         "ic" 'sh-case
         "id" 'sh-cd-here
         "if" 'sh-for
         "i TAB" 'sh-if
         "il" 'sh-indexed-loop
         "io" 'sh-while-getopts
         "ir" 'sh-repeat
         "is" 'sh-select
         "it" 'sh-tmp-file
         "iu" 'sh-until
         "iw" 'sh-while
         "i(" 'sh-function
         "i+" 'sh-add

         "TAB"   "indent"
         "TAB -" 'sh-learn-line-indent
         "TAB =" 'sh-set-indent
         "TAB |" 'sh-learn-buffer-indent
         "TAB ?" 'sh-show-indent))
    #+END_SRC

*** company-shell
    #+BEGIN_SRC emacs-lisp
      (use-package company-shell
        :straight t
        :defer  t
        :after  sh-mode
        :config
        (company/configure-mode (sh-mode :major t)
          company-shell company-shell-env))
    #+END_SRC

** ssh
   :PROPERTIES:
   :header-args+: :tangle (package-yes! ssh-config)
   :END:

   #+BEGIN_SRC emacs-lisp
     (use-package ssh-config-mode
       :straight t
       :defer  t
       :delight (ssh-config-mode "SSH")
       ;; TODO advise last host to behave like org mode
       :general
       (:keymaps '(ssh-config-mode-map ssh-known-hosts-mode-map)
        :states 'motion
        "gj" 'ssh-config-host-next
        "gk" 'ssh-config-host-prev))
   #+END_SRC

** makefile
   :PROPERTIES:
   :header-args+: :tangle (package-yes! makefile)
   :END:

   #+BEGIN_SRC emacs-lisp
     (use-package make-mode
       :defer t
       :config
       (defun makefile--enable-evil-motion-state (&rest _)
         (evil-motion-state +1))

       ;; tabs for indentation, spaces for allignment
       (advice-add 'makefile-backslash-region :around
                   (defun makefile-backslash-region--no-tabs (func &rest args)
                     (let (indent-tabs-mode)
                       (apply func args))))

       (advice-add #'makefile-switch-to-browser          :after #'makefile--enable-evil-motion-state)
       (advice-add #'makefile-create-up-to-date-overview :after #'makefile--enable-evil-motion-state)

       :lazy-leader
       (:mode '(makefile-automake-mode
                makefile-bsdmake-mode
                makefile-gmake-mode
                makefile-imake-mode
                makefile-mode
                makefile-makepp-mode)
        "b" 'makefile-switch-to-browser
        "o" 'makefile-create-up-to-date-overview
        "p" 'makefile-pickup-everything
        "f" 'makefile-pickup-filenames-as-targets

        ":"   'makefile-insert-target-ref
        "C-:" 'makefile-insert-target-ref

        "\\"  'makefile-backslash-region
        "TAB" 'makefile-insert-gmake-function)

       :general
       (:keymaps 'makefile-mode-map
        :states 'insert
        "TAB" 'indent-for-tab-command
        "<tab>" 'indent-for-tab-command)
       (:keymaps 'makefile-mode-map
        :states 'motion
        "gj" 'makefile-next-dependency
        "gk" 'makefile-previous-dependency)
       (:states  'motion
        :keymaps 'makefile-browser-map
        "j" 'makefile-browser-next-line
        "k" 'makefile-browser-previous-line

        "t"     'makefile-browser-toggle
        "TAB"   'makefile-browser-toggle
        "<tab>" 'makefile-browser-toggle
        "RET"   'makefile-browser-insert-continuation

        "I" 'makefile-browser-insert-selection-and-quit
        "i" 'makefile-browser-insert-selection

        [remap quit-window] 'makefile-browser-quit))
   #+END_SRC

** markdown
   :PROPERTIES:
   :header-args+: :tangle (package-yes! markdown)
   :END:

    #+BEGIN_SRC emacs-lisp
      (use-package markdown-mode
        :straight t
        :defer  t
        :hook ((markdown-mode . display-line-numbers-mode)
               (markdown-mode . flycheck-mode))
        :custom
        (markdown-indent-on-enter 'indent-and-new-item)
        (markdown-fontify-code-blocks-natively t)

        :config
        (advice-add 'markdown-insert-list-item :before
                    (defun markdown-insert-list-item--adjust-line+ (&rest args)
                      "by default, inserting a new list item goes below the current item."
                      (when (markdown-list-item-at-point-p)
                        (save-excursion
                          (goto-char (line-end-position))
                          (newline))

                        (markdown-forward-paragraph))))

        (advice-add 'markdown-insert-list-item :after
                    (defun markdown-insert-list-item--force-evil-insert+ (&rest args)
                      (if (eq (char-before)
                              ?\ )
                          (evil-insert nil)
                        (evil-append nil))))

      ;;; evil-markdown-mode (Somelauw/evil-markdown)
        (with-eval-after-load 'evil
          (evil-declare-motion 'markdown-forward-paragraph)
          (evil-declare-motion 'markdown-backward-paragraph)

          ;; heading
          (evil-declare-motion 'markdown-forward-same-level)
          (evil-declare-motion 'markdown-backward-same-level)
          (evil-declare-motion 'markdown-up-heading)
          (evil-declare-motion 'markdown-next-heading)
          (evil-declare-motion 'markdown-previous-heading)
          (evil-declare-motion 'markdown-next-visible-heading)
          (evil-declare-motion 'markdown-previous-visible-heading)

          ;; other
          (evil-declare-motion 'markdown-beginning-of-block)
          (evil-declare-motion 'markdown-beginning-of-defun)
          (evil-declare-motion 'markdown-end-of-block)
          (evil-declare-motion 'markdown-end-of-block-element)
          (evil-declare-motion 'markdown-end-of-defun)
          (evil-declare-motion 'markdown-next-visible-heading)
          (evil-declare-motion 'markdown-next-link)
          (evil-declare-motion 'markdown-previous-visible-heading)
          (evil-declare-motion 'markdown-previous-link)

          ;; non-repeatible
          (evil-declare-change-repeat 'markdown-cycle)
          (evil-declare-change-repeat 'markdown-shifttab))

        :lazy-leader
        (:mode 'markdown-mode
         ;; unbound commands:
         ;;  * markdown-outdent-region
         ;;  * markdown-indent-region
         ;;  * markdown-outline-previous-same-level
         "h" 'markdown-up
         "j" 'markdown-next
         "k" 'markdown-previous
         "l" 'markdown-outline-next-same-level
         "g" 'markdown-next-link
         "G" 'markdown-previous-link
         "}" 'markdown-forward-block
         "{" 'markdown-backward-block
         "SPC" 'markdown-do
         "'" 'markdown-edit-code-block
         "f" 'markdown-follow-thing-at-point
         ">" 'markdown-blockquote-region
         "TAB" 'markdown-pre-region ;; preformat

         ;; complete/checks
         "c"  "check/complete"
         "cc" 'markdown-complete
         "cb" 'markdown-complete-buffer
         "cr" 'markdown-check-refs
         "cR" 'markdown-unused-refs
         "cl" 'markdown-cleanup-list-numbers

         "o" 'markdown-open
         "e" 'markdown-export
         "p" 'markdown-preview
         "v" 'markdown-export-and-preview
         "O" 'markdown-other-window

         ;; insert
         "i"  "insert"
         "i TAB" 'markdown-insert-image
         "i*" 'markdown-insert-list-item
         "i!" 'markdown-insert-header-setext-1
         "i-" 'markdown-insert-hr
         "i1" 'markdown-insert-header-atx-1
         "i2" 'markdown-insert-header-atx-2
         "i3" 'markdown-insert-header-atx-3
         "i4" 'markdown-insert-header-atx-4
         "i5" 'markdown-insert-header-atx-5
         "i6" 'markdown-insert-header-atx-6
         "i@" 'markdown-insert-header-setext-2
         "iC" 'markdown-insert-gfm-code-block
         "iH" 'markdown-insert-header-setext-dwim
         "i[" 'markdown-insert-gfm-checkbox
         "ib" 'markdown-insert-bold
         "ic" 'markdown-insert-code
         "ie" 'markdown-insert-italic
         "if" 'markdown-insert-footnote
         "ii" 'markdown-insert-italic
         "ik" 'markdown-insert-kbd
         "ip" 'markdown-insert-pre
         "iq" 'markdown-insert-blockquote
         "is" 'markdown-insert-strike-through

         "ih"  "header"
         "ih!" 'markdown-insert-header-setext-1
         "ih1" 'markdown-insert-header-atx-1
         "ih2" 'markdown-insert-header-atx-2
         "ih3" 'markdown-insert-header-atx-3
         "ih4" 'markdown-insert-header-atx-4
         "ih5" 'markdown-insert-header-atx-5
         "ih6" 'markdown-insert-header-atx-6
         "ih@" 'markdown-insert-header-setext-2
         "ihH" 'markdown-insert-header-setext-dwim
         "ihh" 'markdown-insert-header-dwim
         "ihs" 'markdown-insert-header-setext-2
         "iht" 'markdown-insert-header-setext-1

         "il"  "link"
         "ill" 'markdown-insert-link
         "ilf" 'markdown-insert-footnote
         "ilu" 'markdown-insert-uri
         "ilw" 'markdown-insert-wiki-link

         ;; delete/kill
         "d"  "delete"
         "dd" 'markdown-kill-thing-at-point
         "db" 'markdown-kill-block
         "do" 'markdown-kill-outline
         "dy" 'markdown-kill-ring-save

         ;; toggles
         "M"  "toggle"
         "Mm" 'markdown-toggle-math
         "Mf" 'markdown-toggle-fontify-code-blocks-natively
         "Mi" 'markdown-toggle-inline-images
         "Mu" 'markdown-toggle-url-hiding
         "Mm" 'markdown-toggle-markup-hiding
         "Mc" 'markdown-toggle-gfm-checkbox
         "Ml" 'markdown-live-preview-mode

         ;; narrowing
         "n"  "narrow"
         "nb" 'markdown-narrow-to-block
         "np" 'markdown-narrow-to-page
         "ns" 'markdown-narrow-to-subtree
         "nw" 'widen

         ;; marks
         "m"  "mark"
         "ms" 'markdown-mark-subtree
         "mb" 'markdown-mark-block

         ;; table
         "t"  "table"
         "ts" 'markdown-table-sort-lines
         "tT" 'markdown-table-transpose
         "tt" 'markdown-insert-table
         "tn" 'markdown-insert-table
         "tc" 'markdown-table-convert-region

         "ti"  "insert"
         "tir" 'markdown-table-insert-row
         "tic" 'markdown-table-insert-column
         "tit" 'markdown-insert-table

         "td"  "delete"
         "tdr" 'markdown-table-delete-row
         "tdc" 'markdown-table-delete-column)

        :general
        (:keymaps 'markdown-mode-map
         :states 'motion
         "gh" 'markdown-up-heading
         "gj" 'markdown-outline-next
         "gk" 'markdown-outline-previous
         "gl" 'markdown-outline-next-same-level
         "}" 'markdown-forward-paragraph
         "{" 'markdown-backward-paragraph)
        (:keymaps 'markdown-mode-map
         :states 'insert
         "RET"      'markdown-enter-key
         "<return>" 'markdown-enter-key)
        (:keymaps 'markdown-mode-map
         :states '(normal insert)
         "C-<return>" 'markdown-insert-list-item)
        (:keymaps 'markdown-mode-map
         :states '(insert normal)
         :predicate '(markdown-list-item-at-point-p)
         [remap drag-stuff-down]  'markdown-move-down
         [remap drag-stuff-up]    'markdown-move-up)
        (:keymaps 'markdown-mode-map
         :states '(insert normal)
         :predicate '(or (markdown-list-item-at-point-p)
                         (markdown-on-heading-p))
         [remap evil-shift-right] 'markdown-demote
         [remap evil-shift-left]  'markdown-promote)
        (:keymaps 'markdown-mode-map
         :states '(insert normal)
         :predicate '(or (markdown--table-at-point-p)
                         (markdown-on-heading-p))
         "<tab>"           'markdown-cycle
         "<S-iso-lefttab>" 'markdown-shifttab
         "<S-tab>"         'markdown-shifttab
         "<backtab>"       'markdown-shifttab))
    #+END_SRC

*** markdown-toc
    #+BEGIN_SRC emacs-lisp
      (use-package markdown-toc
        :straight t
        :defer  t
        :lazy-leader
        (:mode 'markdown-mode
         "bx" 'markdown-toc-delete-toc
         "br" 'markdown-toc-refresh-toc
         "bb" 'markdown-toc-generate-or-refresh-toc
         "bi" 'markdown-toc-generate-toc))
    #+END_SRC

*** gh-md
    #+BEGIN_SRC emacs-lisp
      (use-package gh-md
        :straight t
        :defer  t
        :after  markdown-mode
        :leader
        (:mode 'markdown-mode
         "r" 'gh-md-render-buffer
         "R" 'gh-md-render-region))
    #+END_SRC

** cmake
   :PROPERTIES:
   :header-args+: :tangle (package-yes! cmake)
   :END:

   #+BEGIN_SRC emacs-lisp
     (use-package cmake-mode
       :straight t
       :defer  t
       :mode (rx (or "CMakeLists.txt" ".cmake"))
       :hook (cmake-mode . flycheck-mode))
   #+END_SRC

*** company-cmake
    #+BEGIN_SRC emacs-lisp
      (use-package company-cmake
        :straight (company-cmake :host github :fork "company-cmake")
        :after cmake
        :defer t
        :init
        (company/configure-mode (cmake-mode :major t)
          company-cmake))
    #+END_SRC

** c
   :PROPERTIES:
   :header-args+: :tangle (package-yes! c)
   :END:

   #+BEGIN_SRC emacs-lisp
     (use-package cc-mode
       :straight (cc-mode :type built-in)
       :defer t
       :mode ("\\.h$" . c++-mode)
       :commands (cc-mode-set-bindings+)
       :hook ((c-mode   . flycheck-mode)
              (c++-mode . flycheck-mode))
       :config
       (c-toggle-auto-newline  +1)
       ;; WARN never do this, it breaks commenting in
       ;;      weird places.
       ;; (c-toggle-comment-style +1)

       (setq c-default-style "stroustrup")

       ;; (company/configure-mode ((c-mode c++-mode) :major t :predicate ycmd-mode)
       ;;   company-ycmd company-c-headers)

       (defun cc-mode-set-bindings+ (mode)
         (leader/set-keys-for-major-mode mode
           "S" 'c-set-style
           "D" 'c-display-defun-name
           "m" 'c-mark-function
           "r" 'c-indent-defun
           "/" 'c-backslash-region
           "\\" 'c-toggle-comment-style
           "DEL" 'c-hungry-delete-forward
           "M-DEL" 'c-hungry-delete-backwards))

       (cc-mode-set-bindings+ 'c-mode)
       (cc-mode-set-bindings+ 'cc-mode))
   #+END_SRC

*** lsp
    LSP implementation for C++/C.

    #+BEGIN_SRC emacs-lisp :tangle (package-yes! c :lsp)
      ;; prefer clang to ccls (when available).
      (when (and +c-prefer-clangd
                 (package! eglot)
                 (executable-find "clangd"))
        (with-eval-after-load 'eglot
          (add-to-list 'eglot-server-programs
                       '((c++-mode c-mode) "clangd"))))

      (add-hook 'c-mode-hook   +lsp-command)
      (add-hook 'c++-mode-hook +lsp-command)
    #+END_SRC

*** disaster
    #+BEGIN_SRC emacs-lisp
      (use-package disaster
        :straight t
        :defer  t
        :after  cc-mode
        :leader
        (:mode '(c-mode c++-mode)
         "D" 'disaster))
    #+END_SRC

** kotlin
   :PROPERTIES:
   :header-args+: :tangle (package-yes! kotlin)
   :END:

   #+BEGIN_SRC emacs-lisp :tangle (package-yes! kotlin :lsp)
     (add-hook 'kotlin-mode-hook +lsp-command)
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (use-package kotlin-mode
       :straight t
       :defer  t
       :config
       (push (cons 'kotlin-mode 4) +indent-config)

       :lazy-leader
       (:mode 'kotlin-mode
        "r" 'kotlin-repl

        "e"     "eval"
        "e-"    'kotlin-send-line
        "e|"    'kotlin-send-block
        "er"    'kotlin-send-region
        "eb"    'kotlin-send-buffer
        "e S--" 'kotlin-send-line-and-focus
        "e S-|" 'kotlin-send-block-and-focus
        "eR"    'kotlin-send-region-and-focus
        "eB"    'kotlin-send-buffer-and-focus))
   #+END_SRC

** java
   :PROPERTIES:
   :header-args+: :tangle (package-yes! java)
   :END:

   java, the language *everyone* tolerates.

   #+BEGIN_SRC emacs-lisp
     (use-package cc-mode
       :defer t
       :init
       :config
       (cc-mode-set-bindings+ 'java-mode)

       (add-hook 'java-mode-hook
                 (defun +java-mode-fix-indentation ()
                   (c-set-offset 'inexpr-class 0))))
   #+END_SRC

*** meghanada
    a language server for java, written in java. NOT LSP Compliant.

   #+BEGIN_SRC emacs-lisp
     (use-package meghanada
       :straight t
       :defer  t
       :delight (meghanada-mode "MEG")
       :hook (java-mode . meghanada-mode)
       :config
       (require 'yasnippet)

       (company/configure-mode (meghanada-mode)
         company-meghanada)

       (setq meghanada-map+ (make-sparse-keymap))

       :lazy-leader
       (:mode 'meghanada-mode
        :minor t
        :prefix leader-server-leader-prefix
        ""  "meghanada"
        ""  meghanada-map+

        "c" "compile/run"
        "t" "test"
        "S" "server"
        "i" "insert/refactor")

       :general
       (:keymaps 'meghanada-map+
        "SPC" 'meghanada-run-task
        "D"   'meghanada-typeinfo
        "G"   'meghanada-back-jump
        "F"   'meghanada-search-everywhere-ex
        "d"   'meghanada-reference ;; documentation
        "g"   'meghanada-jump-declaration
        "k"   'meghanada-server-kill
        "n"   'meghanada-server-start
        "p"   'meghanada-code-beautify
        "r"   'meghanada-restart
        "s"   'meghanada-show-project
        "f"   'meghanada-search-everywhere
        "y"   'meghanada-mode

        "cc" 'meghanada-compile-project
        "cd" 'meghanada-debug-main
        "cf" 'meghanada-compile-file
        "cr" 'meghanada-exec-main

        "Si" 'meghanada-install-server
        "Su" 'meghanada-update-server

        "ia" 'meghanada-import-all
        "il" 'meghanada-local-variable
        "io" 'meghanada-optimize-import
        "ip" 'meghanada-import-at-point

        "td"      'meghanada-debug-junit-class
        "tt"      'meghanada-switch-testcase                                         ; test -> file -> test
        "tf"      'meghanada-run-junit-class
        "t SPC"   'meghanada-run-junit-test-case
        "t C-SPC" 'meghanada-debug-junit-test-case))
   #+END_SRC

** javascript
   :PROPERTIES:
   :header-args+: :tangle (package-yes! javascript)
   :END:

   # NOTE no on the fly syntax checking? make sure eslint is installed no warning
   # or error will be issued if it isn't :(

*** javascript-mode
    I just use this as a drop in replacement for json-mode :)

    #+BEGIN_SRC emacs-lisp :tangle yes
      (push '(js-mode . 2) +indent-config)
    #+END_SRC

*** js2-mode
    the true javascript package for emacs.

    #+BEGIN_SRC emacs-lisp
      (use-package js2-mode
        :straight t
        :defer  t
        :mode (rx ".js")
        :hook ((js2-mode . flycheck-mode)
               (js2-mode . javascript-enable-lsp-in-projects)
               (js2-jx-mode . javascript-enable-lsp-in-projects))
        :commands (js-jsdoc-return+)
        :init
        (defun javascript-enable-lsp-in-projects (&rest _)
          (when (and +lsp-command
                     (project-has-file-p "package.json"
                                         "yarn.lock"))
            (funcall +lsp-command)))

        :config
        (setq js2-mode-show-parse-errors      nil
              js2-mode-show-strict-warnings   nil
              js2-strict-missing-semi-warning nil)

        (defun js-jsdoc-return+ (&optional arg)
          (interactive "p")
          (barf-if-buffer-read-only) ;; can't continue adding to readonly buffer.
          (setq arg (or arg 1)) ;; insert one line when arg hasn't been given.

          (let (inserted)
            (when (in-comment-p)
              (let* ((current-line (buffer-substring-no-properties
                                    (line-beginning-position)
                                    (line-end-position)))
                     (start-regexp (rx bol (zero-or-more blank) "/**"))
                     (continue-regexp (rx bol (one-or-more blank) "*"))
                     start-p continue-p)
                (when (or (setq continue-p (string-match-p continue-regexp current-line))
                          (setq start-p    (string-match-p start-regexp    current-line)))
                  (setq inserted t)
                  (let ((start-column (line-beginning-column)))
                    (when start-p (cl-incf start-column)) ;; one char past start column
                    (dotimes (_ arg)
                      ;; (goto-char (line-end-position))
                      (newline)
                      (insert (make-string start-column ? ) "* ")
                      (save-excursion
                        (previous-line)
                        (whitespace-cleanup-region (line-beginning-position) (line-end-position))))))))
            (unless inserted
              (dotimes (_ arg)
                (indent-new-comment-line)))))

        :lazy-leader
        (:mode 'js2-mode
         "i"  "insert"
         "h"  "help"
         "gg" 'js2-jump-to-definition

         ;; toggle hide-show
         "H"  "hide/show"
         "HH" 'js2-mode-show-all
         "Hw" 'js2-mode-toggle-warnings-and-errors
         "He" 'js2-mode-toggle-element
         "Hc" 'js2-mode-toggle-hide-comments
         "Hf" 'js2-mode-toggle-hide-functions

         ;; hide
         "Hh" "hide"
         "Hhw" 'js2-mode-hide-warnings-and-errors
         "Hhe" 'js2-mode-hide-element
         "Hhc" 'js2-mode-show-comments
         "Hhf" 'js2-mode-hide-functions

         ;; show
         "Hs" "show"
         "Hsw" 'js2-mode-display-warnings-and-errors
         "Hse" 'js2-mode-show-element
         "Hsc" 'js2-mode-hide-comments
         "Hsf" 'js2-mode-show-functions)

        :general
        (:keymaps 'js2-mode-map
         [remap indent-new-comment-line] 'js-jsdoc-return+)
        (:keymaps 'js2-mode-map
         :states  'insert
         ;; properly formets javadocs
         "<return>" 'js2-line-break
         "RET"      'js2-line-break))
    #+END_SRC

*** js-doc
    #+BEGIN_SRC emacs-lisp
      (use-package js-doc
        :straight t
        :defer  t
        :config
        ;; (general-define-key
        ;;   :keymaps 'js2-mode-map
        ;;   :states 'insert
        ;;   "@" 'js-doc-insert-tag)

        :config
        (advice-add 'js-doc-insert-function-doc-snippet :after
                    (lambda (&rest r)
                      (evil-insert nil)))

        :lazy-leader
        (:mode 'js2-mode
          "i@" 'js-doc-insert-tag
          "i)" 'js-doc-insert-function-doc                                            ; only works from within method
          "i(" 'js-doc-insert-function-doc-snippet
          "if" 'js-doc-insert-file-doc
          "h@" 'js-doc-describe-tag))
    #+END_SRC

*** js2-refactor
    #+BEGIN_SRC emacs-lisp
      ;; most of this doesn't seem to work very well...
      ;; so I'm only using a few functions with simple features.
      (use-package js2-refactor
        :straight t
        :defer  t
        :diminish
        :hook (js2-mode . js2-refactor-mode)
        :config
        (defun js2r-exit-visual-mode-after-func-call (&rest args)
          (when (evil-visual-state-p)
            (evil-exit-visual-state)))

        (advice-add 'js2r-extract-method   :after #'js2r-exit-visual-mode-after-func-call)
        (advice-add 'js2r-extract-function :after #'js2r-exit-visual-mode-after-func-call)

        :lazy-leader
        (:mode 'js2-mode
         "[" 'js2r-expand-node-at-point
         "]" 'js2r-contract-node-at-point

         ;; doesn't work unless executed from within a function
         "e"  "extract"
         "ef" 'js2r-extract-function
         "em" 'js2r-extract-method
         "ev" 'js2r-extract-var
         "el" 'js2r-extract-let
         "ec" 'js2r-extract-const

         "l" 'js2r-log-this
         "L" 'js2r-debug-this

         "v" 'js2r-var-to-this

         "s" 'js2r-forward-slurp
         "b" 'js2r-forward-barf))
    #+END_SRC

*** xref-js2
    #+BEGIN_SRC emacs-lisp
      (use-package xref-js2
        :straight t
        :defer  t
        :hook (xref-backend-functions . xref-js2-xref-backend)
        :config
        (setq xref-js2-search-program 'rg))
    #+END_SRC

*** skewer-mode
    #+BEGIN_SRC emacs-lisp :tangle no
      (use-package skewer-mode
        :straight t
        :defer  t
        :delight
        (skewer-css-mode "skewerC")
        (skewer-html-mode "skewerH")
        :init
        (setq skewer-leader-prefix (concat leader-major-mode-prefix "S"))

        :config
        ;; once required, enable skewer in all
        ;; compatible buffers
        (add-hook 'js2-mode-hook 'skewer-mode)
        (add-hook 'css-mode-hook 'skewer-css-mode)
        (add-hook 'html-mode-hook 'skewer-html-mode)

        ;; (run-skewer) ;; and begin server

        :lazy-leader
        (:mode 'skewer-mode
         :minor t
         :prefix skewer-leader-prefix
         "e" 'skewer-eval-last-expression
         "E" 'skewer-eval-print-last-expression
         "(" 'skewer-eval-defun
         "b" 'skewer-load-buffer

         "R" 'skewer-repl
         "L" 'skewer-bower-load
         "B" 'skewer-bower-refresh
         "p" 'skewer-run-phantomjs
         "P" 'skewer-phantomjs-kill)
        (:mode 'skewer-html-mode
         :minor t
         :prefix skewer-leader-prefix
         "s" 'skewer-html-fetch-selector-into-buffer
         "e" 'skewer-html-eval-tag

         "R" 'skewer-repl
         "L" 'skewer-bower-load
         "B" 'skewer-bower-refresh
         "p" 'skewer-run-phantomjs
         "P" 'skewer-phantomjs-kill)
        (:mode 'skewer-css-mode
         :minor t
         :prefix skewer-leader-prefix
         "e" 'skewer-css-eval-current-rule
         "b" 'skewer-css-eval-buffer
         "c" 'skewer-css-clear-all
         "d" 'skewer-css-eval-current-declaration

         "R" 'skewer-repl
         "L" 'skewer-bower-load
         "B" 'skewer-bower-refresh
         "p" 'skewer-run-phantomjs
         "P" 'skewer-phantomjs-kill))
    #+END_SRC

** typescript
   :PROPERTIES:
   :header-args+: :tangle (package-yes! javascript typescript)
   :END:

   Typescript depends on javascript +for now+.

   #+BEGIN_SRC emacs-lisp
     (use-package typescript-mode
       :straight t
       :defer  t
       :mode ("\\.tsx" . typescript-mode)
       :hook (typescript-mode . javascript-enable-lsp-in-projects)
       :general
       (:keymaps 'typescript-mode-map
        [remap indent-new-comment-line] 'js-jsdoc-return+))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (when +lsp-command
       (add-hook 'typescript-mode-hook  +lsp-command))

     (push '(typescript-mode . 2) +indent-config)
     (add-hook 'typescript-mode-hook
               (defun ts-setup-tsx ()
                 (when (string-suffix-p ".tsx"
                                        (buffer-file-name))
                   (emmet-mode +1)
                   (setq-local emmet-expand-jsx-className? t))))
   #+END_SRC

** css/less
   :PROPERTIES:
   :header-args+: :tangle (package-yes! css)
   :END:

*** css-mode
    #+BEGIN_SRC emacs-lisp
      (use-package css-mode
        :defer t
        :config
        (company/configure-mode (css-mode :major t)
          company-css)

        :lazy-leader
        (:mode '(less-css-mode css-mode)
         "?" 'css-lookup-symbol
         "b" 'web-beautify-css))
    #+END_SRC

*** lsp
    Requires ~npm install --global vscode-css-languageserver-bin~.

    #+BEGIN_SRC emacs-lisp :tangle (package-yes! css :lsp)
      (add-hook 'css-mode-hook  +lsp-command)
      (add-hook 'scss-mode-hook +lsp-command)

      (when (package! eglot)
        (with-eval-after-load 'eglot
          (push '((css-mode scss-mode)
                  "css-languageserver" "--stdio")
                eglot-server-programs)))
    #+END_SRC

*** less-css-mode
    #+BEGIN_SRC emacs-lisp
      (use-package less-css-mode
        :defer t
        :config
        (company/configure-mode (less-css-mode :major t)
          company-css)

        :lazy-leader
        (:mode 'less-css-mode
         "c" 'less-css-compile))
    #+END_SRC

** haskell
   :PROPERTIES:
   :header-args+: :tangle (package-yes! haskell)
   :END:

*** hindent
    #+BEGIN_SRC emacs-lisp
      (use-package hindent
        :straight t
        :defer  t
        :hook (haskell-mode . hindent-mode))
    #+END_SRC

*** company-cabal
    #+BEGIN_SRC emacs-lisp
      (use-package company-cabal
        :straight t
        :defer  t
        :after haskell-mode
        :init
        (company/configure-mode (haskell-cabal-mode :major t)
          company-cabal))
    #+END_SRC

*** flycheck-haskell
    #+BEGIN_SRC emacs-lisp :tangle (package-yes! haskell flycheck)
      (use-package flycheck-haskell
        :straight t
        :defer  t
        :after  haskell-mode)
    #+END_SRC

*** haskell-mode
    #+BEGIN_SRC emacs-lisp
      (use-package haskell-mode
        :straight t
        :defer  t
        :init
        (push 'haskell-interactive-mode whitespace-exempt-modes)
        (push 'inferior-haskell-mode whitespace-exempt-modes)
        (defalias 'haskell-repl #'run-haskell)

        :config
        (use-package haskell-indent
          :commands (haskell-indent-cycle))

        (setq haskell-process-type 'cabal-repl)
        (evil-set-initial-state 'haskell-interactive-mode 'emacs)

        (defun haskell-enable-indent-control+ ()
          (interactive)
          (haskell-indent-mode +1)
          (general-define-key
            :states  '(insert replace)
            :keymaps 'haskell-mode-map
            "<tab>" 'haskell-indent-cycle))

        :lazy-leader
        (:mode 'haskell-mode
         "TAB"   'haskell-indent-cycle
         "S-TAB" 'haskell-delete-indentation

         "r"  "refactor"
         "ri" 'haskell-mode-format-imports
         "rI" 'haskell-sort-imports

         "i"  "insert"
         "is" 'haskell-mode-toggle-scc-at-point
         "i|" 'haskell-indent-insert-guard
         "iw" 'haskell-indent-insert-where
         "io" 'haskell-indent-insert-other
         "i=" 'haskell-indent-insert-equal

         "s"  "session"
         "sc" 'haskell-session-change
         "sC" 'haskell-session-change-target
         "sk" 'haskell-session-kill
         "sK" 'haskell-kill-session-process)

        :general
        (:keymaps 'haskell-mode-map "C-M-i" nil))
    #+END_SRC

*** lsp
    #+BEGIN_SRC emacs-lisp :tangle (package-yes! haskell :lsp)
      (if (eq +lsp-command 'lsp)
          (use-package lsp-haskell
            :straight t
            :defer  t
            :after  haskell-mode
            :hook ((haskell-mode . lsp) ;; order of evaluation matters
                   (haskell-mode . (lambda ()
                                     (require 'lsp-haskell)
                                     ;; until there's actually any useful info
                                     (setq-local lsp-eldoc-enable-hover nil))))
            :config
            (setq lsp-haskell-process-args-hie (list "-d" "-l" (make-temp-file "hie." nil ".log"))))
        (add-hook 'haskell-mode-hook +lsp-command))
    #+END_SRC

** nim
   :PROPERTIES:
   :header-args+: :tangle (package-yes! nim)
   :END:

   #+BEGIN_SRC emacs-lisp
     (use-package nim-mode
       :straight t
       :defer  t
       :hook (nim-mode . nim-eldoc-on)
       :config
       (+set-compilation-bindings 'nim-compile-mode 'nim-compile-mode-map)

       (advice-add 'nim-compile--assert :override
                   (defun nim-compile--assert+ (command)
                     "Check COMMAND.
     Basically copied from `compile-command's document."
                     (or (stringp command)
                         (and (bound-and-true-p compilation-read-command)
                              (compilation-read-command)))))

       :general
       (:keymaps 'nim-mode-map
        [remap compile] 'nim-compile)
       (:keymaps 'nim-mode-map
        :states 'insert
        "DEL" 'nim-electric-backspace)

       :lazy-leader
       (:mode 'nim-mode
        "c" 'nim-compile))
   #+END_SRC

*** lsp
    Firstly in case lsp is not available, lets rely on the builtin nim help
    facilities curtesy of [[https://nim-lang.org/docs/nimsuggest.html][nimsuggest]].

    #+BEGIN_SRC emacs-lisp :tangle (package-yes! nim :not :lsp)
      (add-hook 'nim-mode-hook #'nimsuggest-mode)
    #+END_SRC

    Lets use [[https://github.com/PMunch/nimlsp][nimlsp]].

    #+BEGIN_SRC emacs-lisp :tangle (package-yes! nim :lsp)
      (add-hook 'nim-mode-hook +lsp-command)
      (remove-hook 'nim-mode-hook 'nim-eldoc-on)                                      ; eldoc is taken care of by my lsp package.

      (when (package! eglot)
        (with-eval-after-load 'eglot
          (push '((nim-mode nimscript-mode) . ("nimlsp")) eglot-server-programs)))
    #+END_SRC

** golang
   :PROPERTIES:
   :header-args+: :tangle (package-yes! golang)
   :END:

   #+BEGIN_SRC emacs-lisp
     (use-package go-mode
       :straight t
       :defer  t
       :config
       ;; only run when current buffer is in go-mode
       (add-hook 'before-save-hook 'gofmt-before-save)

       (add-hook 'go-mode-hook
                 (defun go-mode-setup+ ()
                   ;; recommended by the official style guide for golang.
                   (setq indent-tabs-mode t)))

       (push '(go-mode . 4) +indent-config)

       :lazy-leader
       (:mode 'go-mode
        ;; requires: go get github.com/rogpeppe/godef
        "h" "help/guru"
        "hh" 'godoc-at-point
        "hH" 'godoc

        "g" "goto"
        "gi" 'go-goto-imports
        "gc" 'go-coverage

        "i" "imports"
        "ia" 'go-import-add
        "ig" 'go-goto-imports
        "ir" 'go-remove-unused-imports

        "e" "playground"
        "eb" 'go-play-buffer
        "er" 'go-play-region
        "ed" 'go-download-play))
   #+END_SRC

*** go-guru
    requires: ~go get golang.org/s/using-guru~

    #+BEGIN_SRC emacs-lisp
      (use-package go-guru
        ;; only use when lsp based language support is available
        :only (not +lsp-command)
        :straight t
        :defer  t
        :after  go-mode
        :init
        (add-hook 'go-guru-output-mode-hook
                  (defun go-guru-preserve-compilation-window+ ()
                    "prevent my compilation-hook settings interfering with go-guru."
                    (setq-local compilation-auto-kill-window nil)))

        :lazy-leader
        (:mode 'go-mode
         "hd" 'go-guru-describe
         "hi" 'go-guru-implements
         "hc" 'go-guru-peers
         "hp" 'go-guru-pointsto
         "hs" 'go-guru-callstack
         "he" 'go-guru-whicherrs

         "gr" 'go-guru-referrers
         "g<" 'go-guru-callers
         "g>" 'go-guru-callees
         "go" 'go-guru-set-scope
         "gg" 'go-guru-definition
         "gf" 'go-guru-freevars))
    #+END_SRC

*** gopls
    The golang language server.
    requires: ~GO111MODULE=on  go get -u golang.org/x/tools/gopls@latest~.

    #+BEGIN_SRC emacs-lisp :tangle (package-yes! golang :lsp)
      (add-hook 'go-mode-hook +lsp-command)
    #+END_SRC

** rust
   :PROPERTIES:
   :header-args+: :tangle (package-yes! rust)
   :END:

   LSP support requires: ~rustup component add rls rust-analysis rust-src~.
   or [[https://github.com/rust-analyzer/rust-analyzer][rust-analyzer]].

   #+BEGIN_SRC emacs-lisp
     (use-package rustic
       :straight t
       :defer  t
       :config
       (setq rustic-format-trigget 'on-save
             rustic-lsp-client (cond
                                ((package! eglot)    'eglot)
                                ((package! lsp-mode) 'lsp-mode))
             rustic-lsp-server (if (executable-find "rust-analyzer")
                                   'rust-analyzer
                                 'rls))

       (advice-add 'rustic-popup :around
                   #'restore-default-display-buffer-actions)

       (push 'rustic-popup-mode whitespace-exempt-modes)
       (evil-set-initial-state 'rustic-popup-mode 'emacs)

       ;; (push 'rustic-compilation-mode compilation-auto-kill-ignore-modes)
       (push 'rustic-cargo-test-mode compilation-auto-kill-ignore-modes)

       (with-eval-after-load 'projectile
         (assoc-pop! 'rust-cargo projectile-project-types)

         (projectile-register-project-type 'rust-cargo '("Cargo.toml")
                                           :compile #'rustic-compile
                                           :test    #'rustic-cargo-test
                                           :run     #'rustic-cargo-run))

       :lazy-leader
       (:mode 'rustic-mode
        "," 'rustic-popup
        "c" 'rustic-compile
        "C" 'rustic-recompile
        "p" 'rustic-cargo-run
        "u" 'rustic-playpen
        "d" 'rustic-cargo-doc

        "b" "project"
        "bc" 'rustic-cargo-clean
        "bo" 'rustic-cargo-outdated
        "bd" 'rustic-cargo-build-doc

        "t" "test"
        "tt" 'rustic-cargo-test
        "tT" 'rustic-cargo-test-rerun
        "tb" 'rustic-cargo-bench
        "tc" 'rustic-cargo-check

        "r" "refactor"
        "rx" 'rustic-rustfix
        "rf" 'rustic-cargo-fmt
        "rc" 'rustic-cargo-clippy))
   #+END_SRC

*** compile
    fix ~compilation-was-open-p~ isn't assigned when rustic compilation is begun.

    #+BEGIN_SRC emacs-lisp
      (advice-add 'rustic-compilation :before
                  (defun rustic-compilation-check-window-was-open-p+ (command &rest args)
                    ;; copied from `rustic-compilation'.
                    (let ((buf (get-buffer
                                (or (plist-get args :buffer) rustic-compilation-buffer-name))))
                      (setq compilation-was-open-p
                            (and buf (get-buffer-window buf) t)))))
    #+END_SRC

** git
   :PROPERTIES:
   :header-args+: :tangle (package-yes! git-langs)
   :END:

*** gitignore
    #+BEGIN_SRC emacs-lisp
     (use-package gitignore-mode
       :straight t
       :defer  t)
    #+END_SRC

*** gitconfig
    #+BEGIN_SRC emacs-lisp
     (use-package gitconfig-mode
       :straight t
       :defer  t)
    #+END_SRC

*** gitattributes
    #+BEGIN_SRC emacs-lisp
     (use-package gitattributes-mode
       :straight t
       :defer  t)
    #+END_SRC

** latex
   :PROPERTIES:
   :header-args+: :tangle (package-yes! latex)
   :END:

   #+BEGIN_SRC emacs-lisp
     (use-package tex-mode
       :defer t
       :hook ((latex-mode . display-line-numbers-mode)
              (latex-mode . flycheck-mode))
       :init
       (setq TeX-auto-save  t
             TeX-parse-self t
             TeX-source-correlate-start-server t
             tex-print-file-extension ".pdf")

       (defvaralias 'LaTeX-mode-hook 'latex-mode-hook)

       (defvar latex-modes+ '(latex-mode tex-mode)
         "list of tex related modes. used for leader and pretty symbols.")

       (push '(tex-mode   . 2) +indent-config)
       (push '(latex-mode . 2) +indent-config)

       :config
       (push 'TeX-output-mode whitespace-exempt-modes)
       (push 'TeX-special-mode whitespace-exempt-modes)

       (add-hook 'plain-TeX-mode-hook
                 (defun tex-update-electric-math+ (&rest _)
                   (setq-local TeX-electric-math '("$" . "$"))))

       (add-hook 'LaTeX-mode-hook
                 (defun latex-update-electric-math+ (&rest _)
                   (setq-local TeX-electric-math '("\\(" . "\\)"))))

       ;; show process output on error
       (advice-add 'TeX-command-sentinel :after
                   (defun TeX-process-error-handler+ (p msg)
                     (unless (zerop (process-exit-status p))
                       (TeX-recenter-output-buffer nil))))

       ;; for some reason, focus switches back to tex buffer
       (advice-add 'TeX-recenter-output-buffer :after
                   (defun TeX-recenter-focus (&rest _)
                     (TeX-pop-to-buffer (TeX-active-buffer))))

       (eval
        `(configure-presym! ',latex-modes+
           ,@(cl-loop
              for tuple in tex--prettify-symbols-alist
              append (list (car tuple) (cdr tuple)))))

       ;; (defun latex/font-bold         () (interactive) (TeX-font nil ?\C-b))
       ;; (defun latex/font-medium       () (interactive) (TeX-font nil ?\C-m))
       ;; (defun latex/font-code         () (interactive) (TeX-font nil ?\C-t))
       ;; (defun latex/font-emphasis     () (interactive) (TeX-font nil ?\C-e))
       ;; (defun latex/font-italic       () (interactive) (TeX-font nil ?\C-i))
       ;; (defun latex/font-clear        () (interactive) (TeX-font nil ?\C-d))
       ;; (defun latex/font-calligraphic () (interactive) (TeX-font nil ?\C-a))
       ;; (defun latex/font-small-caps   () (interactive) (TeX-font nil ?\C-c))
       ;; (defun latex/font-sans-serif   () (interactive) (TeX-font nil ?\C-f))
       ;; (defun latex/font-normal       () (interactive) (TeX-font nil ?\C-n))
       ;; (defun latex/font-serif        () (interactive) (TeX-font nil ?\C-r))
       ;; (defun latex/font-oblique      () (interactive) (TeX-font nil ?\C-s))
       ;; (defun latex/font-upright      () (interactive) (TeX-font nil ?\C-u))

       :leader
       (:mode latex-modes+
        "{" 'latex-insert-block
        "}" 'latex-close-block)

       :general
       (:keymaps 'latex-mode-map "C-M-i" nil))
   #+END_SRC

*** auctex
    #+BEGIN_SRC emacs-lisp
      (use-package tex-site
        :straight auctex
        :after  tex-mode
        :defer  t
        :hook ((latex-mode . TeX-fold-mode)
               (latex-mode . TeX-PDF-mode)
               (latex-mode . TeX-source-correlate-mode))
        :config
        (defvar-local TeX-command-last nil
          "the last command invoked by TeX in this buffer.")

        (defun TeX-command-smart (&optional prompt override-confirm)
          "`TeX-command-master' but with memory.
      This function works like the master command, however by default it reruns
      the last run command instead of prompting to run the command. You can pass
      a prefix arg to force the prompt to take place.
      "
          (interactive "P")
          (unless TeX-command-last
            (setq prompt t))

          (let ((cmd (or (and prompt
                              (TeX-command-query (TeX-master-file nil nil t)))
                         TeX-command-last)))
            (setq TeX-command-last cmd) ;; update command memory
            (TeX-command cmd 'TeX-master-file override-confirm)))

        (advice-add 'TeX-command :before
                    (defun TeX-command--prompt-to-save+ (&rest args)
                      "ask to save modified tex buffers, before running commands on them."
                      (when (and (buffer-modified-p)
                                 buffer-file-name
                                 (yes-or-no-p (format "Save file %s?" buffer-file-name)))
                        (save-buffer))))

      ;;; Setup the view command for latex
        (when TeX-view-in-emacs+
          (add-hook 'TeX-after-compilation-finished-functions #'TeX-revert-document-buffer))

        (with-eval-after-load 'tex
          (setq TeX-view-program-selection
                (append (delq nil (list (when TeX-view-in-emacs+
                                          '(output-pdf "PDF Tools"))
                                        (when (executable-find "zathura")
                                          '(output-pdf "Zathura"))
                                        '(output-html "xopen")))                      ; prefer over xdg-open
                        TeX-view-program-selection)))

      ;;; Fix annoying emacsclient issues with synctex
        ;; emacs isn't using the path for my server file and there's no way to specify
        ;; both the server TCP file and socket file, so let's just hack it into the editor
        ;; command.
        (with-eval-after-load 'tex
          (push
           `("Zathura"
             ("zathura %o"
              (mode-io-correlate
               ,(concat " --synctex-forward %n:0:\"%b\" -x \""
                        (concat "emacsclient "
                                (cond ((unix-p)
                                       (concat
                                        " --socket-name "
                                        (shell-quote-argument (join-path server-socket-dir "server"))))
                                      ((windows-p)
                                       (concat
                                        "--server-file "
                                        (shell-quote-argument (join-path server-auth-dir "server"))))))
                        " +%{line} %{input}\"")))
             "zathura")
           TeX-view-program-list))

        :lazy-leader
        (:mode 'TeX-error-overview-mode
         "b" 'TeX-error-overview-toggle-debug-bad-boxes
         "w" 'TeX-error-overview-toggle-debug-warnings
         "s" 'TeX-error-overview-toggle-suppress-ignored-warnings
         "l" 'TeX-error-overview-goto-log)
        (:mode latex-modes+
         "SPC" 'TeX-command-master
         "b" 'LaTeX-environment ;; block but more interactive.
         "," 'TeX-command-smart
         "." 'TeX-command-run-all
         "l" 'TeX-recenter-output-buffer
         "e" 'TeX-error-overview
         "k" 'TeX-kill-job
         "v" 'TeX-view
         "h" 'TeX-doc
         "RET" 'TeX-command-run-all
         "t" 'TeX-font
         "\\" 'TeX-insert-macro
         "s" 'LaTeX-section
         "m" 'LaTeX-mark-environment ;; or LaTeX-mark-section

         ;; preview
         "p"   "preview"
         "pb"  'preview-buffer
         "pc"  'preview-clearout
         "pd"  'preview-document
         "pe"  'preview-environment
         "pf"  'preview-cache-preamble
         "pp"  'preview-at-point
         "pr"  'preview-region
         "ps"  'preview-section

         ;; fold
         "z" "fold"
         "z=" 'TeX-fold-math
         "zz" 'TeX-fold-dwim
         "zb" 'TeX-fold-buffer
         "zB" 'TeX-fold-clearout-buffer
         "ze" 'TeX-fold-env
         "zr" 'TeX-fold-region
         "zR" 'TeX-fold-clearout-region
         "zm" 'TeX-fold-macro
         "z\\" 'TeX-fold-macro
         "zp" 'TeX-fold-paragraph
         "zP" 'TeX-fold-clearout-paragraph
         "z%" 'TeX-fold-comment
         "zc" 'TeX-fold-clearout-item

         ;; indentation
         "TAB"   "indent"
         "TAB b" 'LaTeX-fill-environ
         "TAB p" 'LaTeX-fill-paragra
         "TAB r" 'LaTeX-fill-region
         "TAB s" 'LaTeX-fill-section

         ;; modes
         "M"  "mode"
         "Mp" 'TeX-PDF-mode ;; toggle between PDF and DVI output.
         "Ms" 'TeX-source-correlate-mode
         "Mi" 'TeX-interactive-mode
         "Mm" 'LaTeX-math-mode

         ;; toggle
         "T"  "toggle"
         "Tb" 'TeX-toggle-debug-bad-boxes
         "Td" 'TeX-toggle-debug-warnings
         "Ts" 'TeX-toggle-suppress-ignored-warnings)

        :general
        (:states 'motion
         :keymaps 'TeX-error-overview-mode-map
         "RET" 'TeX-error-overview-goto-source
         "j" 'TeX-error-overview-next-error
         "k" 'TeX-error-overview-previous-error
         "o" 'TeX-error-overview-jump-to-source
         [remap quit-window] 'TeX-error-overview-quit))
    #+END_SRC

** bibtex
   :PROPERTIES:
   :header-args+: :tangle (package-yes! bibtex)
   :END:

   #+BEGIN_SRC emacs-lisp
     (use-package bibtex
       :defer t
       :hook (bibtex-mode . display-line-numbers-mode)
       :init
       (setq bibtex-files (directory-files (org! "bib") t ".bib")
             bibtex-completion-library-path (list
                                             (org! "docs/")
                                             (org! "docs/unidocs/"))
             bibtex-completion-notes-path (org! "notes"))

       (with-no-warnings
         (defvaralias 'bibtex-completion-bibliography 'bibtex-files))

       :config
       (setq bibtex-align-at-equal-sign t
             bibtex-include-OPTkey t
             orhc-bibtex-cache-file (var! "orhc-bibtex-cache")
             ;; use all available words and be as long as needed
             bibtex-autokey-titleword-length nil
             bibtex-autokey-titlewords nil
             ;; what I can I say, this just makes sense
             bibtex-field-delimiters 'double-quotes)

       ;; configure bibtex autokey structure: YEARauthor-paper-name
       (defvar bibtex-autokey-year-name-separator+ bibtex-autokey-name-year-separator
         "String to be put between year part and name part of key.
     See ‚Äòbibtex-generate-autokey‚Äô for details.")

       (defvar bibtex-autokey-name-title-separator+ bibtex-autokey-year-title-separator
         "String to be put between year part and name part of key.
     See ‚Äòbibtex-generate-autokey‚Äô for details.")

       (setq bibtex-autokey-year-name-separator+ ""
             bibtex-autokey-name-title-separator+ "-"
             bibtex-autokey-titleword-separator "-")

       (advice-add #'bibtex-generate-autokey :override
                   (defun bibtex-generate-autokey+ ()
                     (let* ((names (bibtex-autokey-get-names))
                            (year (bibtex-autokey-get-year))
                            (title (bibtex-autokey-get-title))
                            (autokey (concat bibtex-autokey-prefix-string
                                             year
                                             (unless (or (equal names "")
                                                         (equal year ""))
                                               bibtex-autokey-year-name-separator+)
                                             names
                                             (unless (or (and (equal names "")
                                                              (equal year ""))
                                                         (equal title ""))
                                               bibtex-autokey-name-title-separator+)
                                             title)))
                       (if bibtex-autokey-before-presentation-function
                           (funcall bibtex-autokey-before-presentation-function autokey)
                         autokey))))

       (evil-set-initial-state 'bibtex-mode 'normal)

       (add-hook 'bibtex-mode-hook
                 (defun bibtex-mode-setup+ ()
                   ;; 18 space indent... no thank you.
                   (setq-local fill-prefix nil)))

       (advice-add 'bibtex-clean-entry :around
                   (defun bibtex-reset-fill-prefix+ (func &rest args)
                     (let ((fill-prefix (make-string (1+ bibtex-text-indentation) ? )))
                       (apply func args))))

       ;; unused bindings
       ;; C-c C-y         bibtex-yank
       ;; C-c M-y         bibtex-yank-pop
       ;; TAB             bibtex-find-text
       ;; C-j             bibtex-next-field

       :lazy-leader
       (:mode 'bibtex-mode
        "," 'bibtex-clean-entry
        "r" 'bibtex-entry-update                                ; fill-out templates for missing fields in the current entry.
        "g" 'bibtex-search-entry
        "n" 'bibtex-narrow-to-entry
        "w" 'widen
        "m" 'bibtex-mark-entry
        "?" 'bibtex-print-help-message
        "u" 'bibtex-url                                         ; opens the url for the current entry (if there is one).
        "-" 'bibtex-fill-entry
        "x" 'bibtex-kill-entry
        "s" 'bibtex-search-crossref
        "j" 'bibtex-pop-next                                    ; fill out current field with similair value from next entry.
        "k" 'bibtex-pop-previous                                ; same as above but the previous entry.
        "o"   'bibtex-remove-OPT-or-ALT
        "C-o" 'bibtex-remove-OPT-or-ALT

        "y" "yank"
        "ys" 'bibtex-copy-summary-as-kill
        "yf" 'bibtex-copy-field-as-kill
        "yy" 'bibtex-copy-entry-as-kill

        "DEL" 'bibtex-empty-field
        "f" 'bibtex-make-field
        "d" 'bibtex-kill-field

        "i"    "insert"
        "ii"   'bibtex-entry
        "ip"   'bibtex-Preamble
        "ia"   'bibtex-Article
        "im"   'bibtex-Misc
        "ic"   'bibtex-InCollection
        "is"   'bibtex-String
        "ir"   'bibtex-TechReport
        "iu"   'bibtex-Unpublished
        "ib"   'bibtex-Book
        "iB"   'bibtex-InBook
        "il"   'bibtex-Booklet
        "ip"   'bibtex-Proceedings
        "iP"   'bibtex-InProceedings
        "i RET" 'bibtex-Manual

        "it"    "thesis"
        "itP"   'bibtex-PhdThesis
        "itm"   'bibtex-MastersThesis)

       :general
       (:keymaps 'bibtex-mode-map "TAB" "C-j")
       (:keymaps 'bibtex-mode-map
        :states 'normal
        "gh" 'bibtex-beginning-of-entry
        "gk" 'bibtex-previous-entry
        "gj" 'bibtex-next-entry
        "gl" 'bibtex-end-of-entry))
   #+END_SRC

*** company-bibtex
    #+BEGIN_SRC emacs-lisp
      (use-package company-bibtex
        :straight t
        :defer  t
        :after (company bibtex)
        :init
        (add-to-list 'company-backends 'company-bibtex)
        (setq company-bibtex-bibliography bibtex-files))
    #+END_SRC

*** bibtex-completion
    #+BEGIN_SRC emacs-lisp
      (use-package bibtex-completion
        :straight nil
        :defer  t
        :commands (bibtex-insert-pdftools-link+)
        :config
        (setq bibtex-completion-pdf-extension '(".pdf" ".epub" ".pptx" ".doc" ".docx")
              bibtex-completion-pdf-open-function 'xopen-url+)

        (defun bibtex-completion-format-citation-org-mode-cite+ (keys)
          "Format cite references for keys in KEYS for `org-mode'."
          (s-join ", " (--map (format "cite:%s" it) keys)))

        (setq bibtex-completion-format-citation-functions
              '((org-mode      . bibtex-completion-format-citation-org-mode-cite+)
                (latex-mode    . bibtex-completion-format-citation-cite)
                (markdown-mode . bibtex-completion-format-citation-pandoc-citeproc)
                (default       . bibtex-completion-format-citation-default)))

        (defun bibtex-insert-pdftools-link+ (keys)
          (let ((default-directory (or +org-pdf-directory default-directory)))
            (dolist (key keys)
              (let ((pdf (car (bibtex-completion-find-pdf key bibtex-completion-find-additional-pdfs))))
                (unless pdf
                  (user-error "Bib entry with key %s doesn't have an associated pdf file" key))

                (setq pdf (abbreviate-file-name (expand-file-name pdf)))

                (insert (concat
                         "[[pdftools:"
                         pdf
                         "::"
                         (read-from-minibuffer "Page:" "1")
                         "]["
                         (read-string "Description: " nil nil pdf)
                         "]]")))))))
    #+END_SRC

*** ebib
    biblatex/bibtex database management interface for emacs. TODO read [[https://joostkremers.github.io/ebib/ebib-manual.html][manual]].

    #+BEGIN_SRC emacs-lisp :tangle (package-yes! ebib bibtex)
      (use-package ebib
        :straight t
        :defer  t
        :init
        (setq ebib-notes-directory (org! "notes"))

        :config
        (mkdir (var! "ebib") t)

        (setq ebib-preload-bib-files bibtex-files
              ebib-keywords-file (var! "ebib/keywords")
              ebib-reading-list-file (org! "ebib/reading-list.org"))

        ;; make ebib index use evil-motion-state
        (evil-set-initial-state 'ebib-index-mode 'motion)
        (evil-make-overriding-map ebib-index-mode-map 'motion)
        (push 'ebib-index-mode whitespace-exempt-modes)

        ;;; ebib-log-mode
        (push 'ebib-entry-mode whitespace-exempt-modes)
        (evil-set-initial-state 'ebib-entry-mode 'motion)
        (evil-make-overriding-map ebib-entry-mode-map 'motion)

        :lazy-leader
        ("ox" 'ebib)
        (:mode 'ebib-index-mode
         "i" 'ebib-add-entry                                     ; also just bound to a
         "u" 'ebib-browse-url                                    ; also just bound to u
         "s" 'ebib-switch-to-database-nth
         "a" 'ebib-show-annotation
         "n" 'ebib-open-note
         "g" 'ebib-jump-to-entry
         "." 'ebib-toggle-hidden
         "b" 'ebib-browse-doi
         "F" 'ebib-view-file                                     ; open file referenced by current entry
         "!" 'ebib-generate-autokey

         "e" "edit"
         "ee" 'ebib-edit-keyname
         "ep" 'ebib-edit-preamble
         "es" 'ebib-edit-strings

         "f" "filters"
         "f" ebib-filters-map

         "k" "keywords"
         "k" ebib-keywords-map

         "d" "dependent"
         "d" ebib-dependent-map)
        (:mode 'ebib-entry-mode
         "f" 'ebib-view-file-in-field                                           ; TODO find out what this does
         "h" 'ebib-view-field-as-help
         "u" 'ebib-browse-url)

        :general
        (:keymaps 'ebib-index-mode-map
         "C-n" nil ; was ebib-next-entry
         "C-p" nil ; was ebib-prev-entry
         "n"   nil
         "p"   nil
         "?"   nil ; was ebib-search-next
         "SPC" nil ; was ebib-index-scroll-up
         "|"   nil ; was ebib-filters-logical-or
         "~"   nil ; was ebib-filters-logical-not
         "&"   nil ; was ebib-filters-logical-and
         "g"   nil ; was ebib-goto-first-entry
         "1" nil "2" nil "3" nil "4" nil "5" nil "6" nil "7" nil "8" nil "9" nil ; was ebib-switch-to-database-key
         "o"   nil ; was ebib-open-bibtex-file
         "J"   nil ; was ebib-switch-to-database-nth
         "H"   nil ; was ebib-toggle-hidden
         "i"   nil ; was ebib-push-citation
         "h"   nil ; was ebib-index-help
         "Z"   nil ; was ebib-lower
         "b"   nil ; was ebib-index-scroll-down
         "f"   nil ; was ebib-view-file
         "X"   nil ; was ebib-export-preamble
         "I"   nil ; was ebib-browse-doi
         )
        (:keymaps 'ebib-index-mode-map
         :states  'motion
         ;; setup exit and reset commands
         [remap quit-window] 'ebib-leave-ebib-windows            ; leaves buffers alive, just hides windows.
         "gq"                'ebib-quit                          ; kills buffers and windows.
         [remap revert-buffer]  'ebib-reload-current-database
         "gR"                   'ebib-reload-all-databases

         ;; allow using ex commands for evil stuff.
         [remap evil-write]     'ebib-save-current-database
         [remap evil-write-all] 'ebib-save-all-databases

         ;; evil-like motions
         "C-u" 'ebib-index-scroll-down
         "C-d" 'ebib-index-scroll-up
         "C-b" 'ebib-index-scroll-down
         "C-f" 'ebib-index-scroll-up
         "gg"  'ebib-goto-first-entry
         "G"   'ebib-goto-last-entry
         "j"   'ebib-next-entry
         "k"   'ebib-prev-entry
         "gj"  'ebib-next-database
         "gk"  'ebib-prev-database
         "n"   'ebib-search-next

         ;; evil like yank, delete, paste
         "y" 'ebib-kill-entry
         "x" 'ebib-delete-entry                                  ; also bound to d
         "p" 'ebib-yank-entry                                    ; paste yanked entry

         "e" 'ebib-open-bibtex-file                              ; edit-file
         "h" 'ebib-show-log
         "l" 'ebib-edit-entry
         "o" 'ebib-edit-entry
         "RET" 'ebib-edit-entry

         "ss" 'ebib-export-entries                               ; save-as
         "sp" 'ebib-export-preamble                              ; save-preamble-as
         ;; configure sorting
         "sa" 'ebib-index-sort-ascending
         "sd" 'ebib-index-default-sort
         "sd" 'ebib-index-sort-descending)
        (:keymaps 'ebib-log-mode-map
         :states 'motion
         [remap quit-window] 'ebib-quit-log-buffer)
        (:keymaps 'ebib-entry-mode-map
         "g"   nil ; ebib-goto-first-field
         "n"   nil ; ebib-next-field
         "p"   nil ; ebib-prev-field
         "v"   nil ; ebib-view-field-as-help
         "c"   nil ; ebib-copy-field-contents
         "SPC" nil ; ebib-goto-next-set
         "b"   nil ; ebib-goto-prev-set
         "h"   nil ; ebib-entry-help
         "k"   nil ; ebib-kill-field-contents
         ;; r               ebib-toggle-raw
         ;; s               ebib-insert-abbreviation
         )
        (:keymaps 'ebib-entry-mode-map
         ;; allow using ex commands for evil stuff.
         [remap evil-write]     'ebib-save-current-database
         [remap evil-write-all] 'ebib-save-all-databases

         "C-u" 'ebib-goto-prev-set
         "C-d" 'ebib-goto-next-set
         "C-b" 'ebib-goto-prev-state
         "C-f" 'ebib-goto-next-set
         "gg" 'ebib-goto-first-field
         "G"  'ebib-goto-last-field
         "gj" 'ebib-next-field
         "gk" 'ebib-prev-field

         "c" 'ebib-edit-field
         "e" 'ebib-edit-field
         "i" 'ebib-edit-field
         ;; "m" 'ebib-edit-multiline-field
         ;; "x" 'ebib-delete-field-contents
         "d" 'ebib-kill-field-contents
         "x" 'ebib-kill-field-contents

         "y" 'ebib-copy-field-contents
         "p" 'ebib-yank-field-contents

         "o" 'ebib-quit-entry-buffer
         "q" 'ebib-quit-entry-buffer))
    #+END_SRC

* Themes
  #+BEGIN_SRC emacs-lisp
    (set-face-attribute 'default nil
                        :family "Source Code Pro"
                        ;; height value is 1/10pt. so 100 = 10pt
                        :height (if (unix-p) 110 100)
                        :weight 'normal
                        :width 'normal)
  #+END_SRC

  #+BEGIN_SRC emacs-lisp
    (add-to-list 'custom-theme-load-path (etc! "themes"))

    (add-hook 'emacs-startup-hook
              (lambda (&rest _)
                (load-theme 'an-old-hope t)))
  #+END_SRC

** Faces
   Define some extra faces for use in a few different places.

   #+BEGIN_SRC emacs-lisp :tangle (package-yes! spaceline)
     (defface spaceline-minibuffer
       `((t (:inherit spaceline-evil-emacs)))
       "Highlight face for spaceline when minibuffer is active"
       :group 'spaceline)

     (defface spaceline-evil-operator
       `((t (:inherit spaceline-evil-motion)))
       "Evil operator state face"
       :group 'spaceline)

     (defface spaceline-evil-multiedit
       `((t (:weight normal :inherit (highlight spaceline-evil-motion))))
       "Face for evil multiedit face"
       :group 'spaceline)
   #+END_SRC

   #+BEGIN_SRC emacs-lisp :tangle (package-yes! doom-modeline)
     (defface doom-modeline-minibuffer-face
       `((t (:inherit doom-modeline-evil-emacs-state)))
       "highlight face for doom-modeline when minibuffer is active"
       :group 'doom-modeline)
   #+END_SRC

   #+BEGIN_SRC emacs-lisp :tangle (package-yes! ivy)
     (defface ivy-actual-highlight-face '((t (:inherit highlight)))
       "Face actually used by ivy to highlight some candidates.
     See `an-old-hope-theme' for why this is necessary.")
   #+END_SRC

** an old hope
   :PROPERTIES:
   :header-args+: :tangle etc/themes/an-old-hope-theme.el
   :END:

   #+NAME: an-old-hope-theme-description
   #+BEGIN_EXAMPLE
      Emacs theme inspired by a galaxy far far away...

      This theme is largely just a shot for shot copy of [[https://github.com/jesseleite/an-old-hope-syntax-atom][jesseleite/an-old-hope-syntax-atom]]
      ported to emacs because I refuse to live with an IDE that doesn't look like it XD.
      This theme isn't compatible with emacs in the terminal yet, when I find an easy way
      to approximate true-color colors to non-true-color colors, then I'll add support for
      it.
   #+END_EXAMPLE

   #+HEADER: :shebang ;; an-old-hope-theme.el -- a syntax theme from a galaxy far away... -*- lexical-binding: t -*-"
   #+BEGIN_SRC emacs-lisp :comments no
     ;; Author: Mohsin Kaleem
     ;; URL: https://github.com/MoHKale/an-old-hope-theme
     ;; Version: 0.1.0
     ;; Keywords: color, theme
     ;; Package-Requires: ((emacs "24"))

     ;; This file is not part of GNU Emacs

     ;; This file is free software; you can redistribute it and/or modify
     ;; it under the terms of the GNU General Public License as published by
     ;; the Free Software Foundation; either version 3, or (at your option)
     ;; any later version.

     ;; This program is distributed in the hope that it will be useful,
     ;; but WITHOUT ANY WARRANTY; without even the implied warranty of
     ;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     ;; GNU General Public License for more details.

     ;; For a full copy of the GNU General Public License
     ;; see <http://www.gnu.org/licenses/>.

     ;; Commentary:
     ;; see https://github.com/MoHKale/an-old-hope-theme/tree/master/emacs
   #+END_SRC

   #+BEGIN_SRC emacs-lisp :results silent :var desc=an-old-hope-theme-description
     (deftheme an-old-hope
       desc)
   #+END_SRC

   A helper which converts HSL values into RGB ratios and then RGB hex.

   #+NAME: aoh-gen-color
   #+BEGIN_SRC emacs-lisp :results value :tangle no :exports none :var hue=0 sat=0 light=0 approx=(eval nil)
     (require 'color)
     (require 'cl-lib)

     (cl-letf (((symbol-function 'smart-num)
                (lambda (arg)
                  (if (numberp arg)
                      arg
                    (string-to-number arg)))))
       (let* ((hue   (/ (smart-num hue)   360.0))
              (sat   (/ (smart-num sat)   100.0))
              (light (/ (smart-num light) 100.0))

              (rgb (color-hsl-to-rgb hue sat light)))
         (color-rgb-to-hex (nth 0 rgb) (nth 1 rgb) (nth 2 rgb) 2)))
   #+END_SRC

   Here we define the faces used by this theme, all of the an-old-hope colors are
   evaluated using the above helper and I provide 256-bit variants using the same
   HSL values and some of the various emacs [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Text-Terminal-Colors.html][text-terminal-colors]] functions.

   I define both the actual colors and the closest 256-color approximation of them.
   You can create more of these by spawning an emacs-terminal without 24-bit color
   and using the following function:

   #+BEGIN_SRC emacs-lisp :tangle no
     (defun aoh-gen-256-approximation (hue sat light)
       (cl-letf (((symbol-function 'smart-num)
                  (lambda (arg)
                    (if (numberp arg)
                        arg
                      (string-to-number arg)))))
         (let* ((hue   (/ (smart-num hue)   360.0))
                (sat   (/ (smart-num sat)   100.0))
                (light (/ (smart-num light) 100.0))

                (rgb (color-hsl-to-rgb hue sat light))
                (name (car (tty-color-approximate
                            (mapcar (lambda (c) (ceiling (* 65280 c))) rgb)))))
           (cons name
                 (apply 'format "#%02x%02x%02x"
                        (mapcar (lambda (c) (ash c -8))
                                (color-values name)))))))
   #+END_SRC

   #+HEADER: :var cls=(eval t) tru=(quote ((type graphic) (min-colors 16777216))) gui=(quote ((type graphic)))
   #+HEADER: :var   very-light-grey=aoh-gen-color(hue=228, sat=7,   light=81)     very-light-grey-256="#d0d0d0"
   #+HEADER: :var        light-grey=aoh-gen-color(hue=228, sat=7,   light=55)          light-grey-256="#8a8a8a"
   #+HEADER: :var              grey=aoh-gen-color(hue=228, sat=7,   light=44)                grey-256="#6c6c6c"
   #+HEADER: :var         dark-grey=aoh-gen-color(hue=228, sat=7,   light=29)           dark-grey-256="#5f5f87"
   #+HEADER: :var    very-dark-grey=aoh-gen-color(hue=228, sat=7,   light=12)      very-dark-grey-256="#1c1c1c"
   #+HEADER: :var               red=aoh-gen-color(hue=352, sat=81,  light=58)                 red-256="#d75f5f"
   #+HEADER: :var           red-dim=aoh-gen-color(hue=352, sat=60,  light=58)             red-dim-256="#d75f5f"
   #+HEADER: :var           red-int=aoh-gen-color(hue=360, sat=90,  light=58)             red-int-256="#ff5f5f"
   #+HEADER: :var            orange=aoh-gen-color(hue=25,  sat=86,  light=55)              orange-256="#ff8700"
   #+HEADER: :var        orange-dim=aoh-gen-color(hue=25,  sat=60,  light=60)          orange-dim-256="#d7875f"
   #+HEADER: :var        orange-int=aoh-gen-color(hue=25,  sat=86,  light=65)          orange-int-256="#ff875f"
   #+HEADER: :var            yellow=aoh-gen-color(hue=50,  sat=74,  light=61)              yellow-256="#d7d75f"
   #+HEADER: :var        yellow-dim=aoh-gen-color(hue=50,  sat=74,  light=31)          yellow-dim-256="#878700"
   #+HEADER: :var        yellow-int=aoh-gen-color(hue=50,  sat=100, light=61)          yellow-int-256="#ffd75f"
   #+HEADER: :var             green=aoh-gen-color(hue=107, sat=40,  light=57)               green-256="#87af5f"
   #+HEADER: :var         green-int=aoh-gen-color(hue=120, sat=50,  light=57)           green-int-256="#5fd75f"
   #+HEADER: :var         green-dim=aoh-gen-color(hue=107, sat=30,  light=50)           green-dim-256="#87af5f"
   #+HEADER: :var              blue=aoh-gen-color(hue=196, sat=64,  light=58)                blue-256="#5fafd7"
   #+HEADER: :var          blue-dim=aoh-gen-color(hue=200, sat=44,  light=58)            blue-dim-256="#5fafaf"
   #+HEADER: :var          blue-int=aoh-gen-color(hue=220, sat=84,  light=64)            blue-int-256="#5f87ff"
   #+HEADER: :var            purple=aoh-gen-color(hue=313, sat=32,  light=60)              purple-256="#af87af"
   #+HEADER: :var        purple-dim=aoh-gen-color(hue=313, sat=32,  light=70)          purple-dim-256="#d787af"
   #+HEADER: :var        purple-int=aoh-gen-color(hue=313, sat=40,  light=60)          purple-int-256="#af5faf"
   #+HEADER: :var         turquoise=aoh-gen-color(hue=165, sat=70,  light=65)           turquoise-256="#5fd7d7"
   #+HEADER: :var     turquoise-dim=aoh-gen-color(hue=165, sat=60,  light=85)       turquoise-dim-256="#afffd7"
   #+HEADER: :var     turquoise-int=aoh-gen-color(hue=165, sat=80,  light=50)       turquoise-int-256="#00d7af"
   #+HEADER: :var             black=aoh-gen-color(hue=240, sat=6,   light=14)               black-256="#262626"
   #+HEADER: :var         black-dim=aoh-gen-color(hue=240, sat=10,  light=20)           black-dim-256="#00005f"
   #+HEADER: :var         black-int=aoh-gen-color(hue=240, sat=6,   light=0)            black-int-256="#000000"
   #+HEADER: :var             white=aoh-gen-color(hue=0,   sat=100, light=100)              white-256="#ffffff"
   #+HEADER: :var line-highlight-bg=aoh-gen-color(hue=228, sat=7,   light=21)   line-highlight-bg-256="#303030"
   #+HEADER: :var   extra-dark-grey=aoh-gen-color(hue=228, sat=7,   light=10)     extra-dark-grey-256="#00005f"
   #+HEADER: :var             debug=aoh-gen-color(hue=198, sat=91,  light=13)               debug-256="#00005f"
   #+HEADER: :var rainbow-delimeters-colors=(list "#E6B422" "#C70067" "#00A960" "#FC7482")
   #+BEGIN_SRC emacs-lisp :results silent
     (custom-theme-set-faces 'an-old-hope
     ;;; defaults
      `(default
         ((,tru (:foreground ,very-light-grey :background ,very-dark-grey))
          ;; let the terminal inherit its background from the terminals default.
          (,cls (:foreground ,very-light-grey-256))))

      `(italic ((,cls (:italic t :inherit default))))
      `(underline ((,cls (:inherit default))))
      `(shadow ((,cls (:foreground ,light-grey))))
      `(hl-line ((,cls (:background ,line-highlight-bg))))

     ;;; font-lock - Syntax Highlighting Colors
      `(font-lock-builtin-face ((,cls (:foreground ,blue))))
      `(font-lock-comment-face ((,cls (:foreground ,grey))))
      `(font-lock-keyword-face ((,cls (:foreground ,green-256))))
      `(font-lock-constant-face ((,cls (:foreground ,red-256 :inherit bold))))
      `(font-lock-function-name-face ((,cls (:foreground ,yellow-int-256))))
      `(font-lock-negation-char-face ((,cls (:foreground ,red-256))))
      `(font-lock-preprocessor-face ((,cls (:inherit font-lock-keyword-face))))
      `(font-lock-string-face ((,cls (:foreground ,blue))))
      `(font-lock-doc-face ((t (:foreground ,blue))))
      `(font-lock-type-face ((,cls (:foreground ,red-256))))
      `(font-lock-variable-name-face ((,cls (:foreground ,yellow-int-256))))
      `(font-lock-warning-face ((,cls (:background ,yellow-int
                                       :foreground ,very-dark-grey
                                       :distant-foreground ,yellow-int
                                       :underline nil :inherit bold))))

      `(error   ((,cls (:background ,red        :distant-foreground ,red        :foreground ,very-dark-grey :inherit bold))))
      `(success ((,cls (:background ,green-int  :distant-foreground ,green-int  :foreground ,very-dark-grey :inherit bold))))
      `(warning ((,cls (:background ,yellow-int :distant-foreground ,yellow-int :foreground ,very-dark-grey :inherit bold))))

      `(cursor ((,cls (:background ,blue))))
      `(custom-button ((,cls (:background ,very-dark-grey
                              :foreground ,very-light-grey
                              :box (:line-width 2 :style released-button)))))

      ;; Fringe has a different background on the GUI and the terminal, because the default bg
      ;; on the terminal is taken from the terminal bg. We apply a variant color for the fringe
      ;; on the terminal to make it distinctive.
      `(fringe
         ((,gui (:background ,black))
          (,cls (:background ,very-dark-grey))))
      `(header-line ((,cls (:background ,very-dark-grey :foreground ,blue))))
      `(line-number ((,cls (:foreground ,very-light-grey :inherit fringe))))
      `(line-number-current-line ((,cls (:foreground ,blue :inherit line-number))))
      `(vertical-border ((,cls (:foreground ,grey))))
      `(internal-border ((,cls (:foreground ,white :background ,white))))
      `(minibuffer-prompt ((,cls (:foreground ,yellow-256 :weight bold))))

      `(highlight ((,cls (:foreground ,very-dark-grey :background ,blue
                          :distant-foreground ,blue :inherit bold))))

      `(region ((,cls (:background ,dark-grey :weight bold))))
      `(secondary-selection ((,cls (:inherit region))))

      ;; face for current search match. exiting now takes you to it.
      `(isearch ((,cls (:background ,blue-int :inherit bold))))
      `(isearch-fail ((,cls (:inherit compilation-mode-line-fail))))
      `(match ((,cls (:foreground ,green-int))))
      ;; face for matches other than the current match
      `(evil-ex-search ((,cls (:background ,purple :inherit bold))))
      `(lazy-highlight ((,cls (:background ,blue-int :foreground ,black-dim))))

      ;; delimeter colors just taken from https://github.com/gastrodia/rainbow-brackets
      ;; colors 5-9 just recycle 1-4, maybe come up with more.
      `(rainbow-delimiters-depth-1-face ((,cls (:foreground ,(nth 0 rainbow-delimeters-colors)))))
      `(rainbow-delimiters-depth-2-face ((,cls (:foreground ,(nth 1 rainbow-delimeters-colors)))))
      `(rainbow-delimiters-depth-3-face ((,cls (:foreground ,(nth 2 rainbow-delimeters-colors)))))
      `(rainbow-delimiters-depth-4-face ((,cls (:foreground ,(nth 3 rainbow-delimeters-colors)))))
      `(rainbow-delimiters-depth-5-face ((,cls (:foreground ,(nth 0 rainbow-delimeters-colors)))))
      `(rainbow-delimiters-depth-6-face ((,cls (:foreground ,(nth 1 rainbow-delimeters-colors)))))
      `(rainbow-delimiters-depth-7-face ((,cls (:foreground ,(nth 2 rainbow-delimeters-colors)))))
      `(rainbow-delimiters-depth-8-face ((,cls (:foreground ,(nth 3 rainbow-delimeters-colors)))))
      `(rainbow-delimiters-depth-9-face ((,cls (:foreground ,(nth 0 rainbow-delimeters-colors)))))

      ;; hyperlinks and path links
      `(link ((,cls (:foreground ,blue))))
      `(link-visited ((,cls (:foreground ,turquoise :inherit link))))

      `(hl-todo ((,cls (:foreground ,yellow-int :inherit bold))))

     ;;; modeline
      `(mode-line ((,cls
                    (:background ,very-light-grey :foreground ,very-dark-grey
                     :box (:line-width 1 :color ,very-light-grey :style none)))))
      `(mode-line-inactive ((,cls
                             (:weight light :foreground "grey80" :background "grey30"
                              :box (:line-width 1 :color "grey40" :style none)))))

      `(compilation-mode-line-fail ((,cls (:inherit bold :foreground ,red-dim))))
      `(compilation-mode-line-run  ((,cls (:inherit bold :foreground ,orange-dim))))
      `(compilation-mode-line-exit  ((,cls (:inherit bold :foreground ,green-dim))))

      `(magit-mode-line-process-error ((,cls (:inherit compilation-mode-line-fail))))

     ;;; powerline
      `(powerline-active1 ((,gui (:background ,black :foreground ,very-light-grey :inherit mode-line))
                           (,cls (:foreground ,very-light-grey :inherit default))))
      `(powerline-active2 ((,cls (:inherit powerline-active1))))
      `(powerline-inactive1 ((,cls (:box (:line-width 1 :color "grey40" :style none)
                                    :inherit powerline-active1))))

     ;;; spaceline
      `(spaceline-evil-normal  ((,cls (:inherit mode-line :foreground ,very-dark-grey  :background "DarkGoldenrod2"))))
      `(spaceline-evil-insert  ((,cls (:inherit mode-line :foreground ,very-dark-grey  :background ,green-int-256))))
      `(spaceline-evil-emacs   ((,cls (:inherit mode-line :foreground ,very-dark-grey  :background ,blue))))
      `(spaceline-evil-replace ((,cls (:inherit mode-line :foreground ,very-dark-grey  :background ,turquoise-int))))
      `(spaceline-evil-visual  ((,cls (:inherit mode-line :foreground ,very-light-grey :background ,dark-grey))))
      `(spaceline-evil-motion  ((,cls (:inherit mode-line :foreground ,very-dark-grey  :background ,purple-int))))
      `(spaceline-minibuffer   ((,cls (:inherit mode-line :foreground ,very-dark-grey  :background ,blue))))
      `(spaceline-evil-operator ((,cls (:weight normal :inherit (error spaceline-evil-motion)))))

      `(spaceline-flycheck-error   ((,cls (:inherit compilation-mode-line-fail))))
      `(spaceline-flycheck-warning ((,cls (:inherit compilation-mode-line-run))))
      `(spaceline-flycheck-info    ((,cls (:inherit compilation-mode-line-exit))))

     ;;; doom-modeline
      `(doom-modeline-evil-normal-state  ((,cls (:inherit mode-line :foreground ,very-dark-grey  :background "DarkGoldenrod2"))))
      `(doom-modeline-evil-insert-state  ((,cls (:inherit mode-line :foreground ,very-dark-grey  :background ,green-int-256))))
      `(doom-modeline-evil-emacs-state   ((,cls (:inherit mode-line :foreground ,very-dark-grey  :background ,blue))))
      `(doom-modeline-evil-replace-state ((,cls (:inherit mode-line :foreground ,very-dark-grey  :background ,turquoise-int))))
      `(doom-modeline-evil-visual-state  ((,cls (:inherit mode-line :foreground ,very-light-grey :background ,dark-grey))))
      `(doom-modeline-evil-motion-state  ((,cls (:inherit mode-line :foreground ,very-dark-grey  :background ,purple-int))))
      `(doom-modeline-evil-operator-state ((,cls (:weight normal :inherit (error spaceline-evil-motion)))))

      `(doom-modeline-buffer-modified ((,cls (:inherit doom-modeline-buffer-file))))
      `(doom-modeline-lsp-error ((,cls (:inherit compilation-mode-line-fail))))
      `(doom-modeline-lsp-warning ((,cls (:inherit compilation-mode-line-run))))
      `(doom-modeline-lsp-success ((,cls ())))
      `(doom-modeline-lsp-running ((,cls (:foreground ,blue-int :inherit compilation-mode-line-run))))

      `(doom-modeline-urgent ((,cls (:inherit compilation-mode-line-fail))))
      `(doom-modeline-debug ((,cls (:inherit compilation-mode-line-run))))
      `(doom-modeline-info ((,cls (:inherit compilation-mode-line-exit))))

      `(doom-modeline-buffer-minor-mode ((,cls (:foreground ,purple))))

     ;;; evil
      `(vimish-fold-overlay ((,cls (:background ,dark-grey :foreground ,green))))

     ;;; flycheck
      `(flycheck-fringe-info    ((,cls (:foreground ,green-int  :inherit fringe))))
      `(flycheck-fringe-warning ((,cls (:foreground ,yellow-int :inherit fringe))))
      `(flycheck-fringe-error   ((,cls (:foreground ,red-int    :inherit fringe))))

      `(flycheck-info      ((,cls (:underline (:style wave :color ,green)))))
      `(flycheck-warning   ((,cls (:underline (:style wave :color ,yellow)))))
      `(flycheck-duplicate ((,cls (:underline (:style wave :color ,orange)))))
      `(flycheck-error     ((,gui (:underline (:style wave :color ,red)))
                            (,cls (:background ,red-256 :inherit error))))

     ;;; flymake
      `(flymake-note    ((,cls (:underline (:style wave :color ,green)))))
      `(flymake-warning ((,cls (:underline (:style wave :color ,yellow)))))
      `(flymake-error   ((,gui (:underline (:style wave :color ,red)))
                         (,cls (:background ,red-256 :inherit error))))

     ;;; flyspell
      `(flyspell-duplicate ((,cls (:foreground ,orange-dim :underline t))))
      `(flyspell-incorrect ((,cls (:foreground ,red-dim :underline t))))

     ;;; avy
      `(avy-background-face ((,cls (:foreground ,grey))))
      `(avy-lead-face   ((,cls (:background ,red-int :foreground ,white))))
      `(avy-lead-face-0 ((,cls (:background ,blue-int :foreground ,white))))
      `(avy-lead-face-1 ((,cls (:background ,very-light-grey :foreground ,very-dark-grey))))
      `(avy-lead-face-2 ((,cls (:background ,purple-int :foreground ,white))))

      `(frog-menu-border ((,cls (:background ,white :foreground ,white))))
      `(frog-menu-posframe-background-face ((,cls (:background ,very-dark-grey))))

     ;;; company - intellisense
      `(company-tooltip-mouse ((,cls (:foreground ,turquoise-int))))
      `(company-template-field ((,cls (:foreground ,turquoise-int))))

      ;; scrollbar
      `(company-scrollbar-bg ((,cls (:background ,very-light-grey :foreground ,very-light-grey))))
      `(company-scrollbar-fg ((,cls (:background ,dark-grey       :foreground ,dark-grey))))

      `(company-preview ((,cls (:foreground ,blue-int :weight bold :inherit hl-line))))
      `(company-preview-common ((,cls (:inherit company-preview))))
      `(company-preview-search ((,cls (:foreground ,orange-int :weight normal :inherit company-preview))))

      ;; NOTE tooltip is the drop down menu which shows up when multiple results exist
      `(company-tooltip ((,cls (:inherit bold :background ,very-light-grey :foreground ,very-dark-grey))))
      `(company-tooltip-selection ((,cls (:foreground ,very-light-grey :background ,blue-int))))
      `(company-tooltip-common ((,cls (:foreground ,blue-int :inherit company-tooltip))))
      `(company-tooltip-common-selection ((,cls (:foreground ,very-dark-grey :background ,blue-int :inherit company-tooltip-common))))
      `(company-tooltip-search ((,cls (:foreground ,orange :inherit company-tooltip))))
      `(company-tooltip-search-common ((,cls (:inherit company-tooltip-search))))
      `(company-tooltip-search-selection ((,cls (:background ,blue-int :inherit company-tooltip-search))))

      ;; NOTE annotations are extra information in the tooltip
      `(company-tooltip-annotation ((,cls (:weight bold :foreground ,grey))))
      `(company-tooltip-annotation-selection ((,cls (:foreground ,turquoise-int :background ,blue-int :inherit company-tooltip-annotation))))

      `(popup ((,cls (:inherit popup-face))))

     ;;;; custom mode variants
     ;;; whitespace-mode
      `(whitespace-space ((,cls (:foreground ,dark-grey))))
      `(trailing-whitespace ((,cls (:background ,dark-grey))))

     ;;; auto-highlight-symbol mode
      ;; NOTE: distant foreground is meaningless here because the faces are always given priority.
      `(ahs-definition-face ((,cls (:background ,blue-dim :distant-foreground ,blue-dim :foreground ,dark-grey))))
      `(ahs-edit-mode-face ((,cls (:background ,red-dim :distant-foreground ,red-dim :foreground ,very-light-grey))))
      `(ahs-face ((,cls (:background ,very-light-grey :foreground ,black :inherit bold))))
      `(ahs-plugin-whole-buffer-face ((,cls (:background ,blue :distant-foreground ,green :foreground ,black))))
      `(ahs-plugin-bod-face ((,cls (:background ,blue-int :distant-foreground ,blue-int :foreground ,black))))
      `(ahs-plugin-defalt-face ((,cls (:background ,orange-dim :distant-foreground ,orange-dim :foreground ,black))))
      `(ahs-warning-face ((,cls (:foreground ,red-dim))))

     ;;; compilation mode
      `(compilation-line-number ((,cls (:foreground ,yellow))))
      `(compilation-column-number ((,cls (:inherit font-lock-doc-face))))

      ;; NOTE also represents value count in mode line
      `(compilation-error ((,cls (:foreground ,red :inherit bold))))
      `(compilation-info ((,cls (:foreground ,green-int :inherit bold))))
      `(compilation-warning ((,cls (:foreground ,orange-int :inherit bold))))

     ;;; markdown-mode
      `(markdown-code-face ((,cls (:inherit default))))

     ;;; anzu
      `(anzu-mode-line ((,cls (:foreground ,very-dark-grey :inherit bold))))
      `(anzu-mode-line-no-match ((,cls (:foreground ,red-int :inherit bold))))

     ;;; hydra-posframe
      ;; for some reason... if hydra-posframe-face inherits default, internal border won't work
      `(hydra-posframe-face ((,cls (:background ,very-dark-grey :foreground ,very-light-grey))))
      `(hydra-posframe-border-face ((,cls (:inherit internal-border))))

     ;;; selectrum
      `(selectrum-current-candidate ((,cls (:foreground ,very-dark-grey :weight bold :inherit highlight))))
      `(selectrum-primary-highlight ((,cls (:background "#555555"))))
      `(selectrum-secondary-highlight ((,cls (:background "#7777FF")))) ;; #8A498A

     ;;; consult
      `(consult-async-finished ((,cls (:inherit compilation-info))))
      `(consult-async-running ((,cls (:inherit compilation-warning))))
      `(consult-async-failed ((,cls (:inherit compilation-error))))
      `(consult-narrow-indicator ((,cls (:foreground ,blue :weight bold))))
      `(consult-preview-match ((,cls (:foreground ,blue-int :weight bold))))

     ;;; orderless
      ;; Match face were taken from ivys default match faces.
      `(orderless-match-face-0 ((,cls (:background "#555555"))))
      `(orderless-match-face-1 ((,cls (:background "#777777"))))
      `(orderless-match-face-2 ((,cls (:background "#7777ff"))))
      `(orderless-match-face-3 ((,cls (:background "#8a498a"))))

     ;;; swiper
      `(swiper-match-face-1 ((,cls (:background "#555555"))))
      `(swiper-match-face-2 ((,cls (:background "#777777"))))
      `(swiper-match-face-3 ((,cls (:background "#7777ff"))))
      `(swiper-match-face-4 ((,cls (:background "#8a498a"))))

     ;;; ivy
      ;; by default, it seems if ivy-highlight-face has its own spec, it'll interfere
      ;; with the face of ivy-current-match. Which'll make it harder to tell which
      ;; candidate is the current candidate.
      ;;
      ;; If ivy-highlight-face just inherits another face, then when both it and
      ;; ivy-current-match are applied to a string, ivy-current-match will override
      ;; ivy-highlight-face. Thus, this.
      `(ivy-actual-highlight-face ((,cls (:foreground ,very-dark-grey :background ,turquoise
                                          :distant-foreground ,turquoise :inherit bold))))
      `(ivy-highlight-face ((,cls (:inherit ivy-actual-highlight-face))))
      `(ivy-current-match ((,cls (:foreground ,very-dark-grey :weight bold :inherit highlight))))

     ;;; org-mode
      `(org-link ((,cls (:inherit (link bold)))))
      `(org-footnote ((,cls (:foreground ,blue))))

      ;; Overridden by hl-todo-keyword-faces
      `(org-todo ((,cls (:foreground ,purple-int :inherit bold))))
      `(org-done ((,cls (:foreground ,green-int :inherit bold))))

      `(org-upcoming-deadline ((,cls (:foreground ,red-dim))))
      `(org-warning ((,cls (:foreground ,orange :inherit bold))))
      `(org-scheduled-today ((,cls (:foreground ,green-int))))
      `(org-block-begin-line ((,cls (:background "royalblue4" :distant-foreground "royalblue4" :foreground "steelblue1" :extend t))))
      `(org-meta-line ((,cls (:inherit font-lock-comment-face))))

      `(org-block ((,cls (:background ,extra-dark-grey :extend t))))
      `(org-document-title ((,cls (:foreground ,white :height 1.3 :inherit bold))))

     ;;; rust[ic]-mode
      `(rustic-compilation-warning ((,cls (:inherit compilation-warning))))
      `(rustic-compilation-info ((,cls (:inherit compilation-info))))
      `(rustic-compilation-error ((,cls (:inherit compilation-error))))
      `(rustic-compilation-column ((,cls (:inherit compilation-column-number))))
      `(rustic-compilation-line ((,cls (:inherit compilation-line-number))))

     ;;; dired
      `(dired-symlink ((,cls (:foreground ,blue))))
      `(dired-special ((,cls (:foreground ,purple))))

     ;;; dashboard
      `(dashboard-text-banner ((,cls (:foreground ,orange-int))))
      `(dashboard-items-face ((,cls (:weight normal))))
      `(dashboard-no-items-face ((,cls (:weight normal))))
      `(dashboard-heading ((,cls (:inherit (bold dashboard-navigator)))))

     ;;; eshell-prompt-extras
      `(epe-remote-face ((,cls (:foreground ,turquoise))))
      `(epe-venv-face ((,cls (:foreground ,purple))))

     ;;; typescript
      `(typescript-primitive-face ((,cls (:inherit font-lock-type-face))))

     ;;; latex
      `(font-latex-sedate-face       ((,cls (:inherit font-lock-keyword-face))))
      `(font-latex-sectioning-0-face ((,cls (:inherit font-lock-function-name-face))))
      `(font-latex-sectioning-1-face ((,cls (:inherit font-lock-function-name-face))))
      `(font-latex-sectioning-2-face ((,cls (:inherit font-lock-function-name-face))))
      `(font-latex-sectioning-3-face ((,cls (:inherit font-lock-function-name-face))))
      `(font-latex-sectioning-4-face ((,cls (:inherit font-lock-function-name-face))))
      `(font-latex-sectioning-5-face ((,cls (:inherit font-lock-function-name-face))))

     ;;; man/woman
      `(Man-underline  ((,cls (:foreground ,green-int :inherit bold))))
      `(woman-addition ((,cls (:foreground ,purple))))
      `(woman-bold     ((,cls (:foreground ,red :inherit bold))))
      `(woman-italic   ((,cls (:foreground ,green))))
      `(woman-unknown  ((,cls (:inherit error))))

     ;;; vline
      `(vline ((,cls (:inherit hl-line))))
      `(vline-visual ((,cls (:inherit hl-line))))

     ;;; marginalia
      `(marginalia-documentation ((,cls (:inherit font-lock-comment-face))))
      )

      (custom-theme-set-variables 'an-old-hope
        `(hl-todo-keyword-faces
          '(("TODO"        ,red)
            ("NEXT"        ,red)
            ("RANT"        ,red)
            ("SEE"         ,red)
            ("SKIP"        ,red)
            ("LATE"        ,red)
            ("THEM"        ,purple)
            ("PROG"        ,blue-int)
            ("OKAY"        ,blue-int)
            ("DONT"        ,green-int)
            ("FAIL"        ,red)
            ("DONE"        ,green-int)
            ("NOTE"        ,yellow-int)
            ("WAIT"        ,yellow-int)
            ("KLUDGE"      ,yellow-int)
            ("HACK"        ,yellow-int)
            ("TEMP"        ,yellow-int)
            ("FIXME"       ,orange)
            ("WARN"        ,orange)
            ("XXX+"        ,orange)
            ("\\?\\?\\?+"  ,orange))))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
      (provide-theme 'an-old-hope)
   #+END_SRC
