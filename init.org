#+TITLE: init.org
#+STARTUP: show2levels
#
#  _______ _______ _______    _______ _______ _______ ______ _______
# |     __|    |  |   |   |  |    ___|   |   |   _   |      |     __|
# |    |  |       |   |   |  |    ___|       |       |   ---|__     |
# |_______|__|____|_______|  |_______|__|_|__|___|___|______|_______|
#
# On the planet Emacs in the holy control tower and among the stars aboard
# the evil flagship. -- Spacemacs

#+PROPERTY: header-args  :tangle init.el :shebang ";; -*- lexical-binding: t -*-"
#+PROPERTY: header-args+ :comments link :mkdirp yes :noweb yes :hlines no :results values

Welcome to my personal Emacs configuration üòé.

* TODO Action Points
  These are packages or features I'd like to look into at some point:
  + [ ] Look into Emacs [[https://github.com/Fuco1/smartparens][smartparens-mode]].
  + [ ] Replace PowerShell with [[https://github.com/sch0lars/koopa-mode][Koopa-mode]].
  + [ ] Make =org-roam-rg+= use same customize options as =consult-ripgrep=.
  + [ ] Setup configurations for =edit-abbrevs-mode=.
  + [ ] Remove [[*Skeletor][skeletor]] in favour of cookiecutters.
  + [ ] Look into [[https://github.com/svaante/lsp-snippet][lsp-snippet]].
  + [ ] Look into [[https://code.bsdgeek.org/adam/cape-jinx-completion][cape-jinx-completion]].
  + [ ] Look into [[https://codeberg.org/joostkremers/visual-fill-column][visual-fill-column]].
  + [ ] Remove use-package installation with straight.

* Pre-Initialisation
  This is a hacky indirection. It makes org mode evaluate these code blocks from
  later in this file while tangling. Ensuring the tangle environment is self
  sufficient and doesn't need to require any tangled files to tangle to begin with.

  #+begin_src emacs-lisp
    ;; <<setup-paths()>>
    ;; <<config-default()>>
    ;; <<load-config()>>
    ;; <<package-config()>>
  #+end_src

* Initialise
** Early Init
   :PROPERTIES:
   :header-args+: :tangle early-init.el
   :END:

    [[https://git.savannah.gnu.org/cgit/emacs.git/commit/?id=24acb31c04b4048b85311d794e600ecd7ce60d3b][early-init]] is automatically sourced by Emacs since 27 forward, before any other
    enhancements or packages have been sourced. Let's make sure it's loaded on older
    Emacs versions as well.

    #+BEGIN_SRC emacs-lisp :tangle yes
      (when (version< emacs-version "27")
        (load (concat user-emacs-directory "early-init.el")))
    #+END_SRC

    Prevent the new [[https://akrl.sdf.org/gccemacs.html][gccemacs]] native-compile feature from infesting my home-directory.
    This needs to be done early (and for extra thoroughness I've removed the existing
    eln path) to prevent the directory being made and then removed.

    NOTE: Technically this should be first thing in my config but seeing as
    ~early-init.el~ is loaded before my actual config and GCC-Emacs is only relevant
    in versions after which ~early-init~ is supported, I can put it here with no
    troubles.

    #+BEGIN_SRC emacs-lisp :var cache-dir=(cache! "eln-cache") local-cache-dir=(lisp! "eln-cache")
      (setq native-comp-eln-load-path (append
                                       (list cache-dir local-cache-dir)
                                       (cdr (bound-and-true-p native-comp-eln-load-path)))
            native-compile-target-directory cache-dir)
    #+END_SRC

    Let's give the garbage collector free reign to take up as much memory as it needs
    so that we can speed up startup times. Source [[https://github.com/hlissner/doom-emacs/issues/310][doom]].

    #+BEGIN_SRC emacs-lisp
      (defconst default-gc-cons-threshold+ 100000000 ; 100mb
        "My default desired value of `gc-cons-threshold'
      during normal emacs operations.")

      ;; Make garbage collector less invasive
      (setq gc-cons-threshold  most-positive-fixnum
            gc-cons-percentage 0.6)
    #+END_SRC

    Also raise the maximum chunk of output we choose to read from a sub-process.
    Should vastly speed up performance with [[https://emacs-lsp.github.io/lsp-mode/page/performance/][language-servers]].

    #+BEGIN_SRC emacs-lisp
      (setq read-process-output-max (* 1024 1024)) ;; 1mb
    #+END_SRC

    Let's disable some of the unnecessary GUI enhancements, you can re-enable them at
    runtime +but I don't like them anyways+. Disabling them early also prevents GUI
    enhancements being partially visible at startup and then immediately disabled.

    #+BEGIN_SRC emacs-lisp
       ;; Prevent the glimpse of un-styled Emacs by disabling these UI elements early.
       (menu-bar-mode -1)     ; dropdown menu list below frame title
       (tool-bar-mode -1)     ; short mini menu shown below the menu bar
       (push '(vertical-scroll-bars) default-frame-alist)
    #+END_SRC

    We have to disable ~scroll-bar-mode~ the direct way, not just in ~early-init~, or else
    SpaceLine gets truncated on the right hand side.

    #+BEGIN_SRC emacs-lisp :tangle yes
      (scroll-bar-mode -1)   ; scroll bar shown on frames right side
    #+END_SRC

    Also erase ~file-name-handler-alist~ for startup.

    #+BEGIN_SRC emacs-lisp
      (defconst default-file-name-handler-alist+ file-name-handler-alist)
      (setq file-name-handler-alist nil)
    #+END_SRC

    And then make sure these changes are undone after Emacs has started.

    #+BEGIN_SRC emacs-lisp
      (add-hook 'emacs-startup-hook
                (defun emacs-startup-reset-defaults+ ()
                  (setq gc-cons-threshold default-gc-cons-threshold+
                        gc-cons-percentage 0.1
                        file-name-handler-alist default-file-name-handler-alist+)

                  ;; delete no longer necessary startup variable
                  (makunbound 'default-file-name-handler-alist)))
    #+END_SRC

** Setup Paths
   :PROPERTIES:
   :header-args+: :tangle "site-lisp/+core-setup-paths.el"
   :END:

   Configure file system paths and try my utmost to keep my Emacs home-directory as
   clean as possible. These utilities are tangled at the very beginning of my init
   file to allow them to be used in later configuration sections.

   #+begin_src emacs-lisp :var lisp-file=(lisp! "+core-setup-paths") :tangle yes
     (load lisp-file nil 'nomessage)
   #+end_src

   #+NAME: setup-paths
   #+begin_src emacs-lisp
     <<setup-path-xdg>>
     <<setup-path-builders>>
     <<setup-path-customs>>
     <<setup-path-defaults>>
     <<setup-path-load-path>>

     (provide '+core-setup-paths)
   #+end_src

   #+NAME: setup-path-xdg
   #+begin_src emacs-lisp :tangle no
     ;; See [[https://www.gnu.org/software/emacs/manual/html_node/efaq-w32/Location-of-init-file.html][location of init file]].
     (require 'subr-x)
     (require 'xdg)

     (when (member system-type '(cygwin ms-dos windows-nt))
       (setenv "HOME" (string-remove-suffix "\\AppData\\Roaming" (getenv "HOME"))))

     (defun xdg-documents-dir+ ()
       "Return the base directory for user specific cache files."
       (xdg--dir-home "XDG_DOCUMENTS_DIR" "~/Documents"))

     (defun xdg-state-home+ ()
       "Return the base directory for user specific cache files."
       (xdg--dir-home "XDG_STATE_HOME" "~/.local/state"))
   #+end_src

   Initialise shortcut functions for accessing different paths in my Emacs directory.

   #+NAME: setup-path-builders
   #+BEGIN_SRC emacs-lisp :tangle no
     (defun join-path+ (root path &rest rest)
       "Join a series of paths together.
     ROOT is the initial path to join PATH and REST onto."
       (setq path (if (file-name-absolute-p path)
                      path
                    (concat root
                            (unless (string-suffix-p "/" root)
                              "/")
                            path)))
       (if rest (apply 'join-path+ path rest) path))

     (defmacro dotemacs-initialise-path! (path-type path)
       "Initialise a constant for PATH-TYPE and a function to join onto PATH.
     The function will be of the form dotemacs-join-PATH-TYPE-path and will have
     an alias of the form PATH-TYPE!."
       (setq path (eval path))
       (let* ((path-type-name (symbol-name path-type))
              (alias (intern (concat path-type-name "!")))
              (path-sym (intern (concat "dotemacs-"      path-type-name "-path")))
              (func-sym (intern (concat "dotemacs-join-" path-type-name "-path"))))
         `(progn
            (defconst ,path-sym
              (eval-when-compile (join-path+ (expand-file-name user-emacs-directory) ,path)))

            (eval-when-compile
              (unless (file-exists-p ,path-sym)
                (mkdir ,path-sym t)))

            (defun ,func-sym (path &rest args)
              ,(concat "join args onto directory: " path)
              (apply 'join-path+ ,path-sym path args))

            (when (quote ,alias)
              (defalias (quote ,alias) (symbol-function (quote ,func-sym)))))))

     (dotemacs-initialise-path! bin   "bin")
     (dotemacs-initialise-path! etc   "etc")
     (dotemacs-initialise-path! share (join-path+ (xdg-data-home)  "emacs"))
     (dotemacs-initialise-path! cache (join-path+ (xdg-cache-home) "emacs"))
     (dotemacs-initialise-path! state (join-path+ (xdg-state-home) "emacs"))
     (dotemacs-initialise-path! lisp  "site-lisp")
   #+END_SRC

   Now let's set the default paths for a bunch of Emacs built-ins, see [[https://github.com/emacscollective/no-littering/blob/master/no-littering.el][no-littering.el]].

   #+NAME: setup-path-customs
   #+begin_src emacs-lisp :tangle no
     (defconst +notes-home (join-path+ (xdg-documents-dir+) "notes")
       "Base directory containing notes files.")

     (defconst +bib-home (join-path+ (xdg-documents-dir+) "bib")
       "Base directory containing bibliography files.")

     (defconst +docs-home (join-path+ (xdg-documents-dir+) "books/")
       "Base directory containing bibliography documents.")

     (defconst +dashboard-banners-directory (etc! "banners/")
       "Directory containing text banners to show on the dashboard.")
   #+end_src

   #+NAME: setup-path-defaults
   #+BEGIN_SRC emacs-lisp :tangle no
     (defvar org-roam-directory (join-path+ (xdg-documents-dir+) "brain"))

     (setq
      package-user-dir                                   (cache! "elpa")
      auto-save-list-file-prefix                         (state! "auto-save/")
      auth-sources                                       (let ((default-directory (xdg-config-home)))
                                                           (append (list (expand-file-name "authinfo")
                                                                         (expand-file-name "authinfo.gpg")
                                                                         (expand-file-name "netrc"))
                                                                   (bound-and-true-p auth-sources)))
      custom-file                                        (etc! "custom.el")
      custom-theme-directory                             (lisp! "themes")
      org-directory                                      +notes-home
      org-clock-persist-file                             (state! "org/clock-persist.el")
      org-id-locations-file                              (state! "org/id-locations.el")
      org-publish-timestamp-directory                    (state! "org/timestamps/")
      org-registry-file                                  (state! "org/registry.el")
      org-default-notes-file                             (join-path+ +notes-home "index.org")
      projectile-org-projects-directory+                 (join-path+ +notes-home "projects/")
      org-projectile-projects-directory                  projectile-org-projects-directory+
      org-projectile-projects-file                       (join-path+ +notes-home "projects/global.org")
      org-preview-latex-image-directory                  (cache! "org/latex")
      package-quickstart-file                            (state! "package-qs.el")
      server-auth-dir                                    (state! "server/")
      shared-game-score-directory                        (share! "gamescore/")
      tramp-auto-save-directory                          (state! "tramp/auto-save/")
      tramp-persistency-file-name                        (state! "private/tramp/history.el")
      url-cache-directory                                (cache! "url/cache/")
      url-configuration-directory                        (share! "url/configuration/")
      nsm-settings-file                                  (share! "network-security.data")
      request-storage-directory                          (state! "request")
      )

     (let ((treesit-grammer-directory (cache! "tree-sitter" "grammers")))
       (setq treesit--install-language-grammar-out-dir-history (list treesit-grammer-directory)
             treesit-extra-load-path (list treesit-grammer-directory)))

     (advice-add
      'emacs-session-filename :override
      (defun emacs-session-filename+ (session-id)
        (concat (state! "x-sessions/session.") session-id)))

     (with-no-warnings
       ;; Expected to end with a trailing slash and install breaks if omitted.
       (setq straight-base-dir (concat dotemacs-cache-path "/"))
       (defvaralias 'straight-install-dir 'straight-base-dir))
   #+END_SRC

   Update the Emacs load-path to respect any custom files.

   #+NAME: setup-path-load-path
   #+begin_src emacs-lisp
     (add-to-list 'load-path dotemacs-lisp-path)
   #+end_src

** Config Default
   :PROPERTIES:
   :header-args+: :tangle (lisp! "+config-default.el")
   :END:

   #+begin_src emacs-lisp :tangle yes
     (require '+config)
   #+end_src

   This is a good point to start loading my custom configuration override. This file
   at [[file:etc/+config.el]] is a drop in replacement for
   [[file:site-lisp/+config-default.el]]. Ideally it should require =+config-default= and
   alter any properties of it; this isn't necessary however, you can duplicate the
   entire configuration if preferred.

   #+begin_src emacs-lisp
     (require '+core-setup-paths)
   #+end_src

    #+NAME: load-config
   #+begin_src emacs-lisp :tangle (lisp! "+config.el")
      (unless (or (load (etc! "+config-local.el") 'noerror 'nomessage)
                  (require '+config-default nil t)
                  ;; See [[file:bin/emacs-tangle-targets][emacs-tangle-targets]] and [[file:bin/emacs-tangle][emacs-tangle]].
                  (bound-and-true-p checking-tangle-targets+)
                  (bound-and-true-p tangling+))
        (warn "Failed to load Emacs configuration file, using default"))

      (provide '+config)
   #+end_src

   #+NAME: config-default
   #+BEGIN_SRC emacs-lisp :tangle no
      <<config-default-modules>>
      <<config-default-options>>

     (provide '+config-default)
   #+END_SRC

*** Config Modules
    #+NAME: config-default-modules
    #+BEGIN_SRC emacs-lisp
      (defvar +modules
        '(abbrev                                                            ; Enable automatic in text substitutions
          ;; adaptive-wrap                                                  ; Visually wrap long lines. doesn't alter what you write.
          apheleia                                                          ; Automatic buffer formatting after save.
          anzu                                                              ; Show the number of search results incrementally
          ;; beacon                                                         ; Highlight sudden jumps (changes in point) using a beacon
          browse-at-remote                                                  ; Interface emacs with [[https://www.chromium.org/][chromium]]
          ;; command-log-mode                                               ; Echo commands as you enter them
          company                                                           ; Dynamic completion previews through popup dialogs
          ;; corfu                                                          ; Company alternative aiming to be a little more generic
          dashboard                                                         ; A feature full emacs dashboard
          diff-hl                                                           ; Show version control information in the window fringe.
          ;; ebdb                                                           ; A contact management database for emacs
          emmet                                                             ; Enable emmet style shortcuts for html and css modes.
          engine-mode                                                       ; Run a search on a given search engine and view in browser
          ;; eshell                                                         ; A nice lispy shell
          ;; expand-region                                                  ; Expand visual mode by semantic units
          eyebrowse                                                         ; Provides switchable window configurations
          ;; flycheck                                                       ; A better buffer linter and error-checker package
          ;; forge                                                          ; Helpers for remote forges (used with magit)
          ;; hide-comnt                                                     ; Minor mode to disable rendering of comments
          imenu                                                             ; Interactively jump to points of interest in this buffer
          license-templates                                                 ; LICENSE file snippets courtesy of the public GitHub API
          link-hint                                                         ; Jump to links in the current buffer through an avy interface
          magit                                                             ; It's git... but magical ÔÉê ,
          ;; notmuch                                                        ; Mail client and manager
          ;; olivetti                                                       ; A nice writing environment for emacs
          org-roam                                                          ; Org based knowledge base and note taking system
          orglink                                                           ; Render org links in non `org-mode' buffers.
          ;; projectile                                                     ; Extended project management library for emacs
          rainbow-mode                                                      ; Automatically color/highlight css color names
          skeletor                                                          ; Project skeleton generator package
          ;; tab-bar                                                        ; Enable browser like tabs showing buffer information
          toc-org                                                           ; Setup automatically updating table-of-contents for org and markdown modes.
          ;; teleport                                                       ; TRAMP support for teleport tsh.
          ;; undo-tree                                                      ; Undo system based on vim with tree like visualiser
          vimish-fold                                                       ; Fold regions of code just like vim.
          yasnippet                                                         ; Yet-Another-Snippet framework for Emacs

      ;;; Debuggers
          gud                                                               ; Grand unified debugger
          ;; dape                                                           ; Debug adapter interface for Emacs

      ;;; Mode lines
          mk-mode-line                                                      ; My custom mode-line

      ;;; Themes
          an-old-hope                                                       ; A color scheme from a galaxy far far away...

      ;;; Completion frameworks
          vertico                                                           ; A minimalist completing-read compatible completion ui

      ;;; Completion Assistants
          ;; hotfuzz                                                        ; Approximate string matching completion style based on fuzzy finding
          orderless                                                         ; Blazingly fast completion regexp generator using space separated patterns
          prescient                                                         ; Sorting/Filtering based on frequency and proximity.

      ;;; Buffer Menus
          ;; buffer-menu                                                    ; The (default) builtin buffer menu
          ;; bufler                                                         ; A butler for your buffers
          ibuffer                                                           ; An improved buffer menu

      ;;; LSP Clients
          eglot                                                             ; A light weight and clean LSP client
          ;; eglot-x                                                        ; Non-standard LSP extensions for eglot.
          ;; lsp-mode                                                       ; A comprehensive and feature full client

      ;;; Interactive Diffs
          ;; ediff                                                          ; The builtin alternative, it has decades worth of bloat.
          vdiff                                                             ; A diff tool inspired by [[https://github.com/justbur/emacs-vdiff][vimdiff]]

      ;;; Package Enhancements
          ;; ebib                                                           ; Nice emacs based interface for editing bibtex files
                                                                            ; NOTE: This package requires bibtex to be enabled
          ;; diredfl                                                        ; Make dired /extra/ colorful
          edit-indirect                                                     ; Edit regions of a buffer in another mode.
          evil-tty-cursor                                                   ; Make emacs change terminal cursors based on evil-state.
          ;; hydra-posframe                                                 ; Show hydras in a posframe
          ibuffer-vc                                                        ; Filter ibuffer buffers by version-control repos
          ibuffer-tramp                                                     ; Only show ibuffer buffers in remote tramp sessions
          ibuffer-projectile                                                ; Filter ibuffer buffers by active projects
          ;; image-dired                                                    ; View images in dired like sessions

      ;;; language-support
          ;; ggtags                                                         ; GNU Global source code tagging system
          ;; tree-sitter                                                    ; Incremental parsing of your source code asynchronously.

      ;;; Spell checkers
          ;; flyspell                                                      ; Emacs builtin spell checker library.
          jinx                                                             ; A modern JIT spell checker built atop libenchant.

      ;;; Languages
          ;; assembly
          bibtex
          c
          ;; caddy
          ;; csharp
          clojure
          crontab
          ;; crystal
          ;; cmake
          css
          csv
          ;; docker
          elisp
          ;; groovy
          ;; haskell
          ;; ledger
          html
          ;; haml
          ;; java
          ;; golang
          javascript
          ;; typescript                                                     ; NOTE requires javascript to also be enabled
          json
          ;; jq
          ;; kotlin
          ;; glsl
          ;; log
          latex
          ;; lua
          makefile
          markdown
          ;; meson
          ;; nim
          org
          ;; perl
          python
          ;; php
          ;; powershell
          ;; restclient
          ;; robotframework
          ;; ruby
          ;; rust
          ;; scala
          sh-script
          sql
          ssh-config
          toml
          ;; vimlang
          ;; verilog
          xml
          yaml
          ;; yarn
          )
        "Packages I want setup on startup.")
    #+END_SRC

*** Config Options
    #+NAME: config-default-options
    #+begin_src emacs-lisp
      (defvar +man-command (if (member system-type '(cygwin ms-dos windows-nt)) 'woman 'man)
        "Preferred command used for manuals.")

      (defvar +icons-available t
        "When true `all-the-icons' will be available even in terminal Emacs.")

      (defvar +icons-prefer-nerd-font t
        "When true override `all-the-icons' fonts with nerd-fonts.
      Set to a string to use that as nerd-font font family.")

      (defvar +find-file-ignore-regexp
        (rx (or (and ".#" (one-or-more any))
                (and bol "flycheck_")
                (and ".class" eol)
                (and ".o" eol)
                (and "node_modules")
                (and ".git" (zero-or-one "/") eol)
                (and ".elc" eol)
                (and ".bundle/")
                (and "~" eol)
                (and (any ?. ?-) "lock" (zero-or-one ".json") eol))))

      (defvar +TeX-view-in-emacs nil
        "When true, view latex documents in Emacs PDFTools.
      This variable should be set before requiring Auctex.")

      (defvar +browser-edit-mode initial-major-mode
        "Default major mode for a browser edit session.")

      (defvar +browser-edit-mode-alist
        `(("^github.com/" . ,#'markdown-mode)
          ("^gitlab.com/" . ,#'markdown-mode))
        "Association list of url regexps against mode-functions.")

      (defvar +lsp-maybe-connect `((python-mode . :global)
                                   (sh-mode . nil)
                                   (t . :local))
        "Alist configuring whether we should connect a buffer to an LSP server or not.
      The format is (MODE . COND) where mode is a `major-mode' for the buffer and COND
      is a predicate used to decide whether to connect or not. As a special case a
      MODE value of t can be used as a fallback when no other suitable MODE is found.

      COND can be one of a symbol nil/t, a keyword :global/:local or a function which is
      called and should return one of the aforementioned values.
      - :local means connect only if there's an already running server in the current
        workspace.
      - :global means only connect if there's a server running in ANY of the manged
        workspaces.

      This configuration options allows you to continue editing files/buffers without
      the overhead of an LSP server starting unintentionally whenever you switch to a
      file. It gives you the flexibility to continue existing LSP sessions, but avoid
      spawning new ones unless you actively want them.")

      (defvar +indirect-edit-save-buffers t
        "When true saving changes from an `edit-indirect' buffer saves the buffer file.
      This applies both to the `edit-indirect' package and `org-edit-src-save', and
      makes committing consistent between the two packages.")

      (defvar +org-capture-function 'org-capture
        "Function to call to start an `org-capture' session.")

      (defvar +mail-default-conf
        `((user . "mohkale")
          (host . "gmail.com")
          (sent-dir . "local/Sent")
          (signature-file . ,(etc! "signatures" "mohkale@kisara.moe"))
          ;; SMTP configuration should match `smtpmail-multi-accounts'.
          (smtp-host . "smtp.gmail.com")
          (smtp-args . (587 header starttls nil nil nil)))
        "Default configuration options for `+mail-conf'.")

      (defvar +mail-conf
        `((main
           (user . "mohkale")
           (host . "kisara.moe")
           (sent-dir . "kisara/Sent")
           (smtp-host . "kisara.moe"))
          (work
           (user . "mohkalex")
           (sent-dir . "mohkalex/[Gmail]/Sent Mail")
           (signature-file . ,(etc! "signatures" "mohkalex@gmail.com")))
          (personal
           (user . "mohkalsin")
           (sent-dir . "mohkalsin/[Gmail]/Sent Mail")
           (signature-file . ,(etc! "signatures" "mohkalex@gmail.com"))))
        "The comprehensive mail configuration reference.
      There's a bunch of different mail extensions I have setup and each
      seem to redefine or re-reference the same core variables so I define
      and reference them from this variable to minimise the duplication.")

      (defvar +completions-icon t
        "When true enable `all-the-icons' for minibuffer completion.")

      (defvar +cmake-build-directory "build"
        "Default CMake build directory location.")

      (defvar +auto-complete-delay 0.4
        "Interval before which a completion popup should show up.")

      (defvar +completion-popup-kind-icons
        '(;; LSP types.
          (array :text "a" :icon "code-brackets" :face font-lock-type-face)
          (boolean :text "b" :icon "circle-half-full" :face font-lock-builtin-face)
          (class :text "c" :icon "view-grid-plus-outline" :face font-lock-type-face)
          (color :text "#" :icon "palette" :face aoh-blue-int)
          (constant :text "c" :icon "lock-remove-outline" :face font-lock-constant-face)
          ; constructor
          (enummember :text "e" :icon "format-list-checks" :face aoh-blue-int)
          (enum-member :text "e" :icon "format-list-checks" :face aoh-blue-int)
          (enum :text "e" :icon "format-list-bulleted-square" :face aoh-turquoise-int)
          ; event
          (field :text "f" :icon "application-braces-outline" :face aoh-blue-int)
          (file :text "f" :icon "file-document-outline" :face aoh-very-light-grey)
          (folder :text "d" :icon "folder" :face font-lock-function-name-face)
          (interface :text "i" :icon "application-brackets-outline" :face font-lock-type-face)
          (keyword :text "k" :icon "key-variant" :face font-lock-keyword-face)
          ; macro
          (method :text "m" :icon "function-variant" :face font-lock-function-name-face)
          (function :text "f" :icon "function" :face font-lock-function-name-face)
          (module :text "Œº" :icon "file-code-outline" :face font-lock-builtin-face)
          (numeric :text "n" :icon "numeric" :face font-lock-builtin-face)
          (operator :text "o" :icon "plus-minus" :face font-lock-comment-delimiter-face)
          (param :text "p" :icon "cog" :face font-lock-builtin-face)
          (parameter :text "p" :icon "cog" :face font-lock-builtin-face)
          (property :text "p" :icon "application-parentheses-outline" :face aoh-blue-int)
          ; reference
          (ruler :text "r" :face shadow)
          (snippet :text "S" :icon "note-text-outline" :face font-lock-string-face)
          (string :text "s" :icon "sticker-text-outline" :face font-lock-string-face)
          (struct :text "%" :icon "code-braces" :face aoh-orange)
          (text :text "w" :icon "script-text-outline" :face shadow)
          ; typeparameter
          ; type-parameter
          ; unit
          (value :text "v" :icon "plus-circle-outline" :face font-lock-builtin-face)
          (variable :text "v" :icon "variable" :face font-lock-variable-name-face)

          ;; Non-LSP extensions
          (message-address :text "@" :icon "mail" :face font-lock-string-face)
          (ledger-account :text "$" :icon "money" :face font-lock-variable-name-face)

          ;; Default
          (t :text "‚Ä¢" :icon "crosshairs-question" :face shadow))
        "Icon associations for completion-kinds in completion popups.")

      (defvar +completion-popup-show-documentation-popup nil
        "Whether to show a documentation popup alongside the completion popup.")

      (defvar +undo-skip-autosave-regex
        (rx
         (or
          ;; match extensions in filename
          (and (or ".pdf" ".log") eol)
          ;; match exact file paths
          (and
           (or
            ;; wildcard regexp match. any match is a valid match.
            (and "[*Org Src")
            ;; match from the beginning of the line
            (and bol (or
                      (eval temporary-file-directory)
                      (eval dotemacs-state-path)
                      (eval dotemacs-cache-path)
                      (eval dotemacs-share-path)
                      (eval (concat straight-base-dir "straight/"))
                      (eval package-user-dir)
                      (eval +dashboard-banners-directory)))))))
        "Skip undo backups for files matching this regexp")
    #+end_src

*** Config Helpers
    [[*lsp-mode][lsp]] refers to the language-server-protocol and it's how editors such as [[https://code.visualstudio.com/][VSCode]]
    provide such fast and performant language support across so many languages.
    Emacs has 2 packages for this but I don't like kick-starting a language-server
    every time I visit a file. The ~+lsp-maybe-connect~ configuration option lets you
    conditionally connect to a server depending on the current workspace and whether
    or not a server is already running. These helper methods initialise this feature.

    #+begin_src emacs-lisp
      (require '+core-package-config)

      (defvar +lsp-backend
        (cond
         ((package! eglot) 'eglot)
         ((package! lsp-mode) 'lsp-mode)))

      ;; LSP backend interface.
      (cl-defgeneric +lsp--command (backend)
        "Start language server client through BACKEND."
        (ignore backend))
      (cl-defgeneric +lsp--server-running-in-workspace-p (backend mode)
        "Check whether BACKEND language server for MODE is running in the current workspace."
        (ignore backend mode))
      (cl-defgeneric +lsp--server-running-in-any-workspace-p (backend mode)
        "Check whether BACKEND language server for MODE is running in the any workspace."
        (ignore backend mode))

      ;; Auto connect configuration.
      (defun +lsp--should-connect (&optional mode)
        "Assert whether you should connect to a LSP workspace.
      May decide based on if a server is already running for MODE.
      MODE defaults to `major-mode'."
        (or mode (setq mode major-mode))

        (when-let* ((enable (alist-get mode +lsp-maybe-connect
                                       (alist-get t +lsp-maybe-connect))))
          (when (functionp enable)
            (setq enable (funcall enable)))

          (cond
           ((eq enable :local)
            (+lsp--server-running-in-workspace-p +lsp-backend mode))
           ((eq enable :global)
            (+lsp--server-running-in-any-workspace-p +lsp-backend mode))
           (t enable))))

      ;; LSP client connect command.
      (defun +lsp-command ()
        "Command used to start a language server using `+lsp-backend'."
        (interactive)
        (cond
         (+lsp-backend
          (+lsp--command +lsp-backend))
         (interactive-p
          (message "No Language server backend is enabled."))))

      (defun +lsp-hook ()
        (when (+lsp--should-connect)
          (+lsp-command)))
    #+end_src

    ~$REPO_PATH~ is a ~PATH~ like environment variable and it's how I like to reference
    repository locations in my dotfiles.
    This helper provides an interface to this functionality from within emacs, that
    can be used in packages such as ~projectile~ or ~magit~.

    #+begin_src emacs-lisp
      (defun +repo-path (repo-path)
        "Parse REPO-PATH into a list of paths.
      The output will be a collection of conses of the form (PATH . DEPTH)
      specifying we want to look in any directory upto DEPTH paths down in
      PATH. The result of this can be set to `magit-repository-directories'."
        (cl-loop for path in (split-string (or repo-path "") ":")
                 with depth = nil
                 do (setq depth 0)
                 if (string-suffix-p "/" path)
                   do (setq depth 1)
                   and do (while (string-suffix-p "/*/" path)
                            (setq depth (1+ depth)
                                  path (substring path 0 -2)))
                 unless (string-empty-p path)
                   collect (cons (string-remove-suffix "/" path) depth)))
    #+end_src

    This is the command I use to kick-start on the fly linting. In general when
    flycheck is enabled I prefer it, otherwise I go with the built-in flymake.

    #+begin_src emacs-lisp
      (require '+core-package-config)

      (defun +flylint ()
        "Enable `flymake' or `flycheck'."
        (interactive)
        (funcall
         (if (called-interactively-p 'interactive)
             #'funcall-interactively
           #'funcall)
         (cond ((package! flycheck)
                'flycheck-mode)
               (t
                'flymake-mode))
         'toggle))
    #+end_src

    Choose my preferred spell-checker.

    #+begin_src emacs-lisp
      (require '+core-package-config)

      (defun +flyspell ()
        "Enable my preferred spell checking package."
        (interactive)
        (let* ((interactive-p (called-interactively-p 'interactive))
               (caller (if interactive-p #'funcall-interactively #'funcall)))
          (cond
           ((package! jinx)
            (funcall caller 'jinx-mode 'toggle))
           ((package! flyspell)
            (funcall caller 'flyspell-mode 'toggle))
           (interactive-p
            (message "No spell checking package is enabled.")))))
    #+end_src

    Setup LSP support.

    I manage mail configurations from the ~+mail-conf~ variable. Here I define some
    helper methods to make accessing the configuration data in it much simpler.

    #+begin_src emacs-lisp
      (defun +mail-conf-get (key &optional conf)
        (or (alist-get key conf)
            (alist-get key +mail-default-conf)))

      (defun +mail-conf-email (&optional conf)
        (concat (+mail-conf-get 'user conf)
                "@"
                (+mail-conf-get 'host conf)))

      (defun +mail-conf-from-header (&optional conf)
        (concat user-full-name " <" (+mail-conf-email conf) ">"))
    #+end_src

    Lastly here's a little helper sourced from [[https://emacs.stackexchange.com/questions/16890/how-to-find-out-where-a-file-is-being-required][here]] which gives you a tree like
    overview of all the files emacs requires while starting up.
    It's helpful for figuring out what's forcing a deferred package to be loaded.

    #+BEGIN_SRC emacs-lisp :tangle no
      (defvar +require-tree nil)
      (advice-add 'require :around
                  (defun require--advice (orig-fun feature &rest args)
                    (setq +require-tree
                          (append +require-tree
                                  (list (let ((+require-tree (list feature)))
                                          (apply orig-fun feature args)
                                          +require-tree))))))
    #+END_SRC

*** Appendix
    #+begin_src emacs-lisp
      (provide '+config-default)
    #+end_src

** Package Config
   :PROPERTIES:
   :header-args+: :tangle (lisp! "+core-package-config.el")
   :END:

   This section sets up a macro for quickly asserting whether an optional module
   or feature needs to be enabled. This can let you selectively include or exclude
   code-blocks from tangling based on the users Emacs configuration.

   #+begin_src emacs-lisp
     (require '+core-setup-paths)
   #+end_src

   #+NAME: package-config
   #+begin_src emacs-lisp
     (defvar +modules)
     (defun package-build-cond+ (pkgs)
       "Check build conditions for PKGS.
     This is a helper for `package!' and isn't implemented directly in `package!'
     because that would require a recursively defined macro that pushes the
     complexity of building a pkg expression to compile/eval time when it can be
     done at call-time."
       (unless (consp pkgs)
         (setq pkgs (list pkgs)))
       (let (pkg res)
         (while (prog1 (setq pkg (car pkgs))
                  (setq pkgs (cdr pkgs)))
           (if (consp pkg)
               (pcase (car pkg)
                 ('not (push `(not ,(package-build-cond+ (cdr pkg))) res))
                 ('or (push `(or
                              ,@(mapcar #'package-build-cond+ (cdr pkg)))
                            res))
                 ('and (push `(and
                               ,@(mapcar #'package-build-cond+ (cdr pkg)))
                             res))
                 ('var (push (cons 'and (cdr pkg)) res))
                 (_ (warn "`package!' got an unexpected conditional argument %s" (car pkg))))
             (pcase pkg
               (:lsp (push `(or ,(package-build-cond+ 'lsp-mode)
                                ,(package-build-cond+ 'eglot))
                           res))
               (:emmet (push `(and ,(package-build-cond+ 'emmet)
                                   (or ,(package-build-cond+ 'markdown)
                                       ,(package-build-cond+ 'javascript)
                                       ,(package-build-cond+ 'html)
                                       ,(package-build-cond+ 'xml)))
                           res))
               (:consult (push `(or (member (quote consult) +modules)
                                    ,(package-build-cond+ 'vertico))
                               res))
               (:transient (push `(member (quote magit) +modules)
                                 res))
               ((pred keywordp)
                (warn "`package!' got unknown keyword argument %s" pkg)
                (push nil res))
               (_ (push `(member (quote ,pkg) +modules) res)))))
         (if (eq 1 (length res))
             (car res)
           `(and ,@(nreverse res)))))

     (defmacro package! (&rest pkgs)
       "Assert whther all the packages in PKGS are to be installed.
     This is a recursively expanded macro and supports nested conditionals
     such as `or' or `and' and `not'.

     Each argument in PKGS must be a symbol, a keyword, or a list beginning
     with a conditional operator as described above.
     The resulting pkg queries will be parsed and compiled into a conditional
     that asserts them."
       (package-build-cond+ pkgs))

     (defmacro package-yes! (&rest pkgs)
       "Return yes or no depending on `package!'."
       `(if (package! ,@pkgs) "yes" "no"))

     (defmacro package-no! (&rest pkgs)
       "Wrap `not' around `package-yes!'."
       `(if (package! ,@pkgs) "no" "yes"))

     (defmacro package-str! (str &rest pkgs)
       "Return STR or no depending on `package!'."
       `(if (package! ,@pkgs) ,str "no"))

     (defmacro package-lisp! (feature &rest pkgs)
       "Return site-lisp path for FEATURE or no depending on `package!'."
       `(if (package! ,@pkgs) ,(lisp! (concat (symbol-name feature) ".el")) "no"))
   #+end_src

   #+begin_src emacs-lisp
     (provide '+core-package-config)
   #+end_src

** Package Manager
   :PROPERTIES:
   :header-args+: :tangle (lisp! "+core-package-manager.el")
   :END:

   #+begin_src emacs-lisp :tangle yes
     (require '+core-package-manager)
   #+end_src

*** Disable package.el
    [[https://github.com/hlissner/doom-emacs/blob/develop/docs/faq.org#how-does-doom-start-up-so-quickly][Not on my watch, criminal scum!]].

    #+BEGIN_SRC emacs-lisp
      (with-no-warnings
        (setq package-enable-at-startup  nil
              package--init-file-ensured nil
              package-quickstart         nil))
    #+END_SRC

*** Disable Package Signature Checks
    Some packages are out of date and thus their PGP signatures don't work.
    I could go over them manually, but for the sake of my sanity, let's just
    disable signature checks. *WARN* this isn't safe, proceed at your own risk.

    #+BEGIN_SRC emacs-lisp
      (with-no-warnings (setq package-check-signature nil))
    #+END_SRC

*** Setup Package Archives
    Specify the package archives to be used by ~package.el~. This is useful for
    debugging without straight but isn't needed otherwise.

    #+NAME: package-archives
    | name  | URL                           |
    |-------+-------------------------------|
    | MELPA | https://melpa.org/packages/   |
    | gnu   | http://elpa.gnu.org/packages/ |

    #+BEGIN_SRC emacs-lisp :var archives=package-archives :tangle no
      (setq package-archives
            (cl-loop for (name source) in archives
                     collect (cons name source)))
    #+END_SRC

*** Setup straight
    For my config I'll be using [[https://github.com/raxod502/straight.el][straight]], the modern package manager for Emacs.

    #+BEGIN_SRC emacs-lisp
      (setq straight-use-package-by-default nil
            ; straight-recipes-emacsmirror-use-mirror nil
            straight-recipes-gnu-elpa-use-mirror nil
            straight-allow-recipe-inheritance t
            straight-disable-native-compile nil
            straight-process-buffer " *straight*"
            straight-check-for-modifications '(check-on-save find-when-checking)
            straight-recipe-overrides '((nil
                                         (all-the-icons :fork (:host github :repo "mohkale/all-the-icons.el") :branch "feat/customize-all")
                                         (all-the-icons-completion :fork (:host github :repo "mohkale/all-the-icons-completion") :branch "bugfix/comp-extra-props")
                                         (corfu-doc-terminal :type git :repo "https://codeberg.org/akib/emacs-corfu-doc-terminal.git")
                                         (corfu-terminal :type git :repo "https://codeberg.org/akib/emacs-corfu-terminal.git")
                                         (eglot :type built-in)
                                         (flymake :type built-in) ;; Ignore stale [[https://github.com/flymake/emacs-flymake][flymake/emacs-flymake]] repo.
                                         (hide-comnt :host github :repo "emacsmirror/hide-comnt")
                                         (miniedit :host github :repo "emacsorphanage/miniedit")
                                         (transpose-frame :host github :repo "emacsorphanage/transpose-frame")
                                         )))
    #+END_SRC

    Now by default straight is a self hosting package manager, all of it is contained
    within ~straight-base-dir~ including version lockfiles, but I'm not a big fan of
    having to commit configurations into runtime directories so I've advised straight
    to place them in my ~dotmeacs-etc-path~.

    #+NAME: setup-straight-pacman
    #+BEGIN_SRC emacs-lisp
      ;; Place lockfiles into etc instead of into lisp.
      (defvar straight-base-dir)
      (defun straight-override-version-path+ (func &rest args)
        (let ((straight-base-dir dotemacs-etc-path))                                  ; Goes to (etc! "straight/versions").
          (apply func args)))
      (advice-add #'straight--versions-dir  :around #'straight-override-version-path+)
      (advice-add #'straight--versions-file :around #'straight-override-version-path+)

      (defvar straight-repository-branch "develop")

      (let ((bootstrap-file (join-path+ straight-install-dir "straight/repos/straight.el/bootstrap.el"))
            (bootstrap-version 5))
        (unless (file-exists-p bootstrap-file)
          (message "Installing the straight package manager")
          (with-current-buffer
              (url-retrieve-synchronously
               "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
               'silent 'inhibit-cookies)
            (goto-char (point-max))
            (eval-print-last-sexp)))
        (load bootstrap-file nil 'nomessage))
    #+END_SRC

*** Appendix
    #+begin_src emacs-lisp
      (provide '+core-package-manager)
    #+end_src

** Base Packages
   :PROPERTIES:
   :header-args+: :tangle (lisp! "+core-base-packages.el")
   :END:

    #+begin_src emacs-lisp :tangle yes
      (require '+core-base-packages)
    #+end_src

   #+begin_src emacs-lisp
     (require 'straight)

     (use-package general  :straight t :demand t)
     (use-package delight  :straight t :demand t)
     (use-package diminish :straight t :demand t)
     (use-package dash     :straight t :demand t)
     (use-package s        :straight t :demand t)
     (use-package f        :straight t :demand t)

     (use-package use-package
       :custom
       (use-package-always-ensure nil)
       (use-package-always-defer t))
   #+end_src

    #+begin_src emacs-lisp
      (provide '+core-base-packages)
    #+end_src

** Sanitise Emacs
   :PROPERTIES:
   :header-args+: :tangle (lisp! "+core-sanitise-emacs.el")
   :END:

   Make Emacs a saner, friendlier development environment.

   #+begin_src emacs-lisp :tangle yes
      (require '+core-sanitise-emacs)
   #+end_src

*** Common Aliases
    #+begin_src emacs-lisp
      (defalias 'write-autosave+ 'do-auto-save)
    #+end_src

*** Editor Options
    #+BEGIN_SRC emacs-lisp
      (setq delete-old-versions t                                                  ; delete excess backup versions silently
            version-control t                                                      ; use version control
            vc-make-backup-files t                                                 ; make backups in vc as well
            vc-follow-symlinks t                                                   ; no confirmation when opening symlinks
            ring-bell-function 'ignore                                             ; NO ANNOYING RINGS!!!
            sentence-end-double-space nil                                          ; sentence SHOULD end with only a fullstop
            delete-by-moving-to-trash t                                            ; don't rm, trash my garbage please :)
            search-whitespace-regexp nil                                           ; SPC means SPC, not any amount of spaces
            enable-local-variables t                                               ; allow safe variables, even alongside unsafe ones
            auto-save-interval 50                                                  ; auto-save as frequently as possible
            backup-by-copying t                                                    ; don't clobber symlinks
            kill-whole-line t                                                      ; kill-line includes eol
            help-window-select t                                                   ; always select the help window when it pops up
            enable-recursive-minibuffers t                                         ; allow entering minibuffer, when already in minibuffer
            find-file-suppress-same-file-warnings t                                ; don't warn when finding a file that's already open.
            completion-ignore-case t                                               ; make completion case insensitive, holding down shift is annoying.
            use-short-answers t                                                    ; never use `yes-or-no-p', prefer `y-or-n-p'.
            frame-resize-pixelwise t                                               ; Fix weird gaps around windows in GUI frames through X.
            inhibit-startup-screen t                                               ; Disable because for some reason it doesn't support evil.
            remote-file-name-inhibit-locks t
            read-file-name-completion-ignore-case t
            read-buffer-completion-ignore-case t
            ad-redefinition-action 'accept
            require-final-newline t                                                ; Always include a final newline in each file when saving.
            completions-detailed t                                                 ; show annotations for certain completion candidates
            inhibit-startup-echo-area-message t                                    ; Don't tell me I'm in GNU emacs... I think I'll know
            confirm-nonexistent-file-or-buffer nil                                 ; Don't require confirmation when creating a new file
            history-length t                                                       ; Disable completing-read history truncation
            recenter-positions '(top middle bottom)
            overlay-arrow-string ">"
            user-mail-address "mohkale@kisara.moe"
            user-full-name "Mohsin Kaleem")
    #+END_SRC

    Set the default fill column for ~auto-fill-mode~.

    #+BEGIN_SRC emacs-lisp
        (setq-default
         fill-column 85                                                            ; The default line length allowed by `auto-fill-mode'
         )
    #+END_SRC

    Backup behaviour of emacs. *NOTE* ~kept-new-versions~ and ~kept-old-versions~ are
    both used to determine the allowed number of backups. Emacs will keep at most
    ~kept-new-versions~ + ~kept-old-versions~ backups.

    #+BEGIN_SRC emacs-lisp
       (setq
        kept-new-versions 15                                                   ; keep this many latest versions of file.
        kept-old-versions 5                                                    ; keep this many early versions of file.
        )
    #+END_SRC

    The default major mode; used for eg. in newly made files with an unknown file-type.

    #+BEGIN_SRC emacs-lisp
       (setq-default major-mode 'text-mode)
    #+END_SRC

    Default encodings for files, this changes depending on platform so lets force it
    to go the UNIX route.

    #+BEGIN_SRC emacs-lisp
       (setq-default
        default-buffer-file-coding-system 'utf-8-unix
        buffer-file-coding-system 'utf-8-unix)
    #+END_SRC

    #+BEGIN_SRC emacs-lisp
       (setq-default indent-tabs-mode nil                                           ; Use spaces, not tabs
                     show-trailing-whitespace nil
                     truncate-lines t                                               ; Don't split long lines onto next lines
                     scroll-conservatively 101                                      ; Smooth... enough scrolling going line by line
                     scroll-preserve-screen-position t
                     cursor-in-non-selected-windows nil                             ; Don't show the cursor in inactive windows
                     echo-keystrokes 0.02                                           ; Print inputted prefix keys after a pause.
                     )
    #+END_SRC

    Completion ignored extensions lets you exclude files or directories suffixed with
    certain patterns. This is useful for omitting stuff you'll never want to find like
    c object files.

    #+begin_src emacs-lisp
      (push "node_modules/" completion-ignored-extensions)
      (push "__pycache__/" completion-ignored-extensions)
      (push "CMakeFiles/" completion-ignored-extensions)
      (push "eln-cache/" completion-ignored-extensions)
      (push "__pycache__/" completion-ignored-extensions)
      (push "node_modules/" completion-ignored-extensions)
      (push ".pytest_cache/" completion-ignored-extensions)
      (push ".mypy_cache/" completion-ignored-extensions)
      (push ".tox/" completion-ignored-extensions)
      (push ".gradle/" completion-ignored-extensions)
      (push ".sass-cache/" completion-ignored-extensions)
      (push ".jekyll-cache/" completion-ignored-extensions)
      (push ".bundle/" completion-ignored-extensions)
      (push ".clangd/" completion-ignored-extensions)

      (push "#" completion-ignored-extensions)
      (push ".override.yml" completion-ignored-extensions)
      (push ".override.yaml" completion-ignored-extensions)

      ;; Bloomberg BDE UOR conventions use .mem file extensions
      (setq completion-ignored-extensions
            (delete ".mem" completion-ignored-extensions))
    #+end_src

    Set the string shown on the title bar of emacs frames.

    #+BEGIN_SRC emacs-lisp
       (setq frame-title-format
             ;; sets the title string displayed on the frame above. Format of the command is
             ;; a printf like string. Wrap any code you want evaluated conditionally into a list
             ;; and if the first value of that list is a string, it will be evaluated. You can
             ;; include variables anywhere in the string, including sublists, but no functions.
             ;;
             ;; See the format guide here: https://www.emacswiki.org/emacs/FrameTitle
             `("emacs@"
               ,(system-name)
               " [%*] %m"
               (:eval (when (derived-mode-p 'pdf-view-mode)
                        (format "(%d/%d)"
                                (pdf-view-current-page)
                                (pdf-cache-number-of-pages))))
               (buffer-file-name " : %f")))
    #+END_SRC

    Auto saves and backup files, both important parts of emacs

    #+BEGIN_SRC emacs-lisp
       (setq
        ;; Where do autosave files get stored.
        auto-save-file-name-transforms
        (let ((auto-save-dir (state! "auto-save" "sessions/")))
          (mkdir auto-save-dir t)
          `((".*" ,auto-save-dir t)))

        ;; Where do backup files get stored.
        backup-directory-alist `(("." . ,(state! "backups/")))

        ;; How to format lock files, for our use cases just append
        ;; a "#" to the end of it so we can exclude it from `find-file'.
        ;; A ".#" will also be prepended to it automatically.
        lock-file-name-transforms `(("$" "#")))
    #+END_SRC

    load any variables in my ~custom.el~ file. I never use this but if it exists I
    should respect it :upside-down:.

    #+BEGIN_SRC emacs-lisp
      (and (file-exists-p custom-file) (load custom-file 'noerror 'nomessage))
    #+END_SRC

    Re-enable some emacs features that emacs disables by default because they're
    thought to be confusing.

    #+BEGIN_SRC emacs-lisp
      (put 'narrow-to-region 'disabled nil)
    #+END_SRC

    Make the default window separator a [[https://www.reddit.com/r/emacs/comments/3u0d0u/how_do_i_make_the_vertical_window_divider_more/][straight-line]], like TMUX.

    #+BEGIN_SRC emacs-lisp
     (add-hook 'window-configuration-change-hook
               (defun +change-window-divider ()
                 (when-let* ((display-table (or buffer-display-table standard-display-table)))
                   (set-display-table-slot display-table 5 ?‚îÇ)
                   (set-window-display-table (selected-window) display-table))))
    #+END_SRC

*** User Interface Tweaks
    Disable GUI enhancements, some of these are taken care of in [[*early-init][early-init]].

    Let's stop the cursor blinking annoyingly.

    #+BEGIN_SRC emacs-lisp
       (blink-cursor-mode -1)
    #+END_SRC

    Let's also prevent the pointless startup message.

    #+BEGIN_SRC emacs-lisp
       (advice-add 'display-startup-echo-area-message :override #'ignore)
    #+END_SRC

    Make Emacs less verbose in some places.

    #+BEGIN_SRC emacs-lisp
       (setq command-error-function
             (defun command-error-function+ (data context caller)
               "Hide some error message."
               (when (not (memq (car data) '(beginning-of-buffer
                                             end-of-buffer)))
                 (command-error-default-function data context caller))))
    #+END_SRC

*** Terminal Extensions
    Classical terminals [[https://emacs.stackexchange.com/questions/32294/how-to-make-emacs-recognise-c-shift-combinations-in-terminal-mode?rq=1][don't support]] extended, GUI like keybindings. It's a shame,
    but modern terminals are starting to work around it, for eg. *Xterm*.

    [[https://wiki.archlinux.org/index.php/Tmux][TMUX]] (the terminal multiplexer) supports Xterm bindings, but Emacs doesn't accept
    them. Let's change that, courtesy of the [[https://wiki.archlinux.org/index.php/Emacs#Shift_.2B_Arrow_keys_not_working_in_emacs_within_tmux][arch wiki]].

    #+BEGIN_SRC emacs-lisp
      (eval-when-compile
        (require 'term/xterm))

      (advice-add 'terminal-init-screen :before
                  (defun terminal-init-screen+ (&rest _)
                    "Apply xterm keymap, allowing use of keys passed through tmux."
                    (when (getenv "TMUX")
                      (let ((map (copy-keymap xterm-function-map)))
                        (set-keymap-parent map (keymap-parent input-decode-map))
                        (set-keymap-parent input-decode-map map)))))
    #+END_SRC

    Emacs also comes with an ~xterm-mouse-mode~, which lets you use the mouse to
    select things in the terminal, like you would in GUI Emacs. By default you have
    to enable it manually, let's enable it when an xterm like terminal is initialised.

    #+BEGIN_SRC emacs-lisp
      (defun enable-xterm-mouse-mode+ ()
        (xterm-mouse-mode +1))

      (advice-add 'terminal-init-xterm :after #'enable-xterm-mouse-mode+)
      (advice-add 'terminal-init-tmux  :after #'enable-xterm-mouse-mode+)
    #+END_SRC

    Because of Xterm's extended key-codes, you can reclaim some of the key-codes which have
    been taken by Emacs. I've defined a function which adds some more key-codes to the
    Xterm keymap and reclaims some bindings that conventional terminals have repurposed.

    Here's an overview of where we stand.

    | reclaimed | key       | num | name | terminal-key | notes                       |
    |-----------+-----------+-----+------+--------------+-----------------------------|
    | [ ]       | backspace | 127 | DEL  | Ctrl+?       | Maybe translated to Ctrl+h  |
    | [X]       | tab       |   9 | TAB  | Ctrl+I       |                             |
    | [ ]       | linefeed  |  10 | LFD  | Ctrl+j       | Few keyboards have this key |
    | [X]       | return    |  13 | RET  | Ctrl+m       |                             |
    | [X]       | escape    |  27 | ESC  | Ctrl+[       |                             |

    *NOTE*: in GUI, the behaviour shouldn't have changed. The following keys haven't
    been reclaimed, but the GUI variants override the term versions anyways, so you
    shouldn't really notice.

    #+BEGIN_SRC emacs-lisp
      (defun term-setup-frame-bindings+ (&optional frame)
        (with-selected-frame (or frame (selected-frame))
          ;; for some reason, C-/ is remapped to C-_, but (kbd "C-/") isn't C-_,
          ;; it's this bizarre vector here.
          (define-key input-decode-map "" [67108911])

          ;; reclaim key combinations from terminal. See initial source [[https://emacs.stackexchange.com/questions/220/how-to-bind-c-i-as-different-from-tab][here]].
          ;; WARN for this to work, you can't use (kbd key) because that automatically
          ;; gets translated to the original keys. You'll have to use [key] directly.
          ;; You'll also need to declare some input combination to be (effectively) key
          ;; for your terminal, see the xterm eg below.
          (define-key input-decode-map [?\C-i] [C-i]) ;; was TAB
          (if (display-graphic-p)
              ;; GUI specific remappings
              (progn
                (define-key input-decode-map "	"  [C-i])
                (define-key input-decode-map [?\C-m] [C-m]))
            ;; terminal remappings
            (define-key input-decode-map "	"    nil))

          ;; evaluate the following to translate reclaimed bindings back for
          ;; terminals which don't specify any special key combinations for the
          ;; reclaimed keys :cry:.
          ;; (define-key function-key-map [C-i]  "	")
          ;; (define-key function-key-map [C-m]  "")
          (define-key function-key-map [C-\[] "")                             ; I don't mind this being taken

          ;; Some extra bindings I've got in st, see term/xterm.el
          (when (featurep 'xterm)
            (define-key xterm-function-map "\e[127;2u" [S-backspace])
            (define-key xterm-function-map "\e[127;5u" [C-backspace])
            (define-key xterm-function-map "\e[127;6u" [C-S-backspace])
            (define-key xterm-function-map "\e[13;2u"  [S-return])
            (define-key xterm-function-map "\e[13;8u"  [C-M-S-return])
            (define-key xterm-function-map "\eOB"      [down])
            (define-key xterm-function-map "\eOA"      [up])
            (define-key xterm-function-map "\eOD"      [left])
            (define-key xterm-function-map "\eOC"      [right])
            (define-key xterm-function-map "\e[1;2B"   [S-down])
            (define-key xterm-function-map "\e[1;2A"   [S-up])
            (define-key xterm-function-map "\e[1;2D"   [S-left])
            (define-key xterm-function-map "\e[1;2C"   [S-right])
            (define-key xterm-function-map "\e[1;5Z"   [C-S-tab])
            (define-key xterm-function-map "\e[127;7u" (kbd "C-M-DEL"))
            (define-key xterm-function-map "\e[49;5u"  (kbd "C-1"))
            (define-key xterm-function-map "\e[50;5u"  (kbd "C-2"))
            (define-key xterm-function-map "\e[51;5u"  (kbd "C-3"))
            (define-key xterm-function-map "\e[52;5u"  (kbd "C-4"))
            (define-key xterm-function-map "\e[53;5u"  (kbd "C-5"))
            (define-key xterm-function-map "\e[54;5u"  (kbd "C-6"))
            (define-key xterm-function-map "\e[55;5u"  (kbd "C-7"))
            (define-key xterm-function-map "\e[56;5u"  (kbd "C-8"))
            (define-key xterm-function-map "\e[57;5u"  (kbd "C-9"))
            (define-key xterm-function-map "\e[48;5u"  (kbd "C-0"))
            (define-key xterm-function-map "\e[32;2u"  (kbd "S-SPC"))
            (define-key xterm-function-map "\e[37;4u"  (kbd "M-%"))
            (define-key xterm-function-map "\e[58;4u"  (kbd "M-:"))
            (define-key xterm-function-map "\e[58;6u"  (kbd "C-:"))
            (define-key xterm-function-map "\e[124;6u" (kbd "C-|"))
            (define-key xterm-function-map "\e[124;8u" (kbd "C-M-|"))
            (define-key xterm-function-map "\e[94;6u"  (kbd "C-^"))
            (define-key xterm-function-map "\e[60;4u"  (kbd "M-<"))
            (define-key xterm-function-map "\e[62;4u"  (kbd "M->"))
            (define-key xterm-function-map "\e[62;6u"  (kbd "C->"))
            (define-key xterm-function-map "\e[60;6u"  (kbd "C-<"))
            (define-key xterm-function-map "\e[38;4u"  (kbd "M-&"))
            (define-key xterm-function-map "\e[105;7u" (kbd "C-M-i"))
            (define-key xterm-function-map "\e[27;3u"  (kbd "M-ESC"))
            (define-key xterm-function-map "\e[27;5u"  (kbd "C-ESC"))
            (define-key xterm-function-map "\e[123;4u" (kbd "M-{"))
            (define-key xterm-function-map "\e[125;4u" (kbd "M-}"))

            ;; Define xterm codes for ctrl+shift alphabet keys
            (let ((src (number-sequence 65 90))
                  (dest (append (number-sequence 97 105)
                                '(107 106)                  ; For some reason, J & K are switched
                                (number-sequence 108 122)))
                  cell)
              (while (and src dest (setq cell (cons (pop src) (pop dest))))
                (define-key xterm-function-map
                  (concat "\e[" (number-to-string (car cell)) ";2u")
                  (kbd (concat "C-S-" (string (cdr cell)))))
                (define-key xterm-function-map
                  (concat "\e[" (number-to-string (car cell)) ";6u")
                  (kbd (concat "C-S-" (string (cdr cell))))))))

          ;; NOTE: reclaimed key combinations, see source [[https://emacs.stackexchange.com/questions/220/how-to-bind-c-i-as-different-from-tab/20290#20290][here]].
          (define-key input-decode-map "\e[105;5u" [C-i])
          (define-key input-decode-map "\e[109;5u" [C-m])
          (define-key input-decode-map "\e[91;5u"  [C-\[])))

      (add-hook 'after-make-frame-functions #'term-setup-frame-bindings+)
    #+END_SRC

    If however you're running Emacs from outside of the daemon (eg. ~emacs -nw -c~),
    ~after-make-frame-functions~ won't be invoked on your current frame, you'll have
    to invoke it manually; or preferably invoke it right now.

    #+BEGIN_SRC emacs-lisp
      (unless (daemonp)
        (add-hook 'emacs-startup-hook #'term-setup-frame-bindings+))
    #+END_SRC

    Try to enable clipboard support, these settings should do something... but
    they don't seem to work for me :cry:.

    #+BEGIN_SRC emacs-lisp :tangle no
      (setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING)
            x-select-enable-clipboard t
            x-select-enable-primary t
            x-stretch-cursor t)
    #+END_SRC

    As a last resort, let's defer to an excellent external package which takes care
    of this for you automatically... assuming you have the right tools on your host.

    #+BEGIN_SRC emacs-lisp
      (use-package xclip
        :straight t
        :hook (after-init . xclip-mode))
    #+END_SRC

*** Extra Hooks                                                    :disabled:
    :PROPERTIES:
    :header-args+: :tangle no
    :END:
    Run a hook on buffer change

    #+BEGIN_SRC emacs-lisp
      (defvar switch-to-buffer-hook+ nil
        "Hook run when you switch to a buffer.")

      (advice-add 'switch-to-buffer
                  :after (defun switch-to-buffer-hook--execute-hook+ (&rest args)
                           (apply 'run-hook-with-args 'switch-to-buffer-hook+ args)))
    #+END_SRC

    Run a hook when Emacs changes themes.

    #+BEGIN_SRC emacs-lisp
      (defvar after-load-theme-hook+ nil
        "Hook which is executed after loading a theme.")

      (advice-add 'load-theme
                  :after (defun load-theme-execute-hooks+ (&rest _)
                           (run-hooks 'after-load-theme-hook+)))
    #+END_SRC

*** Appendix
    #+begin_src emacs-lisp
      (provide '+core-sanitise-emacs)
    #+end_src

** Leader Key
   :PROPERTIES:
   :header-args+: :tangle (lisp! "+core-leader.el")
   :END:

   Setup [[https://github.com/mohkale/spaceleader][spaceleader]], my own leader-key package designed to work like [[https://www.spacemacs.org/][spacemacs]].

   TODO: Fix bug in spaceleader where if a keymap with override-state 'all is
   activated and it ends up overriding the leader-key, then some of the leader-key
   bindings are just non-existent in the buffer.
   For example see ~magit-blame-read-only-map~.

   #+begin_src emacs-lisp :tangle yes
     (require '+core-leader)
   #+end_src

*** Setup SpaceLeader
    #+begin_src emacs-lisp
      (require '+core-base-packages)
    #+end_src

    #+BEGIN_SRC emacs-lisp
      (use-package spaceleader
        :straight (spaceleader :host github :repo "mohkale/spaceleader")
        :demand t
        :config
        (require 'spaceleader-use-package)

        :preface
        (defconst leader-server-leader-prefix+ "l"
          "put leader keys related to active servers under this prefix.")

        (defconst leader-diff-leader-prefix+ "d"
          "leader prefix under which diff bindings are assigned.")

        (defconst leader-minor-mode-leader-prefix+ "q"
          "leader key for minor mode bindings.
      this leader prefix is expected to be muddled and unreliable...
      due to tonnes of different minor modes collabratively binding to it.

      That said... I need a place to put minor-mode keys and this was
      unoccupied.")

        :config
        (leader-declare-prefix leader-server-leader-prefix+ "lang-server")
        (leader-declare-prefix leader-minor-mode-leader-prefix+ "minor-modes")

        :preface
        (declare-function evil-set-command-property "evil")

        :general
        ("C-@" (general-simulate-key "C-SPC")) ;; C-SPC in terminal
        ;; Make my none-normal leader key active even in normal states.
        (:states leader-norm-states
         "C-SPC" (eval `(general-simulate-key ,leader-key)))
        ;; Setup C-, to trigger my major-mode leader-keys in both insert and normal states.
        (:keymaps 'override
         :states leader-norm-states
         "C-," (eval `(general-simulate-key ,(concat leader-key " " leader-major-mode-prefix))))
        (:keymaps 'override
         :states leader-nnorm-states
         "C-," (eval `(general-simulate-key ,(concat leader-nnorm-key " " leader-major-mode-prefix)))))
    #+END_SRC

*** Base Bindings
    Here we setup the base leader-key bindings we have always available, regardless
    of later configurations or overrides.

    #+begin_src emacs-lisp
      (require 'spaceleader)
    #+end_src

    #+begin_src emacs-lisp
      (leader-set-keys
        "SPC" '(execute-extended-command-for-buffer :wk "M-x")
        "<escape>" 'abort-recursive-edit
        "DEL"      'exit-recursive-edit

        ":" 'repeat-complex-command
        "!" 'shell-command
        "&" 'async-shell-command
        "." 'repeat
        "u" 'universal-argument
        "\\" 'set-input-method)

      (leader-set-keys
        "a" '(:ignore t :wk "applications")
        "a:" 'eshell
        "ad" 'calendar
        "af" 'describe-face
        "aX" 'customize
        "al" 'find-library
        "aL" 'load-library
        "at" 'load-theme
        "ae" 'list-processes

        "ap" '(:ignore t :wk "packages")
        "api" 'straight-use-package
        "apU" 'straight-pull-all
        "apu" 'straight-pull-package-and-deps
        "apf" 'straight-fetch-package-and-deps
        "apF" 'straight-fetch-all
        "apx" 'straight-prune-build
        "apR" 'straight-rebuild-all
        "apr" 'straight-rebuild-package
        "apz" 'straight-freeze-versions
        "apt" 'straight-thaw-versions)

      (leader-set-keys
        "b" '(:ignore t :wk "buffers")
        "bb" 'switch-to-buffer
        "bB" 'switch-to-buffer-other-window
        "bd" 'kill-current-buffer
        "bm" 'buffer-menu
        "bn" 'next-buffer
        "bp" 'previous-buffer
        "br" 'rename-buffer
        "bR" 'rename-uniquely
        "bo" 'occur
        "b DEL" 'bury-buffer
        "bH" 'htmlfontify-buffer
        "bk" 'kill-current-buffer
        "bs" 'scratch-buffer)

      (leader-set-keys
        "c" '(:ignore t :wk "compile/comments")
        "cx" 'kill-compilation
        "cr" 'recompile
        "ck" 'comment-kill
        "c[" 'comment-box
        "ci" 'comment-indent
        "cc" 'compile)

      (leader-set-keys
        "e" '(:ignore t :wk "errors")
        "e1" 'first-error
        "en" 'next-error
        "ep" 'previous-error)

      (leader-set-keys
        "g" '(:ignore t :wk "git/vc"))

      (leader-set-keys
        "h" '(:ignore t :wk "help")
        "hh" 'display-local-help
        "hn" 'view-emacs-news
        "h/" 'apropos-command
        "hg" 'describe-gnu-project
        "hl" 'view-lossage                                                            ; show last few entered commands
        "hw" 'where-is                                                                ; show where a command is bound
        "hp" 'view-emacs-problems
        "ht" 'view-emacs-todo
        "h RET" 'view-order-manuals

        "hd" '(:ignore t :wk "help-describe")
        "hdd" 'shortdoc-display-group
        "hdx" 'describe-command
        "hdo" 'describe-symbol
        "hdi" 'describe-input-method
        "hdL" 'describe-language-environment
        "hdb" 'describe-bindings
        "hdc" 'describe-char
        "hdu" 'describe-coding-system
        "hdk" 'describe-key
        "hdK" 'describe-keymap
        "hdm" 'describe-mode
        "hdp" 'describe-package
        "hdP" 'finder-by-keyword
        "hds" 'describe-syntax
        "hdt" 'describe-theme
        "hdv" 'describe-variable
        "hdf" 'describe-function
        "hdv" 'describe-variable)

      (leader-set-keys
        "i" '(:ignore t :wk "insert")
        "ic" 'insert-char
        "i |" 'indent-to-column
        "i RET" 'split-line
        "i SPC" 'just-one-space)

      (leader-set-keys
        "tm" '(:ignore t :wk "mode")
        "tmz" 'zone
        "tm(" 'emacs-lisp-mode
        "tmL" 'lisp-interaction-mode
        "tmc" 'c++-mode
        "tmC" 'c-mode
        "tmf" '+flyspell
        "tml" '+flylint
        "tmF" 'follow-mode
        "tmt" 'text-mode
        "tmp" 'python-mode
        "tmr" 'ruby-mode
        "tms" 'shell-script-mode
        "tmw" 'whitespace-mode
        "tmo" 'org-mode
        "tmx" 'hexl-mode
        "tm?" 'toggle-rot13-mode
        "tmv" 'visual-line-mode
        "tmD" 'decipher)

      (leader-set-keys
        "n" '(:ignore t :wk "narrrow/numbers")
        "nr" 'narrow-to-region
        "np" 'narrow-to-page
        "nw" 'widen)

      (leader-set-keys
        "r" '(:ignore t :wk "registers"))

      (leader-set-keys
        "x" '(:ignore t :wk "edit-text")
        "xa" 'describe-text-properties
        "xt" 'delete-trailing-whitespace
        "xr"   '(:ignore t :wk "regexp")
        "xrb"  'regexp-builder)

      (leader-set-keys
        "s" '(:ignore t :wk "search/symbol")
        "sg" 'rgrep
        "sF" 'find-dired
        "sf" 'find-grep-dired
        "ss" 'isearch-forward)

      (leader-set-keys
        "8" '(:ignore t :wk "calculator")
        "8." 'calc-dispatch
        "88" 'calc
        "8p" '(calc-copy-to-buffer :wk "calc-paste"))

      (leader-set-keys
        "t" '(:ignore t :wk "toggles")
        "ta" 'toggle-text-mode-auto-fill
        "tb" 'toggle-indicate-empty-lines
        "tc" 'toggle-case-fold-search
        "td" 'toggle-debug-on-error
        "te" '(read-only-mode :wk "toggle-read-only")
        "tf" '(+flylint :wk "toggle-linting")
        "ti" 'toggle-input-method
        "tl" 'toggle-truncate-lines
        "tn" '(display-line-numbers-mode :wk "toggle-line-numbers")
        "tq" 'toggle-debug-on-quit
        "tr" '(auto-revert-mode :wk "toggle-auto-revert")
        "tu" 'toggle-uniquify-buffer-names
        "tw" 'toggle-word-wrap

        "tg" '(:ignore t :wk "gui")
        "tg|" 'toggle-scroll-bar
        "tg-" 'toggle-horizontal-scroll-bar
        "tgt" 'toggle-tool-bar-mode-from-frame
        "tgm" 'toggle-menu-bar-mode-from-frame)

      (leader-set-keys
        "f" '(:ignore t :wk "files/frames")
        "ff" 'find-file
        "fc" 'copy-file
        "fh" 'find-file-at-point
        "f\"" 'recover-this-file
        "f'" 'recover-file
        "fl" 'find-file-literally
        ;; frame
        "fx" 'delete-frame
        "fX" 'delete-other-frames
        "fm" '(make-frame-command :wk "new-frame")
        "fn" 'other-frame
        "f DEL" 'save-buffers-kill-emacs
        "f RET" 'set-frame-name
        "fg" 'select-frame-by-name
        "fR" 'rename-visited-file
        "f TAB" 'find-sibling-file

        "fe" '(:ignore t :wk "emacs")
        "fev" 'emacs-version

        "fv" '(:ignore t :wk "variables")
        "fvd" 'add-dir-local-variable
        "fvs" 'add-file-local-variable
        "fvl" 'add-file-local-variable-prop-line

        "fvc" 'customize-dirlocals

        "fvm" '(:ignore t :wk "copy")
        "fvmf" 'copy-dir-locals-to-file-locals
        "fvmd" 'copy-file-locals-to-dir-locals
        "fvml" 'copy-dir-locals-to-file-locals-prop-line

        "fvr" '(:ignore t :wk "remove")
        "fvrv" 'kill-local-variable
        "fvrd" 'delete-dir-local-variable
        "fvrf" 'delete-file-local-variable
        "fvrl" 'delete-file-local-variable-prop-line)

      (leader-set-keys
        "j" '(:ignore t :wk "jump")
        "jx" 'goto-char
        "jl" 'goto-line
        "j TAB" '(move-to-column :wk "goto-column")
        "jd" '(dired-jump :wk "jump-to-directory")
        "jD" '(dired-jump-other-window :wk "jump-to-directory-other-window"))
    #+end_src

*** Appendix
    #+begin_src emacs-lisp
      (provide '+core-leader)
    #+end_src

** Global Bindings
   :PROPERTIES:
   :header-args+: :tangle (lisp! "+core-bindings.el")
   :END:

   Where I put global bindings.

   #+begin_src emacs-lisp :tangle yes
     (require '+core-bindings)
   #+end_src

   #+begin_src emacs-lisp
     (eval-when-compile (require '+core-base-packages))
     (require '+core-leader)
   #+end_src

   *WARN*: never bind ESC, it *BREAKS EVERYTHING!*.

   Firstly, specify some defaults for the bindings I reclaimed from the terminal,
   this should just be the same keys they would have if they were not reclaimed.

   #+BEGIN_SRC emacs-lisp
     (general-define-key
      [C-i] 'indent-for-tab-command
      [C-m] "RET" ; 'newline-and-indent
      )

     (general-define-key
      :states 'motion
      ;; evil doesn't seem to have a default for tab.
      ;; [C-i] 'indent-for-tab-command
      [C-m] 'evil-ret)
   #+END_SRC

   Let's also make some terminal exclusive bindings have the same affect in GUI emacs.

   #+BEGIN_SRC emacs-lisp
       (general-define-key "C-S-v" 'yank)
   #+END_SRC

   Now let's unbind some undesired emacs global keys

   #+BEGIN_SRC emacs-lisp
     (general-define-key
       "M-h"    nil                            ; was backward-kill-sentence
       "C-M-\\" nil                            ; was indent-region
       "M-b"    nil                            ; was backward-word
       "M-f"    nil                            ; was forward-word
       "C-k"    nil
       )
   #+END_SRC

   Now for global keys.

   Shell command bindings.

   #+BEGIN_SRC emacs-lisp
     (general-define-key
      "C-!" 'shell-command
      "M-!" 'async-shell-command
      "C-|" 'shell-command-on-region+
      "C-:" 'completion-at-point)
   #+END_SRC

   Shell compatibility with vim

   #+BEGIN_SRC emacs-lisp
     (general-define-key
      "C-z" 'suspend-frame)
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (general-define-key
      ;; char variants, can be found on C-h & C-l
      "C-b" 'backward-word
      "C-f" 'forward-word

      ;; rebound to default-indent-new-line in emacs>=27 and that's
      ;; bugged out in org mode.
      "C-M-j" 'indent-new-comment-line

      "M-l"             'recenter-top-bottom ;; was kill-sentence
      "M-L"             'downcase-word
      "M-H"             'upcase-word
      "C-M-a"           'mark-whole-buffer
      "C-M--"           'indent-region
      "C-M-h"           'left-word
      "C-M-l"           'right-word
      "C-s"             'isearch-forward
      "M-r"             'revert-buffer
      ;; "C-q"             'quit-window
      "C-v"             'quoted-insert
      "C-j"             "RET"
      "C-<tab>"         'next-buffer
      "C-S-<tab>"       'previous-buffer
      "C-<iso-lefttab>" 'previous-buffer
      "RET"             'newline
      "<C-M-return>"    'comment-indent-new-line
      "<C-backspace>"   'evil-delete-backward-word
      "M-DEL"           'delete-forward-char
      "<C-S-backspace>" 'kill-word)
   #+END_SRC

   Root level remaps.

   #+begin_src emacs-lisp
     (when (functionp 'revert-buffer-quick)
       (general-define-key
        [remap revert-buffer] 'revert-buffer-quick                                   ; Why ever be prompted if nothings been modified?
        ))
   #+end_src

   My window map, like ~C-w~ in vim.

   #+BEGIN_SRC emacs-lisp
     (defvar emacs-window-map+ (make-sparse-keymap))

     (leader-set-keys "w" emacs-window-map+)

     (general-define-key
      :states '(motion emacs)
      "C-w" emacs-window-map+)

     ;; Tmux leader compatibility
     (general-define-key
      :states 'insert
      "C-q" (with-no-warnings (general-simulate-key "C-w" :state 'normal)))

     (general-define-key
      :states '(normal motion emacs)
      "C-q" (with-no-warnings (general-simulate-key "C-w")))
   #+END_SRC

   #+begin_src emacs-lisp
     (provide '+core-bindings)
   #+end_src

** Completion
   :PROPERTIES:
   :header-args+: :tangle (lisp! "+core-completion.el")
   :END:

   #+begin_src emacs-lisp :tangle yes
     (require '+core-completion)
   #+end_src

   We install cape. A capf adapter for company style completion backends.

   #+begin_src emacs-lisp
     (use-package cape
       :straight t
       :autoload cape-company-to-capf
       :init
       (setq-default completion-at-point-functions '()))
   #+end_src

    Helpers to set completion backends through use-package.

    #+begin_src emacs-lisp
      (eval-when-compile (require 'cl-lib))

      (defun completion--use-package-normalize+ (name keyword args)
        (apply
         #'append
         (mapcar
          (lambda (arg)
            (let* ((result nil)
                   (mode (car arg))
                   (mode-hook (intern (concat (symbol-name mode) "-hook"))))
              (dolist (spec (cdr arg))
                (push
                 (append
                  (list :mode mode :mode-hook mode-hook)
                  (pcase spec
                    ((pred symbolp) (list :capf spec))
                    ((pred consp)
                     (setq spec (append (list :capf) spec))
                     ;; Re-balance to ensure depth is always above the builtin and global
                     ;; hooks.
                     (let ((depth (or (plist-get spec :depth) 0)))
                       (plist-put spec :depth (- depth 49)))
                     spec)
                    (_ (use-package-error
                        (concat (symbol-name keyword) " capfs should be either a <symbol> or (<symbol> . <property-plist>)")))))
                 result))
              (nreverse result)))
          args)))

      (defun completion--use-package-handler+ (name keyword args rest state)
        (use-package-concat
         (use-package-process-keywords name rest state)
         (list
          (append
           (list 'progn)
           (let ((result nil))
             (dolist (it args)
               (cl-destructuring-bind (&key capf mode-hook depth company &allow-other-keys) it
                 (let* ((add-capf-func-name
                         (cl-gentemp (concat "completion+--add-" (symbol-name capf) "-")))
                        (capf-to-add (if company
                                  (cl-gentemp (concat "completion+--company-adapt-" (symbol-name capf) "-"))
                                capf)))
                   (setq result
                         (append
                          result
                          `(,@ (when company
                                 `((defalias ',capf-to-add
                                     ;; Cape throws an error when adapting and using company-mode since
                                     ;; there's a performance overhead. But there isn't a nice way to set
                                     ;; priorities between capf and company backends so we ignore the check.
                                     (let ((capf (cape-company-to-capf #',capf)))
                                       (lambda (&rest args)
                                         (let ((company-mode nil))
                                           (apply capf args)))))))
                               (defun ,add-capf-func-name ()
                                 (add-hook 'completion-at-point-functions ',capf-to-add ,depth t))
                               (add-hook ',mode-hook ',add-capf-func-name)))))))
             result)))))

      (defalias 'use-package-normalize/:completion+ 'completion--use-package-normalize+)
      (defalias 'use-package-handler/:completion+ 'completion--use-package-handler+)

      (let ((tail (nthcdr (cl-position :hook use-package-keywords)
                          use-package-keywords)))
        (setcdr tail (cons :completion+ (cdr tail))))
    #+end_src

    #+begin_src emacs-lisp
      (provide '+core-completion)
    #+end_src

* Library
** Transient Hook
   :PROPERTIES:
   :header-args+: :tangle (lisp! "+lib-transient-hook.el")
   :END:

   [[https://github.com/hlissner/doom-emacs/blob/develop/core/core-lib.el#L458][Doom just keeps providing]], a transient-hook is a hook that's run only once and then
   promptly erases itself. can be bound to either a function or a hook variable.

   #+BEGIN_SRC emacs-lisp
     (defvar +transient-hook-counter 0
       "Used to generate a unique function-name for a transient hook.")

     (defmacro add-transient-hook! (hook-or-function &rest forms)
       "Attaches a self-removing function to HOOK-OR-FUNCTION.
     FORMS are evaluated once, when that function/hook is first invoked, then never
     again.
     HOOK-OR-FUNCTION can be a quoted hook or a sharp-quoted function (which will be
     advised)."
       (declare (indent 1))
       (let ((append (if (eq (car forms) :after) (pop forms)))
             ;; Avoid `make-symbol' and `gensym' here because an interned symbol is
             ;; easier to debug in backtraces (and is visible to `describe-function')
             (fn (intern (format "emacs--transient-hook-%d-h" (cl-incf +transient-hook-counter)))))
         `(let ((sym ,hook-or-function))
            (defun ,fn (&rest _)
              ;; ,(format "Transient hook for %S" hook-or-function)
              ,@forms
              (let ((sym ,hook-or-function))
                (cond ((functionp sym) (advice-remove sym ',fn))
                      ((symbolp sym)   (remove-hook sym ',fn))))
              (unintern ',fn nil))
            (cond ((functionp sym)
                   (advice-add ,hook-or-function ,(if append :after :before) ',fn))
                  ((symbolp sym)
                   (put ',fn 'permanent-local-hook t)
                   (add-hook sym ',fn ,append))))))

     (provide '+lib-transient-hook)
   #+END_SRC

** Host Environment                                             :compiletime:
   :PROPERTIES:
   :header-args+: :tangle (lisp! "+lib-host-environment.el")
   :END:

   #+BEGIN_SRC emacs-lisp
     (require 'cl-lib)

     (cl-defsubst windows-p+ ()
       (member system-type '(cygwin ms-dos windows-nt)))

     (cl-defsubst macos-p+ ()
       (eq system-type 'darwin))

     (cl-defsubst unix-p+ ()
       (member system-type '(gnu gnu/linux gnu/kfreebsd)))

     (provide '+lib-host-environment)
   #+END_SRC

** Plist Pop                                                    :compiletime:
   :PROPERTIES:
   :header-args+: :tangle (lisp! "+lib-plist-pop.el")
   :END:

   #+BEGIN_SRC emacs-lisp
     (defmacro plist-pop! (list prop &optional default)
       "delete PROP from plist LIST, returning value of PROP.
     if PROP isn't in LIST, DEFAULT will be returned."
       `(prog1
            (or (plist-get ,list ,prop) ,default)
          (cl-remf ,list ,prop)))

     (provide '+lib-plist-pop)
   #+END_SRC

** Plist Bind                                                   :compiletime:
   :PROPERTIES:
   :header-args+: :tangle (lisp! "+lib-plist-bind.el")
   :END:

    #+BEGIN_SRC emacs-lisp
      (require '+lib-misc)
      (require '+lib-plist-pop)

      (cl-defmacro plist-bind! ((list &rest props) &rest body)
        "declare local bindings in BODY using a property list LIST.
      This functions exists as an alternative to `cl-defmacro's very limited support
      for variable argument lists alongside keyword argument lists. A use case I've
      encountered so often, it merited creating this.

      This function accepts a LIST argument and then a bunch of property
      specifications. For every property in PROPS, that property is popped from LIST
      and then included in the local scope of BODY. A property can be specified as an
      ALIST, in which case the `car' of the list is the property name and the `cdr'
      is the default value for the property.

      WARN LIST should be an identifier for a list variable... not a LIST by itself.

      The remaining value of LIST is all the properties which were not provided in
      the spec."
        `(let* ((,list (cl-copy-list ,list))
                ,@(cl-loop for prop in props
                           with default = nil
                             when (listp prop)
                               do (setq default (cdr prop) prop (car prop))
                             end
                             collect (list (keyword-sym-normalise! prop)
                                           `(plist-pop! ,list ,prop ,default))))
           ,@body))
      (put 'plist-bind! 'lisp-indent-function 'defun)

      (provide '+lib-plist-bind)
    #+END_SRC

** Modify Syntax Table
   :PROPERTIES:
   :header-args+: :tangle (lisp! "+lib-modify-syntax.el")
   :END:

   #+BEGIN_SRC emacs-lisp
     (cl-defsubst modify-syntax! (syntax &optional syntax-table)
       "Helper for `modify-syntax-entry' which modifies in mass.
     SYNTAX should be an alist of conses of (CHAR . SYNTAX).
     You can optionally specify a SYNTAX-TABLE to modify with SYNTAX."
       (declare (indent defun))
       (cl-loop for (char . type) in syntax
                do (modify-syntax-entry char type syntax-table)))

     (defmacro modify-syntax-hook! (syntax mode)
       "Helper for `modify-syntax!' which modifes syntax on a hook.
     Useful for certain major modes that seem to reset their syntax-tables
     every time their initialised."
       (declare (indent defun))
       (let* ((mode-name (symbol-name mode)))
         `(progn
            (add-hook ',(intern (concat mode-name "-hook"))
                      (defun ,(intern (concat mode-name "-setup-syntax+")) (&optional syntax-table)
                        (modify-syntax! ,syntax syntax-table))))))
   #+END_SRC

   #+begin_src emacs-lisp
     (provide '+lib-modify-syntax)
   #+end_src

*** Use Package
    :PROPERTIES:
    :header-args+: :tangle (lisp! "+use-package-modify-syntax.el")
    :END:

    #+begin_src emacs-lisp
      (require 'use-package-core)
      (eval-when-compile (require '+lib-modify-syntax))

      (defun use-package-normalize/:modify-syntax+ (name keyword args)
        (let ((result nil))
          (dolist (arg args)
            (when (or (not (listp arg))
                      (eq (car arg) 'quote))
              (setq arg (list (list arg))))

            (pcase (length arg)
              (0 (use-package-error (concat (symbol-name keyword) " Must supply syntax modifications")))
              (1 (push (cons
                        (pcase keyword
                          (:modify-syntax+ (intern (concat (symbol-name name) "-syntax-table")))
                          (:modify-syntax-hook+ name)
                          (_ (use-package-error (concat (symbol-name keyword)
                                                        " Unsupported keyword"))))
                        (car arg))
                       result))
              (2 (push arg result))
              (_ (let ((last (last arg)))
                   (while (cdr arg)
                     (push (cons (car arg) last) result)
                     (setq arg (cdr arg)))))))
          (nreverse result)))

      (defun use-package-handler/:modify-syntax+ (name keyword args rest state)
        (use-package-concat
         (use-package-process-keywords name rest state)
         (when args
           `((eval-when-compile (require '+lib-modify-syntax))
             ,@(cl-loop for (syntax-table modifications) in args collect
                        `(,(pcase keyword
                             (:modify-syntax+ 'modify-syntax!)
                             (:modify-syntax-hook+ 'modify-syntax-hook!)
                             (_ (use-package-error (concat (symbol-name keyword)
                                                           " Unsupported keyword"))))
                          ,modifications ,syntax-table))))))

      (defalias 'use-package-normalize/:modify-syntax-hook+ 'use-package-normalize/:modify-syntax+)
      (defalias 'use-package-handler/:modify-syntax-hook+ 'use-package-handler/:modify-syntax+)

      (let ((tail (nthcdr (cl-position :config use-package-keywords)
                          use-package-keywords)))
        (setcdr tail (append (list :modify-syntax+) (cdr tail))))

      (let ((tail (nthcdr (cl-position :init use-package-keywords)
                          use-package-keywords)))
        (setcdr tail (append (list :modify-syntax-hook+) (cdr tail))))
    #+end_src

    #+begin_src emacs-lisp
      (provide '+use-package-modify-syntax)
    #+end_src

** Miscellaneous
   :PROPERTIES:
   :header-args+: :tangle (lisp! "+lib-misc.el")
   :END:

   Core functions needed to edit with Emacs and basic syntax sugar functions, inspired
   by [[https://github.com/hlissner/doom-emacs/blob/develop/core/core-lib.el][doom]].

   This macro lets you create basic interactive lambdas that take no arguments easily.

   #+begin_src emacs-lisp
     (defmacro lambda! (&rest body)
       "Expands to (lambda () (interactive) ,@body).
     A factory for quickly producing interaction commands, particularly for keybinds
     or aliases."
       (declare (doc-string 1) (pure t) (side-effect-free t) (indent defun))
       `(lambda () (interactive) ,@body))
   #+end_src

   Convert keywords to symbols.

   #+BEGIN_SRC emacs-lisp
     (defun keyword-sym-normalise! (sym)
       "convert a keyword symbol, SYM, to a non-keyword symbol.
     eg. :hello to hello."
       (let ((sym-string (symbol-name sym)))
         (if (string-prefix-p ":" sym-string)
             (intern (substring sym-string 1))
           sym)))
   #+END_SRC

   A safe variant of ~nconc~ that avoids cyclic lists, source [[https://www.emacswiki.org/emacs/DestructiveOperations#toc4][Destructive Operations]].

   #+begin_src emacs-lisp
     (defun nconc-safe! (ls1 ls2)
       "`nconc', but avoids creating circular lists."
       (let ((tail ls1))
         (while (and (cdr tail) (not (eq tail ls2)))
           (setq tail (cdr tail)))
         (unless (eq tail ls2)
           (if (null tail)
               (setq ls1 ls2)
             (setcdr tail ls2)))
         ls1))
   #+end_src

   Wrapper that suppresses emacs attempts to write a message.

   #+begin_src emacs-lisp
     (defun inhibit-messages-wrapper! (func &rest args)
       (let ((inhibit-message t))
         (apply func args)))
   #+end_src

   Use ~assoc~ to retrieve an element from an alist and then delete that element.

   #+begin_src emacs-lisp
     (defmacro assoc-pop! (key alist)
       `(let ((result (assoc ,key ,alist)))
          (setq ,alist (delete result ,alist))
          result))
   #+end_src

   Predicate for whether a buffer-object references a killed buffer or not, see [[https://ftp.gnu.org/old-gnu/Manuals/elisp-manual-20-2.5/html_node/elisp_408.html][here]].

   #+begin_src emacs-lisp
     (defun buffer-killed-p+ (buffer)
       "Return t if BUFFER is killed."
       (not (buffer-name buffer)))
   #+end_src

   String truncation functions.

   #+begin_src emacs-lisp
     (defmacro string-truncate-left! (str count)
       `(and ,str
             (if (> (length ,str) ,count)
                 (substring ,str ,count)
               "")))

     (defmacro string-truncate-right! (str count)
       `(and ,str
             (let ((len (length ,str)))
               (if (> len ,count)
                   (substring ,str 0 (- len ,count))
                 ""))))

     (defmacro string-truncate! (str left right)
       `(and ,str
             (let ((len (length ,str)))
               (if (> len (+ ,left ,right))
                   (substring ,str ,left (- len ,right))
                 ""))))
   #+end_src

   #+begin_src emacs-lisp
     (cl-defmacro save-vars-with-temp-buffer! ((&rest vars) &rest body)
       "Store the values of VARS in current buffer, and then create a
     temp buffer reassigning the values of VARS and then invoking BODY."
       (declare (indent defun))
       (let* ((current-vars
               (cl-loop with name = nil
                        for var in vars
                        do (setq name (symbol-name var))
                        collect (list (intern (concat "-current-" name))
                                      var)))
              (assign-vars
               (cl-loop for var in current-vars
                        collect (list (nth 1 var) (car var)))))
         `(let ,current-vars
            (with-temp-buffer
              (let ,assign-vars
                ,@body)))))
   #+end_src

   #+begin_src emacs-lisp
     (defun column-number+ (point)
       "returns the column number at point"
       (interactive "")
       (save-excursion
         (goto-char point)
         (current-column)))

     (defun in-comment-p+ (&optional pos)
       (save-excursion
         (goto-char (or pos (point)))
         (nth 4 (syntax-ppss))))

     (defun line-empty-p+ (&optional point)
       (save-excursion
         (and point (goto-char point))
         (beginning-of-line)
         (looking-at "[[:space:]]*$")))

     (defun in-font-lock-comment-p+ (&optional pos)
       "Test if character at POS is comment.
     If POS is nil, character at `(point)' is tested"
       (unless pos (setq pos (point)))
       (let* ((fontfaces (get-text-property pos 'face)))
         (when (not (listp fontfaces))
           (setf fontfaces (list fontfaces)))
         (delq nil
               (mapcar #'(lambda (f)
                           ;; learn this trick from flyspell
                           (or (eq f 'font-lock-comment-face)
                               (eq f 'font-lock-comment-delimiter-face)))
                       fontfaces))))
   #+end_src

    #+begin_src emacs-lisp
      (provide '+lib-misc)
    #+end_src

* Setup
** Display Buffer
   :PROPERTIES:
   :header-args+: :tangle (lisp! "+setup-display-buffer.el")
   :END:

   Customises how popup windows are shown/represented by Emacs.

   #+begin_src emacs-lisp :tangle yes
      (require '+setup-display-buffer)
   #+end_src

   Firstly lets add some display-buffer commands to show a window to the left/right
   of the current window. These functions have been adapted from [[https://stackoverflow.com/a/21544307/6247387][this]] stack-overflow
   answer.

   #+BEGIN_SRC emacs-lisp
     (defun display-buffer-left+ (buffer alist)
       "Display a buffer to the left of the current buffer.
     (1) If `buffer` is already displayed, then display it again in the same window.
     (2) If `buffer` is not already displayed, and if there is a window to the left,
         then display that `buffer` in said window.
     (3) If `buffer` is not already displayed, and if there is a window to the
         right, then use the selected window.
     (4) If all else fails, then create a new window to the left and display
         `buffer` there.
     (5) Select the target window which displays `buffer`."
       (let ((window
              (cond
               ((get-buffer-window buffer (selected-frame)))
               ;; ((window-in-direction 'above))
               ((window-in-direction 'left))
               ((window-in-direction 'right)
                (selected-window))
               (t
                (split-window (selected-window) nil 'left)))))
         (window--display-buffer buffer window 'window alist)))

     (defun display-buffer-right+ (buffer alist)
       "Display a buffer to the right of the current buffer.
     (1) If `buffer` is already displayed, then display it again in the same window.
     (2) If `buffer` is not already displayed, and if there is a window to the
         right, then display that `buffer` in said window.
     (3) If `buffer` is not already displayed, and if there is a window to the left,
         then use the selected window.
     (4) If all else fails, then create a new window to the right and display
         `buffer` there.
     (5) Select the target window which displays `buffer`."
       (let ((window
              (cond
               ((get-buffer-window buffer (selected-frame)))
               ;; ((window-in-direction 'above))
               ((window-in-direction 'right))
               ((window-in-direction 'left)
                (selected-window))
               (t
                (split-window (selected-window) nil 'right)))))
         (window--display-buffer buffer window 'window alist)))
   #+END_SRC

   Now lets add variants of all the builtin display-buffer commands to switch focus to
   windows after displaying-them. Personally I prefer this because it makes quitting
   windows easier (often just ~q~ after it pops up).

   *NOTE*: You can also get this affect by simply setting ~(body-function .
   select-window)~ in the configuration alist for a display-buffer action, but these
   give you the flexibility to select with one action or not select with another.

   #+BEGIN_SRC emacs-lisp
       (defmacro display-buffer-create-focus-method+ (func)
         `(defun ,(intern (concat (symbol-name func) "-and-focus+")) (buffer alist)
            (when-let* ((window (,func buffer alist)))
              (select-window window))))

       (display-buffer-create-focus-method+ display-buffer--maybe-same-window)
       (display-buffer-create-focus-method+ display-buffer-reuse-window)
       (display-buffer-create-focus-method+ display-buffer--maybe-pop-up-frame-or-window)
       (display-buffer-create-focus-method+ display-buffer-in-previous-window)
       (display-buffer-create-focus-method+ display-buffer-in-side-window)
       (display-buffer-create-focus-method+ display-buffer-use-some-window)
       (display-buffer-create-focus-method+ display-buffer-pop-up-frame)
       (display-buffer-create-focus-method+ display-buffer-below-selected)

       (display-buffer-create-focus-method+ display-buffer-left+)
       (display-buffer-create-focus-method+ display-buffer-right+)
   #+END_SRC

   By default I'd rather switch focus so lets enable it.

   #+BEGIN_SRC emacs-lisp
       (defmacro with-display-buffer-no-select-window+ (&rest body)
         "Within the scope of `body' update `display-buffer-fallback-action' to not
       select the displayed window by default."
         (declare (indent defun))
         `(let ((display-buffer-fallback-action
                 (append (list (car display-buffer-fallback-action))
                         (list '(body-function . nil))
                         (cdr display-buffer-fallback-action))))
            ,@body))

       (defun display-buffer-no-select-window-advice+ (func &rest args)
         "Restore the default display buffer actions used by emacs."
         (with-display-buffer-no-select-window+
           (apply func args)))

       ;; Make the default body-function for `display-buffer' select the
       ;; displayed window. You can override this in `display-buffer-alist'
       ;; by setting (body-function . nil) in the actions configuration.
       ;;
       ;; WARN This is a finicky solution. If you ever decide to use a
       ;; different body-function or if you only want to select the window
       ;; with a specific handler instead of the global one then you'll
       ;; probably have to defer to one of the display+select actions defined
       ;; above.
       (setq display-buffer-fallback-action
             `(,@display-buffer-fallback-action
               (body-function . select-window)))
   #+END_SRC

   Firstly lets disable automatic selection for any buffers matching the following
   pattern. In some cases it makes sense to not select popups, such as those that are
   automatically shown (example: /flycheck-error-messages/) and will automatically close
   themselves.

   #+BEGIN_SRC emacs-lisp
       (push `(,(rx
                 (or "*image-dired-display-image*"
                     "*Anaconda*"
                     "magit-diff: "
                     "*Bug Help*"
                     (and bol "*vundo-diff" (+ any) eol)
                     "*Flycheck error messages*"
                     (and bol "org-roam: ")
                     "*org-roam*"
                     "*HTTP Response*"
                     "*Compile-Log*"
                     (and bol "tree-sitter: ")
                     (and "*eglot-help for " (+ any) "*")))
               ,(car display-buffer-fallback-action)
               (body-function . nil)
               ,@(cdr display-buffer-fallback-action))
             display-buffer-alist)
   #+END_SRC

   Make compilation buffers take focus *unless* they're already open, in which case just
   keep them where they are. This lets me re-run compilations without constantly
   switching to the compilation-buffer.

   #+BEGIN_SRC emacs-lisp
     (defun display-buffer--compilation+ (buffer alist)
       "Display buffer function for compilation buffers."
       (let* ((windows (window-list))
              (window-count (length windows))
              (side-horizontal (alist-get 'side-horizontal alist 'left))
              (side-vertical (alist-get 'side-vertical alist 'down))
              (window-height (alist-get 'window-height alist 0.5))
              (window-width (alist-get 'window-width alist 0.5)))
         (cond
          ((eq (length windows) 2)
           ;; Check if horizontal or vertical split and split appropriately.
           (setq windows
                 (seq-sort (lambda (win-a win-b)
                             (cl-block nil
                               (dolist (func (list #'window-pixel-left #'window-pixel-top))
                                 (let ((a-pixel (funcall func win-a))
                                       (b-pixel (funcall func win-b)))
                                   (unless (eq a-pixel b-pixel)
                                     (cl-return (< a-pixel b-pixel)))))
                               nil))
                           windows))

           (window--display-buffer
            buffer
            (if-let* ((horizontal-layout (with-selected-window (car windows)
                                           (window-in-direction 'right))))
                (split-window (if (eq side-horizontal 'left)
                                  (car windows)
                                (cadr windows))
                              nil
                              side-vertical)
              (split-window (if (eq side-vertical 'up)
                                (car windows)
                              (cadr windows))
                            nil
                            side-horizontal))
            'window alist))
          ((eq (length windows) 3)
           ;; Find remaining split location needed to get 4 splits total.
           ;;
           ;; This is basically the only window that has only one exposed corner.
           (let ((target-window
                  (cl-find-if (lambda (window)
                                (eq (length
                                     (cl-loop for direction in '(left right up down)
                                              with direction-window = nil
                                              do (setq direction-window
                                                       (window-in-direction direction window))
                                              when direction-window
                                                collect direction-window))
                                    1))
                              windows)))
             (window--display-buffer
              buffer
              (split-window target-window nil side-vertical)
              'window alist)))
          ;; In every other case we create a new split window on the side.
          (t
           (funcall #'display-buffer-in-side-window-and-focus+ buffer alist)))))

     (push `(,(rx
               (or "*Async Shell Command*"
                   "*compilation*"
                   "*rustic-compilation*"
                   "*cargo-test*"))
             (display-buffer-reuse-window
              display-buffer--maybe-pop-up-frame-or-window-and-focus+
              display-buffer--compilation+)
             (window-height . 0.5)
             (window-width . 0.5)
             (reusable-frames . t)
             (body-function . nil)
             (side . bottom)
             ;; Only used by `display-buffer--compilation'.
             (side-vertical . down)
             (side-horizontal . left))
           display-buffer-alist)
   #+END_SRC

   Some commands like ~next-error~ rely on the compilation-buffer being open and visible
   so they try to display them, but don't account for the buffer being open in a
   separate window.

   #+BEGIN_SRC emacs-lisp
       ;; Nice way to keep the compilation buffer open in a separate
       ;; frame but still update it as you move forward or back with
       ;; `next-error' and `previous-error'.
       (push `(,(defun next-error-hide-compilation-buffer+ (_buffer _action)
                  "Make `next-error' work when the compilation buffer is hidden
       or open in separate frame.
       By default `next-error' and it's derivatives pop open a compilation
       buffer or have this annoying bug where they keep showing the same
       buffer in new windows if the compilation-buffer isn't visible."
                  (member this-command '(next-error
                                         previous-error
                                         first-error
                                         compile-goto-error)))
               (display-buffer--maybe-same-window
                display-buffer-reuse-window
                display-buffer-no-window)
               ;; Allow reuse-window to check other [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Buffer-Display-Action-Functions.html][frames]] and don't
               ;; switch frames by default.
               (reusable-frames . t)
               (inhibit-switch-frame . t)
               (body-function . nil))
             display-buffer-alist)
   #+END_SRC

   The warnings buffer is... annoying. Emacs can spawn warnings at any time for any
   reason. Most often in my case when it starts native compiling things in the
   background after I trigger a keybinding or load a file with a major mode that
   needs to be re-compiled. This buffer I do want to take control, but if it does so
   while in a minibuffer session or something else it just forces an indirection
   while editing. Even outside of this case you don't want to keep suppressing
   warnings as you're working because they keep coming. For now I do 2 things:

   1. Disable the buffer display. You wanna see it, select it.
   2. Advise =display-warning= to display a message on display warning calls.

   #+begin_src emacs-lisp
     (push `(,(rx "*Warnings*")
             (,(lambda (&rest _) t)))
           display-buffer-alist)

     (defvar warning-levels)
     (defvar warning-minimum-log-level)
     (defvar warning-suppress-log-types)
     (declare-function warning-numeric-level "warning")
     (declare-function warning-suppress-p "warning")
     (advice-add #'display-warning
                 :after
                 (defun display-warning--message-after-display+
                     (type message &optional level buffer-name)
                   (unless level
                     (setq level :warning))
                   (when-let* ((new (cdr (assq level warning-levels))))
                     (setq level new))

                   (unless (or (not (or after-init-time noninteractive (daemonp)))
                               (< (warning-numeric-level level)
                                  (warning-numeric-level warning-minimum-log-level))
                               (warning-suppress-p type warning-suppress-log-types))
                     (let ((message-log-max nil))
                       (message "Warning (%s): %s" type message)))))
   #+end_src

   #+begin_src emacs-lisp
     (provide '+setup-display-buffer)
   #+end_src

** Show Whitespace
   :PROPERTIES:
   :header-args+: :tangle (lisp! "+setup-show-whitespace.el")
   :END:

   #+begin_src emacs-lisp :tangle yes
     (use-package +setup-show-whitespace
       :autoload set-trailing-whitespace+
       :hook (change-major-mode-after-body . set-trailing-whitespace+))
   #+end_src

   Configure displaying of trailing whitespace. Now I personally am not a fan of
   source code with invisible trailing whitespace, it takes up meaningless space
   ([[https://www.youtube.com/watch?v=SsoOG6ZeyUI][insert irrelevent video here]]) and probably annoys the hell out of other people
   with editors smart enough to see it.

   So I enable displaying of trailing whitespace by default in every mode. That way
   you can see and remove it. If you'd like to disable whitespace display, then you'll
   have to append to either of the following variables or optionally attach the
   following hook function.

   #+BEGIN_SRC emacs-lisp
      (defun +hide-trailing-whitespace ()
        (setq show-trailing-whitespace nil))
   #+END_SRC

   Here we define the configuration variables used for determining whether to enable
   visible whitespace or not.

   #+BEGIN_SRC emacs-lisp
     (defvar +whitespace-exempt-modes '(help-mode
                                        Buffer-menu-mode
                                        ibuffer-mode
                                        eshell-mode
                                        term-mode
                                        minibuffer-mode
                                        minibuffer-inactive-mode
                                        messages-buffer-mode
                                        eshell-mode)
       "Modes under which no trailing whitespace is shown")

     (defvar +whitespace-exempt-buffers
       (list (rx "*Ibuffer confirmation*")
             (rx "*Org Export Dispatcher*")
             (rx "*eldoc*")
             (rx "*Completions*"))
       "Regexp matching buffer names where no trailing whitespace is shown.")
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (defun set-trailing-whitespace--mode-p+ ()
       "Check the mode of the current buffer, to see whether trailing
     whitespace should be shown."
       (not (and +whitespace-exempt-modes
                 (derived-mode-p +whitespace-exempt-modes))))

     (defun set-trailing-whitespace--name-p+ ()
       "Check the name of the current buffer, to see whether trailing
     whitespace should be shown."
       (not
        (and +whitespace-exempt-buffers
             (let ((it (buffer-name)))
               (cl-find-if (lambda (regexp)
                             (string-match-p regexp it))
                           +whitespace-exempt-buffers)))))

     (defun set-trailing-whitespace+ (&rest _)
       (setq show-trailing-whitespace
             ;; when both name and mode decide you can show
             ;; whitespace, then show it. otherwise when at
             ;; least one says no, then hide it.
             (and (set-trailing-whitespace--mode-p+)
                  (set-trailing-whitespace--name-p+))))
   #+END_SRC

   #+begin_src emacs-lisp
     (provide '+setup-show-whitespace)
   #+end_src

*** Use Package
    :PROPERTIES:
    :header-args+: :tangle (lisp! "+use-package-show-whitespace.el")
    :END:

    #+begin_src emacs-lisp
      (require 'use-package-core)

      (defun use-package-normalize/:hide-whitespace+ (name keyword args)
        (mapcar (lambda (arg)
                  (unless (symbolp arg)
                    (use-package-error (concat (symbol-name keyword) " args must be mode symbols.")))
                  arg)
                args))

      (defun use-package-handler/:hide-whitespace+ (name keyword args rest state)
        (use-package-concat
         (use-package-process-keywords name rest state)
         (when args
           `((defvar +whitespace-exempt-modes)
             (with-eval-after-load '+setup-show-whitespace
              (progn
                ,@(cl-loop for arg in args collect
                           `(push (quote ,arg) +whitespace-exempt-modes))))))))

      (defun use-package-normalize/:hide-whitespace-regex+ (name keyword args)
        args)

      (defun use-package-handler/:hide-whitespace-regex+ (name keyword args rest state)
        (use-package-concat
         (use-package-process-keywords name rest state)
         (when args
           `((defvar +whitespace-exempt-buffers)
             (with-eval-after-load '+setup-show-whitespace
              (progn
                ,@(cl-loop for arg in args collect `(push ,arg +whitespace-exempt-buffers))))))))

      (let ((tail (nthcdr (cl-position :init use-package-keywords)
                          use-package-keywords)))
        (setcdr tail (append (list :hide-whitespace+ :hide-whitespace-regex+)
                             (cdr tail))))
    #+end_src

    #+begin_src emacs-lisp
      (provide '+use-package-show-whitespace)
    #+end_src

** Indentation
   :PROPERTIES:
   :header-args+: :tangle (lisp! "+setup-indent.el")
   :END:

   #+begin_src emacs-lisp :tangle yes
     (use-package +setup-indent
       :hook (after-change-major-mode . set-indent-offset+)
       :commands set-indent-offset+
       :leader ("t TAB" 'set-indent-offset+))
   #+end_src

   Configure the preferred indentation for buffers. Emacs doesn't really have a nice
   builtin way to do this across multiple modes. I got tired of always having to
   remember special variables for each mode so I've defined the following alist to
   store indent configurations and a command ~set-indent-offset~ which automatically (or
   manually sets the desired indent).

   ~+indent-config~ is the main user configuration variable for indentation. This is
   used when no alternative indent config (such as buffer-local variables, or
   EditorConfig files) specify how to deal with the current buffer.

   #+begin_src emacs-lisp
      (defvar +indent-config '((t . 4))
        "Alist configuring preferred indentation for buffers.
      the `car' of an entry is used to match which buffer it's applied to
      and `cdr' is used to determine the value of it.

      the `car' can be a symbol, a string, a function or some expression
      which evaluates to t. if it's a symbol, the major mode of the
      buffer is compared against it. if it's a string the name of the
      buffer is matched against it.

      the cons can be a number, a function or some expression which
      evaluates to a number.

      NOTE: indentation is set exclusively when a buffer-mode change
            occurs, changing the buffer name doesn't alter the indent.
      ")

      (defvar-local +indent nil
        "Override the local indent for the current file.")
   #+end_src

   A package that lets you configure project parameters (indent size, line endings
   etc.) in a [[https://editorconfig.org/][single configuration]] file.

   I really only need the parsing facilities so that I can extract the indent-offset
   but EditorConfig also has a mapping of common indent variables for major-modes
   that's bound to come in very useful „ÉΩ(*¬¥–∑ÔΩÄ*)Ôæâ.

   #+begin_src emacs-lisp
     (require '+core-base-packages)

     (use-package editorconfig
       :straight t
       :autoload editorconfig-set-indentation
       :custom
       (editorconfig-lisp-use-default-indent t)

       :config
       (push '(plantuml-mode plantuml-indent-level)
             editorconfig-indentation-alist)

       (push '(asm-mode comment-column)
             editorconfig-indentation-alist))
   #+end_src

   #+BEGIN_SRC emacs-lisp
     (defun +indent-offset (&optional buffer)
       "Use `+indent-config' to find the preffered indent for BUFFER."
       (with-current-buffer (or buffer (current-buffer))
         (cl-loop with matcher = nil
                  with indent  = nil
                  for cfg in +indent-config
                  do (setq matcher (car cfg))
                  if (cond
                      ((eq matcher t) t)
                      ((symbolp matcher) (eq matcher major-mode))
                      ((stringp matcher) (string-match-p matcher (buffer-name)))
                      ((functionp matcher) (funcall matcher))
                      (t (eval matcher)))
                  do (setq indent (cdr cfg))
                  and return (if (functionp indent)
                                 (funcall indent)
                               indent))))

     (defun set-indent-offset+ (&optional indent tab-size)
       "Set the indentation level of the current buffer.
     this method uses `+indent-config' to determine what
     the indentation of the current buffer should be and then sets
     it. Also setting any mode dependent, specific indent bindings,
     alongside it.

     You can pass a specific value for the indent as an argument and
     the current buffers indentation will be set to that."
       (interactive (let ((size (read-number "Indent: ")))
                      (list size size)))
       (let* ((conf (or (ignore-errors
                          (funcall editorconfig-get-properties-function))
                        (make-hash-table :size 0)))
              (style (or (gethash 'indent_style conf)
                         (if indent-tabs-mode "tab" "space"))))
         (setq indent (or indent                                                     ; Interactive argument.
                          +indent                                                    ; Directory-local variable.
                          (gethash 'indent_size conf)                                ; Extract from editorconfig.
                          (+indent-offset))                                          ; Calculate from `+indent-config'.
               tab-size (or tab-size
                            (gethash 'tab_width conf)))

         (when (numberp indent)
           (setq indent (number-to-string indent)))
         (when (numberp tab-size)
           (setq tab-size (number-to-string tab-size)))

         (if (not indent)
             (and (called-interactively-p 'interactive)
                  (user-error "set-indent-offset: unable to determine indent for current buffer."))
           (editorconfig-set-indentation style indent tab-size))))
   #+END_SRC

   #+begin_src emacs-lisp
     (provide '+setup-indent)
   #+end_src

*** Use Package
    :PROPERTIES:
    :header-args+: :tangle (lisp! "+use-package-setup-indent.el")
    :END:

    #+begin_src emacs-lisp
      (require 'use-package-core)

      (defun use-package-normalize/:indent+ (name keyword args)
        (mapcar (lambda (arg)
                  (unless (and (listp args) (<= (length arg) 2) (>= (length arg) 1))
                    (use-package-error (concat (symbol-name keyword) " indent configuration should be (mode value).")))
                  arg)
                args))

      (defun use-package-handler/:indent+ (name keyword args rest state)
        (use-package-concat
         (use-package-process-keywords name rest state)
         (when args
           `((defvar +indent-config)
             (with-eval-after-load '+setup-indent
              (progn
                ,@(cl-loop for arg in args collect
                           `(push (cons (quote ,(car arg)) ,(cadr arg))
                                  +indent-config))))))))

      (let ((tail (nthcdr (cl-position :init use-package-keywords)
                          use-package-keywords)))
        (setcdr tail (cons :indent+ (cdr tail))))
    #+end_src

    #+begin_src emacs-lisp
      (provide '+use-package-setup-indent)
    #+end_src

** Birthday
   :PROPERTIES:
   :header-args+: :tangle (lisp! "+setup-birthday.el")
   :END:

   #+begin_src emacs-lisp :tangle yes
      (require '+setup-birthday)
   #+end_src

   #+begin_src emacs-lisp
     (when (string-equal (format-time-string "%d.%m" (current-time))
                         "08.12")
       (add-hook 'emacs-startup-hook 'animate-birthday-present))

     (provide '+setup-birthday)
   #+end_src

** Find Emacs
   :PROPERTIES:
   :header-args+: :tangle (lisp! "+setup-find-emacs.el")
   :END:

   #+begin_src emacs-lisp :tangle yes
     (use-package +setup-find-emacs
       :commands
       (find-dotemacs-org-file+
        find-dotemacs-directory+
        find-dotemacs-snippets-file+
        find-dotemacs-file+
        find-file-from-dotemacs+
        find-dotemacs-config-file+)

       :leader
       ("fec" 'find-dotemacs-org-file+
        "fed" 'find-dotemacs-directory+
        "fey" 'find-dotemacs-snippets-file+
        "fel" 'find-dotemacs-file+
        "fef" 'find-file-from-dotemacs+
        "fex" 'find-dotemacs-config-file+))
   #+end_src

   Find files related to my own configuration/directory layouts.

   #+BEGIN_SRC emacs-lisp
     (defun find-dotemacs-file+ ()
       (interactive)
       (find-file (join-path+ user-emacs-directory "init.el")))

     (defun find-dotemacs-directory+ ()
       (interactive)
       (find-file user-emacs-directory))

     (defun find-dotemacs-org-file+ ()
       (interactive)
       (find-file (join-path+ user-emacs-directory "init.org")))

     (defun find-dotemacs-snippets-file+ ()
       (interactive)
       (find-file (etc! "snippets.org")))

     (declare-function imenu--make-index-alist "imenu")

     (defun find-dotemacs-config-file+ (&optional arg)
       (interactive "P")
       (cl-destructuring-bind (file . point)
           (or (unless arg
                 (let ((conf (etc! "+config-local.el")))
                   (and (file-exists-p conf)
                        (cons conf nil))))
               (save-window-excursion
                 (find-dotemacs-org-file+)
                 (require 'imenu)
                 (cons (buffer-file-name)
                       (alist-get "** Config Default" (imenu--make-index-alist t) nil nil #'equal))))
         (if file
             (progn
               (find-file file)
               (when point
                 (goto-char point)))
           (user-error "No configuration file found"))))

     (defun find-file-from-dotemacs+ ()
       (interactive)
       (let ((default-directory (file-truename user-emacs-directory)))
         (call-interactively 'find-file)))
   #+END_SRC

   #+begin_src emacs-lisp
     (provide '+setup-find-emacs)
   #+end_src

** Scratch
   :PROPERTIES:
   :header-args+: :tangle (lisp! "+setup-scratch.el")
   :END:

   #+begin_src emacs-lisp :tangle yes
      (use-package +setup-scratch
        :demand t
        :general
        ([remap scratch-buffer] 'scratch-buffer+)
        :leader
        ("b RET" 'new-scratch-buffer+))
   #+end_src

   An extension of the persistent scratch function which provides functions to
   create a new scratch buffer and interactively switch to one.

   *WARN* multi-scratch doesn't save the first scratch buffer. That's a real scratch
   buffer, which is expected to get erased every time emacs is killed. All other
   scratch buffers are properly restored though.

   First we define what a scratch buffer should look like, and add facilities for
   creating a new scratch buffer interactively.

   #+BEGIN_SRC emacs-lisp
     (defconst scratch-buffer-name+ "*scratch*"
       "Name of users scratch buffer")

     (defun scratch-buffer-p+ (&optional buffer)
       (string-match
        (regexp-quote scratch-buffer-name+)
        (buffer-name buffer) 0))

     (defun new-scratch-buffer+ (&optional buffer-name interactive)
       "Creates and returns a new empty scratch like buffer
     with prefix it prompts you for the name of the buffer.
     if called interactively, the new buffer is switched to."
       (interactive "Pp")
       (let* ((def-buf-name scratch-buffer-name+)
              (buffer-name
               (cond
                ((stringp buffer-name) buffer-name)
                (buffer-name (read-buffer "buffer name: " def-buf-name))
                (t def-buf-name)))
              (buffer-name (generate-new-buffer-name buffer-name))
              (buffer (get-buffer-create buffer-name)))
         (with-current-buffer buffer
           ;; Setup copied from `get-scratch-buffer-create'.
           ;; (when initial-scratch-message
           ;;   (insert (substitute-command-keys initial-scratch-message))
           ;;   (set-buffer-modified-p nil))
           (funcall initial-major-mode))
         (when (called-interactively-p 'interactive)
           (switch-to-buffer buffer))
         buffer))
   #+END_SRC

   Now a command to list and jump to scratch buffers.

   #+BEGIN_SRC emacs-lisp
     (defun scratch-buffers+ ()
       (require 'persistent-scratch)                                                               ; Make sure scratches have been restored
       (sort
        (seq-filter #'scratch-buffer-p+ (buffer-list))
        (lambda (x y) (string< (buffer-name x) (buffer-name y)))))

     (defun scratch-buffer+ (&optional prefix)
       "Switch to the scratch buffer
     with PREFIX, prompts for which buffer named like the scratch
     buffer to switch to. If none exists, a new scratch buffer will
     be made. If only one exists, it will be switched to and if more
     than one exists then prompts for it."
       (interactive "P")
       (let ((buf
              (if prefix
                  (let* ((buffer-list (scratch-buffers+))
                         (buffer-names (mapcar #'buffer-name buffer-list)))
                    (cond
                     ((zerop (length buffer-list))
                      (get-scratch-buffer-create))
                     ((eq 1 (length buffer-list))
                      (car buffer-list))
                     (t (completing-read "Switch to buffer: " buffer-names))))
                (or (get-buffer scratch-buffer-name+)
                    (get-scratch-buffer-create)))))
         (when (called-interactively-p 'any)
           (switch-to-buffer buf))
         buf))
   #+END_SRC

   Setup persistent scratch support. allows scratch buffers to survive Emacs sessions.

   #+BEGIN_SRC emacs-lisp
     (use-package persistent-scratch
       :straight t
       :autoload persistent-scratch-save
       :custom
       (persistent-scratch-save-file (share! "scratch.el"))
       (persistent-scratch-autosave-interval 800)

       :init
       (setq persistent-scratch-scratch-buffer-p-function
             (defun multiscratch-scratch-buffer-p+ (&optional buffer)
               "Persist all but the main scratch buffer."
               (and (not (string= (buffer-name buffer) scratch-buffer-name+))
                    (scratch-buffer-p+ buffer))))

       :config
       (add-hook 'kill-emacs-hook #'persistent-scratch-save))
   #+END_SRC

   Ensure persistent scratch restores the last session when we first navigate to a
   scratch buffer or try to create a new one.

   #+begin_src emacs-lisp
     (require '+lib-transient-hook)

     (use-package persistent-scratch
       :autoload persistent-scratch-restore
       :config
       (let* ((loaded)
              (handle (lambda ()
                        (when (and (not loaded)
                                   (file-exists-p persistent-scratch-save-file))
                          (save-window-excursion
                            (persistent-scratch-restore))
                          (setq loaded t)))))
         (add-transient-hook! #'scratch-buffers+    (funcall handle))
         (add-transient-hook! #'new-scratch-buffer+ (funcall handle))))
   #+end_src

   #+begin_src emacs-lisp
      (provide '+setup-scratch)
   #+end_src

** Universal Argument
   :PROPERTIES:
   :header-args+: :tangle (lisp! "+setup-universal-argument.el")
   :END:

   #+begin_src emacs-lisp :tangle yes
      (use-package +setup-universal-argument
        :commands smart-universal-argument+
        :leader
        ("U" 'universal-argument
         "u" 'smart-universal-argument+)

        :general
        (:keymaps 'universal-argument-map
         "M-u" 'universal-argument-batch-increment+
         "M-U" 'universal-argument-batch-decrement+))
   #+end_src

   #+BEGIN_SRC emacs-lisp
      (defmacro defun-universal-argument-operation+ (name docstring &rest body)
        `(defun ,name ()
           ,(eval docstring)
           (interactive)
           (prefix-command-preserve-state)
           (if (not prefix-arg)
               (universal-argument)
             ,@body)

           (when prefix-arg
             (universal-argument--mode))))
      (put 'defun-universal-argument-operation+ 'lisp-indent-function 'defun)

      (defun-universal-argument-operation+ smart-universal-argument+
        "combine both universal-argument and universal-argument-more
      into a single invokeable command. for some reason, calling simply
      more before a regular prefix has been specified, will result in no
      overall prefix being set :("
        (universal-argument-more prefix-arg))

      ;; I'm not sure why universal-argument-more multiplies
      ;; the prefix arg by a factor of 4. I mean, 4 to 16 is
      ;; fine, but 16 to 64 is pretty unlikely to be what you
      ;; wanted. Adding by 4 would be more useful, especially
      ;; if you're using it to gauge indents.
      (defun-universal-argument-operation+ universal-argument-batch-increment+
        "increment the current prefix-arg by 4"
        (let* ((prefix-value (prefix-numeric-value prefix-arg)))
          (setq prefix-arg
                (+ prefix-value 4))))

      (defun-universal-argument-operation+ universal-argument-batch-decrement+
        "decrement the current prefix-arg by 4"
        (let* ((prefix-value (prefix-numeric-value prefix-arg)))
          (setq prefix-arg (- prefix-value 4))))
   #+END_SRC

   #+begin_src emacs-lisp
     (provide '+setup-universal-argument)
   #+end_src

** Unpackaged
   :PROPERTIES:
   :header-args+: :tangle (lisp! "+setup-unpackaged.el")
   :END:

   Useful functions sourced from [[https://github.com/alphapapa/unpackaged.el/blob/master/unpackaged.el][unpackaged.el]].

   #+BEGIN_SRC emacs-lisp :tangle yes
       (use-package +setup-unpackaged
         :commands (font-compare+
                    lorem-ipsum-overlay+)
         :leader
         ("xl" 'lorem-ipsum-overlay+))
   #+END_SRC

   #+begin_src emacs-lisp
     (require '+pkg-lorem-ipsum)
     (require 'lorem-ipsum)
   #+end_src

   Font methods.

   #+BEGIN_SRC emacs-lisp
     (defun font-compare+ (text fonts)
       "Compare TEXT displayed in FONTS.
     If TEXT is nil, use `lorem-ipsum' text.  FONTS is a list of font
     family strings and/or font specs.

     Interactively, prompt for TEXT, using `lorem-ipsum' if left
     empty, and select FONTS with `x-select-font', pressing Cancel to
     stop selecting fonts."
       (interactive (list (pcase (read-string "Text: ")
                            ("" nil)
                            (else else))
                          ;; `x-select-font' calls quit() when Cancel is pressed, so we use
                          ;; `inhibit-quit', `with-local-quit', and `quit-flag' to avoid that.
                          (let ((inhibit-quit t))
                            (cl-loop for font = (with-local-quit
                                                  (x-select-font))
                                     while font
                                     collect font into fonts
                                     finally do (setf quit-flag nil)
                                     finally return fonts))))
       (setq text (or text (s-word-wrap 80 (s-join " " (seq-random-elt lorem-ipsum-text)))))
       (with-current-buffer (get-buffer-create "*Font Compare*")
         (erase-buffer)
         (--each fonts
           (let ((family (pcase it
                           ((pred fontp) (symbol-name (font-get it :family)))
                           ((pred stringp) it))))
             (insert family ": "
                     (propertize text
                                 'face (list :family family))
                     "\n\n")))
         (pop-to-buffer (current-buffer))))
   #+END_SRC

   Lorem ipsum overlay.

   #+BEGIN_SRC emacs-lisp
     (defvar lorem-ipsum-overlay-exclude+ nil
       "List of regexps to exclude from `lorem-ipsum-overlay'.")

     ;;;###autoload
     (defun lorem-ipsum-overlay+ ()
       "Overlay all text in current buffer with \"lorem ipsum\" text.
     When called again, remove overlays.  Useful for taking
     screenshots without revealing buffer contents.

     Each piece of non-whitespace text in the buffer is compared with
     regexps in `lorem-ipsum-overlay-exclude', and ones
     that match are not overlaid.  Note that the regexps are compared
     against the entire non-whitespace token, up-to and including the
     preceding whitespace, but only the alphabetic part of the token
     is overlaid.  For example, in an Org buffer, a line that starts
     with:

       ,#+TITLE: unpackaged.el

     could be matched against the exclude regexp (in `rx' syntax):

       (rx (or bol bos blank) \"#+\" (1+ alnum) \":\" (or eol eos blank))

     And the line would be overlaid like:

       ,#+TITLE: parturient.et"
       (interactive)
       (let ((ovs (overlays-in (point-min) (point-max))))
         (if (cl-loop for ov in ovs
                      thereis (overlay-get ov :lorem-ipsum-overlay))
             ;; Remove overlays.
             (dolist (ov ovs)
               (when (overlay-get ov :lorem-ipsum-overlay)
                 (delete-overlay ov)))
           ;; Add overlays.
           (let ((lorem-ipsum-words (--> lorem-ipsum-text
                                         (-flatten it) (apply #'concat it)
                                         (split-string it (rx (or space punct)) 'omit-nulls)))
                 (case-fold-search nil))
             (cl-labels ((overlay-match (group)
                                        (let* ((beg (match-beginning group))
                                               (end (match-end group))
                                               (replacement-word (lorem-word (match-string group)))
                                               (ov (make-overlay beg end)))
                                          (when replacement-word
                                            (overlay-put ov :lorem-ipsum-overlay t)
                                            (overlay-put ov 'display replacement-word))))
                         (lorem-word (word)
                                     (if-let* ((matches (lorem-matches (length word))))
                                         (apply-case word (downcase (seq-random-elt matches)))
                                       ;; Word too long: compose one.
                                       (apply-case word (downcase (compose-word (length word))))))
                         (lorem-matches (length &optional (comparator #'=))
                                        (cl-loop for liw in lorem-ipsum-words
                                                 when (funcall comparator (length liw) length)
                                                 collect liw))
                         (apply-case (source target)
                                     (cl-loop for sc across-ref source
                                              for tc across-ref target
                                              when (not (string-match-p (rx lower) (char-to-string sc)))
                                              do (setf tc (string-to-char (upcase (char-to-string tc)))))
                                     target)
                         (compose-word (length)
                                       (cl-loop while (> length 0)
                                                for word = (seq-random-elt (lorem-matches length #'<=))
                                                concat word
                                                do (cl-decf length (length word)))))
               (save-excursion
                 (goto-char (point-min))
                 (while (re-search-forward (rx (group (1+ (or bol bos blank (not alpha)))
                                                      (0+ (not (any alpha blank)))
                                                      (group (1+ alpha))
                                                      (0+ (not (any alpha blank)))))
                                           nil t)
                   (unless (cl-member (match-string 0) lorem-ipsum-overlay-exclude+
                                      :test (lambda (string regexp)
                                              (string-match-p regexp string)))
                     (overlay-match 2))
                   (goto-char (match-end 2)))))))))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
       (provide '+setup-unpackaged)
   #+END_SRC

** Commands
   :PROPERTIES:
   :header-args+: :tangle (lisp! "+setup-commands.el")
   :END:

   #+begin_src emacs-lisp :tangle yes
     (use-package +setup-commands
       :demand t
       :autoload smart-buffer-file-name+
       :general
       ("M-j" 'custom-insert-line-below+
        "M-k" 'custom-insert-line-above+)
       (:keymaps 'emacs-window-map+
        "T"   'force-set-all-visible-windows-dedication+
        "o"   'other-window
        "M-o" 'display-last-buffer+
        "C-o" 'vertical-display-last-buffer+
        "SPC" 'set-window-dedication+
        "M-d" 'set-window-dedication+

        "m"   'window-zen+
        "RET" 'window-zen+
        [C-m] 'window-zen+
        "M"   'window-zen-restore+
        "M-m" 'window-zen-restore+)
       :leader
       ("bE" '(safe-erase-buffer+ :wk "safe-erase-buffer")
        "M-|" 'async-shell-command-on-region+
        "TAB" '(switch-to-last-buffer+ :wk "last-buffer")
        "bK" 'kill-this-buffer-and-window-maybe+
        "bM" '(switch-to-messages-buffer+ :wk "switch-to-messages")
        "f~" 'write-backup+
        "fa" 'write-autosave+
        "fD" 'delete-buffer-file+
        "by" 'show-and-copy-buffer-name+
        "fy" 'show-and-copy-buffer-file-name+
        "fu" 'show-and-copy-directory+
        "f%" 'show-and-copy-buffer-file-basename+
        "bh" '(goto-home-buffer+ :wk "switch-to-home")
        "ft" 'find-temp-file+
        "tL" 'toggle-lexical-binding+
        "t-" 'toggle-buffer-header+
        "xf" 'list-faces+
        ))
   #+end_src

*** Buffer Files
    #+BEGIN_SRC emacs-lisp
      (defun delete-buffer-file+ ()
        (interactive)
        (let ((buffer (current-buffer))
              (filename (buffer-file-name))
              (name (buffer-name)))
          (if (not filename)
              (message "buffer %s is not visiting a file" name)
            (when (yes-or-no-p "Are you sure you want to delete this file? ")
              (when (file-exists-p filename)
                (delete-file filename t))

              (kill-buffer buffer)))))

      (defun smart-buffer-file-name+ (&optional buffer strip-remote)
        (with-current-buffer (or buffer (current-buffer))
          (or (when-let* ((bfn (buffer-file-name)))
                (if-let* ((strip-remote strip-remote)
                          (remote (file-remote-p bfn)))
                    (string-remove-prefix remote bfn)
                  bfn))
              (and (derived-mode-p 'dired-mode)
                   (when (functionp 'dired-current-directory)
                     (string-trim-right (dired-current-directory) "/")))
              (and (boundp 'org-capture-mode)
                   (when (functionp 'org-capture-get)
                     (buffer-file-name (org-capture-get :buffer t))))
              (and (boundp 'org-src-mode)
                   (bound-and-true-p org-src-source-file-name))
              (and (derived-mode-p 'magit-mode)
                   default-directory)
              (and (derived-mode-p 'notmuch-show-mode)
                   (when (functionp 'notmuch-show-get-filename)
                     (notmuch-show-get-filename))))))

      (defun show-and-copy+ (msg)
        (or (stringp msg)
            (setq msg (format "%s" msg)))                                      ; Force msg to be a string

        (when msg
          (message msg)
          (kill-new msg)))

      (defun show-and-copy-buffer-file-basename+ (&optional include-linum)
        (interactive "P")
        (when-let* ((file-name (smart-buffer-file-name+ nil t)))
          (show-and-copy+
           (concat
            (file-name-nondirectory file-name)
            (when include-linum
              (concat
               ":"
               (number-to-string (line-number-at-pos nil t))))))))

      (defun show-and-copy-buffer-file-name+ (&optional include-linum)
        (interactive "P")
        (when-let* ((file-name (smart-buffer-file-name+ nil t)))
          (show-and-copy+
           (concat
            file-name
            (when include-linum
              (concat
               ":"
               (number-to-string (line-number-at-pos nil t))))))))

      (defun show-and-copy-buffer-name+ ()
        (interactive)
        (show-and-copy+ (buffer-name)))

      (defun show-and-copy-directory+ ()
        (interactive)
        (show-and-copy+
         (if-let* ((file-name (smart-buffer-file-name+ nil t)))
             (file-name-directory file-name)
           default-directory)))

      (cl-defun write-backup+ (&optional prefix (silent t))
        "manually force emacs to backup the current buffer.
      By default doesn't do anything when the current buffer hasn't been modified.
      Pass a single-prefix `C-u` to force backing-up even if the buffer has not been
      modified. Pass two prefixes `C-u C-u`to backup the buffer and then save; this
      in affect backs up the last save and then saves the current buffer."
        (interactive "P")
        (let* ((modified (buffer-modified-p))
               (save-after (and (listp prefix)
                                (eq (car prefix) 8)))
               (save-before (and (not save-after)
                                 modified)))
          (if (and (not prefix)
                   (not modified))
              (or silent
                  (message "buffer not modified since last save"))
            (or save-before (save-buffer))

            ;; buffer-backed-up is Permenently buffer-local so you have to account
            ;; for when it's already been backed up and when you first back it up.
            (if buffer-backed-up
                (let (buffer-backed-up)
                  (backup-buffer))
              (backup-buffer))

            (or save-after (save-buffer)))))

      (defun write-kill-buffer+ (&optional buffer-or-name confirm)
        "write buffer to file and then kill it"
        (interactive)
        (let ((buffer (get-buffer (or buffer-or-name (current-buffer)))))
          (when (buffer-modified-p)
            (write-file (or (buffer-file-name) (read-file-name "write file: "))
                        confirm))

          (when (or (not confirm)
                    (y-or-n-p (format "are you sure you want to kill this buffer (%s): " buffer)))
            (let ((window (get-buffer-window buffer)))
              (kill-buffer buffer)
              (when (and window (> (length (window-list)) 1))
                (delete-window window))))))

      (defun goto-home-buffer+ ()
        (interactive)
        (unless initial-buffer-choice
          (user-error "No initial buffer choice setup"))
        (if-let* ((buffer
                   (pcase initial-buffer-choice
                     ((pred stringp)
                      (find-buffer-visiting initial-buffer-choice))
                     ((pred functionp)
                      (funcall initial-buffer-choice))
                     ((pred symbol-value)
                      (get-buffer "*scratch*")))))
            (switch-to-buffer buffer)))
    #+END_SRC

*** Switch to Buffer
   Commands to switch to various buffers.

   #+begin_src emacs-lisp
       (defun switch-to-messages-buffer+ ()
         "Switches to messages buffer."
         (interactive)
         (switch-to-buffer (messages-buffer)))

       (defun switch-to-last-buffer+ (&optional buffer)
         (interactive)
         (switch-to-buffer buffer))
   #+end_src

   #+BEGIN_SRC emacs-lisp
     (defun display-last-buffer+ ()
       (interactive)
       (display-buffer
        (other-buffer)
        '((display-buffer-below-selected-and-focus+
           display-buffer-in-previous-window-and-focus+
           display-buffer-use-some-window-and-focus+
           display-buffer-pop-up-frame-and-focus+))))

     (defun vertical-display-last-buffer+ ()
       (interactive)
       (display-buffer
        (other-buffer)
        (cons '(display-buffer-right-and-focus+
                display-buffer-in-previous-window-and-focus+
                display-buffer-use-some-window-and-focus+
                display-buffer-pop-up-frame-and-focus+)
              '((side . right)
                (window-width . 0.5)))))
   #+END_SRC

*** Temp File
    #+begin_src emacs-lisp
      (defun find-temp-file+ (path)
        (interactive
         (list (let* ((default-basename (format-time-string "%Y%m%d.%H%M%S"))
                      (default-directory
                        (concat (xdg--dir-home "XDG_TEMP_DIR" "~/.local/temp") "/")))
                 (expand-file-name
                  (read-file-name
                   "Make temp file: "
                   default-directory
                   nil
                   nil
                   default-basename)))))
        (when-let* ((dir (file-name-directory path)))
          (unless (string-empty-p dir)
            (mkdir dir t)))
        (find-file path))
    #+end_src

*** Kill Buffer
    #+BEGIN_SRC emacs-lisp
      (defun kill-this-buffer-and-window-maybe+ ()
        "Kills the currently open buffer and the window if another is open"
        (interactive)
        (let ((window-count (length (window-list))))
          (if (> window-count 1)
              (kill-buffer-and-window)
            (kill-current-buffer))))
    #+END_SRC

*** Split Window
    #+BEGIN_SRC emacs-lisp
      (defun split-window-right-and-focus+ ()
        (interactive)
        (split-window-horizontally)
        (other-window 1))

      (defun split-window-below-and-focus+ ()
        (interactive)
        (split-window-vertically)
        (other-window 1))
    #+END_SRC

*** Shell Command
    Emacs has some cool built-in commands for running shell commands but there
    doesn't seem to be straightforward ways to pass the current buffer as standard
    input to those commands. So here are variants that let you do this.

    #+BEGIN_SRC emacs-lisp
      (defun shell-command-on-buffer+ (&optional prefix)
        "Asks for a command and executes it in inferior shell with current buffer
      as input. if prefix is given, output of command is inserted in current buffer
      at point."
        (interactive "P")
        (let ((command (read-shell-command "Shell command on buffer: "))
              (input-buffer (current-buffer)) output-buffer process-output)
          (with-temp-buffer ;; needed for process output
            (setq output-buffer (current-buffer))

            (with-current-buffer input-buffer
              (shell-command-on-region
               (point-min) (point-max)
               command output-buffer nil output-buffer))

            (setq process-output (buffer-string)))

          (if prefix
              (insert process-output)
            (message process-output))))

      (declare-function comint-send-eof "comint")

      (defun async-shell-command-on-region+ (start end)
        "`async-shell-command' variant which uses the region as standard input."
        (interactive (list (if (region-active-p)
                               (list (region-beginning) (region-end))
                             (list (point-min) (point-max)))))
        (unless (eq start end) ;; region is not active
          (let ((command (read-shell-command "Async shell command on buffer: ")))
            (if (string-empty-p command)
                (user-error "Must supply a non-empt shell command.")
              (async-shell-command command) ;; XXX WHY??? don't you return the process :P
              (let ((program-buffer (get-buffer "*Async Shell Command*")))
                (process-send-region (get-buffer-process program-buffer) start end)

                (with-current-buffer program-buffer
                  (comint-send-eof)

                  (unless (get-buffer-process program-buffer)
                    (funcall-interactively 'initial-major-mode)))

                (display-buffer program-buffer))))))
    #+END_SRC

*** Window Zen
    ~window-zen+~ lets you quickly zoom into the current window and then zoom back out.
    The gist of it is that when you call ~window-zen+~ with multiple windows it saves
    the current window configuration and then erases all the other windows. If you
    call it again when in only a single window it restores the previous configuration.

    It's implemented as a stack tied to the current frame. Meaning each frame has
    its own history of zens. You can zen repeatedly, one after the other and then
    jump back through your saved configurations using ~window-zen-restore+~.

    #+BEGIN_SRC emacs-lisp
      (defun window-zen+ (&optional prefix)
        (interactive "P")
        (if (or prefix
                (= (length (window-list)) 1))
            (window-zen-restore+)
          (set-frame-parameter (frame-focus) 'window-zen-history
                               (append
                                (list (current-window-configuration))
                                (frame-parameter (frame-focus) 'window-zen-history)))
          (delete-other-windows)))

      (defun window-zen-restore+ ()
        (interactive)
        (let* ((current-frame (frame-focus))
               (configs (frame-parameter current-frame 'window-zen-history)))
          (unless configs
            (user-error "No previous zens found for the current frame."))
          (unwind-protect
              (save-excursion
                (set-window-configuration (pop configs)))
            (set-frame-parameter current-frame 'window-zen-history configs))))
    #+END_SRC

*** Window Dedication
    #+BEGIN_SRC emacs-lisp
      (defun force-set-all-visible-windows-dedication+ (&optional dedicate)
        "Allows you to set the dedication of all visible windows
      DEDICATE if truthy, will result in all windows recieving a dedication.
      if falsy, all windows will have their dedication removed."
        (interactive "P")
        ;; TODO require persp-mode here
        (and dedicate (setq dedicate t))      ; rationalise value as bool
        (or  dedicate (setq dedicate nil))    ; rationalise value as nil

        (dolist (window (window-list))
          (when (not (eq dedicate (window-dedicated-p window)))
            (set-window-dedicated-p window dedicate))))
    #+END_SRC

    #+BEGIN_SRC emacs-lisp
      (defun set-window-dedication+ (&optional prefix window)
        "Set the dedication value for the current window.
      By default it toggles the dedication. Supply a prefix arg
      to explicitly enable or disable.

      When a window is dedicated, you can't change the buffer for it."
        (interactive "P")
        (when (and prefix
                   (listp prefix))
          (setq prefix (car prefix)))
        (or window (setq window (selected-window)))

        (set-window-dedicated-p
         window
         (if prefix
             (> prefix 0)
           (not (window-dedicated-p window)))))
    #+END_SRC

*** Buffer Erase
    #+BEGIN_SRC emacs-lisp
      (defun safe-erase-buffer+ (&optional prefix)
        "prompts to really erase and then erases the current buffer"
        (interactive "P")
        (barf-if-buffer-read-only)
        (when (or prefix
                  (y-or-n-p (concat "Erase content of buffer "
                                    (buffer-name)
                                    " ?")))
            (erase-buffer)))
    #+END_SRC

*** Lexical Binding
    #+BEGIN_SRC emacs-lisp
      (defun toggle-lexical-binding+ (&optional arg)
        (interactive "P")
        (setq lexical-binding
              (if (not arg)
                  (not lexical-binding)
                (or (listp arg)
                    (not (zerop arg)))))

        (message "lexical binding: %s" (if lexical-binding
                                           (propertize "enabled" 'face 'compilation-info)
                                         (propertize "disabled" 'face 'compilation-error))))

    #+END_SRC

*** Buffer Header
    #+BEGIN_SRC emacs-lisp
      (defvar-local header-line-actual-format+ nil
        "value of `header-line-format' before being modified by `toggle-buffer-header'.")

      (defun toggle-buffer-header+ (&optional arg no-error)
        (interactive "P")
        (let ((showing (if arg
                           (not (zerop (prefix-numeric-value arg)))
                         header-line-actual-format+)))
          (if showing
              (if (not header-line-actual-format+)
                  (unless no-error
                    (user-error "tried to restore header-line: nil"))
                (setq header-line-format header-line-actual-format+
                      header-line-actual-format+ nil))
            (setq header-line-actual-format+ header-line-format
                  header-line-format nil))))
    #+END_SRC

*** Cycle Hook
    #+begin_src emacs-lisp
      (defun cycle-hook+ (hook-var &optional global)
        "Interactively cycle the order of functions in HOOK-VAR.
      When GLOBAL is true then the global value of the hook is modified
      even if there's a buffer-local value."
        (interactive
         (list (intern (completing-read
                        "Hook variable: "
                        obarray #'boundp t nil nil nil))
               current-prefix-arg))
        (unless (boundp hook-var)
          (error "Hook variable %s not bound" hook-var))

        (let* ((hook-value (if global
                               (default-value hook-var)
                             (eval hook-var)))
               (hook-value (if (or (not hook-value)
                                   (not (listp hook-value)))
                               (error "The hook variable %s is not a hook" hook-var)
                             hook-value))
               (contains-t (member t hook-value))
               (hook-value (remove t hook-value))
               (cycle-to
                (cl-position (intern
                              (completing-read "Cycle hook: "
                                               (lambda (str pred action)
                                                 (if (eq action 'metadata)
                                                     ;; Don't resort the order of the hook.
                                                     ;; It makes cycling confusing.
                                                     '(metadata
                                                       (category . function)
                                                       (cycle-sort-function . identity)
                                                       (display-sort-function . identity))
                                                   (complete-with-action action hook-value str pred)))
                                               nil t nil 'cycle-hook-history))
                             hook-value))
               (new-hook-value hook-value))
          (unless (zerop cycle-to)
            (setq new-hook-value (append (nthcdr cycle-to hook-value)
                                         (cl-subseq hook-value 0 cycle-to)
                                         (when contains-t
                                           (list t)))))
          (message "%s" new-hook-value)
          (funcall (if global #'set-default 'set) hook-var new-hook-value)))
    #+end_src

*** Keymaps at Point
    #+BEGIN_SRC emacs-lisp
      (defun keymaps-at-point+ ()
        "List entire keymaps present at point."
        (interactive)
        (let ((map-list
               (list
                (mapcar (lambda (overlay)
                          (overlay-get overlay 'keymap))
                        (overlays-at (point)))
                (mapcar (lambda (overlay)
                          (overlay-get overlay 'local-map))
                        (overlays-at (point)))
                (get-text-property (point) 'keymap)
                (get-text-property (point) 'local-map))))
          (apply #'message
                 (concat
                  "Overlay keymap: %s\n"
                  "Overlay local-map: %s\n"
                  "Text-property keymap: %s\n"
                  "Text-property local-map: %s")
                 map-list)))
    #+END_SRC

*** Faces at Point
    #+begin_src emacs-lisp
      (defun list-faces+ (&optional point)
        (interactive "d")
        (or point (setq point (point)))
        (let ((faces (remq nil
                           `(,(get-char-property point 'read-face-name)
                             ,(get-char-property point 'face)
                             ,(plist-get (text-properties-at point) 'face)))))
          (and (called-interactively-p 'any) (message (format "%s" faces)))
          faces))
    #+end_src

*** Toggle Relative Line Numbers
    #+BEGIN_SRC emacs-lisp
      (defun toggle-relative-linum+ (&optional arg)
        "toggle relative line numbers in the current buffer
      when ARG is given and is 0, then relative line numbers are disabled,
      otherwise if ARG is greater than 0 then they're enabled and if ARG is
      nil then relative line-numbers are toggled."
        (interactive "P")
        (setq display-line-numbers
              (cond
               ((and arg (zerop (prefix-numeric-value arg)))
                t)
               (arg 'relative)
               (t
                (if (eq display-line-numbers 'relative) t 'relative)))))
    #+END_SRC

*** Text Commands
    #+BEGIN_SRC emacs-lisp
      (defun dos2unix ()
        "Not exactly but it's easier to remember"
        (interactive)
        (set-buffer-file-coding-system 'unix 't))
    #+END_SRC

    #+BEGIN_SRC emacs-lisp
      (defun unix2dos ()
        (interactive)
        (set-buffer-file-coding-system 'dos 't))
    #+END_SRC

    #+begin_src emacs-lisp
      (defun custom-insert-line+ (&optional prefix)
        "inserts a line above or below point

      if a prefix argument of 0 or more (or none) is given, the
      line is inserted below the point. Otherwise its inserted
      above the point.

      The absolute value of the prefix determines how many lines
      are inserted.

      Eg: A prefix of:
        ,,* nil - inserts a single line below the cursor
        ,,* -1  - inserts a single line above the cursor
        ,,* 0   - inserts a single line below the cursor
        ,,* 1   - inserts a single line below the cursor
        ,,* -10 - inserts 10 lines above the cursor
        ,,* 10  - inserts 10 lines below the cursor"
        (interactive "P")

        (save-excursion
          (let ((move-arg (if (or (not prefix)
                                  (>= prefix 0))
                              nil ; if prefix xor prefix >= 0
                            0)))
            (move-end-of-line move-arg)
            (open-line (max 1 (abs prefix))))))

      (defun custom-insert-line-below+ (&optional prefix)
        (interactive "P")
        (custom-insert-line+ (abs (or prefix 1))))

      (defun custom-insert-line-above+ (&optional prefix)
        (interactive "P")
        (custom-insert-line+ (- (abs (or prefix 1)))))
    #+end_src

*** Appendix
    #+begin_src emacs-lisp
      (provide '+setup-commands)
    #+end_src

* Packages                                                          :package:
  :PROPERTIES:
  :header-args+: :shebang ";; -*- lexical-binding: t -*-\n(require '+core-base-packages)\n(require '+core-leader)\n(require '+config)\n(require '+core-completion)\n(eval-when-compile (require '+use-package-setup-indent))\n(eval-when-compile (require '+use-package-show-whitespace))\n(eval-when-compile (require '+use-package-show-whitespace))"
  :END:
  Builtin and external package setup.

** Completion Styles
   :PROPERTIES:
   :header-args+: :tangle (lisp! "+pkg-completions.el")
   :END:

   #+BEGIN_SRC emacs-lisp :tangle yes
     (require '+pkg-completions)
   #+END_SRC

*** Orderless                                                      :optional:
    :PROPERTIES:
    :header-args+: :tangle (package-lisp! +pkg-completions orderless)
    :END:

    A package for building nicer matching regexps for completion using space
    separated components. ATM it doesn't (and has no intentions for) ordering
    completion based on match counts or accuracy (shame üò¢) but we can get around
    that by using prescient.

    #+BEGIN_SRC emacs-lisp
      (use-package orderless
        :straight t
        :demand t
        :custom
        (completion-styles '(orderless basic))
        (completion-category-overrides
         '((file (styles basic-remote+ orderless partial-completion))))
        (orderless-affix-dispatch-alist nil)

        :preface
        (defun orderless-double-space-escapes+ (string)
          "Split STRING on spaces, which can be escaped with two subsequent spaces."
          ;; Works by replacing each escaped space with a C-@ character
          ;; and then splitting on single spaces, before turning the
          ;; C-@'s back to regular spaces.
          (mapcar
           (lambda (piece) (replace-regexp-in-string (string 0) " " piece))
           (split-string (replace-regexp-in-string
                          (rx (repeat 2 " "))
                          (lambda (x) (if (>= (length x) 2) (string 0) x))
                          string 'fixedcase 'literal)
                         " +" t)))
        :custom
        (orderless-component-separator #'orderless-double-space-escapes+)

        :preface
        (cl-defmacro defun-orderless-dispatcher+ (name &key string style prefix docstring)
          (declare (indent defun))
          `(defun ,name (pattern _index _total)
             ,docstring
             (if (string-equal pattern ,string)
                 ;; In the case where the input is the prefix/suffix then match
                 ;; it exactly until you expand it.
                 (cons 'orderless-literal pattern)
               ;; Otherwise check the prefix or suffix for string.
               (let ((matched-p)
                     (checking-both (eq ,prefix 'both)))
                 (when (and (or checking-both ,prefix)
                            (string-prefix-p ,string pattern))
                   (setq matched-p t
                         pattern (substring pattern 1)))
                 (when (and (not matched-p)
                            (or checking-both ,(not prefix))
                            (string-suffix-p ,string pattern))
                   (setq matched-p t
                         pattern (substring pattern 0 -1)))

                 (when matched-p
                   (cons ,style pattern))))))

        (defun-orderless-dispatcher+ flex-if-twiddle
          :docstring "Glob when trailing tilde."
          :string "~"
          :style 'orderless-flex)

        (defun-orderless-dispatcher+ literal-if-equals
          :docstring "Match literally if leading equals."
          :string "="
          :prefix 'both
          :style 'orderless-literal)

        (defun-orderless-dispatcher+ without-if-bang
          :docstring "Exclude literal when leading punctuation-mark."
          :string "!"
          :prefix t
          :style 'orderless-without-literal)

        ;; Allows you to [[http://endlessparentheses.com/new-in-emacs-25-1-easily-search-non-ascii-characters.html][search]] unicode characters with ascii queries.
        (defun-orderless-dispatcher+ fold-if-percent
          :docstring "Do smart unicode search with percent."
          :string "%"
          :prefix t
          :style 'char-fold-to-regexp)

        :custom
        (orderless-matching-styles '(orderless-regexp))
        (orderless-style-dispatchers '(flex-if-twiddle
                                       literal-if-equals
                                       without-if-bang
                                       fold-if-percent)))
    #+END_SRC

    #+begin_src emacs-lisp :tangle (package-lisp! +pkg-completions orderless :consult)
      (use-package consult
        :autoload consult--convert-regexp)

      (use-package orderless
        :autoload (orderless--highlight orderless-compile)
        :custom (consult--regexp-compiler #'consult--orderless-regexp-compiler+)
        :autoload consult--orderless-regexp-compiler+
        :config
        (defun consult--orderless-regexp-compiler+ (input type _ignore-case)
          (setq input (cdr (orderless-compile input)))
          (cons
           (mapcar (lambda (r) (consult--convert-regexp r type)) input)
           (apply-partially #'orderless--highlight input))))
    #+end_src

    #+begin_src emacs-lisp :tangle (package-lisp! +pkg-completions orderless company)
      (use-package orderless
        :after company
        :autoload orderless-company-fix-face+
        :config
        (defun orderless-company-fix-face+ (fn &rest args)
          (let ((orderless-match-faces [completions-common-part]))
            (apply fn args)))

        ;; Fixes face issues in tooltip, see [[https://github.com/oantolin/orderless/tree/d97a91f6e12ace638e65bdccefd14d1e638a2dae#company][here]].
        (advice-add 'company-capf--candidates :around #'orderless-company-fix-face+))
    #+end_src

*** HotFuzz                                                        :optional:
    :PROPERTIES:
    :header-args+: :tangle (package-lisp! +pkgs-completions hotfuzz)
    :END:

    #+begin_src emacs-lisp
      (use-package hotfuzz
        :straight t
        :custom (completion-styles '(hotfuzz)))
    #+end_src

*** Prescient                                                      :optional:
    :PROPERTIES:
    :header-args+: :tangle (package-lisp! +pkg-completions prescient)
    :END:

    A package for remembering and sorting completion candidates based on frequency of
    usage. This is intended to be used with orderless, however because prescient has
    its own functions for filtering if orderless is disabled prescient will take over
    that as well.

    For tips on how to integrate this with orderless see [[https://github.com/oantolin/orderless/issues/25#issuecomment-743740717][orderless#25]].

    #+BEGIN_SRC emacs-lisp
      (use-package prescient
        :straight t
        :hook (after-init . prescient-persist-mode)
        :custom
        (prescient-history-length 1000)
        (completion-preview-sort-function #'prescient-completion-sort)
        (prescient-save-file (state! "prescient-history.el")))
    #+END_SRC

*** Appendix
    #+BEGIN_SRC emacs-lisp
      (provide '+pkg-completions)
    #+END_SRC

** Hydra
   :PROPERTIES:
   :header-args+: :tangle (lisp! "+pkg-hydra.el")
   :END:

   #+begin_src emacs-lisp :tangle yes
     (require '+pkg-hydra)
   #+end_src

*** Hydra
    #+begin_src emacs-lisp
      (use-package hydra
        :straight t
        :preface
        (defvar leader-hydra-leader-prefix+ "H")

        :leader
        (leader-hydra-leader-prefix+
         '(:ignore t :wk ("hydras" . "Cut off one head, two more shall take it's place!")))

        :autoload
        (hydra-set-transient-map
         hydra-show-hint
         hydra--call-interactively-remap-maybe
         hydra-keyboard-quit
         hydra-default-pre))
    #+end_src

    #+begin_src emacs-lisp
      (use-package +setup-show-whitespace
        :hook (lv-window . +hide-trailing-whitespace)
        :custom (lv-use-separator t))
    #+end_src

*** Use Package Hydra
    #+begin_src emacs-lisp
      (use-package use-package-hydra :straight t :demand t)
    #+end_src

*** Pretty Hydra
    #+begin_src emacs-lisp
      (use-package pretty-hydra :straight t :demand t)
    #+end_src

*** Core Hydras
**** WinMan
     :PROPERTIES:
     :header-args+: :tangle (lisp! "+hydra-winman.el")
     :END:

     #+begin_src emacs-lisp :tangle (lisp! "+pkg-hydra.el")
       (use-package +hydra-winman
         :commands winman-hydra/body
         :general
         (:keymaps 'emacs-window-map+
          "." '(winman-hydra/body :wk "winman-hydra"))
         :leader
         (:prefix leader-hydra-leader-prefix+
          "h" '(winman-hydra/body :wk "winman-hydra")))
     #+end_src

     #+begin_src emacs-lisp
       (require 'hydra)
       (require 'evil)
       (require 'windmove)
       (require 'winner)
       (require 'winum)
       (require '+setup-commands)

       (declare-function eyebrowse-hydra/body "+pkg-eyebrowse")

       (defhydra winman-hydra (:exit nil :foreign-keys nil :hint nil)
         "
       ^create^               ^move^      ^shift^          ^numbers^               ^resize^
       ^-^------------------  ^-^-------  ^-^------------  ^-^--^-^--------------  ^-^----------------               (__)
       _c_ create             _h_ left    _H_ move-left    _1_.._9_ window-n       _>_ increase-width                (00)
       _d_ delete             _j_ down    _J_ move-down    _0_  ^ ^ window-by-num  _<_ decrease-width          /------\\/
       _s_ split              _k_ up      _K_ move-up      ^ ^  ^ ^                _+_ increase-height        / |    ||
       _v_ vsplit             _l_ right   _L_ move-right   ^ ^  ^ ^                _-_ decrease-height       *  /\\---/\\
       _S_ split-and-focus    _n_ next    ^ ^              ^ ^  ^ ^                ^ ^                          ~~   ~~
       _V_ vsplit-and-focus   _p_ prev

       "
         ("d" evil-window-delete)
         ("c" evil-window-new)
         ("s" evil-window-split)
         ("v" evil-window-vsplit)
         ("S" split-window-below-and-focus+)
         ("V" split-window-right-and-focus+)

         ("h" evil-window-left)
         ("k" evil-window-up)
         ("j" evil-window-down)
         ("l" evil-window-right)
         ("n" evil-window-next)
         ("p" evil-window-prev)

         ("H" windmove-left)
         ("J" windmove-up)
         ("K" windmove-down)
         ("L" windmove-right)

         ("0" winum-select-window-by-number)
         ("1" winum-select-window-1)
         ("2" winum-select-window-2)
         ("3" winum-select-window-3)
         ("4" winum-select-window-4)
         ("5" winum-select-window-5)
         ("6" winum-select-window-6)
         ("7" winum-select-window-7)
         ("8" winum-select-window-8)
         ("9" winum-select-window-9)

         ("C-0" digit-argument)
         ("C-1" digit-argument)
         ("C-2" digit-argument)
         ("C-3" digit-argument)
         ("C-4" digit-argument)
         ("C-5" digit-argument)
         ("C-6" digit-argument)
         ("C-7" digit-argument)
         ("C-8" digit-argument)
         ("C-9" digit-argument)

         (">" evil-window-increase-width)
         ("<" evil-window-decrease-width)
         ("+" evil-window-increase-height)
         ("-" evil-window-decrease-height)
         ("_" evil-window-decrease-height)

         ("u" winner-undo "undo")
         ("r" winner-redo "redo" :exit t)

         ("w" eyebrowse-hydra/body "workgroups" :exit t)

         ("m" window-zen+ "zen" :exit t)
         ("q" nil "quit" :exit t)
         ("<escape>" nil "quit" :exit t)) ;; prevent evil-escape

       (provide '+hydra-winman)
     #+end_src

**** Indent
     :PROPERTIES:
     :header-args+: :tangle (lisp! "+hydra-indent.el")
     :END:

     #+begin_src emacs-lisp :tangle (lisp! "+pkg-hydra.el")
       (use-package +hydra-indent
         :commands hydra-indent/body
         :general
         ("C-x TAB" 'indent-hydra/body)
         :leader
         (:prefix leader-hydra-leader-prefix+
          "TAB" '(indent-hydra/body :wk "winman-hydra"))
         ("i TAB" '(indent-hydra/body :wk "winman-hydra")))
     #+end_src

     #+BEGIN_SRC emacs-lisp
       (require 'hydra)
       (require 'evil)
       (require 'general)
       (require '+lib-misc)

       (defmacro indent-hydra--keep-visual-state-active+ (&rest body)
         "when body is invoked with evil-visual, restore the state after body"
         `(let ((visual-active (evil-visual-state-p)))
            ,@body
            (when visual-active
              (evil-normal-state)
              (evil-visual-restore))))
       (put 'indent-hydra--keep-visual-state-active+ 'elisp-indent-function 'defun)

       (defun indent-hydra--get-region+ ()
         "return the active region, or the current lines region"
         (if (region-active-p)
             (list (region-beginning) (region-end))
           (list (line-beginning-position) (line-end-position))))

       (defun indent-hydra--join-args-to-region+ (&rest args)
         (let ((region (indent-hydra--get-region+)))
           (apply 'list
                  (car   region)
                  (nth 1 region)
                  args)))

       (defun indent-hydra-set-column+ (&optional column)
         "Set indentation of line or region such that it reaches COLUMN
       when a region is active, function works by moving from the start of the
       region downwards until a non-empty (whitespace does not count) line is
       encountered, and then calculates the offset required to make that lines
       indentation the same as the COLUMN and then applies that offset to every
       line in the region.

       Negative values for COLUMN will be coerced to be +ve and unless called
       interactively, COLUMN will default to 1 when not specified."
         (interactive "P")
         (or column (setq column
                          (if (not (called-interactively-p 'interactive))
                              +1
                            (read-number "column: "))))

         (and (< column 0) (setq column 0)) ;; ensure +ve

         (save-excursion
           (let* ((region-boundary (indent-hydra--get-region+))
                  (start           (car   region-boundary))
                  (end             (nth 1 region-boundary))
                  indent-diff)
             (goto-char start) ;; start of indenting section

             (while (and (<= start end)
                         (line-empty-p+)
                         (not (eobp)))
               ;; move forward until indent-able line encountered
               (forward-line))

             (unless (or (eobp)
                         (> start end))
               (setq indent-diff (- column (current-indentation)))
               (indent-rigidly start end indent-diff)))))

       (defvar indent-hydra--ascii-art
         "
       "
         "cool ascii art, which can't be in docstring because it has ___")

       (with-no-warnings
         (defhydra indent-hydra (:foreign-keys run :hint nil)
           "
        ^ ^    ^ ^    ^ ^ |  ^ ^         |       dMP dMMMMb  dMMMMb  dMMMMMP dMMMMb dMMMMMMP .aMMMb dMMMMMMP dMP .aMMMb  dMMMMb
        _H_    ^ ^    ^ ^ | [_q_]: quit  |      amr dMP dMP dMP VMP dMP     dMP dMP   dMP   dMP\"dMP   dMP   amr dMP\"dMP dMP dMP
        _h_   _RET_   _l_ | [_s_]: break |     dMP dMP dMP dMP dMP dMMMP   dMP dMP   dMP   dMMMMMP   dMP   dMP dMP dMP dMP dMP
        ^ ^    ^ ^    _L_ |  ^ ^         |    dMP dMP dMP dMP.aMP dMP     dMP dMP   dMP   dMP dMP   dMP   dMP dMP.aMP dMP dMP
        ^ ^    ^ ^    ^ ^ |  ^ ^         |   dMP dMP dMP dMMMMP\" dMMMMMP dMP dMP   dMP   dMP dMP   dMP   dMP  VMMMP\" dMP dMP
       "
           ("h" (indent-hydra--keep-visual-state-active+
                 (apply 'indent-rigidly
                        (indent-hydra--join-args-to-region+
                         (or (and current-prefix-arg
                                  (- current-prefix-arg))
                             -1)))))
           ("l" (indent-hydra--keep-visual-state-active+
                 (apply 'indent-rigidly
                        (indent-hydra--join-args-to-region+
                         (or current-prefix-arg +1)))))
           ("H" (indent-hydra--keep-visual-state-active+
                 (apply 'evil-shift-left
                        (indent-hydra--join-args-to-region+
                         (or current-prefix-arg +1)))))
           ("L" (indent-hydra--keep-visual-state-active+
                 (apply 'evil-shift-right
                        (indent-hydra--join-args-to-region+
                         (or current-prefix-arg +1)))))
           ("s"   (indent-hydra--keep-visual-state-active+
                   (call-interactively 'split-line)))
           ("RET" (indent-hydra--keep-visual-state-active+
                   (call-interactively 'indent-hydra-set-column+)))

           ("q" nil :exit t)))

       (general-define-key
         :keymaps 'indent-hydra/keymap
         ;; That's scroll-up silly?
         "C-u" nil
         ">" 'indent-hydra/lambda-L
         "<" 'indent-hydra/lambda-H)

       (provide '+hydra-indent)
     #+END_SRC

*** Appendix
    #+BEGIN_SRC emacs-lisp
      (provide '+pkg-hydra)
    #+END_SRC

** Evil
   :PROPERTIES:
   :header-args+: :tangle (lisp! "+pkg-evil.el")
   :END:

   Come to the dark side, we have cookies... :)

   #+begin_src emacs-lisp :tangle yes
     (require '+pkg-evil)
   #+end_src

   #+begin_src emacs-lisp
     (use-package evil
       :straight t
       :autoload (evil-command-properties
                  evil-ex-define-cmd
                  evil-get-command-property
                  evil-operator-range
                  evil-set-command-properties
                  evil-set-command-property
                  evil-set-initial-state
                  evil-visual-rotate
                  evil-visual-select
                  evil-visual-state-p
                  evil-visual-type))
   #+end_src

*** Evil Commands
    :PROPERTIES:
    :header-args+: :tangle (lisp! "+evil-commands.el")
    :END:

    #+begin_src emacs-lisp :tangle (lisp! "+pkg-evil.el")
      (use-package +evil-commands
        :config
        (evil-ex-define-cmd "rev[erse]" 'evil-reverse)

        :autoload with-evil-adjust-to-eol+

        :leader
        ("xc" 'evil-capitalize+)

        :general
        ("C-/" 'toggle-comment-at-point+
         "C-S-/" 'toggle-comment-at-point-alt+)
        (:states 'normal
         "gC" 'evil-capitalize+
         "gc" 'evil-toggle-comment+)
        (:states 'normal
         "K" 'evil-join-backwards+)
        (:states '(normal insert)
         "C-k"   'evil-join-backwards+
         "C-M-k" 'evil-join-backwards+)
        (:states '(insert replace)
         "<S-escape>" 'evil-shift-normal-state+)

        (:states 'visual
         "gy" 'evil-narrow-yank+)

        (:states 'motion
         "g3" 'evil-ansi-render+)

        (:states '(normal visual insert)
         [remap eval-print-last-sexp]   'evil-adjust-eval-print-last-sexp+
         [remap eval-replace-last-sexp] 'evil-adjust-eval-replace-last-sexp+))
    #+end_src

    #+begin_src emacs-lisp
      (require 'evil)
    #+end_src

    #+begin_src emacs-lisp
      ;; [[https://raw.githubusercontent.com/troyp/evil-adjust/master/evil-adjust.el][evil-adjust]]
      (defmacro with-evil-adjust-to-eol+ (&rest body)
        `(let ((-last-evil-state evil-state)
               (evil-echo-state nil))
           (when (member evil-state '(normal visual))
             (evil-append 1)) ; switch to insert state
           (condition-case err
               (progn ,@body)
             (error
              (evil-change-state -last-evil-state)
              (signal (car err) (cdr err))))
           (evil-change-state -last-evil-state)))
      (put 'with-evil-adjust-to-eol+ 'lisp-indent-function 'defun)
    #+end_src

    #+begin_src emacs-lisp
      (evil-define-operator evil-capitalize+ (beg end)
        (capitalize-region beg end))

      (defun evil-shift-normal-state+ (&optional arg)
        "Return to normal state while also removing
      any trailing whitespace from the current line"
        (interactive "P")
        (delete-trailing-whitespace (line-beginning-position)
                                    (line-end-position))
        (evil-normal-state arg))

      (evil-define-operator evil-narrow-yank+ (beg end type register yank-handler)
        "`evil-yank' except block yanks are yanked as their own lines.
      evil by default yanks them such that you can compose them onto other lines.
      this isn't always desirable (especially when you want to filter a region onto
      it's own lines, thus this method satifies that requirement.

      eg:
      `evil-yank' cfj then `evil-paste-after'.
        ab|c|   >   abc|c
        de|f|   >   deff
        gh|j|   >   ghjj

      `evil-narrow-yank' cfj then `evil-paste-after'.
        ab|c|   >   abc
        de|f|   >   |c
        gh|i|   >   f
                >   j
                >   def
                >   ghj
      "
        (interactive "<R><x><y>")
        (evil-visual-restore)
        (if (eq type 'block)
            (progn
              (evil-yank-rectangle beg end ?\" yank-handler)

              (with-temp-buffer
                (evil-paste-before nil ?\")
                (evil-yank (point-min) (point-max) 'line register yank-handler)))
          (evil-yank beg end type register yank-handler)))

      (defun toggle-comment-at-point+ (start end)
        "toggle comment on line or region
      pass a prefix argument to bulk toggle across multiple lines.
      This function will always comment the line your point is on,

      prefix behaviour:
      | prefix range | behaviour                                        |
      |--------------+--------------------------------------------------|
      | 0            | current line only                                |
      | >1           | current line and upto prefix-1 lines after point |
      | <1           | current line and upto prefix lines before point  |

      the behaviour is mapped to exactly replicate the vim dd command."
        (interactive (let ((prefix current-prefix-arg))
                       (if (region-active-p)
                           ;; always use region when region available
                           (list (region-beginning) (region-end))
                         (if (or (not prefix)
                                 (listp prefix) ;; regular prefix
                                 (zerop prefix))
                             ;; no prefix, comment current line only
                             (list (line-beginning-position) (line-end-position))
                           ;; prefix given, use it to determine comment region
                           (let* ((prefix-positive (> prefix 0))
                                  (current-pos (if prefix-positive
                                                   (line-beginning-position)
                                                 (line-end-position))))
                             (save-excursion
                               (if prefix-positive
                                   (progn
                                     (evil-next-line (- prefix 1))
                                     (list current-pos (line-end-position)))
                                 (evil-next-line prefix)
                                 (list (line-beginning-position) current-pos))))))))
        (comment-or-uncomment-region start end))

      (defun toggle-comment-at-point-alt+ ()
        "variant of toggle-comment-at-point which conforms to relative line numbers

      prefix behaviour:
      | prefix range | behaviour                                         |
      |--------------+---------------------------------------------------|
      | 0            | current line only                                 |
      | >1           | current line and upto prefix-1 lines after point  |
      | <1           | current line and upto prefix+1 lines before point |
      "
        (interactive)
        (let ((current-prefix-arg (and current-prefix-arg
                                       (cond
                                        ((>= current-prefix-arg 1) (1+ current-prefix-arg))
                                        ;; ((<  current-prefix-arg 0) (1- current-prefix-arg))
                                        (t current-prefix-arg)))))
          (call-interactively 'toggle-comment-at-point)))

      (evil-define-operator evil-toggle-comment+ (beg end)
        :type        line
        :repeat      t
        :move-point  nil
        :keep-visual nil
        "run `toggle-comment-at-point+' using evil motion."
        (toggle-comment-at-point+ beg end))

      (defun evil-adjust-eval-print-last-sexp+ ()
        (interactive)
        (save-excursion
          (with-evil-adjust-to-eol+
            (funcall-interactively 'eval-print-last-sexp)
            (message nil))))

      (defun evil-adjust-eval-replace-last-sexp+ ()
        (interactive)
        (with-evil-adjust-to-eol+
          (funcall-interactively 'eval-replace-last-sexp)
          (message nil)))

      (evil-define-operator evil-reverse+ (beg end)
        :type line
        :repeat t
        "evil command to reverse lines over range."
        (reverse-region beg end))

      (eval-and-compile (autoload 'ansi-color-apply-on-region "ansi-color"))
      (evil-define-operator evil-ansi-render+ (beg end)
        :repeat t
        "render ansi-color escape sequences between BEG and END."
        ;; source [[https://stackoverflow.com/questions/23378271/how-do-i-display-ansi-color-codes-in-emacs-for-any-mode][here]].
        (let ((inhibit-read-only (or inhibit-read-only
                                     (and buffer-read-only
                                          (y-or-n-p "Buffer is read only, ignore: ")))))
          (barf-if-buffer-read-only)
          (ansi-color-apply-on-region beg end)))

      ;; TODO: Save directly to evil registers, not emacs registers.
      (evil-define-command evil-save-window-config+ (reg)
        (interactive "<x>")
        (window-configuration-to-register
         (or reg
             (register-read-with-preview
                          "Save window config to register: "))))

      (require '+lib-misc)

      (defun evil-join-backwards+ (&optional prefix)
        "Same as join line, except joins line immediately before point."
        (interactive "p")
        (let ((start nil)
              (end   nil))
          (if (evil-visual-state-p)
              (let ((range (evil-visual-range)))
                (setq start (nth 0 range))
                (setq end   (nth 1 range)))
            ;; not visual, calculate ranges
            (setq end (point))
            (save-excursion
              (forward-line (- (abs prefix)))
              (setq start (point))))
          ;; remove excursion block if you wan't to
          ;; reallign point to start of line on join
          (save-excursion
            (if (line-empty-p+ start)
                ;; when joining onto an empty line
                ;; maintain leading whitespace
                (evil-join-whitespace start end)
              ;; otherwise trim to single space
              (evil-join start end)))))
    #+end_src

    #+begin_src emacs-lisp
      (provide '+evil-commands)
    #+end_src

*** Evil Matchit
    A better jump-to-matching element function for Emacs evil.

    #+begin_src emacs-lisp
      (use-package evil-matchit
        :straight t
        :hook (evil-mode . global-evil-matchit-mode)
        :preface
        (defun evilmi-customize-keybinding ()
          (general-define-key
           ;; WARN binding to motion map breaks things.
           :states  '(normal visual)
           :keymaps 'evil-matchit-mode-map
           "%" 'evilmi-jump-items)))
    #+end_src

    #+begin_src emacs-lisp
      (use-package evil-matchit-org
        :straight evil-matchit
        :config
        (push '(("begin_center") () ( "end_center") "MONOGAMY")
              evilmi-org-match-tags))
    #+end_src

*** Evil Surround
    #+begin_src emacs-lisp
      (use-package evil-surround
        :straight t
        :hook (evil-mode . global-evil-surround-mode)
        :init
        (setq-default evil-surround-pairs-alist
                      '((?\( . ("(" . ")"))
                        (?\[ . ("[" . "]"))
                        (?\{ . ("{" . "}"))

                        (?\) . ("( " . " )"))
                        (?\] . ("[ " . " ]"))
                        (?\} . ("{ " . " }"))

                        (?# . ("#{" . "}")) ; ruby string interpolation
                        (?b . ("(" . ")"))
                        (?B . ("{" . "}"))
                        (?> . ("<" . ">"))
                        (?t . evil-surround-read-tag)
                        (?< . evil-surround-read-tag)
                        (?f . evil-surround-function)))

        :general
        ;; only allow surrounding via selections or explicitly using gS
        (:states 'visual "s"  'evil-surround-region)
        (:states 'motion "gs" 'evil-surround-edit)
        (:keymaps 'evil-surround-mode-map
         "$" nil))
    #+end_src

*** Evil Terminal Cursor
    #+begin_src emacs-lisp
      (use-package evil-terminal-cursor-changer
        :straight t
        :custom
        (evil-motion-state-cursor   'box)  ; ‚ñà
        (evil-visual-state-cursor   'box)  ; ‚ñà
        (evil-normal-state-cursor   'box)  ; ‚ñà
        (evil-insert-state-cursor   'bar)  ; ‚é∏
        (evil-emacs-state-cursor    'box)  ; ‚ñà
        (evil-operator-state-cursor 'hbar) ; _

        :hook (tty-setup . evil-terminal-cursor-changer-activate+)
        :autoload (evil-terminal-cursor-changer-activate+
                   etcc--evil-set-cursor
                   etcc--evil-set-cursor-color)
        :config
        (advice-add 'etcc--evil-set-cursor :filter-args #'ignore)
        (advice-add 'etcc--evil-set-cursor-color :filter-args
                    (lambda (color &rest _)
                      (list color)))

        ;; Latest version of cursor changer no longer depends on evil, but
        ;; this change means it cannot process evil-operator-state-cursor
        ;; so I've reverted to the prior implementation.
        (defun evil-terminal-cursor-changer-activate+ ()
          (when etcc-use-blink
            (add-hook 'blink-cursor-mode-hook #'etcc--evil-set-cursor))
          (advice-add 'evil-set-cursor :after #'etcc--evil-set-cursor)
          (advice-add 'evil-set-cursor-color :after #'etcc--evil-set-cursor-color))

        :config
        (advice-add 'etcc--make-tmux-seq :override #'identity))
    #+end_src

*** Evil Numbers
    #+BEGIN_SRC emacs-lisp
      (use-package evil-numbers
        :straight t
        :general
        (:states 'normal
         "C-S-a" 'evil-numbers/inc-at-pt
         "C-S-x" 'evil-numbers/dec-at-pt))
    #+END_SRC

*** Evil Snipe
    Let's you start a motion to some string matching some series of input characters.
    Think evil-search... but to a fixed number of characters, which can be raised at
    invocation.

    #+BEGIN_SRC emacs-lisp
      (use-package evil-snipe
        :straight t
        :hook ((magit-status-mode . turn-off-evil-snipe-mode)
               (calc-mode . turn-off-evil-snipe-mode)
               (evil-mode . evil-snipe-mode))
        :diminish
        evil-snipe-mode
        evil-snipe-local-mode

        :init
        (defvar evil-snipe-local-mode-map (make-sparse-keymap))                       ; Suppress creation because I can't seem to override it :?

        :custom
        (evil-snipe-scope 'buffer)                                                    ; how far can a snipe take place
        (evil-snipe-repeat-scope 'buffer)                                             ; how far repeating previous snipe can take place.
        (evil-snipe-enable-highlight nil)                                             ; don't highlight after jump
        (evil-snipe-repeat-keys nil)                                                  ; sniping after a snipe, repeats the last snipe
        (evil-snipe-enable-incremental-highlight t)                                   ; do highlight matching snipe locations
        (evil-snipe-skip-leading-whitespace t)                                        ; whitespace at start of line is ignored
        (evil-snipe-smart-case t)                                                     ; case sensitive until it's not, like ivy
        (evil-snipe-tab-increment t)                                                  ; hit tab to raise amount of snipes left
        (evil-snipe-override-evil-repeat-keys nil)                                    ; don't replace ; and , with evil keys
        (evil-snipe-auto-disable-substitute nil)                                      ; keep my substitute key available

        :preface
        (defvar evil-snipe-find-scopes-to-line+ nil
          "When true, evil-snipe-{f,F,t,T} (I.E. for single finds) only extends to EOL.")

        :preface
        (defmacro evil-snipe-with-normalised-settings+ (&rest body)
          `(let ((evil-snipe-enable-highlight nil)                           ; don't highlight jump matches after jump
                 (evil-snipe-enable-incremental-highlight nil)               ; don't highlight jump matches while searching
                 (evil-snipe-tab-increment nil)                              ; disable tab to raise snipe count
                 (evil-snipe-show-prompt nil)                                ; don't show prompt, why bother? you can't increment it.
                 (evil-snipe-smart-case nil)                                 ; fJ != fj
                 (evil-snipe-skip-leading-whitespace nil)
                 (evil-snipe-scope (if evil-snipe-find-scopes-to-line+
                                       'line
                                     evil-snipe-scope)))
             ,@body))

        :autoload (evil-snipe--normalise-single-snipes+
                   evil-snipe--normalise-single-snipes-wrapper+)
        :config
        (defun evil-snipe--normalise-single-snipes+ (func &rest args)
          "Normalise snipes with count 1 to match `evil-find-char'.
      don't want highlighting, or a prompt or other feature enhancements.
      just simple, jump to char.

      NOTE this function updates settings during the input reading phase
      only; which is taken care of in the interactive section prior to
      method body invocation."
          (if (eq evil-snipe--match-count 1)
              (evil-snipe-with-normalised-settings+
                (apply func args))
            (apply func args)))

        (defun evil-snipe--normalise-single-snipes-wrapper+ (func &rest args)
          "Specify normalisation for the body of the given function."
          (evil-snipe-with-normalised-settings+ (apply func args)))

        (advice-add 'evil-snipe--collect-keys :around #'evil-snipe--normalise-single-snipes+)
        (advice-add 'evil-snipe-f :around #'evil-snipe--normalise-single-snipes-wrapper+)
        (advice-add 'evil-snipe-F :around #'evil-snipe--normalise-single-snipes-wrapper+)
        (advice-add 'evil-snipe-t :around #'evil-snipe--normalise-single-snipes-wrapper+)
        (advice-add 'evil-snipe-T :around #'evil-snipe--normalise-single-snipes-wrapper+)

        ;; I don't need it, I've got my own keys bound to do the same thing :)
        (advice-add 'evil-snipe--transient-map :override #'ignore)

        :general
        (:keymaps 'evil-snipe-mode-map
         :states  '(normal motion visual)
         ;; S is inclusive, X is exclusive.
         "gT" 'evil-snipe-X
         "gt" 'evil-snipe-x
         "gF" 'evil-snipe-S
         "gf" 'evil-snipe-s
         "f"  'evil-snipe-f
         "F"  'evil-snipe-F
         "t"  'evil-snipe-t
         "T"  'evil-snipe-T
         ";"  'evil-snipe-repeat
         "g;" 'evil-snipe-repeat-reverse))
    #+END_SRC

*** Evil Exchange                                                  :disabled:
    Cut a region into a kill buffer, and then swap it with another region somewhere else.

    #+BEGIN_SRC emacs-lisp :tangle no
      (use-package evil-exchange
        :straight t
        :general
        (:states 'normal
         "gx" 'evil-exchange
         "gX" 'evil-exchange-cancel))
    #+END_SRC

*** Evil Multiedit
    #+BEGIN_SRC emacs-lisp
      (use-package iedit
        :straight t
        :custom
        (iedit-toggle-key-default nil))

      (use-package evil-multiedit
        :straight t
        :after evil
        :commands (evil-multiedit
                   evil-multiedit-all)
        :init
        (evil-ex-define-cmd "ie[dit]" 'evil-multiedit-ex-match)

        :autoload evil-multiedit--multiedit+
        :config
        (defun evil-multiedit--multiedit+ (beg end)
          (evil-visual-select beg
                              (max 0 (- end 1)))
          (evil-multiedit-match-and-next))

        (evil-define-operator evil-multiedit+ (beg end)
          :repeat nil
          (if (evil-get-command-property 'evil-multiedit :move-point)
              (save-excursion
                (evil-multiedit--multiedit+ beg end))
            (evil-multiedit--multiedit+ beg end)))

        :autoload evil-multiedit--multiedit-all+
        :config
        (defun evil-multiedit--multiedit-all+ (beg end)
          (evil-visual-select beg
                              (max 0 (- end 1)))
          (evil-multiedit-match-all))

        (evil-define-operator evil-multiedit-all+ (beg end)
          :repeat nil
          (if (evil-get-command-property 'evil-multiedit-all :move-point)
              (save-excursion
                (evil-multiedit--multiedit-all+ beg end))
            (evil-multiedit--multiedit-all+ beg end)))

        :general
        (:states 'normal "gi" nil)                                                    ; Suppress default iedit binding
        (:states '(motion multiedit)
         "gi" 'evil-multiedit+
         "g*" 'evil-multiedit-all+
         "gI" 'evil-multiedit-restore)
        (:states 'multiedit
         "g*" 'evil-multiedit-match-all
         "gh" 'evil-multiedit-prev
         "gl" 'evil-multiedit-next
         "gj" 'evil-multiedit-match-and-next
         "gk" 'evil-multiedit-match-and-prev)
        ;; (:states 'visual
        ;;  "RET" 'evil-multiedit-toggle-or-restrict-region)
        (:states 'multiedit
         "G"  nil "gg" nil))
    #+END_SRC

**** Evil Multiedit Hydra
     #+begin_src emacs-lisp
       (require '+pkg-hydra)

       (use-package evil-multiedit
         :general
         (:states 'multiedit
          "g." 'evil-multiedit-hydra/body)

         :hydra
         (evil-multiedit-hydra ()
          ("k" evil-multiedit-next "next")
          ("j" evil-multiedit-prev "prev")
          ("l" evil-multiedit-match-and-next "mark-next")
          ("h" evil-multiedit-match-and-prev "mark-prev")
          ("*" evil-multiedit-match-all "mark-all")

          ("q" nil nil)
          ("<escape>" nil nil)))

     #+end_src

*** Evil Traces
    Indicators for various ex commands.

    #+BEGIN_SRC emacs-lisp
       (use-package evil-traces
         :straight t
         :diminish
         :hook (evil-mode . evil-traces-mode))
    #+END_SRC

*** Evil Args
    #+BEGIN_SRC emacs-lisp
      (use-package evil-args
        :straight t

        :preface
        (defun evil-args-adjust-for-elisp+ ()
          (setq evil-args-delimiters '(" ")))
        :hook ((emacs-lisp-mode       . evil-args-adjust-for-elisp+)
               (lisp-interaction-mode . evil-args-adjust-for-elisp+))

        :leader
        ("j[" 'evil-backward-arg
         "j]" 'evil-forward-arg
         "ja" 'evil-jump-out-args)

        :general
        (:keymaps '(evil-inner-text-objects-map
                    evil-outer-text-objects-map)
         "a" 'evil-inner-arg)
        (:states 'motion
         "[u" 'evil-jump-out-args
         "]u" 'evil-jump-out-args

         "[h" 'evil-backward-arg
         "]h" 'evil-backward-arg

         "[l" 'evil-forward-arg
         "]l" 'evil-forward-arg

         "[a" 'evil-backward-arg
         "]a" 'evil-forward-arg))
    #+END_SRC

*** Evil EasyMotion
    Avy inspired evil motions.

    #+BEGIN_SRC emacs-lisp
      (use-package evil-easymotion
        :straight t
        :leader
        (:prefix "jh"
         ""   '(:ignore t :wk "avy-motion")
         "w"  'evilem-motion-forward-word-begin
         "W"  'evilem-motion-forward-WORD-begin
         "e"  'evilem-motion-forward-word-end
         "E"  'evilem-motion-forward-WORD-end
         "b"  'evilem-motion-backward-word-begin
         "B"  'evilem-motion-backward-WORD-begin
         ;; "ge" 'evilem-motion-backward-word-end
         ;; "gE" 'evilem-motion-backward-WORD-end
         "j"  'evilem-motion-next-line
         "k"  'evilem-motion-previous-line
         "J"  'evilem-motion-next-visual-line
         "K"  'evilem-motion-previous-visual-line
         "t"  'evilem-motion-find-char-to
         "T"  'evilem-motion-find-char-to-backward
         "f"  'evilem-motion-find-char
         "F"  'evilem-motion-find-char-backward
         "n"  'evilem-motion-search-next
         "p"  'evilem-motion-search-previous
         "*"  'evilem-motion-search-word-forward
         "#"  'evilem-motion-search-word-backward
         "-"  'evilem-motion-previous-line-first-non-blank
         "+"  'evilem-motion-next-line-first-non-blank))
    #+END_SRC

*** Evil Vimish Fold                                               :optional:
    Folding like vim

    #+BEGIN_SRC emacs-lisp :tangle (package-lisp! +pkg-evil vimish-fold)
       (use-package evil-vimish-fold
         :straight t
         ;; :hook (after-init . vimish-fold-global-mode)
         :custom
         (evil-vimish-fold-lighter "z")
         (vimish-fold-allow-nested t)
         (vimish-fold-dir (state! "vimish-fold/"))
         (vimish-fold-persist-on-saving nil "Prefer using marks.")
         :hook (vimish-fold-mode . vimish-fold-refold-all)

         :general
         (:keymaps 'evil-vimish-fold-mode-map
          :states '(normal motion)
          "zA" 'vimish-fold-toggle-recursively
          "zC" 'vimish-fold-refold-all
          "zF" 'vimish-fold-refold-all
          "zd" 'evil-vimish-fold/delete
          "zD" 'evil-vimish-fold/delete-all
          "zO" 'vimish-fold-unfold-all))
    #+END_SRC

*** Evil
    #+begin_src emacs-lisp
      (use-package evil
        :demand t
        :commands evil-mode
        :config (evil-mode +1)

        :custom
        (evil-cross-lines t)
        (evil-start-of-line nil)
        (evil-default-state 'motion)
        (evil-want-C-i-jump nil)
        (evil-want-C-u-scroll t)
        (evil-want-visual-char-semi-exclusive t)
        (evil-toggle-key "M-z")
        (evil--jumps-buffer-targets
         (rx "*"
             (or "new"
                 "Help"
                 "scratch"
                 (and "Org src " (zero-or-more any) "[ " (zero-or-more any) " ]"))
             "*")
         "see https://emacs.stackexchange.com/questions/42060/add-dired-buffers-to-evil-jump-list")

        :preface
        (use-package evil-search
          :straight evil
          :autoload evil-select-search-module
          :config
          (evil-select-search-module 'evil-search-module 'evil-search))

        :config
        (with-no-warnings
          (defvaralias 'evil-ex-search-history 'regexp-search-ring))

        :config
        (evil-set-initial-state 'prog-mode 'normal)
        (evil-set-initial-state 'text-mode 'normal)
        (evil-set-initial-state 'conf-mode 'normal)

        :config
        ;; From [[https://github.com/hlissner/doom-emacs/blob/develop/modules/editor/evil/config.el#L137][doom]].
        (advice-add 'evil-global-marker-p :before-until
                    (defun evil--make-numbered-markers-global+ (char)
                      (and (>= char ?2) (<= char ?9))))

        :commands (evil-write evil-write-all)
        :config
        (evil-ex-define-cmd "W[RITE]" 'evil-write)

        (evil-ex-define-cmd "Wa[ll]"  'evil-write-all)
        (evil-ex-define-cmd "WA[LL]"  'evil-write-all)

        (evil-ex-define-cmd "wk[ill]" 'write-kill-buffer+)
        (evil-ex-define-cmd "Wk[ill]" 'write-kill-buffer+)
        (evil-ex-define-cmd "WK[ILL]" 'write-kill-buffer+)

        (evil-ex-define-cmd "wb[ackup]" 'write-backup+)
        (evil-ex-define-cmd "Wb[ackup]" 'write-backup+)
        (evil-ex-define-cmd "WB[ACKUP]" 'write-backup+)

        (evil-ex-define-cmd "a[s]ave" 'write-autosave+)
        (evil-ex-define-cmd "A[s]ave" 'write-autosave+)
        (evil-ex-define-cmd "A[S]AVE" 'write-autosave+)

        (evil-ex-define-cmd "buffers" 'ibuffer)

        :lazy-leader
        ("jE" 'evil-goto-definition
         "id" 'evil-insert-digraph
         "sc" '(evil-ex-nohighlight :wk "search-noh")
         "xu" 'evil-upcase
         "xd" 'evil-downcase)

        :general
        ("M-g" 'evil-change-to-initial-state)
        (:keymaps 'minibuffer-local-map
         "C-r" 'evil-paste-from-register)

        (:states '(motion insert)
         "C-a" 'beginning-of-line
         "C-e" 'end-of-line)

        (:states '(insert emacs multiedit)
         "C-o" 'evil-copy-from-above
         "M-o" 'evil-copy-from-below
         "C-c C-o" 'evil-execute-in-normal-state
         "C-." 'evil-execute-in-normal-state)

        ("C->" 'evil-shift-right-line
         "C-<" 'evil-shift-left-line)

        (:states 'normal
         "gU" nil
         "gq" nil
         "zf" 'evil-close-fold
         "gu" 'evil-upcase
         "gd" 'evil-downcase
         "g@" 'what-cursor-position
         "ga" 'evil-fill-and-move
         "g-" 'evil-indent)

        (:states '(normal motion)
         ;; Y = yy is easy   to press
         ;; Y = y$ is harder to press
         "Y" (general-simulate-key "y$"))

        (:states 'insert
         "M-k" nil
         "C-d" nil
         "C-t" nil
         "C-@" nil

         "<tab>"           'indent-for-tab-command
         "TAB"             "<tab>"
         "C-c TAB"         'indent-relative
         "<S-backspace>"   'evil-delete-char

         "C-y" 'yank
         "M-y" 'yank-unindented

         ;; (kbd "C-M-k") 'evil-insert-digraph
         "C-l" 'forward-char
         "C-h" 'backward-char
         "C-n" 'evil-next-line
         "C-p" 'evil-previous-line
         "C-w" 'backward-kill-word)

        (:states 'visual
         "C-y" 'evil-paste-after)

        (:states 'motion
         "C-o" 'evil-jump-backward
         "M-o" 'evil-jump-forward
         "C-b" 'evil-scroll-line-up
         "C-f" 'evil-scroll-line-down
         "\""  'evil-use-register
         "zn"  'evil-scroll-column-right
         "zN"  'evil-scroll-right
         "zp"  'evil-scroll-column-left
         "zP"  'evil-scroll-left

         "gN" nil
         "gn" 'evil-next-match
         "gp" 'evil-previous-match

         ;; NOTE: These will probably always be overridden
         "gj" 'evil-next-visual-line
         "gk" 'evil-previous-visual-line
         "gq" 'quit-window
         "g=" 'count-words
         "g;" 'evil-repeat-find-char-reverse
         "m"  'evil-set-marker
         "-"  'negative-argument
         "q"  'quit-window)

        (:states 'motion
         :override t
         "gr" 'revert-buffer
         "gR" 'read-only-mode
         "gz" 'recenter-top-bottom)

        (:keymaps 'evil-command-line-map
         "C-a" 'move-beginning-of-line
         "C-e" 'move-end-of-line
         "C-M-q" 'quit-window)

        (:keymaps 'emacs-window-map+
         [remap window-configuration-to-register] 'evil-save-window-config+
         "+" 'evil-window-increase-height
         "-" 'evil-window-decrease-height
         "<" 'evil-window-decrease-width
         ">" 'evil-window-increase-width
         "=" 'balance-windows
         "-" 'evil-window-set-width
         "|" 'evil-window-set-height

         "C-1" 'evil-window-top-left
         "C-0" 'evil-window-bottom-right

         ;; ("u" . evil-window-rotate-upwards)
         ;; ("i" . evil-window-rotate-downwards)
         "C-q" 'evil-window-mru ;; last buffer, new window

         ;; TODO maximise buffer
         "C-M-h" 'evil-window-move-far-left
         "C-M-j" 'evil-window-move-far-down
         "C-M-k" 'evil-window-move-far-up
         "C-M-l" 'evil-window-move-far-right

         ;; NOTE bindings with control variants
         "n"   'evil-window-next
         "C-n" 'evil-window-next
         "p"   'evil-window-prev
         "C-p" 'evil-window-prev
         "s"   'evil-window-split
         "M-s" 'evil-window-split
         "v"   'evil-window-vsplit
         "M-v" 'evil-window-vsplit
         "S"   'split-window-below-and-focus+
         "C-s" 'split-window-below-and-focus+
         "V"   'split-window-right-and-focus+
         "C-v" 'split-window-right-and-focus+
         "d"   'evil-window-delete
         "C-d" 'evil-window-delete
         "h"   'evil-window-left
         ;; "C-h" 'evil-window-left
         "j"   'evil-window-down
         ;; "C-j" 'evil-window-down
         "k"   'evil-window-up
         ;; "C-k" 'evil-window-up
         "l"   'evil-window-right
         ;; "C-l" 'evil-window-right
         "c"   'evil-window-new
         "C-c" 'evil-window-new))
    #+end_src

*** Appendix
    #+begin_src emacs-lisp
      (provide '+pkg-evil)
    #+end_src

** All the Icons
   :PROPERTIES:
   :header-args+: :tangle (lisp! "+pkg-all-the-icons.el")
   :END:

   #+BEGIN_SRC emacs-lisp :tangle yes
     (require '+pkg-all-the-icons)
   #+END_SRC

   Provides some fonts for rendering graphical icons within Emacs; alongside a set
   of functions to make retrieving appropriate functions for appropriate purposes.

*** All the Icons
    #+BEGIN_SRC emacs-lisp
      (use-package all-the-icons
        :straight t
        :leader ("ii" 'all-the-icons-insert)
        :autoload (all-the-icons-auto-mode-match?
                   all-the-icons-icon-for-dir
                   all-the-icons-icon-for-url
                   all-the-icons-icon-for-mode
                   all-the-icons-icon-for-file
                   all-the-icons--data-name
                   all-the-icons--function-name
                   all-the-icons-alltheicon
                   all-the-icons-fileicon
                   all-the-icons-faicon
                   all-the-icons-octicon
                   all-the-icons-wicon
                   all-the-icons-material)
        :custom
        (inhibit-compacting-font-caches t)

        :preface
        (defsubst all-the-icons-pad+ (icon &optional suffix)
          (concat icon (or suffix " ")))

        (defun all-the-icons-pad-on-tty-advice+ (value &optional suffix)
          ":filter-return advice for all-the-icons functions which appends
      an extra space to the icon when displaying icons on the tty."
          (if (and value
                   (not (string-empty-p value))
                   (not (display-graphic-p)))
              (all-the-icons-pad+ value suffix)
            value))

        :init
        (defconst +icon-nerd-to-all-the-icons '((mdi . material)
                                                (fa . faicon)
                                                (oct . octicon)
                                                (weather . wicon))
          "Family translations between `nerd-fonts' and `all-the-icons'.")

        (defun all-the-icons-prefer-nerd-fonts+ (func &rest args)
          ":around advice to prefer nerd-fonts over all-the-icons fonts."
          (eval
           `(cl-letf ,(cl-loop for (nerd-icon . ati-icon) in +icon-nerd-to-all-the-icons
                               append `(((symbol-function ',(all-the-icons--function-name ati-icon))
                                         (symbol-function ',(all-the-icons--function-name (intern (concat "nerd-" (symbol-name nerd-icon))))))))
              (apply ',func ',args))))

        (defun all-the-icons-pad-families-on-tty-advice+ (func &rest args)
          ":around advice ensuring all `all-the-icons-%s' calls are padded on terminals.
      This isn't the most performant implementation possible so you should assign it
      to the highest level function possible that ends up calling a family function."
          (if (display-graphic-p)
              (apply func args)
            ;; Needs to be evaluated since the cl-letf spec is calculated here.
            (eval
             `(cl-letf ,(cl-loop for it in all-the-icons-font-families
                                 with func-name = nil
                                 do (setq func-name (all-the-icons--function-name it))
                                 with new-func-name = nil
                                 do (setq new-func-name (intern (concat (symbol-name func-name) "--default")))
                                 append `(((symbol-function ',new-func-name)
                                           (symbol-function ',func-name))
                                          ((symbol-function ',func-name)
                                           (lambda (&rest icon-args)
                                             (all-the-icons-pad-on-tty-advice+
                                              (apply ',new-func-name icon-args))))))
                (apply ',func ',args)))))

        (defmacro +icon (family &rest args)
          "Retrieve an icon from FAMILY smartly.
      This function acts as a proxy for the various `all-the-icons-%s-icon'
      functions. It can smartly fallback to a built-in `all-the-icons' font
      when a nerd-font icon is requested but not available.

      Note: This may throw an error when `all-the-icons' doesn't have an
      association for a font in the same family that nerd font does have.
      This can happen because `all-the-icons' associations are out of date."
          (when (and (not +icons-prefer-nerd-font)
                     (string-prefix-p "nerd-" (symbol-name family)))
            (if-let* ((new-family (alist-get (intern (substring (symbol-name family) 5))
                                             +icon-nerd-to-all-the-icons)))
                (setq family new-family)
              (error "Nerd fonts not enabled but need to return a %s icon" family)))
          ;; Function name calculation copied from `all-the-icons--function-name'.
          `(,(intern (concat "all-the-icons-" (downcase (symbol-name family)))) ,@args))

        (defmacro +icon-for (for target &rest args)
          "Generic icon fetcher for TARGET.
      TARGET can be a buffer, directory path, file-name, mode-symbol, etc. depending
      on the value of FOR. ARGS when supported will be passed to the associated icon
      fetcher and can be used to set :height or :face properties."
          (if-let* ((func (cl-case for
                            (file #'all-the-icons-icon-for-file)
                            (mode #'all-the-icons-icon-for-mode)
                            (url  #'all-the-icons-icon-for-url)
                            ((dir directory) #'all-the-icons-icon-for-dir))))
              `(,func ,target ,@args)
            (cl-case for
              ;; `all-the-icons-icon-for-buffer'.
              (buffer `(with-current-buffer ,target
                         (if (and (buffer-file-name)
                                  (all-the-icons-auto-mode-match?))
                             (apply #'all-the-icons-icon-for-file
                                    (file-name-nondirectory (buffer-file-name))
                                    ',args)
                           (apply #'all-the-icons-icon-for-mode major-mode ',args))))
              ;; TODO: Icon formatting args aren't used by the following.
              ((dir+chevron directory+chevron)
               `(all-the-icons-icon-for-dir-with-chevron ,target))
              (t (error "Don't know how to fetch an icon for %s" for)))))

        :config
        (setq
         ;; Major mode
         all-the-icons-mode-icon-alist
         (append
          `((rustic-mode all-the-icons-alltheicon "rust")
            (web-mode all-the-icons-faicon "html5")
            (Man-mode all-the-icons-faicon "book")
            (woman-mode all-the-icons-faicon "book")
            (process-menu-mode all-the-icons-faicon "linux")
            (notmuch-search-mode all-the-icons-material "email")
            (notmuch-hello-mode all-the-icons-material "email")
            (notmuch-tree-mode all-the-icons-material "email")
            (notmuch-show-mode all-the-icons-material "email")
            (notmuch-messages-mode all-the-icons-material "email")
            (messages-buffer-mode all-the-icons-material "message"))
          all-the-icons-mode-icon-alist)

         ;; Directory regular expressions
         all-the-icons-dir-icon-alist
         (append
          `((,(rx ".github") all-the-icons-faicon "github"))
          all-the-icons-dir-icon-alist)

         ;; File regular expressions
         all-the-icons-regexp-icon-alist
         (append
          `((,(rx bol (or "pyproject.toml" "poetry.lock" "scrapy.cfg"))
             all-the-icons-alltheicon "python")
            (,(rx ".editorconfig")
             all-the-icons-fileicon "editorconfig" :face all-the-icons-yellow)
            (,(rx bol (or ".gitignore" ".gitattributes" ".gitmodules") eol)
             all-the-icons-faicon "git" :face all-the-icons-red)
            (,(rx "Thorfile") all-the-icons-octicon "ruby" :face all-the-icons-lred)
            (,(rx "." eol) all-the-icons-octicon "file-directory" :height 1.0 :v-adjust -0.1)
            (,(rx bol (or "news" "NEWS") (optional "." (+ num))) all-the-icons-faicon "newspaper-o")
            (,(rx bol "*Flymake diagnostics for " (one-or-more any) "*" eol)
             all-the-icons-material "error")
            (,(rx ".journal" eol) all-the-icons-faicon "book"))
          all-the-icons-regexp-icon-alist)

         ;; File extension regular expressions
         all-the-icons-extension-icon-alist
         (append
          `((,(rx "thor") all-the-icons-octicon "ruby" :face all-the-icons-lred))
          all-the-icons-extension-icon-alist))

        (setf (car (assoc "^Makefile$" all-the-icons-regexp-icon-alist))
              (rx bol (or (any "M" "m")) "akefile" eol))

        :commands (all-the-icons-insert-all+
                   all-the-icons-insert-all-icons+)
        :config
        (defun all-the-icons-insert-all+ ()
          (interactive)
          (cl-loop for family in all-the-icons-font-families
                   do (cl-loop for (name . icon) in (funcall (all-the-icons--data-name family))
                               do (insert "\n" icon "  " (symbol-name family) " - " name))))

        (defun all-the-icons-insert-all-icons+ ()
          (interactive)
          (dolist (icon-list (list all-the-icons-regexp-icon-alist
                                   all-the-icons-dir-icon-alist
                                   all-the-icons-weather-icon-alist
                                   all-the-icons-mode-icon-alist
                                   ;; all-the-icons-url-alist
                                   ))
            (dolist (icon icon-list)
              (let* ((func (nth 1 icon))
                     (args (nthcdr 2 icon))
                     (name (car args))
                     (type (substring (symbol-name func) 14)))
                (unless (= (length args) 0)
                  (insert "\n" (apply func args) " " type " - " name)))))))
    #+END_SRC

*** Nerd Fonts
    When available we prefer [[https://github.com/ryanoasis/nerd-fonts][nerd-fonts]] (and it's many bundled font-sets) over the
    various all-the-icon fonts.

    #+begin_src emacs-lisp
      (use-package all-the-icons-nerd-fonts
        :straight t
        :when +icons-prefer-nerd-font
        :autoload (all-the-icons-nerd-fa
                   all-the-icons-nerd-md
                   all-the-icons-nerd-pl
                   all-the-icons-nerd-fae
                   all-the-icons-nerd-oct
                   all-the-icons-nerd-mdi
                   all-the-icons-nerd-iec
                   all-the-icons-nerd-dev
                   all-the-icons-nerd-ple
                   all-the-icons-nerd-cod
                   all-the-icons-nerd-pom
                   all-the-icons-nerd-seti
                   all-the-icons-nerd-linux
                   all-the-icons-nerd-custom
                   all-the-icons-nerd-weather)
        :custom
        (all-the-icons-nerd-fonts-family
         (if (stringp +icons-prefer-nerd-font)
             +icons-prefer-nerd-font
           "Symbols Nerd Font"))

        :config
        (setf (alist-get 'notmuch-show-mode all-the-icons-mode-icon-alist)
              '(all-the-icons-nerd-md "email-open"))

        :autoload all-the-icons-nerd-fonts-prefer
        :init
        (with-eval-after-load 'all-the-icons
          (all-the-icons-nerd-fonts-prefer)))
    #+end_src

*** Appendix
    #+BEGIN_SRC emacs-lisp
      (provide '+pkg-all-the-icons)
    #+END_SRC

** Cape                                                                :comp:
   :PROPERTIES:
   :header-args+: :tangle (lisp! "+pkg-cape.el")
   :END:

   Common configurations for interactive completion clients.

   #+begin_src emacs-lisp :tangle yes
     (require '+pkg-cape)
   #+end_src

   #+begin_src emacs-lisp
     (use-package cape
       :straight t
       :completion+
       (prog-mode (cape-file :depth 5)
                  ;; Support keyword completions upto 3 chars. After that
                  ;; fallback to mode specific completion and barring that
                  ;; back to keywords. Prevents keyword matching obstructing
                  ;; language server mappings.
                  (cape-keyword-with-length-limit+ :depth 10)
                  (cape-keyword :depth 50))
       (org-mode (cape-elisp-block :depth 10))
       (text-mode (cape-emoji :depth -15))
       (emacs-lisp-mode (cape-emoji :depth 15))
       (abbrev-mode cape-abbrev)
       (org-mode (cape-elisp-block :depth -5)
                 (cape-file :depth 5))
       ;; (jinx-mode cape-dict)
       ;; (flyspell-mode cape-dict)
       (latex-mode cape-tex)
       (LaTeX-mode cape-tex)

       :preface
       (defun cape-wrap-max-prefix-length+ (capf length)
         "Call CAPF and ensure that prefix length is greater or equal than LENGTH.
     If the prefix is long enough, enforce auto completion."
         (pcase (funcall capf)
           (`(,beg ,end ,table . ,plist)
            (when (<= (- end beg) length)
              `(,beg ,end ,table
                     :company-prefix-length t
                     ,@plist)))))

       (defun cape-capf-max-prefix-length+ (capf length)
         (lambda () (funcall #'cape-wrap-max-prefix-length+ capf length)))

       :autoload cape-keyword-with-length-limit+
       :config
       (defalias 'cape-keyword-with-length-limit+
         (cape-capf-max-prefix-length+ #'cape-keyword 2)))
   #+end_src

   #+begin_src emacs-lisp
    (provide '+pkg-cape)
   #+end_src

** Browse URL
   :PROPERTIES:
   :header-args+: :tangle (lisp! "+pkg-browse-url.el")
   :END:

   #+begin_src emacs-lisp :tangle yes
      (require '+pkg-browse-url)
   #+end_src

   Provides functions to open URLs and file-paths on your local system using system
   specific tools.

   #+BEGIN_SRC emacs-lisp
     (use-package browse-url
       :straight t
       :init
       (advice-add #'browse-url-xdg-open :override #'+xopen-url)
       (advice-add 'browse-url-can-use-xdg-open :override
                   (defun browse-url-prefer-xopen+ ()
                     (and (or (getenv "DISPLAY")
                              (getenv "WAYLAND_DISPLAY"))
                          (executable-find "xopen")))))
   #+END_SRC

   #+begin_src emacs-lisp
     (require '+setup-commands)

     (use-package browse-url
       :leader ("fo" '+xopen-url)
       :commands +xopen-url
       :config
       (declare-function dired-get-file-for-visit "dired")

       (defun +xopen-url (url &optional arg)
         "Open visited file in default external program.
     When in dired mode, open file under the cursor.
     With a prefix ARG always prompt for command to use."
         (interactive (list (or (when (derived-mode-p 'dired-mode)
                                  (dired-get-file-for-visit))
                                (smart-buffer-file-name+)
                                (user-error "Cannot determine file name for buffer."))
                            current-prefix-arg))

         (when (string-prefix-p "~" url)
           (setq url (expand-file-name url)))

         (let ((program (if arg
                            (read-shell-command "Open current file with: ")
                          "xopen")))
           (call-process program nil 0 nil url))))
   #+end_src

   #+begin_src emacs-lisp
     (use-package browse-url
       :autoload +xopen-pdf
       :config
       (defun +xopen-pdf (path page)
         (if (and (not (string-empty-p page))
                  (executable-find "zathura"))
             (call-process "zathura" nil 0 nil path "--page" page)
           (+xopen-url path))))
   #+end_src

   #+begin_src emacs-lisp
     (use-package browse-url
       :commands +xopen-file
       :config
       (defun +xopen-file (file &optional arg)
         (interactive "fP")
         (+xopen-url file))
       :general
       (:keymaps 'embark-file-map [remap embark-open-externally] '+xopen-file))
   #+end_src

   #+begin_src emacs-lisp
      (provide '+pkg-browse-url)
   #+end_src

** Buffer Move
   :PROPERTIES:
   :header-args+: :tangle (lisp! "+pkg-buffer-move.el")
   :END:

   #+begin_src emacs-lisp :tangle yes
     (use-package +pkg-buffer-move
       :commands (rotate-windows+)
       :general
       (:keymaps 'emacs-window-map+
        "H"   'buf-move-left
        "M-h" 'buf-move-left
        "J"   'buf-move-down
        "M-j" 'buf-move-down
        "K"   'buf-move-up
        "M-k" 'buf-move-up
        "L"   'buf-move-right
        "M-l" 'buf-move-right))
   #+end_src

   Move buffer to windows in other directions. Like the vim C-w <Shift>+{h,j,k,l}
   series of functions.

   #+BEGIN_SRC emacs-lisp
     (use-package buffer-move
       :straight t)
   #+END_SRC

   See [[https://www.emacswiki.org/emacs/TransposeWindows][Transpose Windows]].

   #+begin_src emacs-lisp
     (defun rotate-windows+ (arg)
       "Rotate your windows; use the prefix argument to rotate the other direction"
       (interactive "P")
       (if (not (> (count-windows) 1))
           (message "You can't rotate a single window!")
         (let* ((rotate-times (prefix-numeric-value arg))
                (direction (if (or (< rotate-times 0) (equal arg '(4)))
                               'reverse 'identity)))
           (dotimes (_ (abs rotate-times))
             (dotimes (i (- (count-windows) 1))
               (let* ((w1 (elt (funcall direction (window-list)) i))
                      (w2 (elt (funcall direction (window-list)) (+ i 1)))
                      (b1 (window-buffer w1))
                      (b2 (window-buffer w2))
                      (s1 (window-start w1))
                      (s2 (window-start w2))
                      (p1 (window-point w1))
                      (p2 (window-point w2)))
                 (set-window-buffer-start-and-point w1 b2 s2 p2)
                 (set-window-buffer-start-and-point w2 b1 s1 p1)))))))
   #+end_src

   #+begin_src emacs-lisp
      (provide '+pkg-buffer-move)
   #+end_src

** Drag Stuff
   :PROPERTIES:
   :header-args+: :tangle (lisp! "+pkg-drag-stuff.el")
   :END:

   #+begin_src emacs-lisp :tangle yes
      (require '+pkg-drag-stuff)
   #+end_src

   VS Code like drag region or line upwards or downwards.

   #+begin_src emacs-lisp
     (use-package drag-stuff
       :straight t
       :general
       ("C-<up>" 'drag-stuff-up
        "C-<down>" 'drag-stuff-down))
   #+end_src

   #+begin_src emacs-lisp
      (provide '+pkg-drag-stuff)
   #+end_src

** Define Word
   :PROPERTIES:
   :header-args+: :tangle (lisp! "+pkg-define-word.el")
   :END:

   #+begin_src emacs-lisp :tangle yes
      (require '+pkg-define-word)
   #+end_src

   #+begin_src emacs-lisp
     (use-package define-word
       :straight t
       :leader
       ("hdW" 'define-word
        "hdw" 'define-word-at-point))
   #+end_src

   #+begin_src emacs-lisp
      (provide '+pkg-define-word)
   #+end_src

** Emojify Mode
   :PROPERTIES:
   :header-args+: :tangle (lisp! "+pkg-emojify.el")
   :END:

   #+begin_src emacs-lisp :tangle yes
      (require '+pkg-emojify)
   #+end_src

*** Emojify
    #+begin_src emacs-lisp
      (use-package emojify
        :straight t
        :hook ((org-mode              . emojify-mode)
               (git-commit-mode       . emojify-mode)
               (web-mode              . emojify-mode)
               (emacs-lisp            . emojify-mode)
               (lisp-interaction-mode . emojify-mode)
               (yaml-mode             . emojify-mode)
               (bibtex-mode           . emojify-mode)
               (shell-mode            . emojify-mode)
               (markdown-mode         . emojify-mode)
               (lisp-interaction-mode . emojify-mode)
               (scss-mode             . emojify-mode))
        :custom
        (emojify-emojis-dir (cache! "emojify/"))
        (emojify-point-entered-behaviour 'uncover
         "Make emojis work like `prettify-symbols-mode'.")
        (emojify-emoji-styles '(unicode github))
        (emojify-display-style 'unicode)

        :leader
        ("tme" 'emojify-mode
         "ie" 'emojify-insert-emoji
         "hE" 'emojify-apropos-emoji
         "he" 'emojify-describe-emoji)

        :general
        (:keymaps 'emojify-list-mode-map
         :states 'motion
         "gr" 'emojify-list-force-refresh
         "Y"  'emojify-list-copy-emoji
         "RET" 'emojify-list-describe-emoji)
        (:keymaps 'emojify-description-mode
         :states 'motion
         "Y" 'emojify-description-copy-emoji))
    #+end_src

*** Appendix
    #+begin_src emacs-lisp
       (provide '+pkg-emojify)
    #+end_src

** Eyebrowse
   :PROPERTIES:
   :header-args+: :tangle (lisp! "+pkg-eyebrowse.el")
   :END:

   #+begin_src emacs-lisp :tangle yes
      (require '+pkg-eyebrowse)
   #+end_src

*** Eyebrowse
    #+BEGIN_SRC emacs-lisp
      (use-package eyebrowse
        :straight t
        :commands eyebrowse-mode
        :config (eyebrowse-mode +1))
    #+END_SRC

*** Eyebrowse Hydra
    #+begin_src emacs-lisp
      (eval-when-compile (require '+pkg-hydra))
      (require '+pkg-winner)

      (use-package eyebrowse
        :commands eyebrowse-hydra/body
        :general
        (:keymaps 'emacs-window-map+
         "w"   '(eyebrowse-hydra/body :wk "eyebrowse-hydra")
         "C-w" '(eyebrowse-hydra/body :wk "eyebrowse-hydra"))

        :preface
        (defvar eyebrowse-hydra/verbose-p nil
          "When true, hydra hint doesn't show keybindings.")

        (defvar eyebrowse-hydra/show-wconfig-names t
          "When true, wconfigs in the hydra header will includes names (when applicable).")

        :autoload
        (eyebrowse-last-window-config
         eyebrowse-prev-window-config
         eyebrowse-next-window-config
         eyebrowse-rename-window-config
         eyebrowse-close-window-config
         eyebrowse-create-window-config
         eyebrowse-switch-to-window-config-9
         eyebrowse-switch-to-window-config-8
         eyebrowse-switch-to-window-config-7
         eyebrowse-switch-to-window-config-6
         eyebrowse-switch-to-window-config-5
         eyebrowse-switch-to-window-config-4
         eyebrowse-switch-to-window-config-3
         eyebrowse-switch-to-window-config-2
         eyebrowse-switch-to-window-config-1
         eyebrowse-switch-to-window-config-0)

        :config
        (with-no-warnings
          (defhydra eyebrowse-hydra (:hint nil :foreign-keys nil)
            ("0" eyebrowse-switch-to-window-config-0 :exit t)
            ("1" eyebrowse-switch-to-window-config-1 :exit t)
            ("2" eyebrowse-switch-to-window-config-2 :exit t)
            ("3" eyebrowse-switch-to-window-config-3 :exit t)
            ("4" eyebrowse-switch-to-window-config-4 :exit t)
            ("5" eyebrowse-switch-to-window-config-5 :exit t)
            ("6" eyebrowse-switch-to-window-config-6 :exit t)
            ("7" eyebrowse-switch-to-window-config-7 :exit t)
            ("8" eyebrowse-switch-to-window-config-8 :exit t)
            ("9" eyebrowse-switch-to-window-config-9 :exit t)

            ("M-0" eyebrowse-switch-to-window-config-0)
            ("M-1" eyebrowse-switch-to-window-config-1)
            ("M-2" eyebrowse-switch-to-window-config-2)
            ("M-3" eyebrowse-switch-to-window-config-3)
            ("M-4" eyebrowse-switch-to-window-config-4)
            ("M-5" eyebrowse-switch-to-window-config-5)
            ("M-6" eyebrowse-switch-to-window-config-6)
            ("M-7" eyebrowse-switch-to-window-config-7)
            ("M-8" eyebrowse-switch-to-window-config-8)
            ("M-9" eyebrowse-switch-to-window-config-9)

            ("c" eyebrowse-create-window-config)
            ("d" eyebrowse-close-window-config)
            ("r" eyebrowse-rename-window-config)
            ("n" eyebrowse-next-window-config)
            ("l" eyebrowse-next-window-config)
            ("N" eyebrowse-prev-window-config)
            ("h" eyebrowse-prev-window-config)
            ("TAB" eyebrowse-last-window-config)
            ("u" (progn (winner-undo) (setq this-command 'winner-undo)))
            ("U" winner-redo :exit t)
            ("?" (setq eyebrowse-hydra/verbose-p (not eyebrowse-hydra/verbose-p)))
            ("t" (setq eyebrowse-hydra/show-wconfig-names (not eyebrowse-hydra/show-wconfig-names)))
            ("w" winman-hydra/body :exit t)

            ("q" nil :exit t)))

        :preface
        (defface eyebrowse-hydra/active-wconfig-face
          '((t :inherit mode-line))
          "Face for inactive windows in the header string."
          :group '+dot-emacs)

        (defconst eyebrowse-hydra/complete-command-docstring
          "
      Jump                        Actions
      ^^^^‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî  ‚Äî^‚Äî^‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî^‚Äî^‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
      [_0_.._9_] nth wconfig     [_c_] create new wconfig      [_w_] window-manager
      [_TAB_] previous wconfig^^ [_d_] delete current wconfig
      ^^^^                       [_r_] rename current wconfig
      [_h_/_N_] wconfig left
      [_l_/_n_] wconfig right    [_u_/_U_] undo/redo wconfig
      ")

        :config
        (defmacro eyebrowse-window-list-to-title (window-list)
          "Extract window config title from list.
      Window list is either the title or a nil value."
          `(let ((title (car (cdr (cdr ,window-list)))))
             (unless (string-empty-p title)
               title)))

        (setq eyebrowse-hydra/hint
              '(let ((current-wconfig-num (eyebrowse--get 'current-slot))
                     header-s wconfig-item-s)
                 (dolist (wconfig-counter (number-sequence 0 9))
                   (let ((wconfig-item (eyebrowse--window-config-present-p wconfig-counter)))
                     (if (not wconfig-item)
                         nil

                       ;; Include wconfig in header string
                       (let ((win-name (eyebrowse-window-list-to-title wconfig-item)))
                         (setq wconfig-item-s (if (and win-name
                                                       eyebrowse-hydra/show-wconfig-names)
                                                  (format "[%d:%s]" wconfig-counter win-name)
                                                (format "[%d]" wconfig-counter)))

                         (when (eq wconfig-counter
                                   current-wconfig-num)
                           (setq wconfig-item-s (propertize wconfig-item-s
                                                            'face 'eyebrowse-hydra/active-wconfig-face)))

                         (setq header-s (concat header-s wconfig-item-s " "))))))

                 (setq header-s (format "\n%s %s (_?_ help)\n"
                                        (propertize "Window Configs"
                                                    'face 'font-lock-string-face)
                                        (s-trim header-s)))
                 (eval (hydra--format nil
                                      '(nil nil :hint nil)
                                      (if (not eyebrowse-hydra/verbose-p)
                                          header-s
                                        (concat header-s
                                                eyebrowse-hydra/complete-command-docstring))
                                      eyebrowse-hydra/heads)))))
    #+end_src

*** Appendix
    #+begin_src emacs-lisp
       (provide '+pkg-eyebrowse)
    #+end_src

** Git Link
   :PROPERTIES:
   :header-args+: :tangle (lisp! "+pkg-gitlink.el")
   :END:

   #+begin_src emacs-lisp :tangle yes
      (require '+pkg-gitlink)
   #+end_src

   #+BEGIN_SRC emacs-lisp
     (use-package git-link
       :straight t
       :custom
       (git-link-open-in-browser nil)                                                ; default is to open the generated link

       :leader
       ("gy"  '(:ignore t :wk "links")
        "gyl" 'git-link
        "gyc" 'git-link-commit
        "gyh" 'git-link-homepage))
   #+END_SRC

   #+begin_src emacs-lisp :tangle (package-lisp! +pkg-gitlink magit)
     (use-package git-link
       :preface (use-package transient :autoload transient-suffix-put)
       :after magit
       :config
       (transient-insert-suffix 'magit-dispatch '(0 2 6)
         '(git-link-dispatch :key "o" :description "Git link")))
   #+end_src

   #+begin_src emacs-lisp
      (provide '+pkg-gitlink)
   #+end_src

** Hide Mode-Line
   :PROPERTIES:
   :header-args+: :tangle (lisp! "+pkg-hide-mode-line.el")
   :END:

   Makes the mode-line blank in the current buffer. this doesn't let the buffer contents expand
   into the mode-line region, it simply makes it appear as if nothings there.

   #+begin_src emacs-lisp :tangle yes
   (require '+pkg-hide-mode-line)
   #+end_src

   #+BEGIN_SRC emacs-lisp
     (use-package hide-mode-line
       :straight t)
   #+END_SRC

   #+begin_src emacs-lisp
   (provide '+pkg-hide-mode-line)
   #+end_src

** Highlight Todo
   :PROPERTIES:
   :header-args+: :tangle (lisp! "+pkg-hl-todo.el")
   :END:

   Highlight certain keywords in the current buffer.

   #+begin_src emacs-lisp :tangle yes
   (require '+pkg-hl-todo)
   #+end_src

   #+BEGIN_SRC emacs-lisp
     (use-package hl-todo
       :straight t
       :hook ((prog-mode text-mode) . global-hl-todo-mode)
       :hook (org-mode  . hl-todo-mode)
       :leader
       ("jt" 'hl-todo-next
        "jT" 'hl-todo-previous
        "et" 'hl-todo-occur

        "it" 'hl-todo-insert
        "it" 'hl-todo-insert-keyword))
   #+END_SRC

   #+begin_src emacs-lisp
   (provide '+pkg-hl-todo)
   #+end_src

** Lorem Ipsum
   :PROPERTIES:
   :header-args+: :tangle (lisp! "+pkg-lorem-ipsum.el")
   :END:

   Insert placeholder text in the [[https://www.lipsum.com/][lorem-ipsum-dolor]] format.

   #+begin_src emacs-lisp :tangle yes
     (require '+pkg-lorem-ipsum)
   #+end_src

   #+BEGIN_SRC emacs-lisp
     (use-package lorem-ipsum
       :straight t
       :leader
       ("il"  '(:ignore t :wk "lorem-ipsum")
        "ill" 'Lorem-ipsum-insert-list
        "ilp" 'Lorem-ipsum-insert-paragraphs
        "ils" 'Lorem-ipsum-insert-sentences))
   #+END_SRC

   #+begin_src emacs-lisp
     (provide '+pkg-lorem-ipsum)
   #+end_src

** Page Break Lines
   :PROPERTIES:
   :header-args+: :tangle (lisp! "+pkg-page-break-lines.el")
   :END:

   Display ^L lines as horizontal-rules. Like so:



   #+begin_src emacs-lisp :tangle yes
   (require '+pkg-page-break-lines)
   #+end_src

   #+BEGIN_SRC emacs-lisp
     (use-package page-break-lines
       :straight t
       :hook ((org-mode                    . page-break-lines-mode)
              (dashboard-mode              . page-break-lines-mode)
              (help-mode                   . page-break-lines-mode)
              (outline-mode                . page-break-lines-mode)
              (emacs-lisp-compilation-mode . page-break-lines-mode)
              (lisp-interaction-mode       . page-break-lines-mode)
              (emacs-lisp-mode             . page-break-lines-mode)
              (cc-mode                     . page-break-lines-mode))
       :diminish page-break-lines-mode)
   #+END_SRC

   #+begin_src emacs-lisp
   (provide '+pkg-page-break-lines)
   #+end_src

** PCRE 2 Elisp Regexp
   :PROPERTIES:
   :header-args+: :tangle (lisp! "+pkg-pcre2el.el")
   :END:

   Convert from Emacs regular expressions to perl style regexps and vice versa.

   #+begin_src emacs-lisp :tangle yes
   (require '+pkg-pcre2el)
   #+end_src

   #+BEGIN_SRC emacs-lisp
     (use-package pcre2el
       :straight t
       :leader
       ("xr'"  'rxt-convert-to-strings
        "xr/"  'rxt-explain
        "xrc"  'rxt-convert-syntax
        "xrt"  'rxt-toggle-elisp-rx
        "xrx"  'rxt-convert-to-rx

        "xre"  '(:ignore t :wk "elisp")
        "xre'" 'rxt-elisp-to-strings
        "xre/" 'rxt-explain-elisp
        "xrep" 'rxt-elisp-to-pcre
        "xret" 'rxt-toggle-elisp-rx
        "xrex" 'rxt-elisp-to-rx

        "xrp"  '(:ignore t :wk "PCRE")
        "xrp'" 'rxt-pcre-to-strings
        "xrp/" 'rxt-explain-pcre
        "xrpe" 'rxt-pcre-to-elisp
        "xrpx" 'rxt-pcre-to-rx))
   #+END_SRC

   #+begin_src emacs-lisp
   (provide '+pkg-pcre2el)
   #+end_src

** Sudo Edit
   :PROPERTIES:
   :header-args+: :tangle (lisp! "+pkg-sudo-edit.el")
   :END:

   Reopen the current file as root user.

   #+begin_src emacs-lisp :tangle yes
   (require '+pkg-sudo-edit)
   #+end_src

   #+BEGIN_SRC emacs-lisp
      (use-package sudo-edit
        :straight t
        :leader ("fE" 'sudo-edit))
   #+END_SRC

   #+begin_src emacs-lisp
   (provide '+pkg-sudo-edit)
   #+end_src

** Transpose Frame
   :PROPERTIES:
   :header-args+: :tangle (lisp! "+pkg-transpose-frame.el")
   :END:

   #+begin_src emacs-lisp :tangle yes
   (require '+pkg-transpose-frame)
   #+end_src

   #+BEGIN_SRC emacs-lisp
     (use-package transpose-frame
       :straight (transpose-frame :host github :repo "emacsorphanage/transpose-frame")
       :general
       (:keymaps 'emacs-window-map+
        "C-t" 'transpose-frame
        "t"   'transpose-frame
        "("   'rotate-frame-clockwise                                                ; 90 degrees
        ")"   'rotate-frame-anti-clockwise                                           ; 90 degrees
        "*"   'rotate-frame                                                          ; 180 degrees
        "F"   'flop-frame                                                            ; Flip horizontally
        "f"   'flip-frame))
   #+END_SRC

   #+begin_src emacs-lisp
   (provide '+pkg-transpose-frame)
   #+end_src

** Rainbow Delimiters
   :PROPERTIES:
   :header-args+: :tangle (lisp! "+pkg-rainbow-delimiters.el")
   :END:

   Pretty colors for my lisp parentheses :-).

   #+begin_src emacs-lisp :tangle yes
     (require '+pkg-rainbow-delimiters)
   #+end_src

   #+BEGIN_SRC emacs-lisp
     (use-package rainbow-delimiters
       :straight t
       :hook (prog-mode . rainbow-delimiters-mode))
   #+END_SRC

   #+begin_src emacs-lisp
   (provide '+pkg-rainbow-delimiters)
   #+end_src

** UUID Generate
   :PROPERTIES:
   :header-args+: :tangle (lisp! "+pkg-uuidgen.el")
   :END:

   #+begin_src emacs-lisp :tangle yes
   (require '+pkg-uuidgen)
   #+end_src

   #+BEGIN_SRC emacs-lisp
     (use-package uuidgen
       :straight t
       :leader
       ("iu" 'uuidgen
        ;; "U1" 'uuidgen-1
        ;; "U4" 'uuidgen-4
        ;; "UU" 'uuidgen-U
        ))
   #+END_SRC

   #+begin_src emacs-lisp
   (provide '+pkg-uuidgen)
   #+end_src

** Visible Mark
   :PROPERTIES:
   :header-args+: :tangle (lisp! "+pkg-visible-mark.el")
   :END:

   Highlight region when mark is active.

   #+begin_src emacs-lisp :tangle yes
   (require '+pkg-visible-mark)
   #+end_src

   #+BEGIN_SRC emacs-lisp
     (use-package visible-mark
       :straight t)
   #+END_SRC

   #+begin_src emacs-lisp
   (provide '+pkg-visible-mark)
   #+end_src

** Which Key
   :PROPERTIES:
   :header-args+: :tangle (lisp! "+pkg-which-key.el")
   :END:

   Show completion candidates for the current key prefix, after a mild delay.

   #+begin_src emacs-lisp :tangle yes
   (require '+pkg-which-key)
   #+end_src

   #+BEGIN_SRC emacs-lisp
     (use-package which-key
       :straight t
       :hook (after-init . which-key-mode)
       :diminish
       :demand t
       :config (which-key-setup-minibuffer)
       :leader ("hk" 'which-key-show-top-level)
       :custom
       (which-key-show-prefix 'bottom)
       (which-key-sort-order 'which-key-key-order-alpha)
       (which-key-echo-keystrokes 0.02)

       :autoload
       (which-key--show-keymap
        which-key--hide-popup-ignore-command)

       :commands which-key-M-x+
       :leader ("h RET" 'which-key-M-x+)
       :autoload (which-key--get-current-bindings
                  which-key--hide-popup-ignore-command
                  which-key--maybe-add-docstring
                  which-key-setup-minibuffer)
       :preface
       (defun which-key--completing-read-format+ (bnd)
         "Format binding BND for `completing-read'."
         (let* ((key (car bnd))
                (cmd (cdr bnd))
                (desc (format "%s (%s)" cmd
                              (propertize key 'face 'which-key-key-face))))
           (which-key--maybe-add-docstring
            (format "%-50s" desc) cmd)))

       (defun which-key--completing-read-cmd+ (&optional prefix)
         "Completing read command for PREFIX.

     Read commands for PREFIX or top-level if PREFIX not given."
         (which-key--hide-popup-ignore-command)
         (let ((desc
                (completing-read
                 (if prefix
                     (format "Execute (%s): " (key-description prefix))
                   "Execute: ")
                 (mapcar #'which-key--completing-read-format+
                         (which-key--get-current-bindings prefix)))))
           (intern (car (split-string desc)))))

       (defun which-key--execute-cmd+ (cmd)
         "Execute command CMD as if invoked by key sequence."
         (setq prefix-arg current-prefix-arg
               this-command cmd
               real-this-command cmd)
         (command-execute cmd 'record))

       (defun which-key-M-x+ (&optional key)
         "Completing read command and execute it.
     Only commands which are bound to keys are considered. If KEY is
     given it should be the prefix-key for which commands should be
     completed. Otherwise read command from top-level. "
         (interactive)
         (let ((cmd (which-key--completing-read-cmd+ key)))
           (when (commandp cmd)
             (which-key--execute-cmd+ cmd)))))
   #+END_SRC

  Prefix-completion courtesy of [[https://with-emacs.com/posts/ui-hacks/prefix-command-completion/][Clemara]].

   #+begin_src emacs-lisp
     (use-package which-key
       :commands which-key-M-x-prefix+
       :init (setq prefix-help-command #'which-key-M-x-prefix+)
       :config
       (defun which-key-M-x-prefix+ (&optional _)
         "Completing read and execute command from prefix-map.

     This command can be used as `prefix-help-command'. The optional
     argument is ignored and only for compatibility with
     `which-key-C-h-dispatch' so this command can be bound in
     `which-key-C-h-map', too."
         (interactive)
         (let* ((evs (cond ((which-key--current-prefix)
                            (which-key--current-key-list))
                           (t
                            (butlast (append (this-command-keys-vector) nil)))))
                (key  (and evs (apply #'vector evs))))
           (which-key-M-x+ key))))
   #+end_src

   #+begin_src emacs-lisp
   (provide '+pkg-which-key)
   #+end_src

** Winum
   :PROPERTIES:
   :header-args+: :tangle (lisp! "+pkg-winum.el")
   :END:

   Number windows, to make jumping to them easier.

   #+begin_src emacs-lisp :tangle yes
   (require '+pkg-winum)
   #+end_src

   #+BEGIN_SRC emacs-lisp
     (use-package winum
       :straight t
       :demand t
       :custom
       (winum-scope 'frame-local)

       :commands winum-mode
       :init (winum-mode)

       :general
       (:keymaps 'emacs-window-map+
        "1" 'winum-select-window-1
        "2" 'winum-select-window-2
        "3" 'winum-select-window-3
        "4" 'winum-select-window-4
        "5" 'winum-select-window-5
        "6" 'winum-select-window-6
        "7" 'winum-select-window-7
        "8" 'winum-select-window-8
        "9" 'winum-select-window-9
        "0" 'winum-select-window-by-number))
   #+END_SRC

   #+begin_src emacs-lisp
     (use-package +pkg-which-key
       :config
       ;; Reset 1st window number option to window by number
       (push (cons '("\\(.*\\) 1" . "winum-select-window-1")
                   '("\\1 1..9"   . "window-by-number"))
             which-key-replacement-alist)

       ;; Hide numbers 2 through to nine
       (push (cons '(nil . "winum-select-window-[2-9]") t)
             which-key-replacement-alist)

       ;; Abbreviate 0 value
       (push (cons '("\\(.*\\) 0" . "winum-select-window-by-number")
                   '("\\1 0"      . "window-by-prompt"))
             which-key-replacement-alist))
   #+end_src

   #+begin_src emacs-lisp
   (provide '+pkg-winum)
   #+end_src

** Prettify Symbols                                                 :builtin:
   :PROPERTIES:
   :header-args+: :tangle (lisp! "+pkg-prettify-symbols.el")
   :END:

   Lets you convert identifiers like lambda into Unicode symbols like Œª.

   #+BEGIN_SRC emacs-lisp
     (use-package prog-mode
       :delight  (prettify-symbols-mode " Œª")
       :custom
       (lisp-prettify-symbols-alist nil)
       (prettify-symbols-unprettify-at-point 'right-edge
        "Do not need to keep pretty-symbols whil I am hovering over them."))
   #+END_SRC

*** Configure Pretty Symbol
    Utility macro to make prettify-symbols mode easier to setup for individual modes.
    This was partially inspired by this [[https://emacs.stackexchange.com/questions/34808/using-prettify-symbols-with-strings-instead-of-characters][stack-exchange]] post.

    #+BEGIN_SRC emacs-lisp
      (defvar prettify-symbols-pretty-symbols-alist+ nil
        "alist of mode to pretty symbols ")
    #+END_SRC

    Inspired by [[https://emacs.stackexchange.com/questions/34808/using-prettify-symbols-with-strings-instead-of-characters][this post]], this is a helper to make creating pretty symbols easier.

    #+BEGIN_SRC emacs-lisp
      (require '+lib-plist-bind)

      (defun prettify-symbols-string+ (to)
        "Get a prettify symbols entry to map a string to a string."
        (let ((length (length to)))
          (cl-loop for i from 0 to length
                   for char in (string-to-list to)
                   unless (eq i (- length 1))
                   do (setq char (list char '(Br . Bl)))
                   else
                   do (setq char (list char))
                   end
                   append char)))

      (defun configure-presym--prepare-args+ (args)
        "Convert ARGS to partitioned 2 length cons cells.
      ARGS should simply be a flat sequence of string to pretty-symbol.

      The pretty-symbol part can be a given as a string, to automatically
      pass through `prettify-symbols-string+'."
        (cl-loop for (src dest) in (-partition 2 args)
                 collect (cons src
                               (if (stringp dest)
                                   (prettify-symbols-string+ dest)
                                 dest))))

      ;; TODO add duplicate remove check.
      (defmacro configure-presym! (modes &rest args)
        "Configure prettify-symbols for modes MODES.
      This function adds/modifies an entry for mode in the
      `prettify-symbols-pretty-symbols-alist+' alist and binds a hook in MODES
      mode-hook to enable `prettify-symbols-mode'.

      MODES can be given as a quoted list, or a single quoted mode name or a
      variable pointing to either of these types (and discoverable at macro
      expansion time).

      ARGS should be a form acceptable by `configure-presym--prepare-args+'.

      eg. (configure-presym! (quote org-mode) \"lambda\" ?Œª)"
        (plist-bind! (args :remove-duplicates)
          (setq modes (eval modes))

          (when modes
            (unless (listp modes)
              (setq modes `(,modes))))

          (let (res ; aggregate forms into here
                (tuples (configure-presym--prepare-args+ args)))
            (dolist (mode modes)
              (let ((mode-name (symbol-name mode)))
                (push
                 `(let ((config (assoc (quote ,mode) prettify-symbols-pretty-symbols-alist+)))
                    (if config
                        ; add to existing config, while preventing cyclic loops
                        (nconc-safe! (car (cdr config)) tuples)
                      (push (cons (quote ,mode) (list tuples))
                            prettify-symbols-pretty-symbols-alist+)

                      (add-hook (quote ,(intern (concat mode-name "-hook")))
                                (defun ,(intern (concat "configure-presym-" mode-name)) (&rest _)
                                  ,(concat "sets up pretty symbols for " mode-name)
                                  (let ((config (assoc (quote ,mode)
                                                       prettify-symbols-pretty-symbols-alist+)))
                                    (when (and config
                                               (setq config (car (cdr config))))
                                      (setq prettify-symbols-alist
                                            (append prettify-symbols-alist
                                                    (copy-sequence config)))

                                      (prettify-symbols-mode +1)))))))
                 res)))
            `(let ((tuples (quote ,tuples))) ,@res))))
      (put 'configure-presym! 'lisp-indent-function 'defun)
    #+END_SRC

*** Use Package
    :PROPERTIES:
    :header-args+: :tangle (lisp! "+use-package-prettify-symbols.el")
    :END:

    #+begin_src emacs-lisp
      (require 'use-package-core)

      (defun use-package-normalize/:pretty-symbols+ (name keyword args)
        args)

      (defun use-package-handler/:pretty-symbols+ (name keyword args rest state)
        (use-package-concat
         (use-package-process-keywords name rest state)
         `((require '+pkg-prettify-symbols)
           (declare-function configure-presym! "+pkg-prettify-symbols")
           ,@(cl-loop for (modes . pretty-symbols) in args collect
                      `(configure-presym! (quote ,modes)
                         ,@pretty-symbols)))))

      (let ((tail (nthcdr (cl-position :config use-package-keywords)
                          use-package-keywords)))
        (setcdr tail (append (list :pretty-symbols+) (cdr tail))))
    #+end_src

    #+begin_src emacs-lisp
      (provide '+use-package-prettify-symbols)
    #+end_src

*** Appendix
    #+begin_src emacs-lisp
      (provide '+pkg-prettify-symbols)
    #+end_src

** Auto Fill Mode                                                   :builtin:
   :PROPERTIES:
   :header-args+: :tangle (lisp! "+pkg-auto-fill-mode.el")
   :END:

   #+begin_src emacs-lisp :tangle yes
     (require '+pkg-auto-fill-mode)
   #+end_src

   #+BEGIN_SRC emacs-lisp
     (use-package simple
       :commands set-word-wrap-column+
       :leader
       ("ta" 'set-word-wrap-column+)

       :config
       (defun set-word-wrap-column+ (&optional arg)
         "Set the maximum wanted length for a line in this buffer.
     This function enables `auto-fill-mode' in this buffer and sets
     the fill column value.

     If `auto-fill-mode' is already active and this function is called
     with no ARG, then a new `fill-column' value is interactively read.
     This also happens if a non numeric ARG is passed.

     If ARG is a number, `fill-column' is set to the value of that number.

     However, if the final value of ARG resolves to be non-positive,
     `auto-fill-mode' will be disabled."
         (interactive "P")
         (let ((active (bound-and-true-p auto-fill-function)))
           (setq arg
                 (cond
                  ((numberp arg)
                   arg)
                  ((or (consp arg)
                       active)
                   ;; why would you pass a prefix to make this ask you for a number
                   ;; instead of just passing the number, dummy?
                   (read-number "fill-column: " fill-column))
                  (t fill-column)))

           (if (<= arg 0)
               (auto-fill-mode -1)
             (or active
                 (auto-fill-mode +1))
             (setq fill-column arg)))))
   #+END_SRC

   #+begin_src emacs-lisp
     (provide '+pkg-auto-fill-mode)
   #+end_src

** Auto Revert Mode                                                 :builtin:
   :PROPERTIES:
   :header-args+: :tangle (lisp! "+pkg-auto-revert-mode.el")
   :END:

   A major mode that checks when a file is changed on disk and reloads it in Emacs.

   #+begin_src emacs-lisp :tangle yes
     (use-package autorevert
       :diminish auto-revert-mode)
   #+end_src

** Bookmark                                                         :builtin:
   :PROPERTIES:
   :header-args+: :tangle (lisp! "+pkg-bookmark.el")
   :END:

   #+begin_src emacs-lisp :tangle yes
     (require '+pkg-bookmark)
   #+end_src

   #+BEGIN_SRC emacs-lisp
     (use-package bookmark
       :custom
       (bookmark-default-file (etc! "bookmarks.el"))

       :autoload bookmark-get-bookmark
       :preface
       (defun bookmark-jump-prioritise-recent-bookmarks+ (bookmark &optional _display-func)
         (let ((latest (bookmark-get-bookmark bookmark)))
           (setq bookmark-alist (delq latest bookmark-alist))
           (push latest bookmark-alist)))

       :init
       (advice-add 'bookmark-jump :after #'bookmark-jump-prioritise-recent-bookmarks+))
   #+END_SRC

   #+begin_src emacs-lisp
     (provide '+pkg-bookmark)
   #+end_src

** Buffer Menu                                             :builtin:optional:
   :PROPERTIES:
   :header-args+: :tangle (package-lisp! +pkg-buffer-menu buffer-menu)
   :END:

   The default buffer menu provided by Emacs.

   #+begin_src emacs-lisp :tangle (package-yes! buffer-menu)
     (require '+pkg-buffer-menu)
   #+end_src

   #+BEGIN_SRC emacs-lisp
     (use-package buff-menu
       :lazy-leader
       (:mode 'Buffer-menu-mode
        "1" 'Buffer-menu-1-window
        "2" 'Buffer-menu-2-window
        "f" 'Buffer-menu-toggle-files-only
        "/" 'Buffer-menu-isearch-buffers-regexp
        "o" 'Buffer-menu-multi-occur
        "T" 'Buffer-menu-visit-tags-table)

       :general
       (:keymaps 'Buffer-menu-mode-map
        "0" nil "1" nil "2" nil "<" nil ">" nil "?" nil "C-d" nil "C-k" nil
        "S-SPC" nil "SPC" nil "<backtab>" nil "TAB" nil "T" nil "b" nil "e" nil
        "f" nil "g" nil "h" nil "n" nil "p" nil "t" nil "v" nil "SPC" nil)
       (:keymaps 'Buffer-menu-mode-map
        "C-SPC" 'Buffer-menu-mark
        "S-DEL" 'Buffer-menu-bury
        "r"   'Buffer-menu-toggle-read-only
        "C-j" 'Buffer-menu-this-window
        "gr"  'revert-buffer
        "gf" 'Buffer-menu-toggle-files-only
        "C-l" 'tabulated-list-next-column
        "C-M-<return>" 'Buffer-menu-select))
   #+END_SRC

   #+begin_src emacs-lisp
     (provide '+pkg-buffer-menu)
   #+end_src

** Calculator                                                       :builtin:
   :PROPERTIES:
   :header-args+: :tangle (lisp! "+pkg-calc.el")
   :END:

   #+begin_src emacs-lisp :tangle yes
     (require '+pkg-calc)
   #+end_src

   #+begin_src emacs-lisp
     (require 'evil)
   #+end_src

   #+BEGIN_SRC emacs-lisp
     (use-package evil
       :config
       (evil-set-initial-state 'calc-mode 'motion))

     (use-package calc
       :custom (calc-symbolic-mode t)

       :autoload calc-copy-to-buffer
       :init
       (advice-add 'evil-get-register :before-until
                   (defun evil-register-*-is-calc+ (register &optional _)
                     "Make evils * register paste from head of calculator stack."
                     (when (eq register ?*)
                       (condition-case err
                           (with-temp-buffer
                             (calc-copy-to-buffer nil)
                             (buffer-substring (point-min) (point-max)))
                         (error (unless err (signal (car err) (cdr err)))
                                "")))))

       :init
       (with-eval-after-load 'calc-yank
         (general-define-key :keymaps 'calc-mode-map "C-w" nil))                      ; calc-kill-region

       :lazy-leader
       (:mode 'calc-mode "," 'calc-comma)

       :general
       (:keymaps 'calc-mode-map
        "<override-state>" 'motion
        [remap quit-window] 'calc-quit
        [remap evil-scroll-up] 'calc-scroll-down
        [remap evil-scroll-down] 'calc-scroll-up)
       (:keymaps 'calc-mode-map
        "SPC" nil                                                               ; causes recursion-overflow
        "U"   nil                                                               ; calc-undo
        "D"   nil                                                               ; calc-redo
        "Y"   nil                                                               ; empty prefix :P
        "@"   nil                                                               ; calcDigit-start
        "h"   nil                                                               ; calc-help-prefix
        "i"   nil                                                               ; calc-info
        "g"   nil

        ;; copies head of stack to point in buffer.
        "y"   nil                                                               ; calc-copy-to-buffer
        "C-d" nil                                                               ; calc-pop
        )
       (:states '(motion visual)
        :keymaps 'calc-mode-map
        "M-u" 'smart-universal-argument+
        "gq"  'quit-window
        "gQ"  'calc-graph-quit)
       (:states 'visual
        :keymaps 'calc-mode-map
        "x" 'calc-kill-region
        "d" 'calc-kill-region
        "y" 'calc-copy-region-as-kill)
       (:states 'motion
        :keymaps 'calc-mode-map
        "q" 'evil-record-macro
        "y" 'calc-copy-as-kill
        "u" 'calc-undo
        "G" 'calc-realign
        "C-r" 'calc-redo
        "C-t" 'calc-transpose-lines

        ;; [C-m] (with-no-warnings (general-simulate-key "v" :state 'emacs))
        "f"   (with-no-warnings (general-simulate-key "u" :state 'emacs))
        "C-v" (with-no-warnings (general-simulate-key "j" :state 'emacs))
        "C-n" (with-no-warnings (general-simulate-key "k" :state 'emacs))))
   #+END_SRC

   #+begin_src emacs-lisp
     (use-package calc
       :commands evil-calc-next-line
       :general (:states 'motion :keymaps 'calc-mode-map "j" 'evil-calc-next-line)
       :config
       (evil-define-motion evil-calc-next-line (count)
         (interactive "<c>")
         (evil-next-line count)

         (when (eobp)
           (calc-realign)

           (when (evil-visual-state-p)
             (forward-line -1)))

         (goto-char (+ 4 (line-beginning-position))))

       :commands evil-calc-prev-line
       :general (:states 'motion :keymaps 'calc-mode-map "k" 'evil-calc-prev-line)
       :config
       (evil-define-motion evil-calc-prev-line (count)
         (interactive "<c>")
         (evil-previous-line count)

         (when (eq (point-min) (line-beginning-position))
           (calc-goto-point-min+))

         (goto-char (+ 4 (line-beginning-position))))

       :commands calc-goto-point-min+
       :general (:states 'motion :keymaps 'calc-mode-map "gg"  'calc-goto-point-min+) ; was calc-graph-grid
       :config
       (defun calc-goto-point-min+ ()
         (interactive)
         (goto-char (point-min))
         (forward-line)
         (forward-char 4)
         (recenter))

       :commands evil-calc-visual-state+
       :general (:states 'motion :keymaps 'calc-mode-map "v" 'evil-calc-visual-state+)
       :config
       (defun evil-calc-visual-state+ ()
         (interactive)
         (when (string-match-p (rx bol (zero-or-more whitespace)
                                   "." eol)
                               (buffer-substring
                                (line-beginning-position)
                                (line-end-position)))
           (funcall-interactively 'evil-calc-prev-line 1))
         (evil-visual-line))

       :preface
       (defvar evil-calc-support-macro+ nil
         "When true `calc-mode' uses q for macros instead of quit.")
       :general (:states 'motion :keymaps 'calc-mode-map "@" 'evil-calc-call-kbd-macro)
       :config
       (declare-function calc-call-last-kbd-macro "calc-prog")

       (evil-define-command evil-calc-call-kbd-macro (count macro)
         (interactive
          (let (count macro register)
            (setq count (prefix-numeric-value current-prefix-arg)
                  register (or evil-this-register (read-char)))
            (cond
             ((eq register ?@)
              (unless evil-last-register
                (user-error "No previously executed keyboard macro."))
              (setq macro (evil-get-register evil-last-register t)))
             (t
              (setq macro (evil-get-register register t)
                    evil-last-register register)))
            (list count macro)))

         (evil-with-single-undo
           (let ((last-kbd-macro macro))
             (calc-call-last-kbd-macro (or count 1)))))

       :config
       (advice-add 'calc-scroll-down :around
                   (defun calc-scroll-down--make-goto-point-min+ (func &rest args)
                     "For some reason, scrolling before `point-min' doesn't change point."
                     (let ((current-point (point)))
                       (apply func args)

                       (when (eq (point) current-point)
                         (calc-goto-point-min+))))))
   #+end_src

   #+begin_src emacs-lisp
     (provide '+pkg-calc)
   #+end_src

** Change Log Mode                                         :builtin:disabled:
   :PROPERTIES:
   :header-args+: :tangle (lisp! "+pkg-change-log-mode.el")
   :header-args+: :tangle no
   :END:

   #+begin_src emacs-lisp :tangle yes :tangle no
     (require '+pkg-change-log-mode)
   #+end_src

   #+BEGIN_SRC emacs-lisp
     (use-package +pkg-evil
       :autoload evil-set-initial-state
       :config (evil-set-initial-state 'change-log-mode 'motion))

     (use-package add-log
       :hide-whitespace+ change-log-mode
       :lazy-leader
       (:mode 'change-log-mode
        "SPC" 'change-log-goto-source
        "f" 'change-log-find-file
        "j" 'add-log-edit-next-comment
        "K" 'add-log-edit-prev-comment)

       :general
       (:states 'motion
        :keymaps 'change-log-mode-map
        "o" 'change-log-goto-source
        "C-j" 'add-log-edit-next-comment
        "C-K" 'add-log-edit-prev-comment))
   #+END_SRC

   #+begin_src emacs-lisp
     (provide '+pkg-change-log-mode)
   #+end_src

** Calendar                                                         :builtin:
   :PROPERTIES:
   :header-args+: :tangle (lisp! "+pkg-calendar.el")
   :END:

   #+begin_src emacs-lisp :tangle yes
     (require '+pkg-calendar)
   #+end_src

   #+BEGIN_SRC emacs-lisp
     (use-package calendar
       :hide-whitespace+ calendar-mode
       :custom
       (diary-file (share! "diary"))

       :general
       (:states  'motion
        :keymaps 'calendar-mode-map
        ;; see also [[https://github.com/emacs-evil/evil-collection/blob/master/evil-collection-calendar.el][evil-collection]].
        ;; globally useful
        [remap quit-window] 'calendar-exit
        "p"  'calendar-print-day-of-year
        "c"  'calendar-count-days-region
        "?"  'calendar-goto-info-node
        "gr" 'calendar-redraw

        ;; jumpt to date
        "."  'calendar-goto-today
        "h"  'calendar-backward-day
        "j"  'calendar-forward-week
        "k"  'calendar-backward-week
        "l"  'calendar-forward-day
        "0"  'calendar-beginning-of-week
        "$"  'calendar-end-of-week
        "[[" 'calendar-backward-year
        "]]" 'calendar-forward-year
        "("  'calendar-beginning-of-month
        ")"  'calendar-end-of-month
        "{"  'calendar-backward-month
        "}"  'calendar-forward-month
        "/"  'calendar-goto-date

        "C-h" 'calendar-backward-month
        "C-l" 'calendar-forward-month
        "C-j" 'calendar-scroll-left-three-months
        "C-k" 'calendar-scroll-right-three-months

        ;; marking and unmarking
        "X"  'calendar-unmark
        "v"  'calendar-set-mark
        "x"  'calendar-mark-holidays

        ;; diary interaction
        "D"  'diary-view-other-diary-entries
        "d"  'diary-view-entries
        "m"  'diary-mark-entries
        "s"  'diary-show-all-entries))
   #+END_SRC

   #+begin_src emacs-lisp
     (provide '+pkg-calendar)
   #+end_src

** Custom                                                           :builtin:
   :PROPERTIES:
   :header-args+: :tangle (lisp! "+pkg-custom.el")
   :END:

   Mode definition for the customise interface.

   #+begin_src emacs-lisp :tangle yes
     (require '+pkg-custom)
   #+end_src

   #+BEGIN_SRC emacs-lisp
     (use-package +pkg-evil
       :autoload evil-set-initial-state
       :config (evil-set-initial-state 'Custom-mode 'motion))

     (use-package cus-edit
       :hide-whitespace+
       Custom-mode
       customize-mode

       :lazy-leader
       (:mode '(Custom-mode
                notmuch-hello-mode)
        "SPC" 'customize-apropos
        "g" 'customize-group
        "f" 'customize-face
        "h" 'Custom-goto-parent
        "j" 'widget-forward
        "k" 'widget-backward
        "l" 'widget-forward)

       :general
       (:states  'motion
        :keymaps 'custom-mode-map

        "RET" 'widget-button-press

        ;; motion
        "TAB"       'widget-forward
        "S-TAB"     'widget-backward
        "<backtab>" 'widget-backward

        "RET" 'Custom-newline

        "]]" 'widget-forward
        "[[" 'widget-backward

        "gh" 'Custom-goto-parent
        "gl" 'widget-forward

        "gj" 'widget-forward
        "gk" 'widget-backward

        ;; quit
        [remap quit-window] 'Custom-buffer-done)
       (:keymaps 'widget-field-keymap
        "<override-state>" 'insert))
   #+END_SRC

   #+begin_src emacs-lisp
     (provide '+pkg-custom)
   #+end_src

** Debug                                                            :builtin:
   :PROPERTIES:
   :header-args+: :tangle (lisp! "+pkg-debug.el")
   :END:

   Emacs builtin debugger configuration.

   #+begin_src emacs-lisp :tangle yes
     (require '+pkg-debug)
   #+end_src

   #+BEGIN_SRC emacs-lisp
     (use-package +pkg-evil
       :autoload evil-set-initial-state
       :config (evil-set-initial-state 'debugger-mode 'motion))

     (use-package debug
       :leader
       ("kd" 'debug-on-entry
        "kx" 'cancel-debug-on-entry)

       :general
       (:keymaps 'debugger-mode-map
        [remap quit-window] 'debugger-quit)
       (:keymaps 'debugger-mode-map
        :states 'motion
        "TAB" 'forward-button
        "RET" 'backtrace-help-follow-symbol
        "+" 'backtrace-multi-line
        "-" 'backtrace-single-line
        "=" 'debugger-return-value                                                   ; exit current stack frame with inputted value
        "d" 'debugger-frame                                                          ; drop a breakpoint at the frame at point
        "x" 'debugger-frame-clear                                                    ; clear a break point at the frame at point
        "c" 'debugger-continue
        "s" 'debugger-step-through
        [remap evil-next-visual-line]     'backtrace-forward-frame
        [remap evil-previous-visual-line] 'backtrace-backward-frame)

       :lazy-leader
       (:mode 'debugger-mode
        "e" 'debugger-eval-expression
        "r" 'debugger-record-expression
        "j" 'debugger-jump                                                           ; jump down to current stack frame, skipping any upcoming debug-on-entry calls
        "b" 'debugger-frame                                                          ; drop a breakpoint at the frame at point
        "a" 'debugger-list-functions                                                 ; NOTE: not all that useful interactively
        "g" 'backtrace-help-follow-symbol ;; 'backtrace-goto-source
        ;; toggles
        "c" 'backtrace-toggle-print-circle
        "." 'backtrace-expand-ellipses
        "s" 'backtrace-toggle-print-gensym
        "l" 'backtrace-toggle-locals))
   #+END_SRC

   #+begin_src emacs-lisp
     (provide '+pkg-debug)
   #+end_src

** Desktop                                                          :builtin:
   :PROPERTIES:
   :header-args+: :tangle (lisp! "+pkg-desktop.el")
   :END:

   #+begin_src emacs-lisp :tangle yes
     (use-package desktop
       :custom
       (desktop-path (list (state! "desktop/"))))
   #+end_src

** Display Line Numbers                                             :builtin:
   :PROPERTIES:
   :header-args+: :tangle (lisp! "+pkg-display-line-numbers.el")
   :END:

   #+begin_src emacs-lisp :tangle yes
     (use-package display-line-numbers
       :hook ((prog-mode . display-line-numbers-mode)
              (text-mode . display-line-numbers-mode))
       :custom
       (display-line-numbers-type 'visual
        "Prefer relative line numbers when available."))
   #+end_src

** Highlight Line                                                   :builtin:
   :PROPERTIES:
   :header-args+: :tangle (lisp! "+pkg-hl-line.el")
   :END:

   #+begin_src emacs-lisp :tangle yes
     (use-package hl-line
       :hook ((prog-mode . hl-line-mode)
              (text-mode . hl-line-mode))
       :custom
       (hl-line-sticky-flag nil
        "Only highlight line in active window."))
   #+end_src

** Eldoc                                                            :builtin:
   :PROPERTIES:
   :header-args+: :tangle (lisp! "+pkg-eldoc.el")
   :END:

   That package that displays help messages in the minibuffer.

   #+begin_src emacs-lisp :tangle yes
     (require '+pkg-eldoc)
   #+end_src

   #+BEGIN_SRC emacs-lisp
     (use-package +setup-commands :autoload cycle-hook+)

     (use-package eldoc
       :delight ""
       :commands (eldoc-doc-buffer-no-select+)
       :custom
       (eldoc-idle-delay 0.1)
       (eldoc-echo-area-prefer-doc-buffer t)
       (eldoc-echo-area-display-truncation-message nil)
       ;; (eldoc-documentation-strategy #'eldoc-documentation-compose-eagerly)

       :config
       (eval-when-compile (require '+setup-display-buffer))

       (defun eldoc-doc-buffer-no-select+ ()
         (interactive)
         (with-display-buffer-no-select-window+
           (eldoc-doc-buffer)))

       (defun eldoc-cycle-display-function+ (&optional global)
         (interactive "P")
         (cycle-hook+ 'eldoc-documentation-functions global))

       :leader
       ("ev" 'eldoc-cycle-display-function+
        "hb" 'eldoc-doc-buffer
        "ho" 'eldoc-doc-buffer-no-select+))
   #+END_SRC

   #+begin_src emacs-lisp
     (provide '+pkg-eldoc)
   #+end_src

** Electric                                                         :builtin:
   :PROPERTIES:
   :header-args+: :tangle (lisp! "+pkg-electric.el")
   :END:

   #+begin_src emacs-lisp :tangle yes
     (require '+pkg-electric)
   #+end_src

*** Electric Pair
    Electric pair is a built in module which lets auto insert matching pairs.
    For example, inserting a ~(~ will lead to emacs auto inserting ~)~.

    #+BEGIN_SRC emacs-lisp
      (use-package elec-pair
        :hook (emacs-startup . electric-pair-mode)
        :custom
        (electric-pair-skip-whitespace nil)
        (electric-pair-preserve-balance nil)

        :custom (electric-pair-inhibit-predicate #'electric-pair-inhibit-p+)
        :autoload electric-pair-default-inhibit
        :preface
        (eval-when-compile (require '+pkg-minibuffer))

        (defvar electric-pair-skip-completion-categories+
          '(environment-variable file)
          "Completion categories under which electric-pair doesn't work.")

        (defun electric-pair-inhibit-p+ (ch)
          ;; Any of the following can prevent pairing.
          (or
           (when (minibufferp)
             (member (alist-get 'category (+completion-metadata))
                     electric-pair-skip-completion-categories+))
           ;; Respect the default inhibition predicate.
           (electric-pair-default-inhibit ch))))
    #+END_SRC

*** Electric Indent
    Automatically re-indents on newlines or around other important characters.

    #+BEGIN_SRC emacs-lisp
      (use-package electric
        :hook (emacs-startup . electric-indent-mode))
    #+END_SRC

*** Electric Layout
    Automatically insert newlines after you enter characters.

    #+begin_src emacs-lisp
      (defvar electric-layout-mode-rules+ nil
        "Alist mapping from major-modes to `electric-layout-rules'.
      Each entry should be a cons of (MODE . RULES) where MODE should be a
      `major-mode' symbol or a list of such symbols. RULES should be an alist that
      can be assigned directly to `electric-layout-rules'.")
    #+end_src

    #+BEGIN_SRC emacs-lisp
      (use-package electric
        :hook (electric-layout-local-mode . electric-layout-update-rules+)
        :commands electric-layout-update-rules+
        :config
        (defun electric-layout-update-rules+ ()
          (cond
           ((bound-and-true-p electric-layout-mode)
            (when-let* ((local-rules
                         (cl-loop
                          for (mode . variables) in electric-layout-mode-rules+
                          when (seq-find #'derived-mode-p (if (consp mode)
                                                              mode
                                                            (list mode)))
                            append variables)))
              (setq-local electric-layout-rules local-rules)))
           (t
            (kill-local-variable 'electric-layout-rules)))))
    #+END_SRC

*** Appendix
    #+begin_src emacs-lisp
      (provide '+pkg-electric)
    #+end_src

** Finder Mode                                                      :builtin:
   :PROPERTIES:
   :header-args+: :tangle (lisp! "+pkg-finder-mode.el")
   :END:

   #+begin_src emacs-lisp :tangle yes
     (require '+pkg-finder-mode)
   #+end_src

   #+BEGIN_SRC emacs-lisp
     (use-package finder
       :lazy-leader
       (:mode 'finder-mode
        "?" 'finder-summary)

       :general
       (:keymaps 'finder-mode-map
        "SPC" 'nil
        "?"   'nil
        [override-state] 'motion))
   #+END_SRC

   #+begin_src emacs-lisp
     (provide '+pkg-finder-mode)
   #+end_src

** GPG                                                              :builtin:
   :PROPERTIES:
   :header-args+: :tangle (lisp! "+pkg-gpg.el")
   :END:

   Edit encrypted files from Emacs.

   #+begin_src emacs-lisp :tangle yes
     (use-package epg
       :custom
       (epg-pinentry-mode 'loopback)
       (epg-user-id user-mail-address))
   #+end_src

** FlySpell                                                        :optional:
   :PROPERTIES:
   :header-args+: :tangle (package-lisp! +pkg-flyspell flyspell)
   :END:

   On the fly spell checker. Spawns an [[man:aspell(1)][aspell]] sub-process and passes any words you
   write to it. Any misspellings or unknown words will be highlighted as their
   misspelled.

   #+begin_src emacs-lisp :tangle (package-yes! flyspell)
     (require '+pkg-flyspell)
   #+end_src

*** Ispell                                                          :builtin:
    #+BEGIN_SRC emacs-lisp
      (use-package ispell
        :custom
        (ispell-personal-dictionary (join-path+ (xdg-config-home) "enchant" "en_GB.dic"))
        (ispell-alternate-dictionary (join-path+ (xdg-config-home) "ispell" "english-words.txt"))

        :autoload ispell-pdict-save
        :config
        (defun ispell-save-pdict-on-quit+ ()
          (ispell-pdict-save t))

        (add-hook 'kill-emacs-hook 'ispell-save-pdict-on-quit+))
    #+END_SRC

*** FlySpell                                                        :builtin:
    #+BEGIN_SRC emacs-lisp
      (require '+pkg-hydra)

      (use-package evil
        :autoload evil-ex-define-cmd
        :config
        (evil-ex-define-cmd "spell" #'flyspell-buffer))

      (use-package flyspell
        :delight (flyspell-mode " Fly")

        :pretty-hydra
        ((:hint nil :foreign-keys warn :quit-key "q")
        ("Move"
         (("h" flyspell-correct-previous "fix-prev")
          ("j" evil-next-flyspell-error "next")
          ("k" evil-prev-flyspell-error "prev")
          ("l" flyspell-correct-next "fix-next"))
         "Recheck"
         (("gb" flyspell-buffer "check-buffer")
          ("gr" flyspell-region "check-region")
          ("gw" flyspell-word "check-word"))
         "Correct"
         (("TAB" flyspell-auto-correct-word "cycle-suggestion")
          ("c" flyspell-correct-wrapper "correct")
          ("p" flyspell-correct-at-point "fix-at-point"))))

        :lazy-leader
        (:mode 'flyspell-mode
         :minor t
         :prefix leader-minor-mode-leader-prefix+
         "."  'flyspell-hydra/body
         "cb" 'flyspell-buffer
         "cr" 'flyspell-region
         "cw" 'flyspell-word))
    #+END_SRC

*** FlySpell Correct
    #+BEGIN_SRC emacs-lisp
      (use-package flyspell-correct
        :straight t
        :leader
        (:mode 'flyspell-mode
         :minor t
         :prefix leader-minor-mode-leader-prefix+
         leader-minor-mode-leader-prefix+ 'flyspell-correct-wrapper))
    #+END_SRC

*** Appendix
    #+begin_src emacs-lisp
      (provide '+pkg-flyspell)
    #+end_src

** Jinx                                                            :optional:
   :PROPERTIES:
   :header-args+: :tangle (package-lisp! +pkg-jinx jinx)
   :END:

   #+begin_src emacs-lisp :tangle (package-yes! jinx)
   (require '+pkg-jinx)
   #+end_src

*** Jinx Mode
    #+begin_src emacs-lisp
      (use-package jinx
        :straight t
        :delight (jinx-mode " Jinx")

        :custom
        (jinx-languages "en_GB en_US"
         ;; I write in British English... but am a developer so a use a lot of American
         ;; English in code as well.
         "Set preferred language list for jinx.")

        :config
        ;; C++ commonly adopts camel case for types.
        (push 'c-mode jinx-camel-modes)
        (push 'c-ts-mode jinx-camel-modes)
        (push 'c++-mode jinx-camel-modes)
        (push 'c++-ts-mode jinx-camel-modes)
        ;; Used for git commits, which can reference camel-cased code.
        (push 'text-mode jinx-camel-modes)

        :config
        ;; For `magit-commit-mode'.
        (setf (alist-get 'text-mode jinx-exclude-faces)
              '(git-commit-comment-file
                git-commit-comment-heading
                git-commit-comment-branch-local
                git-commit-comment-branch-remote))

        :config
        (setf (alist-get 'hledger-mode jinx-exclude-faces)
              '(font-lock-variable-name-face))

        :config
        ;; Exclude emojis and unicode symbols.
        (push (rx (any (?\U00002600 . ?\U0001ffff)))
              (alist-get t jinx-exclude-regexps))

        :general
        (:keymaps 'jinx-mode-map
         [remap ispell-word] 'jinx-correct)

        :lazy-leader
        (:mode 'jinx-mode
         :minor t
         :prefix leader-minor-mode-leader-prefix+
         leader-minor-mode-leader-prefix+ 'jinx-correct
         "l" 'jinx-languages
         "n" 'jinx-next
         "p" 'jinx-previous))
    #+end_src

*** Cape Jinx Completion                                      :comp:disabled:
    #+begin_src emacs-lisp :tangle no
      (use-package cape-jinx-completion
        :straight (cape-jinx-completion :repo "https://code.bsdgeek.org/adam/cape-jinx-completion")
        :completion+ (jinx-mode cape-jinx-completion))
    #+end_src

*** Appendix
    #+begin_src emacs-lisp
    (provide '+pkg-jinx)
    #+end_src

** GUD - Grand Unified Debugger                                     :builtin:
   :PROPERTIES:
   :header-args+: :tangle (package-lisp! +pkg-gud gud)
   :END:

   The Emacs grand unified debugger interface.

   #+begin_src emacs-lisp :tangle (package-yes! gud)
     (require '+pkg-gud)
   #+end_src

   #+begin_src emacs-lisp
     (require '+pkg-evil)
     (require '+pkg-project)

     (use-package gud
       :hook (gud-mode . gud-tooltip-mode)

       :custom
       (gud-gdb-command-name "gdb -i=mi --silent --fullname")
       (gud-gud-gdb-command-name  "gdb --silent --fullname")
       (gdb-window-configuration-directory (etc! "gdb/window-configs"))
       (gdb-default-window-configuration-file nil)

       :preface
       (defalias 'gnu-debugger+     #'gdb)
       (defalias 'gud-gnu-debugger+ #'gud-gdb)
       (defalias 'perl-debugger+    #'perldb)
       (defalias 'java-debugger+    #'jdb)

       :init
       (push `(,(rx bol
                    (or "*gud-"
                        "*locals of "
                        "*input/output of"
                        "*stack frames of"
                        "*breakpoints of"))
               (display-buffer-reuse-window
                ;; display-buffer--maybe-pop-up-frame-or-window
                display-buffer-in-side-window)
               (side . right)
               (window-width . 0.25)
               (body-function . nil))
             display-buffer-alist)

       :hide-whitespace+
       gdb-inferior-io-mode
       gdb-locals-mode
       gdb-breakpoints-mode
       gdb-frames-mode

       :init
       (evil-set-initial-state 'gdb-locals-mode 'motion)
       (evil-set-initial-state 'gdb-breakpoints-mode 'motion)
       (evil-set-initial-state 'gdb-frames-mode 'motion)

       :config
       ;; Prevent gud from selecting the displayed window. NOTE: Breaks `gdb'.
       ;; (defun gud-dont-select-on-init+ (func &rest args)
       ;;   (let ((active-buffer (current-buffer)))
       ;;     (prog1 (apply func args)
       ;;       (when-let ((window (get-buffer-window active-buffer)))
       ;;         (select-window window)))))

       ;; (advice-add 'gud-common-init :around #'gud-dont-select-on-init+)

       :autoload gud-start-in-project-root+
       :config
       ;; By default gud starts up in the current directory so completion
       ;; doesn't support the path to the binary and other useful stuff that
       ;; would normally be accessible from the root directory.
       (defun gud-start-in-project-root+ (func &rest args)
         (let ((default-directory (or (project-current-root+)
                                      default-directory)))
           (apply func args)))

       (dolist (it (list 'gdb 'gud-query-cmdline 'gud-gdb 'perldb 'jdb 'pdb 'guiler 'dbx 'xdb 'sdb))
         (advice-add it :around #'gud-start-in-project-root+))

       :commands gud-quit-session+
       :config
       (defun gud-quit-session+ ()
         (interactive)
         (if (and gud-comint-buffer
                  (buffer-live-p gud-comint-buffer))
             (kill-buffer gud-comint-buffer)
           (user-error "No GUD session buffer found")))

       :leader
       ("v" '(:ignore t :wk "debugger")
        ;; "vv" 'gud-gdb
        "vv" 'gdb)
       (:prefix "v"
        "DEL" 'gud-quit-session+
        "!" 'gud-basic-call "1" 'gud-basic-call
        "r" 'gud-run
        "b" 'gud-break
        "t" 'gud-tbreak                                                              ; Temporary breakpoint
        "c" 'gud-cont
        "f" 'gud-finish                                                              ; Current function
        "j" 'gud-jump                                                                ; To current line
        "e" 'gud-print                                                               ; Eval expression at point
        "g" 'gud-refresh                                                             ; Redraw buffers
        "x" 'gud-remove
        "s" 'gud-step
        "n" 'gud-next
        "u" 'gud-until                                                               ; Continue until current line
        "w" 'gud-watch
        "]" 'gud-down                                                                ; Stack-frames
        "[" 'gud-up))

     (use-package gdb-mi
       :commands gdb-many-windows
       :leader
       (:prefix "v"
        "SPC" 'gdb-many-windows))
   #+end_src

   #+begin_src emacs-lisp
     (provide '+pkg-gud)
   #+end_src

** Help                                                             :builtin:
   :PROPERTIES:
   :header-args+: :tangle (lisp! "+pkg-help.el")
   :END:

   #+begin_src emacs-lisp :tangle yes
     (use-package help
       :custom
       (describe-bindings-outline t)
       :config
       ;; Once was enough, stop repeating the same message please :P
       (advice-add 'help-window-display-message :around #'ignore))
   #+end_src

** Gamegrid                                                         :builtin:
   :PROPERTIES:
   :header-args+: :tangle (lisp! "+pkg-gamegrid.el")
   :END:

   #+begin_src emacs-lisp :tangle yes
     (use-package gamegrid
       :custom
       (gamegrid-user-score-file-directory (share! "gamegrid/")))
   #+end_src

** Imenu
   :PROPERTIES:
   :header-args+: :tangle (lisp! "+pkg-imenu.el")
   :END:

   See (and jump to) key points of interest in the current buffer using your
   completion framework of choice.

   #+begin_src emacs-lisp :tangle yes
     (require '+pkg-imenu)
   #+end_src

*** Imenu                                                           :builtin:
    #+BEGIN_SRC emacs-lisp
      (use-package imenu
        :leader ("ji" 'imenu))
    #+END_SRC

*** Imenu List
    :PROPERTIES:
    :header-args+: :tangle (package-lisp! +pkg-imenu imenu)
    :END:

    #+BEGIN_SRC emacs-lisp
      (use-package evil
        :autoload evil-set-initial-state
        :config (evil-set-initial-state 'imenu-list-major-mode 'motion))

      (use-package imenu-list
        :straight t
        :leader
        ("jI" 'imenu-anywhere)

        :general
        (:states 'motion
         :keymaps 'imenu-list-major-mode-map
         "gr" 'imenu-list-refresh
         "o"  'imenu-list-display-entry))
    #+END_SRC

*** Imenu Anywhere
    :PROPERTIES:
    :header-args+: :tangle (package-lisp! +pkg-imenu imenu)
    :END:

    #+BEGIN_SRC emacs-lisp
      (use-package imenu-anywhere
        :straight t
        :leader ("bi" 'imenu-list))
    #+END_SRC

*** Appendix
    #+begin_src emacs-lisp
      (provide '+pkg-imenu)
    #+end_src

** Info                                                             :builtin:
   :PROPERTIES:
   :header-args+: :tangle (lisp! "+pkg-info.el")
   :END:

   #+begin_src emacs-lisp :tangle yes
     (require '+pkg-info)
   #+end_src

   #+BEGIN_SRC emacs-lisp
     (use-package info
       :hide-whitespace+ Info-mode
       :leader
       ("hi" 'info-apropos
        ;; "ai" 'info
        "ai" 'info-display-manual)

       :lazy-leader
       (:mode 'Info-mode
        "h" 'Info-directory
        "?" 'Info-summary
        "G" 'Info-goto-node
        "g" 'Info-menu
        "y" 'Info-copy-current-node-name
        "r" 'Info-history
        "i" 'Info-index
        "I" 'Info-virtual-index
        "a" 'Info-top-node
        "e" 'Info-final-node
        )

       :general
       (:keymaps 'Info-mode-map
        [remap imenu] 'Info-menu
        [remap imenu-anywhere] 'Info-menu
        leader-key nil
        "DEL" nil ; was `Info-scroll-down'
        "S-SPC" nil ; was `Info-scroll-down'
        "m" nil ; was `Info-menu'
        "t" nil ; was `Info-top-node'
        "T" nil ; was `Info-toc'
        "f" nil ; was `Info-follow-reference'
        "?" nil ; was `Info-summary'
        "L" nil ; was `Info-history'
        "s" nil ; was `Info-search'
        "S" nil ; was `Info-search-case-sensitively'
        "w" nil ; was `Info-copy-current-node-name'
        "b" nil ; was `beginning-of-buffer'
        "e" nil ; was `end-of-buffer'
        "g" nil ; was `Info-goto-node'
        "n" nil ; was `Info-next'
        "p" nil ; was `Info-prev'
        "r" nil ; was `Info-history-forward'
        "u" nil ; was `Info-up'
        "." nil ; was `beginning-of-buffer'
        ">" nil ; was `Info-top-node'
        "<" nil ; was `Info-final-node'
        "," nil ; was `Info-index-next'
        )
       (:keymaps 'Info-mode-map
        :states 'motion
        leader-key nil

        "l" 'evil-forward-char
        "h" 'evil-backward-char

        "RET" 'Info-follow-nearest-node
        "S-TAB" 'Info-prev-reference
        "TAB" 'Info-next-reference
        [C-i] 'Info-next-reference

        "gu" 'Info-up
        "gj" 'Info-forward-node
        "gk" 'Info-backward-node

        "g1" 'Info-nth-menu-item
        "g2" 'Info-nth-menu-item
        "g3" 'Info-nth-menu-item
        "g4" 'Info-nth-menu-item
        "g5" 'Info-nth-menu-item
        "g6" 'Info-nth-menu-item
        "g7" 'Info-nth-menu-item
        "g8" 'Info-nth-menu-item
        "g9" 'Info-nth-menu-item))
   #+END_SRC

   #+begin_src emacs-lisp
     (provide '+pkg-info)
   #+end_src

** Minibuffer                                                       :builtin:
   :PROPERTIES:
   :header-args+: :tangle (lisp! "+pkg-minibuffer.el")
   :END:

   #+begin_src emacs-lisp :tangle yes
   (require '+pkg-minibuffer)
   #+end_src

*** Minibuffer
    #+begin_src emacs-lisp
      (use-package +setup-show-whitespace
        :hook (minibuffer-setup . +hide-trailing-whitespace))
    #+end_src

    #+begin_src emacs-lisp
      (defun minibuffer-input+ ()
        "Get the input to the last minibuffer prompt."
        (cond ((bound-and-true-p vertico-mode)
               (car (bound-and-true-p vertico--input)))
              (t (buffer-substring-no-properties
                  (line-beginning-position)
                  (line-end-position)))))

      (cl-defsubst +completion-metadata (&optional input)
        (completion-metadata
         (or input
             (buffer-substring (minibuffer-prompt-end)
                               (max (minibuffer-prompt-end) (point))))
         minibuffer-completion-table
         minibuffer-completion-predicate))
    #+end_src

    #+begin_src emacs-lisp
     (use-package minibuffer
       :init
       (defun minibuffer-forward-char-or-exit+ ()
         (interactive)
         (call-interactively (if (eolp)
                                 'exit-minibuffer
                               'forward-char)))

       :general
       ;; There are a *tonne* of minibuffer-completion maps. See [[info:emacs#Minibuffer Maps][minibuffer maps]].
       (:keymaps 'minibuffer-local-map
        "C-j" 'next-line
        "C-k" 'previous-line
        "C-h" 'backward-char
        "C-l" 'minibuffer-forward-char-or-exit+                                      ; exit-minibuffer
        "C-d" 'scroll-up-command
        "C-u" 'scroll-down-command                                                   ; minibuffer-scroll-down-command
        "C-o" 'end-of-buffer
        "M-o" 'beginning-of-buffer                                                   ; minibuffer-beginning-of-buffer
        "M-j" 'next-history-element
        "M-k" 'previous-history-element
        "C-s" 'previous-matching-history-element
        "C-a" 'move-beginning-of-line
        "C-e" 'move-end-of-line
        [C-i] "TAB"
        "C-c C-u" 'universal-argument
        "C-v" 'quoted-insert
        "M-DEL" 'kill-whole-line
        "C-c C-j" 'forward-paragraph
        "C-c C-k" 'backward-paragraph

        ;; "C-?" 'minibuffer-completion-help
        ;; "M-h" 'backward-kill-sentence
        ;; "M-l" 'kill-sentence

        "M-l" 'minibuffer-recenter-top-bottom)
       (:keymaps 'minibuffer-local-must-match-map
        "TAB" 'minibuffer-complete
        "<C-tab>" 'minibuffer-complete-and-exit
        "C-j" nil)
       (:keymaps '(minibuffer-local-map
                   minibuffer-local-must-match-map
                   minibuffer-inactive-mode-map
                   minibuffer-local-ns-map
                   minibuffer-local-completion-map)
        "<escape>" 'abort-recursive-edit))
    #+end_src

    Some more sage advice from the demigods at [[https://github.com/hlissner/doom-emacs/blob/develop/docs/faq.org#how-does-doom-start-up-so-quickly][doom]].

    #+begin_src emacs-lisp
      (use-package minibuffer
        :hook ((minibuffer-setup . defer-garbage-collection+)
               (minibuffer-setup . restore-garbage-collection+))

        :preface
        (defun defer-garbage-collection+ ()
          (setq gc-cons-threshold most-positive-fixnum))

        (defvar default-gc-cons-threshold+)
        (defun restore-garbage-collection+ ()
          ;; Deferred so that commands launched immediately after will enjoy the
          ;; benefits.
          (run-at-time
           1 nil (lambda () (setq gc-cons-threshold default-gc-cons-threshold+)))))
    #+end_src

*** Minibuffer Bindings
    Helpers to define completion category dependent bindings.

    #+begin_src emacs-lisp
      (defun define-minibuffer-key+ (key &rest defs)
        "Define KEY conditionally in the minibuffer.
      DEFS is a plist associating completion categories to commands."
        (define-key minibuffer-local-map key
          (list 'menu-item nil defs :filter
                (lambda (d)
                  (let ((cat (completion-metadata-get
                              (completion-metadata (minibuffer-contents)
                                                   minibuffer-completion-table
                                                   minibuffer-completion-predicate)
                              'category)))
                    (or (plist-get d cat)
                        (plist-get d t)))))))
    #+end_src

    When completing file names I'd prefer if kill-word killed base-name.

    #+begin_src emacs-lisp
      (defvar minibuffer-file-backward-kill-word-kills-basename+ nil
        "When t trying to kill backwards in `find-file' kills the entire basename.")

      (defun minibuffer-backward-kill-file-name+ (input)
        (interactive (list (minibuffer-input+)))
        (setq input (substitute-in-file-name input))
        (let (;; Append successive kills together instead of replacing them each time.
              (last-command (if (eq last-command 'minibuffer-backward-kill-file-name+)
                                'kill-region
                              last-command)))
          (if (equal input "/")
              (kill-region (point-max) (- (point-max) 1))
            (let* ((dirname (or (file-name-directory input) ""))
                   (basename (file-name-nondirectory input))
                   (trailing-slash-p (string-suffix-p "/" dirname)))
              (when trailing-slash-p
                (setq dirname (s-chop-suffix "/" dirname)))

              (cond
               ((not (string-empty-p basename))
                (if minibuffer-file-backward-kill-word-kills-basename+
                    (kill-region (point-max) (- (point-max) (length basename)))
                  (call-interactively #'backward-kill-word)))
               ;; Handle edge cases with last directory or magic tilde.
               ((string-equal dirname "~")
                (kill-region (point-max)
                             (- (point-max) 1 (if trailing-slash-p 1 0)))
                (insert (file-name-directory (expand-file-name "~"))))
               ;; Kill from EOL to the cut off point for the previous directory.
               (t
                (kill-region (point-max)
                             (- (point-max)
                                (-
                                 (length dirname)
                                 (length (or (file-name-directory dirname) ""))
                                 (if trailing-slash-p -1 0))))))))))


      (use-package minibuffer
        :config
        (define-minibuffer-key+ (kbd "C-w")
          'file #'minibuffer-backward-kill-file-name+
          t #'backward-kill-word))
    #+end_src

*** Minibuffer Sorting
    This section declares custom sort functions for various completion categories.
    For the most part I use the following alist to associate specific sorting
    functions with completion categories.

    #+begin_src emacs-lisp
      (defvar +completion-category-sort-func-overrides nil
        "Custom sort functions based on completion categories.")
    #+end_src

    When completing file-names or directories I'd rather have the directories come
    before the files.
    This matches the same format I have for ~ls~ or ~dired~.

    #+begin_src emacs-lisp
      (defvar +directories-before-files-stable nil
        "When true sort directories before files stably.
      This means that when using prescient or a completion framework
      that remembers and re-orders candidates based on frecency, you
      can maintain this relative ordering while still partitioning
      files from directories.

      When disabled the sorting should be closer to ls or [[man:sort][sort]] -V.")

      (defun +directories-before-files (files)
        (if +directories-before-files-stable
            (nconc (seq-filter (lambda (x) (string-suffix-p "/" x)) files)
                   (seq-remove (lambda (x) (string-suffix-p "/" x)) files))
          (sort files
                (lambda (x y)
                  (let ((x-dir (eq (aref x (- (length x) 1)) ?/))
                        (y-dir (eq (aref y (- (length y) 1)) ?/)))
                    (cond
                     ((and x-dir y-dir)
                      (string< (directory-file-name x)
                               (directory-file-name y)))
                     (x-dir t)
                     (y-dir nil)
                     (t (string< x y))))))))

      (push `(file . ,#'+directories-before-files)
            +completion-category-sort-func-overrides)
    #+end_src

    And this is just a helper function that can be used by any completion UI to find
    out which sorting function I want for given completion metadata. By default if the
    metadata specifies its own sort function then that takes priority. If this function
    returns ~nil~ then you should use the default sorting function for your completion
    framework.

    #+begin_src emacs-lisp
      (defun +completion-category-sort-func (metadata)
        (or
         (completion-metadata-get metadata 'display-sort-function)
         (alist-get (completion-metadata-get metadata 'category)
                    +completion-category-sort-func-overrides)))
    #+end_src

*** Minibuffer Highlighting
    This section declares custom highlight functions based on completion categories.

    #+begin_src emacs-lisp
      (defvar +completion-category-hl-func-overrides nil
        "Custom highlight functions based on completion categories.")
    #+end_src

    File name completions have directories highlighted separately from files.

    #+begin_src emacs-lisp
      (defun +completion-category-highlight-files (cand)
        (let ((len (length cand)))
          (when (and (> len 0)
                     (eq (aref cand (1- len)) ?/))
            (add-face-text-property 0 len 'font-lock-function-name-face 'append cand)))
        cand)

      (push `(file . ,#'+completion-category-highlight-files)
            +completion-category-hl-func-overrides)
    #+end_src

    This function associates a highlight function with the given completion metadata.

    #+begin_src emacs-lisp
      (defun +completion-category-hl-func (metadata)
        (alist-get (completion-metadata-get metadata 'category)
                   +completion-category-hl-func-overrides))
    #+end_src

    Here's something unconventional. Ivy has this thing where the current candidate
    overrides any local faces of the candidate and only shows up using the current
    candidate face (configured by each completion framework) and any faces for the
    query matches. This is actually pretty great for themes that use strong colors
    that may not contrast on each other very well. However this doesn't translate
    well to  orderless which simply append a new face to the existing face spec.

    The following code block makes the current candidate face *override* the existing
    faces of the candidate and then overrides any query faces such as orderless or
    prescient on top of that to make it appear closer to ivy. This has a pretty
    obvious performance hit (especially for long candidates) however because it's
    only done on at most one candidate it should be negligible. That said if you have
    any performance issues you can set ~minibuffer-override-faces+~ to ~nil~ to disable
    this.

    #+begin_src emacs-lisp
      (defvar minibuffer-override-faces+ '(orderless-match-face-0
                                           orderless-match-face-1
                                           orderless-match-face-2
                                           orderless-match-face-3
                                           completions-common-part
                                           completions-first-difference
                                           consult-highlight-match)
        "The faces that should remain on top of the current candidate face.
      Set to nil to disable face overriding.")

      (defvar minibuffer-override-face-ignore+ '(face)
        "List of completion categories to avoid face overriding in.")

      (defun minibuffer-override-face-chunks+ (str)
        "Find regions in STR where a different face should be applied."
        ;; TODO: use `next-single-property-change'.
        (cl-loop for i from 0 to (length str)
                 with last-face = nil
                 with current-face = nil
                 do (setq current-face
                          (when-let* ((face (get-text-property i 'face str)))
                            (if (listp face) (car face) face)))
                 with seq-range = nil
                 when (and current-face (member current-face minibuffer-override-faces+))
                   when seq-range
                     when (eq current-face last-face)
                       ;; Increment existing sequence
                       do (setcdr seq-range i)
                     else
                       ;; Finished previous sequence and started a new one
                       collect (cons last-face seq-range)
                       and do (setq seq-range (cons i i))
                     end
                   else
                     do (setq seq-range (cons i i))
                   end
                 else when seq-range
                   collect (cons last-face seq-range)
                   and do (setq seq-range nil)
                 end
                 do (setq last-face current-face)))

      (defun minibuffer-override-face+ (current-face str)
        (when (and minibuffer-override-faces+
                   (not (member (completion-metadata-get (+completion-metadata) 'category)
                                minibuffer-override-face-ignore+)))
          (let ((copied (copy-sequence str)))
            (if (version< emacs-version "27")
                (font-lock-prepend-text-property 0 (length copied) 'face current-face copied)
              (add-face-text-property 0 (length copied) current-face nil copied))

            (dolist (seq (minibuffer-override-face-chunks+ str))
              (cl-destructuring-bind (face . (start . end))
                  seq
                (if (version< emacs-version "27")
                    (font-lock-prepend-text-property start end 'face face copied)
                  (add-face-text-property start (1+ end) face nil copied))))
            copied)))
    #+end_src

*** Minibuffer Depth                                                :builtin:
    #+BEGIN_SRC emacs-lisp
      (use-package mb-depth
        :hook (after-init . minibuffer-depth-indicate-mode))
    #+END_SRC

*** All The Icons Completion
    :PROPERTIES:
    :header-args+: :tangle (package-lisp! +pkg-minibuffer :consult (var +completions-icon))
    :END:

    #+begin_src emacs-lisp
      (use-package all-the-icons-completion
        :straight t
        :hook (marginalia-mode . all-the-icons-completion-marginalia-setup)

        :init
        (advice-add 'all-the-icons-completion-get-icon :filter-return
                    #'all-the-icons-pad-on-tty-advice+)

        :config
        (cl-defmethod all-the-icons-completion-get-icon (cand (_cat (eql project)))
          (all-the-icons-completion-get-icon cand 'file)))

      (use-package +pkg-all-the-icons
        :autoload all-the-icons-pad-on-tty-advice+
        :config
        (advice-add 'all-the-icons-completion-get-icon :filter-return
                    #'all-the-icons-pad-on-tty-advice+))
    #+end_src

*** Appendix
    #+begin_src emacs-lisp
    (provide '+pkg-minibuffer)
    #+end_src

** Compile
   :PROPERTIES:
   :header-args+: :tangle (lisp! "+pkg-compile.el")
   :END:

   In Emacs compile interface.

   This is basically a thin wrapper around a shell command to run compilations with
   support for parsing out certain messages such as compiler warnings or errors.

   #+begin_src emacs-lisp :tangle yes
     (require '+pkg-compile)
   #+end_src

*** Compile Mode
    #+BEGIN_SRC emacs-lisp
      (use-package evil
        :autoload evil-set-command-property
        :config
        (evil-set-command-property 'next-error :jump t)
        (evil-set-command-property 'previous-error :jump t))

      (use-package compile
        :hook ((next-error . recenter)
               (compilation-mode . hack-dir-local-variables-non-file-buffer))
        :hide-whitespace+ compilation-mode
        :custom
        (compilation-skip-threshold 0)
        (next-error-verbose nil)
        (compilation-ask-about-save nil)
        (compilation-message-face 'default)
        (next-error-message-highlight nil)
        (compilation-always-kill t)
        (compilation-read-command nil)
        (compilation-scroll-output 'first-error)

        :preface (use-package ansi-color :autoload ansi-color-compilation-filter)
        :hook (compilation-filter . ansi-color-compilation-filter)

        :config
        ;; Setup a GNU matcher variant for ctest -V invocations.
        (setf
         (alist-get 'gnu+ctest compilation-error-regexp-alist-alist)
         (let* ((gnu (alist-get 'gnu compilation-error-regexp-alist-alist))
                (new-regex (seq-copy gnu)))
           (setcar new-regex (concat (rx bol (? (+ digit) ": "))
                                     (string-remove-prefix (rx bol) (car new-regex))))
           new-regex))

        (when-let* ((entry (member 'gnu compilation-error-regexp-alist)))
          (setcar entry 'gnu+ctest))

        :autoload compile--double-prefix-means-run-comint+
        :init (advice-add #'compile :filter-args #'compile--double-prefix-means-run-comint+)
        :config
        (defun compile--double-prefix-means-run-comint+ (args)
          "Override prefix behaviour for `compile'.
      Only run compile in comint when `current-prefix-arg' is C-u C-u."
          (when (and (cadr args)
                     (not (eq (car-safe current-prefix-arg) 16)))
            (setf (cadr args) nil))
          args)

        :general
        (:states 'motion
         :keymaps 'compilation-mode-map
         "j" nil "k" nil)
        (:keymaps 'emacs-lisp-compilation-mode-map
         [remap revert-buffer] 'emacs-lisp-compilation-recompile))
    #+END_SRC

    #+begin_src emacs-lisp
      (use-package compile
        :autoload compilation-buffer-name

        :commands kill-compilation-windows+
        :leader ("cv" 'kill-compilation-windows+)
        :config
        (defun kill-compilation-windows+ ()
          (interactive)
          (when-let* ((buf (next-error-find-buffer)))
            (delete-windows-on buf)))

        :commands display-compilation-buffer+
        :leader ("cb" 'display-compilation-buffer+)
        :config
        (defun display-compilation-buffer+ ()
          (interactive)
          (if-let* ((buffer (next-error-find-buffer)))
              (select-window
               (display-buffer buffer
                               '(nil
                                 (reusable-frames . nil))))
            (user-error "Could not determine compilation-buffer."))))
    #+end_src

*** Set Compilation Bindings
    #+begin_src emacs-lisp
      (defun +set-compilation-bindings (mode map)
        (leader-set-keys-for-major-mode mode
          "x" 'kill-compilation
          "f" 'next-error-follow-minor-mode)

        (general-define-key
         :keymaps map
         "S-SPC" nil "SPC" nil "DEL" nil "M-p" nil "M-n" nil "M-{" nil "M-}" nil
         "0" nil "h" nil "g" nil "?" nil "n" nil "p" nil "<override-state>" nil)

        (general-define-key
         :keymaps map
         [remap revert-buffer] 'recompile)

        (general-define-key
         :keymaps map
         :states  'motion
         "x"   'kill-compilation

         "RET" 'compile-goto-error
         ;; Flash error location in another-window without selecting it.
         "o"     'compilation-display-error
         "M-RET" 'compilation-display-error
         ;; Move to the next error in compilation buffer.
         "gj"    'compilation-next-error
         "gk"    'compilation-previous-error
         ;; Flash next-error location and move to it.
         "gn"    'next-error-no-select
         "gp"    'previous-error-no-select

         "C-j"     'compilation-next-file
         "C-k"     'compilation-previous-file
         "C-c C-n" 'compilation-next-file
         "C-c C-p" 'compilation-previous-file))

      (use-package compile
        :init
        (+set-compilation-bindings 'compilation-mode 'compilation-mode-map))
    #+end_src

*** Auto Kill Compilation Window
    #+begin_src emacs-lisp
      (defvar compilation-auto-kill-predicate+
        (defun compilation-auto-kill-predicate+ ()
          "Skip killing the compilation window if not in a side-window."
          (window-at-side-p (get-buffer-window)))
        "Predicate ran just before killing a compilation buffer.0")

      (defvar compilation-auto-kill-window+ 2
        "If non-nil, after a successfull compilation the compilation
      window, if open, will automatically be deleted.

      If set to a numerical value, window will be deleted after that many
      seconds.")

      (defvar compilation-auto-kill-ignore-modes+ nil
        "Major modes spawned by `compile' for which auto-kill doesn't take place.")

      (defvar compilation-dont-auto-kill-window-when+ '(warnings focus)
        "Specify not to kill the window when warning, error or info given.
      a list which can take in any symbol from (errors infos warnings).

      you can also specify a symbol, focus, to cancel window killing when
      the compilation window was already open when the compilation was
      started.")

      (defvar-local compilation-was-open-p+ nil
        "True whether the compilation window was visible when compilation began.")

      (advice-add 'compilation-start :around
                  (defun compilation-check-window-was-open+ (func command &optional mode name-function highlight-regexp)
                    ;; name-of-mode and buf-name sourced from compile.el
                    (let* ((mode (or mode 'compilation-mode))
                           (name-of-mode (if (eq mode t)
                                             "compilation"
                                           (replace-regexp-in-string "-mode\\'" "" (symbol-name mode))))
                           (buf-name (compilation-buffer-name name-of-mode mode name-function))
                           (compilation-was-visible (when (get-buffer-window buf-name t) t)))
                      ;; Start compilation and then assign `compilation-was-open-p+'.
                      (with-current-buffer (funcall func command mode name-function highlight-regexp)
                        (setq-local compilation-was-open-p+ compilation-was-visible)))))

      (defun compilation-safely-close-window+ (buffer)
        (when (and buffer
                   (buffer-live-p buffer)
                   (not (get-buffer-process buffer)))
          ;; Kill the compilation window and switch back to the active window.
          (save-selected-window
            (quit-windows-on buffer))
          ;; Sometimes killing the compilation buffer while the minibuffer was active
          ;; causes some artifacts on the display. We rerender to silence them.
          (when (minibufferp)
            (redraw-display))))

      (defun compilation-cancel-auto-kill-p+ ()
        "Whether to cancel compilation window auto-kill.
      Based on `compilation-dont-auto-kill-window-when+'."
        (cl-loop for (name . var) in '((errors   . compilation-num-errors-found)
                                       (warnings . compilation-num-warnings-found)
                                       (infos    . compilation-num-infos-found))
                 when (and (member name compilation-dont-auto-kill-window-when+)
                           (not (zerop (eval var))))
                   collect (symbol-name name)))

      (defun compilation-finish-function+ (buf str)
        "hook to automatically hide compilation output."
        (when (and compilation-auto-kill-window+
                   (or (not (member 'focus compilation-dont-auto-kill-window-when+))
                       (with-current-buffer buf
                         (not compilation-was-open-p+)))
                   ;; An abnormal exit automatically cancels window kill.
                   (not (string-match-p (rx (zero-or-more any)
                                            "exited abnormally"
                                            (zero-or-more any))
                                        str))
                   (not (apply 'derived-mode-p compilation-auto-kill-ignore-modes+)))
          (let ((terminate-window t))
            (when-let* ((notifications (compilation-cancel-auto-kill-p+)))
              (when debug-on-error
                (message "Window kill suspended due to encountering: %s"
                         (combine-and-quote-strings notifications)))
              (setq terminate-window nil))

            (when compilation-auto-kill-predicate+
              (with-current-buffer buf
                (setq terminate-window (funcall compilation-auto-kill-predicate+))))

            (when terminate-window
              (if (numberp compilation-auto-kill-window+) ;; kill after delay
                  (run-at-time (concat (number-to-string compilation-auto-kill-window+)
                                       " sec")
                               nil 'compilation-safely-close-window+ buf)
                (compilation-safely-close-window+ buf))))))

      (use-package compile
        :config
        (add-hook 'compilation-finish-functions 'compilation-finish-function+)
        (add-hook 'compilation-finish-functions
                  (defun compilation-exit-comint+ (&rest _)
                    (when (eq major-mode 'comint-mode)
                      (compilation-mode)))))
    #+end_src

*** Appendix
    #+begin_src emacs-lisp
      (provide '+pkg-compile)
    #+end_src

** Grep
   :PROPERTIES:
   :header-args+: :tangle (lisp! "+pkg-grep.el")
   :END:

   #+begin_src emacs-lisp :tangle yes
     (require '+pkg-grep)
   #+end_src

*** Grep                                                            :builtin:
    Emacs mode for interacting with output from the grep executable.

    #+BEGIN_SRC emacs-lisp
      (use-package grep
        :preface (use-package +pkg-compile :autoload +set-compilation-bindings)
        :config
        (+set-compilation-bindings 'grep-mode 'grep-mode-map))
    #+END_SRC

*** Writable Grep
    Allows you to edit and persists changes to grep-buffers to the underlying
    files... kinda like occur-mode.

    #+begin_src emacs-lisp
      (use-package wgrep
        :straight t
        :after grep
        :custom
        (wgrep-too-many-file-length 15)

        :config
        (advice-add 'wgrep-change-to-wgrep-mode :after 'evil-normal-state)
        (advice-add 'wgrep-abort-changes :after 'evil-motion-state)
        (advice-add 'wgrep-exit :after 'evil-motion-state)
        (advice-add 'wgrep-finish-edit :after 'evil-motion-state)

        :leader
        (:mode 'grep-mode
         "e" 'wgrep-change-to-wgrep-mode)
        :general
        (:keymaps 'wgrep-mode-map
         :prefix leader-major-mode-key
         "q" 'wgrep-abort-changes
         "," 'wgrep-finish-edit
         "s" 'wgrep-save-all-buffers))
    #+end_src

*** Occur                                                           :builtin:
    Grep equivalent for in Emacs buffer searches.

    #+BEGIN_SRC emacs-lisp
      (use-package +pkg-evil
        :autoload (evil-set-initial-state
                   with-evil-adjust-to-eol+)
        :config
        (evil-set-initial-state 'occur-mode 'motion)
        (evil-set-initial-state 'occur-edit-mode 'normal))

      (use-package replace
        :custom
        ;; By default highlight to the end of the line.
        (occur-highlight-regexp (rx (zero-or-more any) eol))

        :config
        ;; occur-mode-display-occurrence
        (use-package +setup-display-buffer
          :autoload display-buffer-no-select-window-advice+
          :config
          (advice-add 'occur-mode-display-occurrence :around
                      #'display-buffer-no-select-window-advice+))

        (defun evil-adjust-occur-next+ ()
          (interactive)
          (with-evil-adjust-to-eol+
            (funcall-interactively 'occur-next)))

        (defun evil-adjust-occur-prev+ ()
          (interactive)
          (with-evil-adjust-to-eol+
            (funcall-interactively 'occur-prev)))

        :lazy-leader
        (:modes '(occur-mode occur-edit-mode)
         "e" 'occur-edit-mode
         "R" 'occur-rename-buffer
         "g" 'occur-mode-goto-occurrence
         "G" 'occur-mode-goto-occurrence-other-window
         "l" 'occur-mode-display-occurrence)
        (:modes 'occur-edit-mode
         "," 'occur-cease-edit)

        :general
        (:keymaps 'occur-mode-map
         :states  'motion
         ;; occur-mode-mouse-goto
         "RET" 'occur-mode-goto-occurrence
         "o" 'occur-mode-goto-occurrence-other-window
         "M-RET" 'occur-mode-display-occurrence

         "j"  'evil-adjust-occur-next+
         "k"  'evil-adjust-occur-prev+
         "gj" 'evil-next-line
         "gk" 'evil-previous-line

         "R" 'occur-rename-buffer
         "q" nil)
        (:states  'normal
         :keymaps 'occur-edit-mode-map
         ;; occur-mode-mouse-goto
         "RET" 'occur-mode-goto-occurrence
         "go"  'occur-mode-goto-occurrence-other-window
         "gO"  'occur-mode-display-occurrence
         "gj"  'evil-adjust-occur-next+
         "gk"  'evil-adjust-occur-prev+
         [remap quit-window] 'occur-cease-edit))
    #+END_SRC

*** Appendix
    #+begin_src emacs-lisp
      (provide '+pkg-grep)
    #+end_src

** Diff                                                             :builtin:
   :PROPERTIES:
   :header-args+: :tangle (lisp! "+pkg-diff.el")
   :END:

   #+begin_src emacs-lisp :tangle yes
   (require '+pkg-diff)
   #+end_src

   #+BEGIN_SRC emacs-lisp
     (use-package +setup-display-buffer
       :config
       (advice-add 'diff-apply-hunk :around 'display-buffer-no-select-window-advice+)
       (advice-add 'diff-test-hunk :around 'display-buffer-no-select-window-advice+))

     (use-package diff-mode
       :hide-whitespace+ diff-mode
       :custom
       (diff-advance-after-apply-hunk nil)

       :preface
       (defun diff-kill-applied-hunks--ensure-all-hunks-killed+ (func &rest args)
         "`diff-kill-applied-hunks' doesn't kill any applied hunks above point :(."
         (save-excursion
           (goto-char (point-min))
           (apply func args)))

       :config
       (advice-add 'diff-kill-applied-hunks :around 'diff-kill-applied-hunks--ensure-all-hunks-killed+)

       :leader
       (:prefix leader-diff-leader-prefix+
        "" '(:ignore t :wk "diff")
        "SPC" 'diff-buffer-with-file)

       :lazy-leader
       (:mode 'diff-mode
        "a" 'diff-apply-hunk
        "r" 'diff-refine-hunk
        "c" 'diff-kill-applied-hunks ;; clean displayed hunks only works on hunks below point.
        "k" 'diff-file-kill
        "f" 'next-error-follow-minor-mode
        "n" 'diff-restrict-view ;; narrow to hunk (or file with prefix)
        "s" 'diff-reverse-direction ;; doesn't do anything?
        "t" 'diff-test-hunk
        "e" 'diff-ediff-patch
        "u" 'diff-unified->context
        "d" 'diff-context->unified
        "l" 'diff-add-change-log-entries-other-window
        "g" 'diff-goto-source)

       :general
       (:states  'motion
        :keymaps 'diff-mode-map
        "a" 'diff-apply-hunk ;; apply diff hunk to prompted file
        ;; NOTE prompts for file onto which diff is being applied
        "x" 'diff-hunk-kill
        "X" 'diff-file-kill
        "u" 'diff-undo
        "q" nil
        "s" 'diff-split-hunk
        "i" 'diff-ignore-whitespace-hunk

        "o" 'diff-goto-source
        "RET" 'diff-goto-source

        "gh" 'diff-hunk-next
        "gj" 'diff-hunk-next
        "gk" 'diff-hunk-prev
        "gl" 'diff-hunk-prev
        "TAB"   'diff-file-next
        "S-TAB" 'diff-file-prev))
   #+END_SRC

   #+begin_src emacs-lisp
   (provide '+pkg-diff)
   #+end_src

** Macros                                                           :builtin:
   :PROPERTIES:
   :header-args+: :tangle (lisp! "+pkg-macros.el")
   :END:

   #+begin_src emacs-lisp :tangle yes
     (use-package +pkg-macros
       :demand t
       :custom
       (mode-line-defining-kbd-macro nil
        "Remove the mode-line indicator for macros.")

       :leader
       ("k" '(:ignore t :wk "macros/lisp")))
   #+end_src

*** KMacro
    #+BEGIN_SRC emacs-lisp
      (use-package kmacro
        :leader
        (:prefix "k"
         ;; 'edit-kbd-macro ;; any named macro
         ;; 'apply-macro-to-region-lines
         "s" 'name-last-kbd-macro
         "i" 'insert-kbd-macro
         "q" 'kbd-macro-query ;; prompt at macro point

         "c"  '(:ignore t :wk "counter")
         "cs" 'kmacro-set-counter
         "c=" 'kmacro-set-counter
         "cc" 'kmacro-insert-counter
         "ci" 'kmacro-insert-counter
         "ca" 'kmacro-add-counter
         "c+" 'kmacro-add-counter
         "cf" 'kmacro-set-format))
    #+END_SRC

*** Edit Macro
    #+BEGIN_SRC emacs-lisp
      (use-package edmacro
        :commands (edmacro-mode)
        :leader
        (:prefix "k"
         ;; 'kmacro-edit-lossage                                                      ; edit last 300 strokes as macro
         ;; 'kmacro-step-edit-macro                                                   ; debug last macro
         "SPC" 'kmacro-edit-macro                                                     ; last defined
         "b"   'kmacro-bind-to-key)

        :config
        (leader-set-keys-for-major-mode 'edmacro-mode
          "," 'edmacro-finish-edit
          "i" 'edmacro-insert-key))
    #+END_SRC

*** Pretty Print
    #+BEGIN_SRC emacs-lisp
      (use-package pp
        :init
        :leader
        (:prefix "k"
         "m" 'pp-macroexpand-last-sexp
         "M" 'pp-macroexpand-expression
         "p" 'pp-eval-last-sexp
         "P" 'pp-eval-expression)

        :init
        (with-eval-after-load 'elisp-mode
          (leader-set-keys-for-major-mode '(emacs-lisp-mode
                                            lisp-interaction-mode)
            "eM" 'pp-macroexpand-expression
            "em" 'pp-macroexpand-last-sexp
            "ex" 'pp-eval-last-sexp
            "eX" 'pp-eval-expression)))
    #+END_SRC

*** Appendix
    #+begin_src emacs-lisp
    (provide '+pkg-macros)
    #+end_src

** Package                                                 :disabled:builtin:
   :PROPERTIES:
   :header-args+: :tangle (lisp! "+pkg-package.el")
   :header-args+: :tangle no
   :END:

   Emacs's builtin package manager, since moving to straight I've disabled this section.

   #+begin_src emacs-lisp :tangle yes :tangle no
   (require '+pkg-package)
   #+end_src

   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package package
       :config
       (evil-set-initial-state 'package-menu-mode 'motion)

       :lazy-leader
       (:mode 'package-menu-mode
        "h" 'package-menu-hide-package
        "?" 'package-menu-quick-help
        "/" 'package-menu-filter

        "m"  '(:ignore t :wk "mark")
        "m~" 'package-menu-mark-obsolete-for-deletion
        "mu" 'package-menu-mark-unmark
        "mi" 'package-menu-mark-install
        "mu" 'package-menu-mark-upgrades
        "md" 'package-menu-mark-delete)

       :general
       (:keymaps 'package-menu-mode-map
        :states  'motion
        "TAB" 'forward-button
        "<backtab>" 'backward-button
        "RET" 'package-menu-describe-package
        "DEL" 'package-menu-backup-unmark
        "("   'package-menu-toggle-hiding
        "S"   'tabulated-list-sort
        "U"   'package-menu-mark-upgrades
        "d"   'package-menu-mark-delete
        "i"   'package-menu-mark-install
        "u"   'package-menu-mark-unmark
        "x"   'package-menu-execute
        "q"   nil
        "~"   'package-menu-mark-obsolete-for-deletion))
   #+END_SRC

   #+begin_src emacs-lisp
   (provide '+pkg-package)
   #+end_src

** Outline Mode                                                     :builtin:
   :PROPERTIES:
   :header-args+: :tangle (lisp! "+pkg-outline-mode.el")
   :END:

   #+begin_src emacs-lisp :tangle yes
   (require '+pkg-outline-mode)
   #+end_src

   #+BEGIN_SRC emacs-lisp
     (use-package outline
       :autoload (outline-on-heading-p
                  outline-backward-same-level)
       :config
       (advice-add 'outline-up-heading :around
                   (defun outline-up-heading--goto-current-first+ (func arg &optional invisible-ok)
                     "make `outline-up-heading' goto the current heading first
     unless already there."
                     (unless (outline-on-heading-p invisible-ok)
                       (outline-backward-same-level 0)
                       (when arg
                         (setq arg (if (> arg 0) (- arg 1) (+ arg 1)))))

                     (when arg
                       (apply func arg invisible-ok))))

       :commands outline-folded-p+
       :autoload outline-invisible-p
       :config
       (defun outline-folded-p+ (&optional _pos)
         (save-excursion
           (goto-char (line-end-position))
           (outline-invisible-p)))

       :commands outline-toggle-show-children
       :autoload (outline-show-subtree
                  outline-hide-subtree)
       :config
       (defun outline-toggle-show-children+ ()
         (interactive)
         (if (outline-folded-p+)
             (outline-show-subtree)
           (outline-hide-subtree)))

       :lazy-leader
       (:mode 'outline-mode
        "m" 'outline-mark-subtree
        "t" 'outline-hide-body ;; show subtree
        "a" 'outline-show-all
        ;; only show outline upto this level.
        "h" 'outline-hide-sublevels
        "l" 'outline-show-branches
        "f" 'outline-hide-other ;; focus
        ;; show remainder of branches in current hidden branch.
        "q" 'outline-show-branches
        "RET" 'outline-insert-heading)

       :general
       (:states  'motion
        :keymaps 'outline-mode-map
        "gh" 'outline-up-heading
        "gj" 'outline-next-heading
        "gk" 'outline-previous-heading
        "gl" 'outline-forward-same-level)
       (:states  'motion
        :keymaps 'outline-mode-map
        :predicate '(outline-on-heading-p)
        [remap evil-shift-right] 'outline-demote
        [remap evil-shift-left]  'outline-promote
        [remap drag-stuff-down]  'outline-move-subtree-down
        [remap drag-stuff-up]    'outline-move-subtree-up
        "TAB"   'outline-toggle-show-children+
        "<tab>" 'outline-toggle-show-children+))
   #+END_SRC

   #+begin_src emacs-lisp
   (provide '+pkg-outline-mode)
   #+end_src

** Show Paren                                                       :builtin:
   :PROPERTIES:
   :header-args+: :tangle (lisp! "+pkg-show-paren.el")
   :END:

   When your point is on a parenthesis, highlight the matching one.

   #+begin_src emacs-lisp :tangle yes
     (use-package paren
       :hook (after-init . show-paren-mode))
   #+end_src

** Proced                                                           :builtin:
   :PROPERTIES:
   :header-args+: :tangle (lisp! "+pkg-proced.el")
   :END:

   Edit processes, like windows task-manager but within emacs :-).

   #+begin_src emacs-lisp :tangle yes
   (require '+pkg-proced)
   #+end_src

   #+BEGIN_SRC emacs-lisp
     (use-package +pkg-evil
       :autoload evil-set-initial-state
       :config (evil-set-initial-state 'proced-mode 'motion))

     (use-package proced
       :lazy-leader
       (:mode 'proced-mode
        "k" 'proced-send-signal

        "m"  '(:ignore t :wk "mark")
        "ma" 'proced-mark-all
        "mu" 'proced-unmark-all
        "mp" 'proced-mark-parents
        "mc" 'proced-mark-children
        "mt" 'proced-toggle-marks
        "mm" 'proced-toggle-marks)

       :general
       (:states  'motion
        :keymaps 'proced-mode-map

        "q"      nil
        "C-?"    'proced-help

        "SPC" 'proced-mark
        "DEL" 'proced-unmark-backward
        "a" 'proced-mark
        "A" 'proced-mark-all
        "u" 'proced-unmark
        "U" 'proced-unmark-all
        "p" 'proced-mark-parents
        "P" 'proced-mark-children
        "M" 'proced-toggle-marks

        "x"   'proced-send-signal
        "C-k" 'proced-send-signal

        "M-SPC" 'proced-toggle-tree

        "r" 'proced-refine
        "R" 'proced-renice

        "o" 'proced-omit-processes ;; marked

        "C-M-SPC" 'proced-format-interactive

        "sS" 'proced-sort-interactive
        "sc" 'proced-sort-pcpu
        "sm" 'proced-sort-pmem
        "sp" 'proced-sort-pid
        "ss" 'proced-sort-start
        "st" 'proced-sort-time
        "su" 'proced-sort-user
        "S"  'proced-filter-interactive))
   #+END_SRC

   #+begin_src emacs-lisp
   (provide '+pkg-proced)
   #+end_src

** Process Menu                                                     :builtin:
   :PROPERTIES:
   :header-args+: :tangle (lisp! "+pkg-process-menu.el")
   :END:

   #+begin_src emacs-lisp :tangle yes
   (require '+pkg-process-menu)
   #+end_src

   #+begin_src emacs-lisp
     (use-package +pkg-evil
       :autoload evil-set-initial-state
       :config (evil-set-initial-state 'process-menu-mode 'motion))
   #+end_src

   #+BEGIN_SRC emacs-lisp
     (use-package simple
       :hide-whitespace+ process-menu-mode
       :general
       (:states  'motion
        :keymaps 'process-menu-mode-map
        "d" 'process-menu-delete-process
        "x" 'process-menu-delete-process

        "TAB"   'forward-button
        "S-TAB" 'backward-button
        "gj"    'forward-button
        "gk"    'backward-button))
   #+END_SRC

   #+begin_src emacs-lisp
   (provide '+pkg-process-menu)
   #+end_src

** Query Replace                                                    :builtin:
   :PROPERTIES:
   :header-args+: :tangle (lisp! "+pkg-query-replace.el")
   :END:

   #+begin_src emacs-lisp :tangle yes
     (use-package query-replace
       :custom
       (query-replace-skip-read-only t)

       :leader
       ("sl" 'query-replace ; literal
        "sq" 'query-replace-regexp))
   #+end_src

** Recentf                                                          :builtin:
   :PROPERTIES:
   :header-args+: :tangle (lisp! "+pkg-recentf.el")
   :END:

   #+begin_src emacs-lisp :tangle yes
   (require '+pkg-recentf)
   #+end_src

   #+begin_src emacs-lisp
     (use-package recentf
       :hook (after-init . recentf-mode)
       :custom
       (recentf-save-file (state! "recentf.el"))
       (recentf-max-saved-items 2048
        "Keep this many files in the recentf history.")
       (recentf-auto-cleanup (* 60 60))
       (recentf-exclude (list (rx (or (and bol
                                           (or "/tmp/"
                                               "/ssh:"
                                               "/sudo:"
                                               (eval straight-base-dir)
                                               ;; Matches a temporarily generated container id.
                                               (and
                                                "/docker:"
                                                (** 12 12 (any alnum))
                                                ":")))
                                      "COMMIT_EDITMSG"
                                      (and (or "/TAGS"
                                               "/GTAGS"
                                               "/GRAGS"
                                               "/GPATH"
                                               ".mkv"
                                               ".avi"
                                               (and ".mp" (any "3" "4"))
                                               (and ".doc" (? "x"))
                                               ".sub"
                                               ".srt"
                                               ".ass"
                                               ".elc"
                                               (and "tmp." (+ (not (any "/" "\\")))))
                                           eol))))
        "Don't show files matching these regexps in recentf alist.")

       :preface (use-package +lib-misc :autoload inhibit-messages-wrapper!)
       :config
       (advice-add 'recentf-load-list :around #'inhibit-messages-wrapper!))
   #+end_src

   #+begin_src emacs-lisp
   (provide '+pkg-recentf)
   #+end_src

** Replace                                                          :builtin:
   :PROPERTIES:
   :header-args+: :tangle (lisp! "+pkg-replace.el")
   :END:

   #+begin_src emacs-lisp :tangle yes
     (use-package replace
       :config
       (advice-add #'perform-replace :around #'display-buffer-no-select-window-advice+)
       (advice-add #'query-replace :around #'display-buffer-no-select-window-advice+)

       :leader
       ("x DEL" 'flush-lines
        "x RET" 'keep-lines))
   #+end_src

** Save Place                                                       :builtin:
   :PROPERTIES:
   :header-args+: :tangle (lisp! "+pkg-save-place.el")
   :END:

   Remembers the cursor position in open files... so when I reopen them I'm
   taken to that point immediately.

   #+begin_src emacs-lisp :tangle yes
   (require '+pkg-save-place)
   #+end_src

   #+begin_src emacs-lisp
     (use-package saveplace
       :hook (after-init . save-place-mode)
       :custom
       (save-place-forget-unreadable-files nil)
       (save-place-version-control 'nospecial)
       (save-place-file (eval-when-compile
                          (let ((save-dir (state! "save-place")))
                            (unless (file-directory-p save-dir)
                              (mkdir save-dir t))

                            (join-path+ save-dir "places.el"))))
       (save-place-ignore-files-regexp (rx
                                        (or "COMMIT_EDITMSG"
                                            "svn-commit"
                                            (and "hg-editor-" (one-or-more num))
                                            (and (or ".txt" ".tmp") eol)
                                            (and bol (or "/tmp/"))
                                            (and "bzr_log." (one-or-more num))))))
   #+end_src

   #+begin_src emacs-lisp
   (provide '+pkg-save-place)
   #+end_src

** Save Hist                                                        :builtin:
   :PROPERTIES:
   :header-args+: :tangle (lisp! "+pkg-save-hist.el")
   :END:

   #+begin_src emacs-lisp :tangle yes
   (require '+pkg-save-hist)
   #+end_src

   #+begin_src emacs-lisp
     (use-package savehist
       :hook (after-init . savehist-mode)
       :custom
       (savehist-file (state! "savehist.el"))
       (savehist-additional-variables
        '(consult--line-history
          corfu-history
          evil-ex-history
          kill-ring
          projectile-project-command-history
          projection--project-cache
          regexp-search-ring
          search-ring))

       :config
       (when-let* ((savehist-stats (file-attributes savehist-file))
                   (savehist-size (file-attribute-size savehist-stats))
                   (savehist-too-big (> savehist-size (* 1024 1024 25))))
         (display-warning
          'dotemacs
          "Savehist file is too large, this can lead to occasional freezes"
          :warning)))
   #+end_src

   #+begin_src emacs-lisp
   (provide '+pkg-save-hist)
   #+end_src

** Visual Line                                             :disabled:builtin:
   :PROPERTIES:
   :header-args+: :tangle (lisp! "+pkg-visual-line.el") :tangle no
   :END:

   Auto wrap long lines at the end of words.

   #+begin_src emacs-lisp :tangle yes :tangle no
     (use-package visual-line
       :delight " ‚ìÅ")
   #+end_src

** Tramp                                                            :builtin:
   :PROPERTIES:
   :header-args+: :tangle (lisp! "+pkg-tramp.el")
   :END:

   Transparent ReMote Access Protocol

   #+begin_src emacs-lisp :tangle yes
     (require '+pkg-tramp)
   #+end_src

*** Tramp
    #+BEGIN_SRC emacs-lisp
      (use-package tramp
        :custom
        (tramp-default-method "sshx")

        :config
        (setq tramp-verbose 1) ;; Doesn't work with :custom.

        :leader
        (:prefix "f2"
         "" '(:ignore t :wk "remote")
         "c" 'tramp-cleanup-this-connection
         "x" 'tramp-cleanup-all-connections
         "b" 'tramp-cleanup-all-buffers))
    #+END_SRC

*** Google Cloud
    Google Cloud integration courtesy of [[https://qiita.com/tanatana/items/218b19808f2428b125fe][tanatana]]. See [[https://cloud.google.com/sdk/docs/quickstart-windows][here]] for how to install
    the Google Cloud CLI.

    #+begin_src emacs-lisp
      (use-package tramp
        :config
        (push
         '("gcssh"
           (tramp-login-program        "gcloud compute ssh")
           (tramp-login-args           (("%h")))
           (tramp-async-args           (("-q")))
           (tramp-remote-shell         "/bin/sh")
           (tramp-remote-shell-args    ("-c"))
           (tramp-gw-args              (("-o" "GlobalKnownHostsFile=/dev/null")
                                        ("-o" "UserKnownHostsFile=/dev/null")
                                        ("-o" "StrictHostKeyChecking=no")))
           (tramp-default-port         22))
         tramp-methods))
    #+end_src

*** Teleport                                                       :optional:
    :PROPERTIES:
    :header-args+: :tangle (package-lisp! +pkg-tramp teleport)
    :END:

    #+begin_src emacs-lisp
      (use-package teleport
        :straight t
        :after tramp
        :demand t
        :config
        (teleport-tramp-add-method))
    #+end_src

*** Appendix
    #+begin_src emacs-lisp
    (provide '+pkg-tramp)
    #+end_src

** Server                                                           :builtin:
   :PROPERTIES:
   :header-args+: :tangle (lisp! "+pkg-server.el")
   :END:

   #+begin_src emacs-lisp :tangle yes
   (require '+pkg-server)
   #+end_src

   #+BEGIN_SRC emacs-lisp
     (use-package server
       :demand t
       :commands (find-client-buffer+
                  next-client-buffer+
                  prev-client-buffer+
                  server-edit-mode+)
       :custom
       (server-client-instructions nil)

       :config
       (advice-add 'server-edit :before
                   (defun server-edit--auto-save-on-exit+ (&rest _args)
                     "Automatically save file before server exit."
                     (save-buffer)))

       ;; (advice-add #'server-start :before
       ;;             (defun server-rename-when-running+ (&rest _args)
       ;;               (when (and (not (bound-and-true-p server-mode))
       ;;                          (server-running-p server-name))
       ;;                 (setq server-name
       ;;                       (read-string
       ;;                        (format "Server [%s] already running, choose new name: " server-name))))))

       :autoload server-client-buffers+
       :config
       (declare-function smart-buffer-file-name+ "+setup-commands")

       (defun server-client-buffers+ (&optional all-frames)
         "List buffers being visited by emacs-client in the current frame.
     With ALL-FRAMES use all frames known to the current emacs session."
         (cl-remove-duplicates
          (cl-loop for frame in (if all-frames (frame-list) (list (selected-frame)))
                   append (when-let* ((proc (frame-parameter frame 'client)))
                            (process-get proc 'buffers)))))

       (defvar move-client-buffers-wrap-around+ t
         "When non-nil `next-client-buffer' wraps around the last client buffer to
     the first.")

       (defun next-client-buffer+ (arg)
         "Switch to the next emacsclient editing buffer.
     With ARG this function acts on clients from all-frames not just the current
     frame."
         (interactive "P")
         (if-let* ((buffers (server-client-buffers+ arg))
                   (mark (1+ (or (seq-position buffers (current-buffer)) -1)))
                   (mark (if (eq mark (length buffers))
                             (if move-client-buffers-wrap-around+
                                 0
                               (user-error "No next client buffer to switch to"))
                           mark))
                   (buffer (nth mark buffers)))
             (progn
               (message "%d/%d: %s"
                        (1+ mark)
                        (length buffers)
                        (abbreviate-file-name
                         (smart-buffer-file-name+ buffer)))
               (switch-to-buffer buffer))
           (user-error "No client buffers found")))

       (defun prev-client-buffer+ (arg)
         "Switch to the previous buffer visited by emacsclient in the current frame.
     With ARG this function acts on clients from all-frames not just the current
     frame."
         (interactive "P")
         (if-let* ((buffers (server-client-buffers+ arg))
                   (mark (- (or (seq-position buffers (current-buffer)) 0) 1))
                   (mark (if (< mark 0)
                             (if move-client-buffers-wrap-around+
                                 (- (length buffers) 1)
                               (user-error "No previous client buffer to switch to"))
                           mark))
                   (buffer (nth mark buffers)))
             (progn
               (message "%d/%d: %s"
                        (1+ mark)
                        (length buffers)
                        (abbreviate-file-name
                         (smart-buffer-file-name+ buffer)))
               (switch-to-buffer buffer))
           (user-error "No client buffers found")))

       (defun find-client-buffer+ (arg)
         "Completing read a buffer from the list of emasclient buffers."
         (interactive "P")
         (switch-to-buffer
          (if-let* ((client-buffers (cl-loop for buf in (server-client-buffers+ arg)
                                             collect (cons (abbreviate-file-name (smart-buffer-file-name+ buf))
                                                           buf)))
                    (cands (mapcar #'car client-buffers)))
              (cond
               ((package! :consult)
                ;; Gives us previews and nicer formatting but may not be available.
                (declare-function consult--read "consult")
                (declare-function consult--buffer-state "consult")
                (declare-function consult--lookup-cdr "consult")
                (consult--read client-buffers
                               :prompt "Client buffer: "
                               :category 'buffer
                               :require-match t
                               :default (car cands)
                               :lookup #'consult--lookup-cdr
                               :state (consult--buffer-state)))
               (t
                (cdr
                 (assoc
                  (completing-read "Client buffer: "
                                   (lambda (str pred action)
                                     (if (eq action 'metadata)
                                         `(metadata (category . buffer))
                                       (complete-with-action action cands str pred)))
                                   nil t nil nil (car cands))
                  client-buffers))))
            (user-error "No client buffers found"))))

       :hook (server-visit . server-switch-enable-server-edit-mode+)
       :init
       (defvar server-edit-ignore-modes+
         '(with-editor-mode)
         "Modes (minor or major) in which `server-edit-mode+' is disabled.")

       (defun server-switch-enable-server-edit-mode+ ()
         (unless (or (apply #'derived-mode-p
                            server-edit-ignore-modes+)
                     (cl-some (lambda (mode)
                                (and (boundp mode)
                                     (eval mode)))
                              server-edit-ignore-modes+))
           (server-edit-mode+ +1)))

       :hook (server-done . server-done-quit-server-edit-mode+)
       :init
       (defun server-done-quit-server-edit-mode+ ()
         (server-edit-mode+ -1))

       :commands server-edit-mode+
       :preface
       ;; add ,, and ,q like bindings in server edit sessions, like org-edit-src-code
       (define-minor-mode server-edit-mode+
         "A dummy minor mode for files being edited by `server'.
     makes it easier to bind keys (& leaders :grinning: for them)."
         :lighter " ServerEdit"
         '(;; ([remap evil-write] . server-edit)
           ([remap evil-save-and-close] . server-edit)
           ([remap evil-quit-all-with-error-code] . server-edit-abort)))

       :autoload server-running-p
       :commands server-start+
       :config
       (defun server-start+ (&optional rename)
         (interactive "P")
         (when rename
           (when (and (server-running-p) server-process)
             (user-error "Cannot rename already running server."))
           (setq server-name (read-string "Server name: " server-name)))
         (funcall-interactively 'server-start))

       :leader
       ("f SPC" 'server-start+
        "fen" 'next-client-buffer+
        "fep" 'prev-client-buffer+
        "feb" 'find-client-buffer+)

       :lazy-leader
       (:mode 'server-edit-mode+
        :minor t
        :prefix leader-major-mode-prefix
        "," 'server-edit
        "q" 'server-edit-abort))
   #+END_SRC

   #+begin_src emacs-lisp
   (provide '+pkg-server)
   #+end_src

** Vline                                                            :builtin:
   :PROPERTIES:
   :header-args+: :tangle (lisp! "+pkg-vline.el")
   :END:

   #+begin_src emacs-lisp :tangle yes
     (use-package vline
       :straight t
       :leader ("tv" 'vline-mode))
   #+end_src

** Whitespace Mode                                                  :builtin:
   :PROPERTIES:
   :header-args+: :tangle (lisp! "+pkg-whitespace.el")
   :END:

   #+begin_src emacs-lisp :tangle yes
     (use-package whitespace
       :delight
       (whitespace-mode " ‚ì¶ ")
       (global-whitespace-mode " ‚ì¶ "))
   #+end_src

** Winner                                                           :builtin:
   :PROPERTIES:
   :header-args+: :tangle (lisp! "+pkg-winner.el")
   :END:

   #+begin_src emacs-lisp :tangle yes
     (require '+pkg-winner)
   #+end_src

*** Winner
    #+begin_src emacs-lisp
      (use-package winner
        :hook (after-init . winner-mode)

        :general
        (:keymaps 'emacs-window-map+
         "<left>"  'winner-undo
         "<right>" 'winner-redo))
    #+end_src

*** Appendix
    #+begin_src emacs-lisp
      (provide '+pkg-winner)
    #+end_src

** Xref                                                             :builtin:
   :PROPERTIES:
   :header-args+: :tangle (lisp! "+pkg-xref.el")
   :END:

   Cross reference keywords across a number of different backends.

   #+begin_src emacs-lisp :tangle yes
   (require '+pkg-xref)
   #+end_src

   #+begin_src emacs-lisp
     (use-package +pkg-evil
       :autoload evil-set-initial-state
       :config (evil-set-initial-state 'xref--xref-buffer-mode 'motion))
   #+end_src

   #+BEGIN_SRC emacs-lisp
     (use-package xref
       :hook ((xref-after-jump . recenter)
              (xref-after-jump . xref-pulse-momentarily))
       :leader
       ("jb" 'xref-go-back
        "jf" 'xref-go-forward
        "jr" 'xref-find-references
        "js" 'xref-find-apropos
        "jq" 'xref-find-references-and-replace
        "jg" 'xref-find-definitions
        "jG" 'xref-find-definitions-other-frame
        "jo" 'xref-find-definitions-other-window)

       :lazy-leader
       (:mode 'xref--xref-buffer-mode
        "s" 'xref-query-replace-in-results)

       :general
       ;; erase global xref bindings
       ("M-."   nil                                                                  ; xref-find-definitions
        "M-,"   nil                                                                  ; xref-go-back
        "M-?"   nil                                                                  ; xref-find-references
        "C-M-." nil                                                                  ; xref-find-apropos
        )
       (:states 'motion
        "[x" 'xref-go-back)
       (:keymaps 'xref--xref-buffer-mode-map
        :states 'motion
        "j" 'xref-next-line
        "k" 'xref-prev-line
        "RET" 'xref-goto-xref
        "M-RET" 'xref-show-location-at-point
        "TAB" 'xref-quit-and-goto-xref))
   #+END_SRC

   #+begin_src emacs-lisp
   (provide '+pkg-xref)
   #+end_src

** Dired
   :PROPERTIES:
   :header-args+: :tangle (lisp! "+pkg-dired.el")
   :END:

   Emacs directory viewer and editor.

   #+begin_src emacs-lisp :tangle yes
   (require '+pkg-dired)
   #+end_src

*** Dired Mode                                                      :builtin:
    #+BEGIN_SRC emacs-lisp
      (use-package dired
        :straight (dired :type built-in)
        :indent+ (dired-mode 1)
        :hide-whitespace+ dired-mode
        :custom
        (ls-lisp-dirs-first t)
        (dired-listing-switches "-laXhv --group-directories-first")
        (dired-auto-revert-buffer t)
        (dired-hide-details-hide-symlink-targets nil)
        (dired-recursive-copies t)
        (dired-make-directory-clickable t)
        (ls-lisp-use-insert-directory-program (executable-find "ls"))

        :commands dired-goto-home-dir+
        :config
        (defun dired-goto-home-dir+ (&optional other-window)
          "goto users home directory
             with prefix, visits in another window"
          (interactive "P")
          (funcall (if other-window
                       'find-file-other-window
                     'find-file)
                   (expand-file-name "~")))

        :commands dired-evil-scroll-down+
        :autoload dired-move-to-filename
        :config
        (defun dired-evil-scroll-down+ ()
          (interactive)
          (call-interactively 'evil-scroll-down)
          (dired-move-to-filename))

        :commands dired-evil-scroll-up+
        :autoload dired-move-to-filename
        :config
        (defun dired-evil-scroll-up+ ()
          (interactive)
          (call-interactively 'evil-scroll-up)
          (dired-move-to-filename))

        :config
        ;; This keeps getting reset by some package on load so defer it.
        (general-define-key :keymaps 'dired-mode-map [override-state] 'all)

        :general
        (:keymaps 'dired-mode-map
         leader-key nil
         leader-major-mode-key nil
         "g" nil)
        (:keymaps 'dired-mode-map
         :states  '(motion normal)
         "j" 'dired-next-line
         "k" 'dired-previous-line
         "~" 'dired-goto-home-dir+
         "=" 'dired-diff
         "K" 'dired-do-kill-lines
         "'" 'dired-show-file-type ;; like file command
         "M" 'dired-unmark
         "u" 'dired-unmark
         "r" 'dired-change-marks
         "y" 'dired-copy-filename-as-kill
         "RET" 'dired-find-file

         "M-<return>" 'dired-display-file
         "C-M-<return>" 'dired-find-alternate-file
         "C-M-d" 'dired-kill-subdir

         "zc" 'dired-hide-subdir ;; collapse
         "zC" 'dired-hide-all

         ;; "|" 'dired-do-hardlink
         "|" 'dired-do-symlink
         "C-|" 'dired-do-relsymlink
         "M-|" 'dired-do-hardlink
         "M-!" 'dired-do-print ;; append names to end of command

         "C-S-J" 'dired-next-marked-file
         "C-S-K" 'dired-prev-marked-file
         "M-j" 'dired-next-dirline           ; unbound, dired-tree-down
         "M-k" 'dired-prev-dirline           ; unbound, dired-tree-up
         "C-d" 'dired-evil-scroll-down+
         "C-u" 'dired-evil-scroll-up+
         "C-h" 'dired-goto-min-subdir
         "C-j" 'dired-next-subdir
         "C-k" 'dired-prev-subdir)
        (:keymaps 'dired-mode-map
         "#" nil "$" nil "%" nil "*" nil "." nil ":" nil "?" nil "~" nil "<" nil
         "=" nil ">" nil "a" nil "A" nil "B" nil "c" nil "C-M-d" nil "C-M-n" nil
         "C-M-p" nil "C-M-u" nil "C-o" nil "e" nil "f" nil "F" nil "g" nil "G" nil
         "h" nil "H" nil "I" nil "j" nil "k" nil "l" nil "L" nil "M" nil "M-$" nil
         "M-(" nil "M-{" nil "M-}" nil "M-DEL" nil "M-G" nil "n" nil "N" nil "O" nil
         "p" nil "P" nil "Q" nil "s" nil "SPC" nil "0" nil "S-SPC" nil "t" nil "T" nil
         "v" nil "V" nil "w" nil "W" nil "X" nil "y" nil "Y" nil "Z" nil "u" nil)

        :lazy-leader
        (:mode '(dired-mode
                 wdired-mode)
         ;; "?" 'dired-summary                                                        ; Like transient state
         "#" 'dired-clean-directory
         "o" 'browse-url-of-dired-file                                                ; Open in external app
         "v" 'dired-view-file                                                         ; find-file but make read-only
         "g" 'dired-goto-file
         "i" 'dired-sort-toggle-or-edit
         "e" '(wdired-change-to-wdired-mode :wk "edit-directory")

         "r"  '(:ignore t :wk "rename")
         "ru" 'dired-upcase
         "rd" 'dired-downcase

         ;; Flag means mark delete
         "d"  '(:ignore t :wk "delete")
         "dj" 'dired-flag-garbage-files
         "db" 'dired-flag-backup-files
         "ds" 'dired-flag-files-regexp
         "d#" 'dired-flag-auto-save-files

         "m"  '(:ignore t :wk "mark")
         "mi" 'dired-toggle-marks
         "ml" 'dired-mark-symlinks
         "md" 'dired-mark-directories
         "mx" 'dired-mark-executables
         "mt" 'dired-mark-subdir-files
         "mg" 'dired-mark-files-containing-regexp ;; grep
         "ms" 'dired-mark-files-regexp
         "me" 'dired-mark-sexp

         "x"  '(:ignore t :wk "emacs")
         "xc" 'dired-do-byte-compile
         "xl" 'dired-do-load
         "xf" 'dired-do-find-marked-files

         ;; Change fs property commands
         "c"  '(:ignore t :wk "change")
         "cg" 'dired-do-chgrp
         "cm" 'dired-do-chmod
         "co" 'dired-do-chown

         ;; Filesystem
         "f"  '(:ignore t :wk "filesystem")
         "fg" 'dired-do-find-regexp                                                   ; grep marked files
         "fs" 'dired-do-find-regexp-and-replace                                       ; regexp substitute marked files
         "fi" 'dired-info                                                             ; run info on current file
         "fm" 'dired-man                                                              ; run man on current file
         "fr" 'dired-do-run-mail
         "ft" 'dired-do-touch

         ;; EasyPG/GPG
         "fp"  '(:ignore t :wk "GPG")
         "fpd" 'epa-dired-do-decrypt
         "fpe" 'epa-dired-do-encrypt
         "fps" 'epa-dired-do-sign
         "fpv" 'epa-dired-do-verify

         ;; operations bound to regexp search
         "s"     '(:ignore t :wk "search")
         "sc"    'dired-do-copy-regexp
         "sr"    'dired-do-rename-regexp
         "sh"    'dired-do-hardlink-regexp
         "ss"    'dired-do-symlink-regexp
         "s|"    'dired-do-symlink-regexp
         "s C-|" 'dired-do-relsymlink-regexp
         "s M-|" 'dired-do-hardlink-regexp)
        (:mode 'wdired-mode
         "q"                   'wdired-abort-changes
         leader-major-mode-key 'wdired-finish-edit))
    #+END_SRC

*** Dired Omit                                                      :builtin:
    Dired file hiding functionality.

    #+BEGIN_SRC emacs-lisp
      (use-package dired-x
        :hook (dired-mode . dired-omit-mode)
        :custom
        (dired-omit-files
         (rx (or ".#"
                 (and bol
                      (or "."
                          ".."
                          ".git"
                          ".github"
                          ".dired"
                          "Pipfile"
                          (and "service.log." (one-or-more (any digit "_")))
                          ;; Dired will respect `completion-ignored-extensions' for files, but not directories.
                          ;; We setup a directory match as part of `dired-omit-files'.
                          (eval
                           `(or
                             ,@(cl-loop
                                for sequence in completion-ignored-extensions
                                when (string-suffix-p "/" sequence)
                                  collect (string-remove-suffix "/" sequence)))))
                      eol))))
        :leader
        (:mode '(dired-mode wdired-mode)
         "." 'dired-omit-mode))
    #+END_SRC

*** Dired Font Lock                                                     :wip:
    Extra font lock rules for Dired; basically adds some more color to Dired sessions.
    nice idea, but too much of a good thing can be bad.

    #+BEGIN_SRC emacs-lisp :tangle (package-yes! diredfl)
      (use-package diredfl
        :straight t
        :hook (dired-mode . diredfl-mode))
    #+END_SRC

*** Dired All The Icons
    :PROPERTIES:
    :header-args+: :tangle (lisp! "+pkg-dired.el")
    :END:

    #+BEGIN_SRC emacs-lisp
      (require '+pkg-all-the-icons)

      (use-package all-the-icons-dired
        :straight t
        :hook (dired-mode . all-the-icons-dired-mode)
        :diminish all-the-icons-dired-mode
        :custom
        (all-the-icons-dired-monochrome nil)

        :init
        (advice-add 'all-the-icons-dired--icon :filter-return #'all-the-icons-pad-on-tty-advice+))
    #+END_SRC

*** Dired Git Info
    Show the last commit log for files in the current dired buffer.

    #+BEGIN_SRC emacs-lisp
      (use-package dired-git-info
        :straight t
        :general
        (:keymaps 'dired-mode-map
         ")" 'dired-git-info-mode))
    #+END_SRC

*** Dired Images                                           :builtin:optional:
    :PROPERTIES:
    :header-args+: :tangle (package-lisp! +pkg-dired image-dired)
    :END:

    #+BEGIN_SRC emacs-lisp :tangle (package-yes! image-dired)
      (use-package image-dired
        ;; :custom
        ;; (image-dired-db-file . (state! "image-dired" "db.el")) ; tag associations
        ;; (image-dired-dir . (state! "image-dired/"))
        ;; (image-dired-gallery-dir . (state! "image-dired" "gallery/"))
        ;; (image-dired-temp-image-file . (state! "image-dired" "temp-image"))
        ;; (image-dired-temp-rotate-image-file . (state! "image-dired" "temp-rotate-image"))

        :config
        (push 'image-dired-thumbnail-mode +whitespace-exempt-modes)

        :config
        ;;; Fixed weird moves line, not thumbnail, behaviour.
        (advice-add #'image-dired-slideshow-step :override
                    (defun image-dired-slideshow-step+ ()
                      "Step to next file, if `image-dired-slideshow-times' has not been reached."
                      (if (< image-dired-slideshow-count image-dired-slideshow-times)
                          (progn
                            (message "%s" (1+ image-dired-slideshow-count))
                            (setq image-dired-slideshow-count (1+ image-dired-slideshow-count))
                            (image-dired-display-next-thumbnail-original))
                        (image-dired-slideshow-stop))))

        :general
        (:keymaps 'image-dired-thumbnail-mode-map
         :states '(normal visual)
         "q" nil

         "h" 'image-dired-backward-image
         "j" 'image-dired-next-line
         "k" 'image-dired-previous-line
         "l" 'image-dired-forward-image
         "<left>"  'image-dired-forward-image
         "<right>" 'image-dired-previous-image

         "x" 'image-dired-delete-char
         "m" 'image-dired-mark-thumb-original-file
         "u" 'image-dired-unmark-thumb-original-file
         "c" 'image-dired-comment-thumbnail
         "d" 'image-dired-flag-thumb-original-file
         "D" 'image-dired-thumbnail-set-image-description
         "s" 'image-dired-slideshow-start
         "t" 'image-dired-toggle-mark-thumb-original-file
         "gr" 'image-dired-refresh-thumb
         "gc" 'image-dired-create-thumbs
         "gg" (lambda! (evil-goto-first-line) (evil-beginning-of-line))
         "G"  (lambda! (goto-char (point-max)) (image-dired-backward-image))

         "C-s" 'image-save                                                            ; NOTE originally was bound to o

         "C-SPC"    'image-dired-mark-thumb-original-file
         "M-SPC"    'image-dired-unmark-thumb-original-file

         "<C-return>" 'image-dired-display-current-image-full
         "<RET>"      'image-dired-display-thumbnail-original-image
         "C-l"        'image-dired-display-next-thumbnail-original
         "C-h"        'image-dired-display-previous-thumbnail-original
      ;;; column view aliases
         "J" 'image-dired-display-next-thumbnail-original
         "K" 'image-dired-display-previous-thumbnail-original
         ;; "o" 'image-dired-display-thumbnail-original-image
         "v" 'image-dired-display-thumbnail-original-image

         "<mouse-1>" 'image-dired-mouse-select-thumbnail
         "<mouse-2>" 'image-dired-mouse-display-image)
        (:keymaps 'image-dired-display-image-mode-map
         :states 'normal
         "f" 'image-dired-display-current-image-full
         "F" 'image-dired-display-current-image-sized
         "s" 'image-dired-display-current-image-sized

         "h" 'image-scroll-right
         "l" 'image-scroll-left
         "k" 'image-scroll-down
         "j" 'image-scroll-up
         ;; horizontal line by line movement
         "C-d" 'image-scroll-up
         "C-u" 'image-scroll-down
         "C-e" 'image-next-line
         "C-y" 'image-previous-line
         ;; Arrow Keys Alias hjkl
         "<left>"  'image-backward-hscroll
         "<right>" 'image-forward-hscroll
         "<up>"    'image-scroll-down
         "<down>"  'image-scroll-up)

        :config
        (leader-declare-prefix-for-major-mode 'image-dired-thumbnail-mode
          "t" "tagging"
          "e" "edit")

        :lazy-leader
        (:mode 'image-dired-thumbnail-mode
         "g" 'image-dired-jump-original-dired-buffer
         "m" 'image-dired

         "td" 'image-dired-thumbnail-set-image-description
         "tt" 'image-dired-tag-thumbnail
         "tT" 'image-dired-tag-thumbnail-remove

         "el" 'image-dired-rotate-thumbnail-left
         "eL" 'image-dired-rotate-original-left
         "er" 'image-dired-rotate-thumbnail-right
         "eR" 'image-dired-rotate-original-right

         "." 'image-dired-track-original-file
         "o" 'image-dired-thumbnail-display-external

         ;; [re]set number of columns per row
         "s" 'image-dired-line-up-interactive
         "S" 'image-dired-line-up-dynamic)

        (:mode 'image-dired-display-image-mode
         "h" 'image-bol ; far left   edge
         "j" 'image-eob ; far bottom edge
         "k" 'image-bob ; far top    edge
         "l" 'image-eol ; far right  edge
         "g" 'image-dired-jump-thumbnail-buffer))
    #+END_SRC

*** Appendix
    #+begin_src emacs-lisp
    (provide '+pkg-dired)
    #+end_src

** Vertico                                              :minibuffer:optional:
   :PROPERTIES:
   :header-args+: :tangle (package-lisp! +pkg-vertico vertico)
   :END:

   #+begin_src emacs-lisp :tangle (package-yes! vertico)
   (require '+pkg-vertico)
   #+end_src

*** Vertico
    #+begin_src emacs-lisp
      (use-package vertico
        :straight (vertico :repo "minad/vertico"
                           :files (:defaults
                                   "extensions/vertico-grid.el"
                                   "extensions/vertico-mouse.el"
                                   "extensions/vertico-multiform.el"
                                   "extensions/vertico-quick.el"
                                   "extensions/vertico-repeat.el"))
        :hook ((after-init . vertico-mode)
               (minibuffer-setup . cursor-intangible-mode))
        :custom
        (vertico-count 15)
        (vertico-cycle t)
        (vertico-preselect 'no-prompt)
        (vertico-scroll-margin 0)
        (minibuffer-prompt-properties
         '(read-only t cursor-intangible t face minibuffer-prompt))
        (vertico-group-format
         (concat
          #("    " 0 4 (face vertico-group-separator))
          #(" %s " 0 4 (face vertico-group-title))
          #(" " 0 1 (face vertico-group-separator display (space :align-to (- right 1)))))
         "Prevent vertico group format from going past the end column on tty displays.")

        :autoload vertico-format-candidates+
        :preface (use-package +pkg-minibuffer
                   :autoload (+completion-category-hl-func
                              minibuffer-override-face+))
        :config
        (advice-add #'vertico--arrange-candidates :around
                    (defun vertico-format-candidates+ (func &rest args)
                      (let ((hl-func (or (+completion-category-hl-func vertico--metadata)
                                         #'identity)))
                        (cl-letf* ((actual-vertico-format-candidate
                                    (symbol-function #'vertico--format-candidate))
                                   ((symbol-function #'vertico--format-candidate)
                                    (lambda (cand &rest args)
                                      (or (and (eq (nth 2 args) vertico--index)
                                               (minibuffer-override-face+
                                                'vertico-current
                                                (apply actual-vertico-format-candidate cand args)))
                                          (apply actual-vertico-format-candidate
                                                 (funcall hl-func cand) args)))))
                          (apply func args)))))

        :preface (use-package +pkg-minibuffer :autoload +completion-category-sort-func)
        :config
        (advice-add 'vertico--sort-function :before-until
                    (defun vertico--sort-function+ ()
                      (+completion-category-sort-func vertico--metadata)))

        :config
        (advice-add 'ffap-menu-ask :around
                    (lambda (&rest args)
                      (cl-letf (((symbol-function #'minibuffer-completion-help)
                                 #'ignore))
                        (apply args))))

        :commands vertico-forward-char-or-exit+
        :config
        (defun vertico-forward-char-or-exit+ ()
          (interactive)
          (call-interactively (if (eolp)
                                  'vertico-exit
                                'forward-char)))

        :general
        (:keymaps 'vertico-map
         "<C-i>" 'vertico-insert
         "C-c C-n" 'vertico-next-group
         "C-c C-p" 'vertico-previous-group
         "<S-return>" 'vertico-exit-input
         [remap minibuffer-forward-char-or-exit+] #'vertico-forward-char-or-exit+))
    #+end_src

    Configure a completion style which explicitly falls back to basic for remote files
    and retains any other completion styles for other types of find-file prompts. This
    was lifted from the [[https://github.com/minad/vertico/tree/a2e9b1b9b04c78e15cc2272a122e7005947d7308#tramp-hostname-completion][vertico]] completion guide.

    #+begin_src emacs-lisp
      (use-package vertico
        :autoload vertico--remote-p
        :preface
        (defun basic-remote-try-completion+ (string table pred point)
          (and (vertico--remote-p string)
               (completion-basic-try-completion string table pred point)))

        (defun basic-remote-all-completions+ (string table pred point)
          (and (vertico--remote-p string)
               (completion-basic-all-completions string table pred point)))

        (add-to-list
         'completion-styles-alist
         '(basic-remote+ basic-remote-try-completion+ basic-remote-all-completions+ nil)))
    #+end_src

*** Vertico Grid
    #+begin_src emacs-lisp
      (use-package vertico-grid
        :config
        (advice-add 'vertico-grid--arrange-candidates :around #'vertico-format-candidates+))
    #+end_src

*** Vertico Mouse
    #+begin_src emacs-lisp
      (use-package vertico-mouse
        :hook (vertico-mode . vertico-mouse-mode))
    #+end_src

*** Vertico Multiform
    #+begin_src emacs-lisp
      (use-package vertico-multiform
        :hook (vertico-mode . vertico-multiform-mode)
        :custom
        (vertico-multiform-categories
         '((jinx grid (vertico-grid-annotate . 25) (vertico-count . 4)))
         "Adjust vertico display based on completion session."))
    #+end_src

*** Vertico Quick
    #+begin_src emacs-lisp
      (use-package vertico-quick
        :general
        (:keymaps 'minibuffer-local-map
         "C-q" 'vertico-quick-exit))
    #+end_src

*** Vertico Repeat
    #+begin_src emacs-lisp
      (use-package vertico-repeat
        :hook (minibuffer-setup . vertico-repeat-save)
        :leader
        ("RET" 'vertico-repeat))
    #+end_src

*** Vertico Marginalia
    :PROPERTIES:
    :header-args+: :tangle (package-lisp! +pkg-vertico :consult vertico)
    :END:

    #+begin_src emacs-lisp
      (use-package marginalia
        :hook (vertico-mode . marginalia-mode))
    #+end_src

*** Vertico Prescient
    :PROPERTIES:
    :header-args+: :tangle (package-lisp! +pkg-vertico prescient vertico)
    :END:

    Vertico integration for Prescient, courtesy of the [[https://github.com/minad/vertico/wiki#using-prescientel][wiki]].

    #+begin_src emacs-lisp
      (use-package vertico-prescient
        :straight t
        :hook (vertico-mode . vertico-prescient-mode)
        :custom
        (vertico-prescient-override-sorting t)
        (vertico-prescient-enable-filtering nil))
    #+end_src

*** Appendix
    #+begin_src emacs-lisp
    (provide '+pkg-vertico)
    #+end_src

** Marginalia                                                      :optional:
   :PROPERTIES:
   :header-args+: :tangle (package-lisp! +pkg-marginalia :consult)
   :END:

   A library for annotating completion targets in minibuffer sessions with useful utilities.

   #+begin_src emacs-lisp :tangle (package-yes! :consult)
   (require '+pkg-marginalia)
   #+end_src

   #+BEGIN_SRC emacs-lisp
      (use-package marginalia
        :straight t
        :custom
        (marginalia-align 'right)
        (marginalia-align-offset -1)

        :general
        (:keymaps 'embark-general-map
         "A" 'marginalia-cycle)
        (:keymaps 'minibuffer-local-map
         "C-c TAB" 'marginalia-cycle)

        :config
        (setq marginalia-command-categories
              (append '((projectile-find-file . project-file)
                        (projectile-find-dir . project-file)
                        (projectile-switch-project . project))
                      marginalia-command-categories))
        (push '(project marginalia-annotate-file builtin none)
              marginalia-annotators))
   #+END_SRC

   #+begin_src emacs-lisp
   (provide '+pkg-marginalia)
   #+end_src

** Embark                                                          :optional:
   :PROPERTIES:
   :header-args+: :tangle (package-lisp! +pkg-embark :consult)
   :END:

   #+begin_src emacs-lisp :tangle (package-yes! :consult)
   (require '+pkg-embark)
   #+end_src

*** Embark
    #+BEGIN_SRC emacs-lisp
      (require '+pkg-which-key)

      (use-package +setup-display-buffer
        :config
        (advice-add 'embark-export  :around 'display-buffer-no-select-window-advice+)
        (advice-add 'embark-collect :around 'display-buffer-no-select-window-advice+)
        (advice-add 'embark-live    :around 'display-buffer-no-select-window-advice+))

      (use-package embark
        :straight t
        :hide-whitespace+ embark-collect-mode

        :autoload (embark-which-key-indicator+
                   embark--truncate-target
                   )
        :custom
        (embark-indicators
         '(embark-which-key-indicator+
           embark-highlight-indicator
           embark-isearch-highlight-indicator))
        :config
        (defun embark-which-key-indicator+ ()
          "An embark indicator that displays keymaps using which-key.
      The which-key help message will show the type and value of the
      current target followed by an ellipsis if there are further
      targets."
          (lambda (&optional keymap targets prefix)
            (if (null keymap)
                (which-key--hide-popup-ignore-command)
              (which-key--show-keymap
               (if (eq (plist-get (car targets) :type) 'embark-become)
                   "Become"
                 (format "Act on %s '%s'%s"
                         (plist-get (car targets) :type)
                         (embark--truncate-target (plist-get (car targets) :target))
                         (if (cdr targets) "‚Ä¶" "")))
               (if prefix
                   (pcase (lookup-key keymap prefix 'accept-default)
                     ((and (pred keymapp) km) km)
                     (_ (key-binding prefix 'accept-default)))
                 keymap)
               nil nil t (lambda (binding)
                           (not (string-suffix-p "-argument" (cdr binding))))))))

        :autoload embark-hide-which-key-indicator+
        :config
        (defun embark-hide-which-key-indicator+ (fn &rest args)
          "Hide the which-key indicator immediately on completing-read prompt."
          (which-key--hide-popup-ignore-command)
          (let ((embark-indicators
                 (remq #'embark-which-key-indicator+ embark-indicators)))
            (apply fn args)))

        (advice-add 'embark-completing-read-prompter :around #'embark-hide-which-key-indicator+)


        :autoload embark-consult-export-grep
        :config
        (push (cons 'xref-location #'embark-consult-export-grep)
              embark-exporters-alist)
        (push (cons 'consult-xref #'embark-consult-export-grep)
              embark-exporters-alist)

        (push '(project embark-file-map) embark-keymap-alist)

        :config
        (defun embark-act-noexit+ ()
          (interactive)
          (let ((current-window (selected-window))
                (embark-quit-after-action nil))
            (call-interactively #'embark-act)
            (when current-window
              (select-window current-window))))

        (add-hook 'embark-collect-mode-hook
                  (defun embark-collect-disable-read-only-mode+ ()
                    (read-only-mode -1)))

        :config
        (defun embark-find-mkdir+ (dir)
          "Mkdirectory and then find it."
          (interactive (list (read-file-name "Directory")))
          (if (file-exists-p dir)
              (message "Warning path already exists: %s" dir)
            (mkdir dir t))
          (find-file dir))

        :commands embark-save-basename+
        :config
        (defun embark-save-basename+ (file)
          "Save the basename of FILE in the kill ring."
          (interactive "FFile: ")
          (thread-first
            file
            (substitute-in-file-name)
            (directory-file-name)
            (file-name-nondirectory)
            (kill-new)))

        :general
        (:keymaps 'embark-file-map
         "m" 'embark-find-mkdir+
         "+" 'embark-find-mkdir+
         "%" 'embark-save-basename+)

        ;; Embark core bindings.

        :general
        (:states '(normal visual motion)
         "RET" 'embark-act
         "<C-return>" 'embark-act)
        (:keymaps '(global-map
                    org-mode-map)
         "C-c C-o" 'embark-collect)

        (:keymaps 'vertico-map
         "<C-return>" 'embark-act
         "M-RET" 'embark-act-noexit+
         "C-c C-o" 'embark-collect
         ;; This is redundant for Vertico sessions.
         "C-c C-l" nil ;; "C-c C-l" 'embark-collect
         "C-c C-e" 'embark-export
         "C-c C-b" 'embark-become)

        ;; embark-collect

        :lazy-leader
        (:mode 'embark-collect-mode
         "," 'embark-act
         "s" 'embark-collect-direct-action-minor-mode
         "a" 'embark-collect-direct-action-minor-mode
         "e" 'embark-export
         "n" 'tabulated-list-narrow-current-column
         "w" 'tabulated-list-widen-current-column)

        :general
        (:keymaps 'embark-collect-mode-map
         :states 'motion
         "a" 'embark-act
         "A" 'embark-act-all
         "gj" 'forward-button
         "gk" 'backward-button
         "<C-return>" 'embark-act
         "<C-M-return>" 'embark-act-all

         "<" 'tabulated-list-narrow-current-column
         ">" 'tabulated-list-widen-current-column

         [remap evil-forward-paragraph] 'outline-next-heading
         [remap evil-backward-paragraph] 'outline-previous-heading
         "u" 'evil-undo
         "C-r" 'evil-redo
         "x" 'evil-delete-whole-line)

        ;; Embark category maps

        (:keymaps 'embark-general-map
         "w" nil
         "y" 'kill-new)

        (:keymaps 'embark-file-map
         "W" nil "Y" 'embark-save-relative-path
         ;; Swap these keybindings
         "a" #'info-lookup-symbol "s" #'xref-find-apropos)

        (:keymaps 'embark-command-map
         "g" 'embark-find-definition
         "b" 'global-set-key
         "w" 'where-is)

        (:keymaps 'embark-become-file+buffer-map
         "t" 'find-temp-file+)

        (:keymaps 'embark-face-map
         "I" nil
         "i" nil
         "i" 'embark-insert
         "g" 'embark-find-definition
         "/" 'make-face-italic
         "?" 'make-face-unitalic)

        (:keymaps 'embark-variable-map
         "g" 'embark-find-definition)

        (:keymaps 'embark-function-map
         "g" 'embark-find-definition)

        (:keymaps 'embark-symbol-map
         "g" 'embark-find-definition)

        (:keymaps 'embark-buffer-map
         "k" nil "x" #'kill-buffer
         "K" nil "X" #'embark-kill-buffer-and-window)

        (:keymaps 'embark-tab-map
         "k" nil "x" #'tab-bar-close-tab-by-name)

        (:keymaps 'embark-expression-map
         "k" nil "x" #'kill-region)

        (:keymaps 'embark-region-map
         ">" nil "." 'embark-encode-map
         ";" nil "/" 'comment-or-uncomment-region))
    #+END_SRC

*** Embark Magit
    Add commands to jump from a project find session to the magit status buffer.

    #+begin_src emacs-lisp :tangle (package-lisp! +pkg-embark :consult magit)
      (require '+pkg-project)

      (use-package embark
        :commands embark-magit-status+
        :preface (use-package magit :autoload magit-status-setup-buffer)
        :config
        (defun embark-magit-status+ (file)
          (interactive "fFile: ")
          (setq file (file-chase-links file))
          (if-let* ((root (project-current-root+
                           (or (when (file-directory-p file)
                                 file)
                               (file-name-directory file)))))
              (magit-status-setup-buffer root)
            (user-error "Could not find project root for %s" root)))

        :commands embark-magit-library-status+
        :preface (use-package find-func :autoload find-library-name)
        :config
        (defun embark-magit-library-status+ (lib)
          (interactive (list (read-library-name)))
          (embark-magit-status+ (find-library-name lib)))

        :general
        (:keymaps 'embark-file-map "g" #'embark-magit-status+)
        (:keymaps 'embark-library-map "g" #'embark-magit-library-status+))
    #+end_src

*** Embark Consult
    #+begin_src emacs-lisp
      (use-package embark-consult
        :straight t
        :after (embark consult)
        :demand t)
    #+end_src

*** Appendix
    #+begin_src emacs-lisp
    (provide '+pkg-embark)
    #+end_src

** Consult                                                         :optional:
   :PROPERTIES:
   :header-args+: :tangle (package-lisp! +pkg-consult :consult)
   :END:

   Consult is a minibuffer agnostic commands package.

   It supports numerous useful commands that work independent of the underlying
   completion session.

   #+begin_src emacs-lisp :tangle (package-yes! :consult)
     (require '+pkg-consult)
   #+end_src

*** Consult
    #+BEGIN_SRC emacs-lisp
      (defvar consult-manual-preview-key+
        (list "C-c <C-i>" "M-i")
        "Manual keys to trigger `consult--read' previews.")

      (use-package +pkg-evil
        :autoload evil-set-command-property
        :config
        (evil-set-command-property 'consult-outline :jump t)
        (evil-set-command-property 'consult-mark :jump t)
        (evil-set-command-property 'consult-line :jump t)
        (evil-set-command-property 'consult-line-symbol-at-point :jump t)
        (evil-set-command-property 'consult-line-from-isearch :jump t))

      ;; For some reason my first manual-preview-key isn't valid.
      (advice-add #'key-valid-p :before-until
                  (lambda (keys) (string-equal keys "C-c <C-i>")))

      (use-package consult
        :straight t
        :autoload (consult--read
                   consult--lookup-cdr)
        :hook (completion-list-mode . consult-preview-at-point-mode)
        :custom
        (consult-async-min-input 2)
        (consult-async-split-style 'slash)
        (consult-async-split-styles-alist
         '((nil :function consult--split-nil)
           (space :separator ?\s :function consult--split-separator)
           (comma :separator ?, :function consult--split-separator)
           (semicolon :separator ?\; :function consult--split-separator)
           (slash :initial "/" :function consult--split-perl)
           (perl :initial "#" :function consult--split-perl)))
        (consult-fontify-max-size 100000)
        (register-preview-function #'consult-register-preview)
        (consult-async-refresh-delay 0.05)
        (consult-narrow-key "M-SPC")
        (consult-widen-key "S-SPC")
        (xref-show-xrefs-function #'consult-xref)
        (xref-show-definitions-function #'consult-xref)

        :autoload consult-fix-dollar+
        :config
        ;; Fix consult cookie/tofu suffixes with some commands make $ (EOL) matching fail.
        (defun consult-fix-dollar+ (args)
          (if (string-suffix-p "$" (car args))
              (list (format "%s[%c-%c]*$"
                            (substring (car args) 0 -1)
                            consult--tofu-char
                            (+ consult--tofu-char consult--tofu-range -1)))
            args))
        :init
        (advice-add 'orderless-regexp :filter-args #'consult-fix-dollar+)
        (advice-add 'prescient-regexp-regexp :filter-args #'consult-fix-dollar+)

        :autoload consult-ripgrep-prefix-ignore-exit+
        :config
        (defun consult-ripgrep-prefix-ignore-exit+ (func &rest args)
          (let ((consult-ripgrep-args
                 (concat (when (executable-find "ignore-exit" 'remote)
                           "ignore-exit 1 ")
                         consult-ripgrep-args)))
            (apply func args)))
        (advice-add 'consult-ripgrep :around #'consult-ripgrep-prefix-ignore-exit+)

        :config
        (defvar consult-font-lock-exclude+ nil
          "The equivalent of `swiper-font-lock-exclude'")

        (advice-add 'consult--line-candidates :around
                    (defun consult--line-candidate-setup+ (func &rest args)
                      (let ((inhibit-field-text-motion t))
                        (apply func args))))

        (advice-add 'consult--fontify-all :around
                    (defun consult--fontify-prevent-p+ (func &rest args)
                      "The equivalent of `swiper-font-lock-ensure-p'."
                      (unless (or (derived-mode-p 'magit-mode)
                                  (bound-and-true-p magit-blame-mode)
                                  (memq major-mode consult-font-lock-exclude+))
                        (apply func args))))

        :commands (consult-find-no-project+
                   consult-ripgrep-no-project+
                   consult-grep-no-project+)
        :preface
        (defmacro with-consult-ignore-project+ (func)
          (setq func (eval func))
          `(defun ,(intern (concat (symbol-name func) "-no-project+")) (&rest args)
             ,(format "Variant of `%s' which skips project checks." func)
             (interactive)
             (let ((consult-project-function nil))
               (apply #'funcall-interactively (quote ,func) args))))

        :config
        (with-consult-ignore-project+ 'consult-ripgrep)
        (with-consult-ignore-project+ 'consult-grep)
        (with-consult-ignore-project+ 'consult-find)

        :config
        ;; Always follow symlinks with `consult-ripgrep'.
        (unless (string-match-p (rx bow "--follow" eow) consult-ripgrep-args)
          (setq consult-ripgrep-args (concat consult-ripgrep-args " --follow")))

        :autoload consult-completion-in-region
        :hook ((vertico-mode icomplete-mode)
               . consult-enable-completion-in-region+)
        :preface
        (defun consult-enable-completion-in-region+ ()
          (setq completion-in-region-function
                (if-let* ((completion-modes '(vertico-mode icomplete-mode))
                          (completion-modes (seq-filter #'boundp completion-modes))
                          (completion-mode (seq-find #'symbol-value completion-modes)))
                    #'consult-completion-in-region
                  #'completion--in-region)))

        :leader
        (:mode 'vertico-mode
         :minor t
         "aa" 'consult-minor-mode-menu
         "ee" 'consult-compile-error
         "jc" 'consult-compile-error
         "ju" 'consult-outline
         "hx" 'consult-complex-command
         "ax" 'consult-mode-command
         "rr" 'consult-register
         "rm" 'consult-mark
         "fr" 'consult-recent-file
         "ee" 'consult-compile-error
         "sr" 'consult-ripgrep-no-project+
         "sb" 'consult-grep-no-project+
         "sv" 'consult-git-grep
         "fs" '(:ignore t :wk "search")
         "fsf" 'consult-find-no-project+
         "kg" 'consult-kmacro
         "ry" 'consult-yank-pop

         "ps" '(:ignore t :wk "search")
         "psr" 'consult-ripgrep
         "psf" 'consult-find
         "psv" 'consult-git-grep
         "psb" 'consult-grep
         "psg" 'consult-grep
         "psi" 'consult-imenu-multi)
        (:mode '(org-mode
                 outline-mode
                 magit-log-mode)
         "g" 'consult-imenu)

        :general
        (:keymaps 'org-mode-map
         [remap consult-imenu] 'consult-org-heading
         [remap imenu] 'consult-org-heading)
        ([remap execute-extended-command-for-buffer] 'consult-mode-command
         [remap imenu] 'consult-imenu
         [remap imenu-anywhere] 'consult-imenu-multi
         [remap switch-to-buffer] 'consult-buffer
         [remap multi-occur] 'consult-line-multi
         [remap apropros-command] 'describe-symbol
         [remap bookmark-jump] 'consult-bookmark
         [remap goto-line] 'consult-goto-line
         [remap isearch-forward] 'consult-line
         [remap keep-lines] 'consult-keep-lines
         [remap load-theme] 'consult-theme
         [remap org-agenda] 'consult-org-agenda
         [remap project-switch-to-buffer] 'consult-project-buffer
         ;; [remap flush-lines] 'consult-flush-lines
         [remap man] 'consult-man
         [remap woman] 'consult-man
         [remap info] 'consult-info
         [remap info-display-manual] 'consult-info
         "C-M-y" 'consult-yank-pop
         "C-s" 'consult-line)
        (:keymaps 'projectile-mode-map
         [remap project-switch-to-buffer] 'consult-project-buffer)
        (:keymaps 'evil-command-line-map
         "C-s" 'consult-history)
        (:keymaps 'minibuffer-local-map
         "C-s" 'consult-history))
    #+END_SRC

*** Consult Buffer
    #+begin_src emacs-lisp
      (use-package consult
        :autoload (consult--source-project-buffer
                   consult--source-project-recent-file)
        :config
        (setq consult-project-buffer-sources
              `((:hidden nil
                 :narrow (?b . "Buffer")
                 ,@consult--source-project-buffer)
                (:hidden t                                        ; Should be shown by project-file.
                 :narrow ?r
                 :narrow (?r . "Recent File")
                 :name "Project Recent File"
                 ,@consult--source-project-recent-file)))

        :autoload (consult--buffer-state
                   consult--buffer-query)
        :preface
        (defvar consult--source-dired+
          `(:name     "Dired"
            :narrow   ?d
            :hidden   t
            :category buffer
            :face     dired-directory
            :state    ,#'consult--buffer-state
            :items
            ,(lambda ()
               (consult--buffer-query :mode 'dired-mode
                                      :sort 'visibility
                                      :as #'buffer-name)))
          "Dired buffer candidate source for `consult-buffer'.")
        :config
        (push 'consult--source-dired+ consult-buffer-sources)

        :preface
        (defvar consult--source-remote+
          `(:name     "Remote"
            :narrow   ?t
            :hidden   t
            :category buffer
            :face     consult-buffer
            :state    ,#'consult--buffer-state
            :items
            ,(lambda ()
               (consult--buffer-query :sort 'visibility
                                      :as #'buffer-name
                                      :predicate (lambda (buffer)
                                                   (with-current-buffer buffer
                                                     (file-remote-p
                                                      (or (buffer-file-name)
                                                          default-directory)))))))
          "Remote buffer candidate source for `consult-buffer'.")
        :config
        (push 'consult--source-remote+ consult-buffer-sources)

        :autoload (consult--file-state
                   consult--file-action)
        :preface
        ;; Make `consult-project-buffer' more like [[https://github.com/Qkessler/consult-project-extra][consult-project-extra]].
        (defvar consult--source-project-file+
          `(:name     "Project File"
            :narrow   (?f . "File")
            :category project-file
            :face     consult-file
            :history  file-name-history
            :state    ,#'consult--file-state
            :action   ,#'consult--file-action
            :enabled  ,#'project-current
            :items
            ,(lambda ()
               (when-let* ((project (project-current)))
                 (consult--hide-prefix+ (project-files project)
                                        (project-root project))))))
        :autoload consult--hide-prefix+
        :preface (use-package project :autoload (project-root project-files))
        :config
        (plist-put consult--source-project-file+ :new
                   (plist-get consult--source-project-recent-file :new))

        (defun consult--hide-prefix+ (file-paths prefix)
          "Strip PREFIX from FILE-PATHS."
          (let* ((inv-root (propertize (expand-file-name prefix) 'invisible t)))
            (mapcar (lambda (f)
                      (let ((relative-file-name (file-relative-name f prefix)))
                        (concat inv-root relative-file-name)))
                    file-paths)))

        (add-to-list 'consult-project-buffer-sources 'consult--source-project-file+ 'append)

        :preface
        (defvar consult--source-known-projects+
          `(:name     "Known Project"
            :narrow   (?p . "Project")
            :category project
            :face     font-lock-constant-face
            :history  file-name-history
            :action   ,#'consult--file-action
            :items    ,#'project-known-project-roots))

        :config
        (add-to-list 'consult-project-buffer-sources 'consult--source-known-projects+ 'append))
    #+end_src

*** Consult Evil
    A helper from the venerable [[https://github.com/minad/consult/issues/318#issuecomment-882067919][noctuid]] to save a consult-line output as the current evil matcher.

    #+begin_src emacs-lisp
      (use-package +pkg-evil
        :after consult
        :init (advice-add 'consult-line :after #'consult-line-evil-history+)
        :autoload consult-line-evil-history+
        :preface (use-package orderless :autoload orderless-compile)
        :config
        (defun consult-line-evil-history+ (&rest _)
          "Add latest `consult-line' search pattern to the evil search history ring."
          (when (and (bound-and-true-p evil-mode)
                     (eq evil-search-module 'evil-search))
            (let* ((input (car consult--line-history))
                   (pattern (cond ((member 'orderless completion-styles)
                                   (eval
                                    `(rx (or ,@(cl-loop for regexp in (cdr (orderless-compile input))
                                                        collect `(regexp ,regexp))))))
                                  (t input))))
              (add-to-history 'evil-ex-search-history pattern)
              (setq evil-ex-search-pattern (list pattern t t)
                    evil-ex-search-direction 'forward)
              (when (and evil-ex-search-persistent-highlight
                         (functionp 'evil-ex-search-activate-highlight))
                (evil-ex-search-activate-highlight evil-ex-search-pattern))))))
    #+end_src

*** Consult Imenu
    #+begin_src emacs-lisp
      (use-package consult-imenu
        :preface
        (defconst consult-imenu-assoc+
          '((("Class" "Classes")                       ?c font-lock-type-face)
            ("Struct"                                  ?s font-lock-type-face)
            (("Interface" "Interfaces")                ?i font-lock-type-face)
            ("Types"                                   ?t font-lock-type-face)
            ("Enum"                                    ?e font-lock-type-face)

            ("Namespace"                               ?n font-lock-preprocessor-face)
            (("Module" "Modules" "Package" "Packages") ?p font-lock-preprocessor-face)

            ("Macros"                                  ?@ font-lock-preprocesser-face)
            ;; TODO: Makes tasks a proxy for Functions, where both may be needed.
            (("Method" "Tasks")                        ?m font-lock-function-name-face)
            ("Constructor"                             ?K font-lock-function-name-face)
            (("Function" "Functions")                  ?f font-lock-function-name-face)

            ("Array"                                   ?A font-lock-variable-name-face)
            ("Boolean"                                 ?B font-lock-variable-name-face)
            ("EnumMember"                              ?E font-lock-variable-name-face)
            ("EnumMember"                              ?B font-lock-variable-name-face)
            ("Number"                                  ?N font-lock-variable-name-face)
            ("Object"                                  ?O font-lock-variable-name-face)
            ("String"                                  ?S font-lock-variable-name-face)

            ("Constant"                                ?k font-lock-variable-name-face)
            (("Variable" "Variables")                  ?v font-lock-variable-name-face)
            ("Field"                                   ?V font-lock-variable-name-face)
            ("Property"                                ?P font-lock-variable-name-face))
          "Language agnostic `consult-imenu-config'.
      This forces consistency in narrowing keys across all languages.")

        :autoload consult-imenu-gen-types+
        :preface
        (defun consult-imenu-gen-types+ (&rest types)
          "Build a `consult-imenu' configuration for TYPES."
          (cl-loop for type in types
                   with conf = nil
                   do (setq conf
                            (cdr (cl-find-if
                                  (lambda (it)
                                    (cond
                                     ((stringp it)
                                      (string-equal it type))
                                     ((consp it)
                                      (cl-member type it :test #'string-equal))))
                                  consult-imenu-assoc+
                                  :key #'car)))
                   when conf
                     collect (append (list (car conf) type) (cdr conf))))


        :custom
        ;; NOTE: Be careful when changing this, consult caches imenu items
        ;; and attaches `consult--type' indicators to candidates in the cache.
        ;; Changing this variable probably won't show any changes until the
        ;; cache is invalidated.
        (consult-imenu-config
         `((magit-mode :types ((?z "Stashes" font-lock-variable-name-face)
                               (?c "Recent commits" font-lock-doc-face)
                               (?t "TODOs" font-lock-type-face)
                               (?s "Staged changes" font-lock-keyword-face)
                               (?u "Unstaged changes" font-lock-number-face)
                               (?U "Untracked files" shadow)))
           (emacs-lisp-mode :toplevel "Functions"
                            :types ,(consult-imenu-gen-types+
                                     "Functions"
                                     "Macros"
                                     "Packages"
                                     "Types"
                                     "Variables"))
           (perl-mode :toplevel "Functions"
                      :types ,(consult-imenu-gen-types+
                               "Variables"
                               "Functions"))
           (verilog-mode :toplevel "Modules"
                         :types ,(consult-imenu-gen-types+
                                  "Modules"
                                  "Variables"
                                  "Classes"
                                  "Tasks"
                                  "Functions"
                                  "Interfaces"
                                  "Types"))
           ;; Both c-mode and c++-mode have almost identical imenu functions.
           ,@(let ((conf `(:toplevel "Function"
                           :types ,(consult-imenu-gen-types+
                                    "Function" "Class" "Variable"))))
               `((c-mode ,@conf)
                 (c++-mode ,@conf)))
           (toml-ts-mode :types ((?h "Header" font-lock-variable-name-face)
                                 (?a "Array" font-lock-variable-name-face))))))

      (use-package eglot
        :after consult-imenu
        :autoload consult-imenu-override-types+
        :init
        ;; Override the types for the current major-mode with types. Used for minor-mode
        ;; configurations since consult doesn't support this.
        (defun consult-imenu-override-types+ (&rest types)
          (make-local-variable 'consult-imenu-config)
          (push `(,major-mode :types ,(apply #'consult-imenu-gen-types+ types))
                consult-imenu-config)
          (setq consult-imenu--cache nil))

        :autoload consult-imenu-setup-lsp+
        :hook ((eglot-managed-mode lsp-mode) . consult-imenu-setup-lsp+)
        :init
        (defun consult-imenu-setup-lsp+ ()
          (consult-imenu-override-types+
           "Array"
           "Boolean"
           "Class"
           "Constant"
           "Constructor"
           "EnumMember"
           "Enum"
           "Field"
           "Function"
           "Interface"
           "Method"
           "Module"
           "Namespace"
           "Number"
           "Object"
           "Package"
           "Property"
           "String"
           "Struct"
           "Type Parameter"
           "Variable"))

        :config
        ;; Apply to any modes that already had LSP enabled prior to loading `consult-imenu'.
        (dolist (buffer (buffer-list))
          (with-current-buffer buffer
            (when (or (bound-and-true-p eglot--managed-mode)
                      (bound-and-true-p lsp-mode))
              (consult-imenu-setup-lsp+)))))
    #+end_src

*** Consult Bufler
    :PROPERTIES:
    :header-args+: :tangle (package-lisp! +pkg-consult bufler :consult)
    :END:

    #+begin_src emacs-lisp
      (use-package bufler
        :after consult
        :autoload bufler-buffer-alist-at
        :preface
        (defvar consult--bufler-workspace+
          `(:name "Workspace"
            :narrow ?w
            :category buffer
            :face consult-buffer
            :history  buffer-name-history
            :state    ,#'consult--buffer-state
            :enabled  ,(lambda () (frame-parameter nil 'bufler-workspace-path))
            :items
            ,(lambda ()
               (let ((bufler-vc-state nil))
                 (mapcar #'buffer-name
                         (mapcar #'cdr
                                 (bufler-buffer-alist-at
                                  (frame-parameter nil 'bufler-workspace-path)
                                  :filter-fns bufler-filter-buffer-fns))))))
          "Bufler workspace buffers source for `consult-buffer'.")

        :config
        (push 'consult--bufler-workspace+ consult-buffer-sources))
    #+end_src

*** Consult Git                                                      :wip:
    #+begin_src emacs-lisp
      (use-package consult-ls-git
        :straight t
        :leader ("gf" 'consult-ls-git))
    #+end_src

*** Consult Yasnippet
    :PROPERTIES:
    :header-args+: :tangle (package-lisp! +pkg-consult yasnippet :consult)
    :END:

    #+begin_src emacs-lisp
      (use-package consult-yasnippet
        :straight t
        :preface
        (defvar embark-yasnippet-completion-actions+ (make-sparse-keymap))

        :general
        (:states '(insert normal)
         "C-M-i" 'consult-yasnippet)
        (:keymaps 'embark-yasnippet-completion-actions+
         "d" 'consult-yasnippet-visit-snippet-file                                  ; NOTE: Binding differs from `ivy-yasnippet' which uses "v".
         "g" 'consult-yasnippet-visit-snippet-file                                  ; NOTE: Binding differs from `ivy-yasnippet' which uses "v".
         ))

      (use-package embark
        :config
        (push '(yasnippet . embark-yasnippet-completion-actions+)
              embark-keymap-alist))
    #+end_src

*** Consult Extensions
    :PROPERTIES:
    :header-args+: :tangle (package-lisp! +consult-custom :consult)
    :END:

    Consult is great but there's some commands its missing that I've had to implement
    myself. Most of those go into this branch and are tangled to a separate file from
    my main ~init.el~ to allow ~consult~ to be deferred.

    #+begin_src emacs-lisp :tangle (package-lisp! +pkg-consult :consult)
      (use-package +consult-custom
        :commands (consult-line-literal+
                   consult-evil-jumps+
                   consult-evil-marks+
                   consult-org-capture+
                   consult-line-or-ripgrep+
                   +dot-goto-fs-aliases
                   +dot-goto-executable
                   +dot-open-bookmark
                   consult-ebdb-display-records+
                   consult-ebdb-mail+
                   consult-ebdb-cite-records-mail+)
        :custom
        (+org-capture-function 'consult-org-capture+)

        :config
        (evil-set-command-property 'consult-line-literal+ :jump t)
        (evil-set-command-property 'consult-evil-jumps+ :jump t)
        (evil-set-command-property 'consult-evil-marks+ :jump t)

        :config
        (consult-customize
         +dot-goto-fs-aliases
         :preview-key consult-manual-preview-key+
         +dot-goto-executable
         +dot-goto-fs-aliases
         +dot-open-bookmark
         :initial "*/")

        :preface
        (defvar embark-org-capture-completion-actions+ (make-sparse-keymap))
        (defvar embark-ebdb-completion-actions+ (make-sparse-keymap))
        :init
        (with-eval-after-load 'embark
          (add-to-list 'embark-keymap-alist '(org-capture . embark-org-capture-completion-actions+))
          (add-to-list 'embark-keymap-alist '(ebdb . embark-ebdb-completion-actions+)))

        :general
        ([remap consult-line] 'consult-line-or-ripgrep+
         "C-M-s" 'consult-line-literal+
         [remap org-capture] 'consult-org-capture+
         )
        (:keymaps 'embark-org-capture-completion-actions+
         "t" 'consult-org-capture-goto-target+
         "l" 'org-capture-goto-last-stored+
         "i" 'consult-org-capture-insert-template+)
        (:keymaps 'embark-ebdb-completion-actions+
         "g" 'consult-org-capture-goto-target+
         "c" 'consult-ebdb-mail+
         "i" 'consult-ebdb-cite-records+)

        :leader
        ("rj" 'consult-evil-jumps+
         "rn" 'consult-evil-marks+
         "ak" '(consult-ebdb-display-records+ :wk "consult-ebdb"))
        ("fd" '(:ignore t :wk "dotfiles")
         "fda" '+dot-goto-fs-aliases
         "fdf" '+dot-goto-fs-aliases
         "fdx" '+dot-goto-executable
         "fdb" '+dot-open-bookmark))
    #+end_src

    #+BEGIN_SRC emacs-lisp
      (require 'consult)
      (require 'consult-register)
      (require 'embark)
      (require 'marginalia)
      (eval-when-compile (require '+lib-plist-pop))
    #+END_SRC

**** consult-line-literal
     #+begin_src emacs-lisp
       (defun consult-line-literal+ ()
         (interactive)
         (let ((completion-styles
                (if (member 'orderless completion-styles)
                    '(orderless)
                  '(substring)))
               (orderless-matching-styles '(orderless-literal))
               (completion-category-defaults nil)
               (completion-category-overrides nil))
           (consult-line)))
     #+end_src

**** consult-evil-jumps
     Adapted from [[https://github.com/emacs-evil/evil-collection/blob/1ad283f5b7ac9320ac3d41bccfc71a52f714563a/modes/consult/evil-collection-consult.el#L106][evil-collection]].

     #+BEGIN_SRC emacs-lisp
       (declare-function evil--jumps-get-window-jump-list "evil")

       (defun consult-evil-jumps+ ()
         "Jump to a position in the evil jump list."
         (interactive)
         (consult-global-mark
          (delq nil (mapcar (lambda (jump)
                              (let ((mark (car jump)))
                                (when (markerp mark)
                                  mark)))
                            (ring-elements (evil--jumps-get-window-jump-list))))))
     #+END_SRC

**** consult-evil-marks
     Taken from [[https://github.com/abo-abo/swiper/blob/25439e26a67b54d1f8aab1cbc727228427692ec8/counsel.el#L4198][counsel.el]].

     #+BEGIN_SRC emacs-lisp
       (declare-function evil-global-marker-p "evil")

       (defun consult--evil-marks-candidates+ ()
         "Convert all evil-marks in the current buffer to mark candidates.
       A mark is a register which points to a location in the current buffer."
         (cl-loop for (char . data) in (when (bound-and-true-p evil-markers-alist)
                                         (append
                                          evil-markers-alist
                                          (default-value 'evil-markers-alist)))
                  if (or (not (evil-global-marker-p char))
                         (markerp data))
                  collect (cons (consult-register-format (cons char data)) data)))

       (defun consult-evil-marks+ ()
         "Jump to a local or glboal evil-mark."
         (interactive)
         (if-let* ((marks (consult--with-increased-gc (consult--evil-marks-candidates+))))
             (consult--read
              marks
              :prompt "Evil mark: "
              :category 'consult-location
              :sort nil
              :require-match t
              :lookup #'consult--lookup-cdr
              :history t ;; disable history
              :add-history (thing-at-point 'symbol)
              :state (consult--jump-state))
           (user-error "No active evil-marks")))
     #+END_SRC

**** consult-org-capture
     Copied from [[https://github.com/abo-abo/swiper/blob/25439e26a67b54d1f8aab1cbc727228427692ec8/counsel.el#L3871][counsel.el]].

     #+BEGIN_SRC emacs-lisp
       (defvar org-capture-templates)
       (defvar org-capture-templates-contexts)
       (declare-function org-capture-goto-target "org")
       (declare-function org-contextualize-keys "org")
       (declare-function org-capture-upgrade-templates "org")

       (defun consult-org-capture-candidates+ ()
         "Taken from `counsel-org-capture'."
         (cl-loop
          with prefixes = nil
          for x in (or (org-contextualize-keys
                        (org-capture-upgrade-templates org-capture-templates)
                        org-capture-templates-contexts)
                       '(("t" "Task" entry (file+headline "" "Tasks")
                          "* TODO %?\n  %u\n  %a")))
          nconc (let ((x-keys (car x)))
                  ;; Remove prefixed keys until we get one that matches the current item.
                  (while (and prefixes
                              (let ((p1-keys (caar prefixes)))
                                (or
                                 (<= (length x-keys) (length p1-keys))
                                 (not (string-prefix-p p1-keys x-keys)))))
                    (pop prefixes))
                  (if (> (length x) 2)
                      (let ((desc (mapconcat #'cadr (reverse (cons x prefixes)) " | ")))
                        (list (cons (format "%-5s %s" x-keys desc) x-keys)))
                    (push x prefixes)
                    nil))))

       (defvar consult-org-capture-history+ nil)
       (defun consult--org-capture+ ()
         "Backend implementation for `consult-org-capture'."
         (consult--read (consult--with-increased-gc
                         (consult-org-capture-candidates+))
                        :prompt "Capture template: "
                        :lookup #'consult--lookup-cdr
                        :category 'org-capture
                        :require-match t
                        :sort nil
                        :history 'consult-org-capture-history+))

       (defun consult-org-capture+ (key)
         "Capture something."
         (interactive
          (list (consult--org-capture+)))
         (org-capture nil key))

       (defun consult-org-capture-goto-target+ (key)
         (interactive
          (list (consult--org-capture+)))
         (org-capture-goto-target key))

       (defun consult-org-capture-insert-template+ (key)
         (interactive
          (list (consult--org-capture+)))
         (org-capture (point) key))
     #+END_SRC

**** consult-ebdb
     #+begin_src emacs-lisp
       (declare-function ebdb-cite-records "ebdb")
       (declare-function ebdb-records "ebdb")
       (declare-function ebdb-display-records "ebdb")
       (declare-function ebdb-record-mail-canon "ebdb")
       (declare-function ebdb-string "ebdb")
       (declare-function ebdb-mail "ebdb")

       (defun consult-ebdb-cands+ ()
         (require 'ebdb)
         (mapcar
          ;; This same lambda is used in `ebdb-counsel'.
          (lambda (rec)
            (let* ((rec-string (ebdb-string rec))
                   (mails (ebdb-record-mail-canon rec))
                   (mail-list (when mails
                                (mapconcat #'identity mails " "))))
              (cons (if mail-list
                        (concat rec-string " => " mail-list)
                      rec-string)
                    rec)))
          (ebdb-records)))

       (defun consult-ebdb-read+ ()
         (if-let* ((cands (consult-ebdb-cands+)))
             (cdr
              (assoc
               (completing-read "Records: "
                                (lambda (str pred action)
                                  (if (eq action 'metadata)
                                      '(metadata (category . ebdb))
                                    (complete-with-action action cands str pred))))
               cands))
           (user-error "No ebdb candidates found.")))

       (defmacro consult-ebdb-define-cmd+ (cmd)
         `(defun ,(intern (concat "consult-" (symbol-name cmd) "+")) (rec)
            (interactive (list (consult-ebdb-read+)))
            (,cmd rec)))

       (defun consult-ebdb-display-records+ (rec)
         (interactive (list (consult-ebdb-read+)))
         (ebdb-display-records (list rec) nil t))
       (consult-ebdb-define-cmd+ ebdb-mail)
       (consult-ebdb-define-cmd+ ebdb-cite-records)
     #+end_src

**** consult-line-or-grep
     #+begin_src emacs-lisp
       (defvar consult-line-or-ripgrep-line-limit+ (* 2 1024 1024) ; 2 MiB
         "Buffer size threshold for `consult-line-or-ripgrep+'.
       When the number of characters in a buffer exceeds this threshold,
       `consult-ripgrep' will be used instead of `consult-line'.")

       (defun consult-line-or-ripgrep+ (&optional initial)
         "Call `consult-line' for small buffers or `consult-ripgrep' for large files."
         (interactive)
         (if (or (not buffer-file-name)
                 (buffer-narrowed-p)
                 (ignore-errors
                   (file-remote-p buffer-file-name))
                 (jka-compr-get-compression-info buffer-file-name)
                 (<= (buffer-size)
                     (/ consult-line-or-ripgrep-line-limit+
                        (if (eq major-mode 'org-mode) 2 1)))
                 (not (executable-find "rg" 'remote)))
             (call-interactively 'consult-line)
           (when (file-writable-p buffer-file-name)
             (save-buffer))
           (let ((consult-ripgrep-args
                  (concat consult-ripgrep-args
                          " --glob=" (shell-quote-argument (file-name-nondirectory buffer-file-name)))))
             (consult-ripgrep-no-project+))))
     #+end_src

**** dotfiles
     #+BEGIN_SRC emacs-lisp
       (defvar +dot-goto-executable-history nil)

       (defun +dot-goto-executable (executable)
         "List and jump to an executable using [[https://github.com/mohkale/dotfiles/blob/master/bin/ls-exec][ls-exec]]."
         (interactive
          (list (consult--read
                 (consult--async-command
                     (lambda (input)
                       (pcase-let ((`(,arg . ,opts) (consult--command-split input)))
                         (unless (string-blank-p arg)
                           (list `("ls-exec" ,arg ,@opts)
                                 (cdr (consult--default-regexp-compiler
                                       input 'basic completion-ignore-case)))))))
                 :prompt "Find executable: "
                 :category 'file
                 :require-match t
                 :history '(:input +dot-goto-executable-history)
                 :initial (consult--async-split-initial "*"))))
         (find-file executable))
     #+END_SRC

     #+BEGIN_SRC emacs-lisp
       (defvar +dot-goto-fs-aliases-narrow '((?f . "File")
                                             (?d . "Directory")
                                             (?s . "Symlink")
                                             (?u . "Unknown")))

       (defun +dot-goto-fs-aliases-format-lines (async builder)
         (let ((highlight))
           (lambda (action)
             (cond ((stringp action)
                    (funcall async action))
                   ((consp action)
                    (let (result)
                      (save-match-data
                        (dolist (fsmap action)
                          (when (string-match (rx bol
                                                  (group (one-or-more (not whitespace)))
                                                  ":"
                                                  (group (one-or-more anychar))
                                                  eol)
                                              fsmap)
                            (push (let* ((alias (match-string 1 fsmap))
                                         (path  (match-string 2 fsmap))
                                         str)
                                    (setq str (concat (propertize alias 'face 'font-lock-type-face)
                                                      " "
                                                      path))
                                    (add-text-properties 0 1 `(consult--type
                                                               ,(or (let ((type (file-attribute-type (file-attributes (file-chase-links path)))))
                                                                      (cond
                                                                       ((eq type t) ?d)
                                                                       ((eq type nil) ?f)
                                                                       ((stringp type) ?s)))
                                                                    ?u))
                                                         str)
                                    (list str (expand-file-name path) 1 1))
                                  result))))
                      (funcall async (nreverse result))))
                   (t (funcall async action))))))

       (defvar +dot-goto-fs-aliases-history nil)

       (defun +dot-goto-fs-aliases (file)
         "List file system maps (using [[https://github.com/mohkale/dotfiles/blob/c534c70befdfcae7abaad3f0a6777392f63db6c5/bin/ls-fsmaps][here]]) and find one in emacs."
         (interactive
          (list (car
                 (let ((builder (lambda (input)
                                  (pcase-let* ((`(,arg . ,opts) (consult--command-split input)))
                                    (unless (string-blank-p arg)
                                      (list `("ls-fs-shortcuts" "-b" "fs-alias" "-er" ,arg ,@opts)
                                            (cdr (consult--default-regexp-compiler
                                                             input 'basic completion-ignore-case))))))))
                   (consult--read
                    (consult--async-command builder
                      (+dot-goto-fs-aliases-format-lines builder))
                    :prompt "File system map: "
                    :lookup #'consult--lookup-cdr
                    :require-match t
                    :group
                    (consult--type-group +dot-goto-fs-aliases-narrow)
                    :narrow
                    ;; (consult--type-narrow +dot-goto-fs-aliases-narrow)
                    (let* ((narrow (consult--type-narrow +dot-goto-fs-aliases-narrow))
                           (pred (plist-pop! narrow :predicate)))
                      `(:predicate
                        ,(lambda (cand)
                           (funcall pred (car cand)))
                        ,@narrow))
                    :history '(:input +dot-goto-fs-aliases-history)
                    :initial (consult--async-split-initial "*"))))))
         (find-file file))
     #+END_SRC

     #+BEGIN_SRC emacs-lisp
       (require '+pkg-browse-url)

       (defun +dot-open-bookmark-format-lines (async builder)
         (let (highlight)
           (lambda (action)
             (cond ((stringp action)
                    (funcall async action))
                   ((consp action)
                    (funcall async
                     (cl-loop for row in action
                              do (setq row (split-string row "\t"))
                              with url   = nil
                              with tags  = nil
                              with title = nil
                              do (setq url   (nth 0 row)
                                       tags  (nth 1 row)
                                       title (nth 2 row))
                              when (string-prefix-p "http" url)
                                collect (cons
                                         (concat (unless (string-empty-p tags)
                                                   (propertize (concat "(" tags ") ") 'face 'bold))
                                                 title
                                                 (when url
                                                   (when-let* ((domain (url-domain (url-generic-parse-url url))))
                                                     (concat " [" (propertize domain 'face 'font-lock-preprocessor-face) "]"))))
                                         url))))
                   (t (funcall async action))))))

       (defvar +dot-open-bookmark-history nil)

       (defun +dot-open-bookmark (bookmark)
         "List system bookmarks (using [[https://github.com/mohkale/dotfiles/blob/master/bin/ls-bookmarks][this]]) and open it in your default browser."
         (interactive
          (list
           (let ((builder (lambda (input)
                            (pcase-let* ((`(,arg . ,opts) (consult--command-split input)))
                              (unless (string-blank-p arg)
                                (list `("ls-bookmarks" ,arg ,@opts)
                                      (cdr (consult--default-regexp-compiler
                                            input 'basic completion-ignore-case))))))))
             (consult--read
              (consult--async-command builder
                (+dot-open-bookmark-format-lines builder))
              :prompt "Bookmark: "
              :lookup #'consult--lookup-cdr
              :require-match t
              :history '(:input +dot-open-bookmark-history)
              :initial (consult--async-split-initial "*")))))
         (+xopen-url bookmark))
     #+END_SRC

**** Appendix
     #+BEGIN_SRC emacs-lisp
       (provide '+consult-custom)
     #+END_SRC

*** Consult Extensions
    Customizations are put at the end because otherwise =consult-customize= will
    trigger compiler warnings.

    #+begin_src emacs-lisp
      (require '+setup-scratch)

      (use-package consult
        :straight t

        :autoload consult--customize-put
        :config
        (consult-customize
         consult-ripgrep
         consult-ripgrep-no-project+
         consult-grep-no-project+
         xref-find-references
         consult-recent-file
         consult--source-recent-file
         consult--source-project-file+
         :preview-key consult-manual-preview-key+
         consult-recent-file
         :sort nil
         ;; Async commands that produce a lot of output so it's useful for them to be async
         ;; but once produced you won't be re-running the command again.
         consult-find
         consult-find-no-project+
         :initial "*/"
         scratch-buffer+
         :state #'consult--buffer-state))
    #+end_src

*** Appendix
    #+begin_src emacs-lisp
    (provide '+pkg-consult)
    #+end_src

** Apheleia                                                        :optional:
   :PROPERTIES:
   :header-args+: :tangle (package-lisp! +pkg-apheleia apheleia)
   :END:

   Auto-format buffers on save using programs like ~black~ or ~gofmt~.

   #+begin_src emacs-lisp :tangle (package-yes! apheleia)
   (require '+pkg-apheleia)
   #+end_src

   #+begin_src emacs-lisp
     (use-package apheleia
       :straight t
       :hook (((go-mode go-ts-mode) . apheleia-mode)
              (caddyfile-mode . apheleia-mode))
       :leader
       ("tma" 'apheleia-mode
        "bf" 'apheleia-format-buffer)

       :custom
       (apheleia-hide-log-buffers t)
       (apheleia-remote-algorithm 'remote)

       :config
       (setf (alist-get 'json-mode apheleia-mode-alist) 'jq)
       (setf (alist-get 'js-json-mode apheleia-mode-alist) 'jq)

       (setf (alist-get 'cabal-fmt apheleia-formatters) '("cabal-fmt"))
       (setf (alist-get 'haskell-mode apheleia-mode-alist) 'cabal-fmt)

       (setf (alist-get 'dotnet apheleia-formatters) '("dotnet" "format"))
       (setf (alist-get 'csharp-mode apheleia-mode-alist) 'dotnet)

       (setf (alist-get 'python-mode apheleia-mode-alist) '(isort black))

       (setf (alist-get 'mbake apheleia-formatters) '("mbake" "format" "--stdin"))
       (setf (alist-get 'makefile-mode apheleia-mode-alist) 'mbake)

       (setf (alist-get 'ruby-mode apheleia-mode-alist) 'rubocop)
       (setf (alist-get 'enh-ruby-mode apheleia-mode-alist) 'rubocop)

       (setf (alist-get 'sh-mode apheleia-mode-alist) 'shfmt))
   #+end_src

   #+begin_src emacs-lisp
   (provide '+pkg-apheleia)
   #+end_src

** Anzu
   :PROPERTIES:
   :header-args+: :tangle (package-lisp! +pkg-anzu anzu)
   :END:

   shows the number of search results in the mode-line. by default. This package only
   works with the built in isearch module for evil.

   #+begin_src emacs-lisp :tangle (package-yes! anzu)
   (require '+pkg-anzu)
   #+end_src

*** Anzu
    #+BEGIN_SRC emacs-lisp
      (use-package anzu
        :straight t
        :hook (after-init . global-anzu-mode)
        :diminish
        :custom
        (anzu-cons-mode-line-p nil)
        (anzu-search-threshold 10000))
    #+END_SRC

*** Evil Anzu                                                      :optional:
    #+BEGIN_SRC emacs-lisp
      (use-package evil-anzu
        :straight t
        :after (evil anzu)
        :demand t)
    #+END_SRC

*** Appendix
    #+begin_src emacs-lisp
    (provide '+pkg-anzu)
    #+end_src

** Browse at Remote                                                :optional:
   :PROPERTIES:
   :header-args+: :tangle (package-yes! browse-at-remote)
   :END:

   Open files in a repository in their configured remote (GitHub/GitLab/etc.).

   #+begin_src emacs-lisp
     (use-package browse-at-remote
       :straight t
       :leader ("go" 'browse-at-remote)

       :general
       (:keymaps 'magit-mode-map
        [remap +xopen-url] 'browse-at-remote))
   #+end_src

** Bufler                                                          :optional:
   :PROPERTIES:
   :header-args+: :tangle (package-lisp! +pkg-bufler bufler)
   :END:

   #+begin_src emacs-lisp :tangle (package-yes! bufler)
   (require '+pkg-bufler)
   #+end_src

   #+BEGIN_SRC emacs-lisp
     (use-package bufler
       :straight t
       :hide-whitespace+ bufler-list-mode
       :custom
       (bufler-list-display-buffer-action
        '((display-buffer-reuse-window
           display-buffer-same-window)))

       :config
       ;; Force buffler to appear in the current window
       (push `(,(rx "*Bufler*")
               (display-buffer-reuse-window
                display-buffer-same-window))
             display-buffer-alist)

       :leader
       ("bm" 'bufler)
       (:mode 'bufler-list-mode
        "b" 'bufler-switch-buffer
        "." 'hydra:bufler/body)

       :general
       (:keymaps 'bufler-list-mode-map
        :states 'motion
        "o" 'bufler-list-buffer-peek
        "RET" 'bufler-list-buffer-switch
        "d" 'bufler-list-buffer-kill
        "s" 'bufler-list-buffer-save
        [remap revert-buffer] 'bufler))
   #+END_SRC

   #+begin_src emacs-lisp
   (provide '+pkg-bufler)
   #+end_src

** Adaptive Wrap                                                   :optional:
   :PROPERTIES:
   :header-args+: :tangle (package-yes! adaptive-wrap)
   :END:

   This package provides a mode such that when a paragraph you're inserting gets too
   long, when it wraps round to the next line (assuming truncate-lines is disabled)
   sequential lines are indented slightly to distinguish them from other lines.

   #+BEGIN_SRC emacs-lisp
     (use-package adaptive-wrap
       :straight t)
   #+END_SRC

** Beacon                                                          :optional:
   :PROPERTIES:
   :header-args+: :tangle (package-yes! beacon)
   :END:

   #+BEGIN_SRC emacs-lisp
     (use-package beacon
       :straight t
       :hook (after-init . beacon-mode))
   #+END_SRC

** Eglot                                                 :optional:lspclient:
   :PROPERTIES:
   :header-args+: :tangle (package-lisp! +pkg-eglot eglot)
   :END:

   #+begin_src emacs-lisp :tangle (package-yes! eglot)
   (require '+pkg-eglot)
   #+end_src

*** Eglot
    #+BEGIN_SRC emacs-lisp
      (use-package eglot
        :hook (eglot-connect . eglot-signal-didChangeConfiguration)
        :custom
        (eglot-autoreconnect nil)
        (eglot-extend-to-xref t)
        (eglot-stay-out-of '(company))                                                ; I'll set my backends myself, thank you.
        (eglot-ignored-server-capabilities '(:documentHighlightProvider)
         "Suppress some language server features.")
        (eglot-confirm-server-initiated-edits nil)

        :autoload eglot-completion-at-point
        :completion+
        (eglot-managed-mode eglot-completion-at-point)

        :init
        (setq-default eglot-workspace-configuration
                      '((:pylsp
                         (configurationSources . ["pycodestyle"])
                         (plugins
                          ;; Completion
                          (jedi_completion (fuzzy . t))
                          (jedi
                           ;; Add src/ to [[https://github.com/python-lsp/python-lsp-server/issues/500][PYTHONPATH]].
                           (extra_paths . ["src"]))
                          ;; Formatters
                          (black
                           (enabled . t)
                           ;; Better performance but will require server restarts on config changes.
                           (cache_config . t))
                          ;; Linters
                          (pydocstyle (enabled . t))
                          (pylint (enabled . nil))
                          (pylsp_mypy
                           ;; Only calculate on file-saves (the alternative is too performance heavy)
                           (live_mode . :json-false)
                           ;; Use the mypy daemon to speed up type-checking.
                           (dmypy . t))
                          (ruff (enabled . t))))
                        (:omnisharp
                         (path . "")
                         (useModernNet . t)
                         (useGlobalMono . "always")
                         (useGlobalMono . nil)
                         (enableEditorConfigSupport . t))))

        :config
        ;; Remove eglot from `mode-line-misc-info'.
        (setf (alist-get 'eglot--managed-mode mode-line-misc-info nil t) nil)

        :autoload (eglot-ensure eglot--major-modes eglot-server-exists-p+)
        :init
        (cl-defmethod +lsp--command ((_backend (eql eglot)))
          (if current-prefix-arg
              (call-interactively #'eglot)
            (eglot-ensure)))

        (defun eglot-server-exists-p+ (mode &optional all-workspaces)
          "Assert whether a server exists in the current workspace for MODE.
      When ALL-WORKSPACES is true we instead check for a server running in any
      workspace."
          (when (featurep 'eglot)
            (seq-find
             (lambda (server)
               (-first (apply-partially #'provided-mode-derived-p mode)
                       (eglot--major-modes server)))
             (if all-workspaces
                 (-flatten (hash-table-values eglot--servers-by-project))
               (gethash (or (project-current) `(transient . ,default-directory))
                        eglot--servers-by-project)))))

        (cl-defmethod +lsp--server-running-in-workspace-p ((_backend (eql eglot)) mode)
          (eglot-server-exists-p+ mode))

        (cl-defmethod +lsp--server-running-in-any-workspace-p ((_backend (eql eglot)) mode)
          (eglot-server-exists-p+ mode 'all-workspaces))

        :autoload eglot-inlay-hints-mode
        :preface
        (defun eglot-turn-off-inlay-hints-mode+ ()
          "Turn off `eglot-inlay-hints-mode'."
          (eglot-inlay-hints-mode -1))
        :hook (eglot-managed-mode . eglot-turn-off-inlay-hints-mode+)

        :autoload eglot--imenu-DocumentSymbol+
        :preface (advice-add 'eglot--imenu-DocumentSymbol :override #'eglot--imenu-DocumentSymbol+)
        :config
        (defun eglot--imenu-DocumentSymbol+ (res)
          "Compute `imenu--index-alist' for RES vector of DocumentSymbol."
          (cl-labels ((flatmap (function sequence)
                               (let ((result nil))
                                 (dolist (it (apply #'append (mapcar function sequence)))
                                   (if-let* ((existing-group (alist-get (car it) result)))
                                       (setcdr existing-group (append (cdr existing-group) (cdr it)))
                                     (push (cons (car it) (cdr it)) result)))
                                 (nreverse result)))
                      (map-parent-group-prefix (name item)
                                               (cons (car item) (list (append (list name) (cdr item)))))
                      (dfs (&key name children range kind &allow-other-keys)
                           (let ((reg (eglot--range-region range)))
                             (if (seq-empty-p children)
                                 `((,kind (,name . ,(car reg))))
                               (let ((result
                                      (mapcar (apply-partially #'map-parent-group-prefix name)
                                              (flatmap (lambda (c) (apply #'dfs c)) children)))
                                     (parent-entry `((,name . ,(car reg)))))
                                 (if-let* ((existing-group (alist-get kind result)))
                                     (setcdr existing-group (append parent-entry (cdr existing-group)))
                                   (push (cons kind parent-entry) result))
                                 result))))
                      (map-kind-names (item)
                                      (cons (alist-get (car item) eglot--symbol-kind-names "Unknown")
                                            (cdr item))))
            (mapcar #'map-kind-names (flatmap (lambda (c) (apply #'dfs c)) res))))

        :commands eglot-completion-at-point-interactive+
        :config
        (defalias 'eglot-completion-at-point-interactive+
          (cape-capf-interactive #'eglot-completion-at-point))

        :general
        ("C-;" 'eglot-completion-at-point-interactive+)

        :leader
        (:prefix leader-server-leader-prefix+
         "l" '+lsp-command
         "p" 'eglot-list-connections
         "e" 'eglot-events-buffer
         "x" 'eglot-shutdown
         ":" 'eglot-completion-at-point-interactive+)

        :lazy-leader
        (:mode 'eglot--managed-mode
         :minor t
         ;; aliases for gg and gG
         "jy" 'eglot-find-implementation
         "jY" 'eglot-find-typeDefinition
         "hy" 'eldoc-doc-buffer)
        (:mode 'eglot--managed-mode
         :minor t
         :prefix leader-server-leader-prefix+
         ;; unbound 'eglot-clear-status
         "a" 'eglot-code-actions
         "h" 'eldoc-doc-buffer
         "2" 'eglot-stderr-buffer
         "r" 'eglot-rename
         "f" 'eglot-format
         "F" 'eglot-format-buffer
         "o" 'eglot-reconnect

         "g" '(:ignore t :wk "goto")
         "gg" 'eglot-find-implementation
         "gG" 'eglot-find-typeDefinition
         "gd" 'eglot-find-declaration

         "t" 'eglot-find-typeDefinition
         "i" 'eglot-find-implementation
         "d" 'eglot-find-declaration

         "t" 'eglot-find-typeDefinition
         "i" 'eglot-find-implementation
         "d" 'eglot-find-declaration

         "w"  '(:ignore t :wk "workspace")
         "ws" 'eglot-show-workspace-configuration
         "wf" 'eglot-forget-pending-continuations
         "wc" 'eglot-signal-didChangeConfiguration))
    #+END_SRC

*** Eglot Yasnippet
    Eglot needs yasnippet otherwise snippet expansion won't work.

    #+begin_src emacs-lisp
      (use-package yasnippet
        :after eglot
        :demand t)
    #+end_src

*** Consult Eglot
    :PROPERTIES:
    :header-args+: :tangle (package-lisp! +pkg-eglot :consult eglot)
    :END:

    #+BEGIN_SRC emacs-lisp
      (use-package +pkg-evil
        :autoload evil-set-command-property
        :config
        (evil-set-command-property 'consult-eglot :jump t))

      (use-package consult-eglot
        :straight t
        :custom
        (consult-eglot-show-kind-name nil)

        :autoload eglot-imenu-make-markers+
        :autoload (eglot--range-region
                   eglot--dcase
                   eglot--error
                   eglot--check-object)
        :preface (use-package imenu :autoload imenu--subalist-p)
        :config
        (defun eglot-imenu-make-markers+ (cands)
          "Helper which makes `eglot-imenu' return points instead of special items.
      This is technically not as powerful as what what `eglot-imenu' currently
      returns since that also has the ability highlight the range over which an
      imenu entry is valid, but at the moment the only significant difference is
      eglots approach is slightly faster since it defers calculating the point of
      an entry until that entry is chosen. That's useful for basic imenu
      functionality but `consult-imenu' lets you preview positions and that would
      conflict with this."
          (cl-labels
              ((unfurl (item)
                (if (imenu--subalist-p item)
                    (mapcar #'unfurl (cdr item))
                  (pcase (cdr item)
                    ;; We ignore anything not of this form, but all entries
                    ;; should be like this so it doesn't really matter.
                    (`(,pos ,_fn . ,_args)
                     (setcdr
                      item
                      (car
                       (eglot--range-region
                        (eglot--dcase (aref pos 0)
                                      (((SymbolInformation) location)
                                       (plist-get location :range))
                                      (((DocumentSymbol) selectionRange)
                                       selectionRange))))))))))
            (mapc #'unfurl cands)
            cands))

        (advice-add 'eglot-imenu :filter-return #'eglot-imenu-make-markers+)

        :general
        (:keymaps 'eglot-mode-map
         [remap xref-find-apropos] 'consult-eglot-symbols
         [remap xref-find-references-and-replace] 'eglot-rename))

      (use-package consult-eglot-embark
        :straight t
        :commands consult-eglot-embark-mode
        :after (embark consult-eglot)
        :demand t
        :config
        (consult-eglot-embark-mode))
    #+END_SRC

*** Eglot-X                                                             :wip:
    :PROPERTIES:
    :header-args+: :tangle (package-lisp! +pkg-eglot :consult eglot eglot-x)
    :END:

    Non standard protocol extensions for eglot.

    #+begin_src emacs-lisp
      (use-package eglot-x
        :straight (eglot-x :host github :repo "nemethf/eglot-x")
        :after eglot
        :demand t
        :custom
        (eglot-x-enable-menu (not (package! mk-mode-line)))
        (eglot-x-enable-files t)

        :config
        (eglot-x-setup))
    #+end_src

*** Appendix
    #+begin_src emacs-lisp
   (provide '+pkg-eglot)
    #+end_src

** LSP Mode                                              :optional:lspclient:
   :PROPERTIES:
   :header-args+: :tangle (package-lisp! +pkg-lsp-mode lsp-mode)
   :END:

   #+begin_src emacs-lisp :tangle (package-yes! lsp-mode)
     (require '+pkg-lsp-mode)
   #+end_src

*** LSP Mode
    #+BEGIN_SRC emacs-lisp
      (use-package lsp-mode
        :straight t
        :custom
        (lsp-auto-guess-root t)
        (lsp-enable-indentation nil)
        (lsp-enable-snippet t)
        ;; (lsp-auto-configure nil)
        (lsp-modeline-diagnostics-enable nil)
        (lsp-enable-symbol-highlighting nil)
        (lsp-eldoc-render-all nil)
        (lsp-enable-xref t)
        (lsp-headerline-breadcrumb-enable nil)
        (lsp-session-file (state! "lsp/session"))
        (lsp-server-install-dir (cache! "lsp/servers"))
        (lsp-diagnostics-provider (if (package! flycheck)
                                      :flycheck
                                    :flymake))

        :autoload (lsp-deferred
                   lsp--workspace-client
                   lsp-workspace-root
                   lsp-session
                   lsp--matching-clients?
                   lsp--filter-clients
                   lsp-mode-server-exists-p+)
        :init
        (cl-defmethod +lsp--command ((_backend (eql lsp-mode)))
          (lsp-deferred))

        (defun lsp-mode-server-exists-p+ (mode &optional all-workspaces)
          (when (buffer-file-name) ; Needed for lsp--matching-clients?
            (let ((major-mode mode))
              (seq-intersection
               (lsp--filter-clients #'lsp--matching-clients?)
               (when-let* ((workspaces
                            (if all-workspaces
                                (-flatten (hash-table-values (lsp-session-folder->servers (lsp-session))))
                              (gethash (lsp-workspace-root) (lsp-session-folder->servers (lsp-session))))))
                 (mapcar #'lsp--workspace-client workspaces))
               #'equal))))

        (cl-defmethod +lsp--server-running-in-workspace-p ((_backend (eql lsp-mode)) mode)
          (lsp-mode-server-exists-p+ mode))

        (cl-defmethod +lsp--server-running-in-any-workspace-p ((_backend (eql lsp-mode)) mode)
          (lsp-mode-server-exists-p+ mode 'all-workspaces))

        :leader
        ("ll" '+lsp-command)

        :lazy-leader
        (:mode 'lsp-mode
         :minor t
         "jy" 'lsp-goto-type-definition
         "jY" 'lsp-goto-implementation)

        (:mode 'lsp-mode
         :minor t
         :prefix leader-server-leader-prefix+

         "?" 'lsp-describe-session
         "a" 'lsp-execute-code-action
         "s" 'lsp-document-highlight
         "h" 'lsp-describe-thing-at-point
         "x" 'lsp-disconnect

         "w"  '(:ignore t :wk "workspace")
         "wR" 'lsp-restart-workspace
         "wa" 'lsp-workspace-folders-add
         "wr" 'lsp-workspace-folders-remove
         "ws" 'lsp-workspace-folders-switch

         "L"  '(:ignore t :wk "lens")
         "Ll" 'lsp-lens-mode
         "Ls" 'lsp-lens-show
         "Lh" 'lsp-lens-hide

         "r"  '(:ignore t :wk "refactor")
         "rr" 'lsp-format-buffer
         "ri" 'lsp-organize-imports
         "rc" 'lsp-rename

         "g"  '(:ignore t :wk "goto")
         "gg" 'lsp-goto-type-definition
         "gG" 'lsp-goto-implementation
         "gF" 'lsp-find-implementation
         "gf" 'lsp-find-type-definition)

        :general
        (:keymaps 'lsp-mode-map
         [remap xref-find-references-and-replace] 'lsp-rename))
    #+END_SRC

*** LSP UI
    UI enhancements for LSP sessions... Tries to make emacs more like VS Code. Boooooo!!!

    #+BEGIN_SRC emacs-lisp
      (use-package lsp-ui
        :straight t
        ;; :hook (lsp-mode . lsp-ui-mode)
        :after lsp-mode
        :custom
        (lsp-ui-sideline-enable nil)
        (lsp-ui-doc-enable nil)

        :lazy-leader
        (:mode 'lsp-mode
         :minor t
         :prefix leader-server-leader-prefix+
         "p"  '(:ignore t :wk "peek")
         "pg" 'lsp-ui-peek-find-definitions
         "pG" 'lsp-ui-peek-find-definitions))
    #+END_SRC

*** DAP Mode                                                       :disabled:
    #+BEGIN_SRC emacs-lisp :tangle no
      (use-package dap-mode
        :straight t)
    #+END_SRC

*** Consult LSP
    :PROPERTIES:
    :header-args+: :tangle (package-lisp! +pkg-lsp-mode :consult lsp-mode)
    :END:

    #+BEGIN_SRC emacs-lisp
      (require 'evil)

      (use-package consult-lsp
        :straight t
        :config
        (evil-set-command-property 'consult-lsp :jump t)

        :leader
        (:mode 'lsp-mode
         :minor t
         :prefix leader-server-leader-prefix+
         "j" 'consult-lsp-symbols)
        :general
        (:keymaps 'lsp-mode-map
         [remap xref-find-apropos] 'consult-lsp-symbols))
    #+END_SRC

*** Appendix
    #+begin_src emacs-lisp
    (provide '+pkg-lsp-mode)
    #+end_src

** Redacted                                                        :disabled:
   :PROPERTIES:
   :header-args+: :tangle no
   :END:

   Provides a mode to obfuscate the text in a buffer in a way that's still legible for
   screenshots.

   #+begin_src emacs-lisp
     (use-package redacted
       :straight t)
   #+end_src

** Rainbow Mode                                                    :optional:
   :PROPERTIES:
   :header-args+: :tangle (package-lisp! +pkg-rainbow-mode rainbow-mode)
   :END:
   Highlights hex color strings in their appropriate color.

   #+begin_src emacs-lisp :tangle (package-yes! rainbow-mode)
     (require '+pkg-rainbow-mode)
   #+end_src

   #+begin_src emacs-lisp
     (use-package rainbow-mode
       :straight t)
   #+end_src

   #+begin_src emacs-lisp
     (provide '+pkg-rainbow-mode)
   #+end_src

** Olivetti                                                        :optional:
   :PROPERTIES:
   :header-args+: :tangle (package-lisp! +pkg-olivetti olivetti)
   :END:

   #+begin_src emacs-lisp :tangle (package-yes! olivetti)
   (require '+pkg-olivetti)
   #+end_src

   #+BEGIN_SRC emacs-lisp
     (use-package olivetti
       :straight t
       :commands olivetti-setup-buffer
       :hook (olivetti-mode . olivetti-setup-buffer)
       :preface
       (defvar olivetti-hide-fringe+ nil
         "When true, olivetti mode will hide the window fringe.")

       :hook (olivetti-mode . olivetti-setup-buffer+)
       :autoload olivetti-setup-buffer+
       :config
       (defun olivetti-setup-buffer+ ()
         "Hide line numbers and the fringe."
         (display-line-numbers-mode (if olivetti-mode -1 +1))

         (apply #'set-window-fringes
                (selected-window)
                (if (and olivetti-mode olivetti-hide-fringe+) '(0 0) '(8 8))))

       :leader
       ("M'" 'olivetti-mode)

       :lazy-leader
       ((concat leader-minor-mode-leader-prefix+ "-") 'olivetti-set-width)

       :general
       (:keymaps 'olivetti-mode-map
        "C-c >" #'olivetti-expand
        "C-c <" #'olivetti-shrink))
   #+END_SRC

   #+begin_src emacs-lisp
   (provide '+pkg-olivetti)
   #+end_src

** Diff Highlight                                                  :optional:
   :PROPERTIES:
   :header-args+: :tangle (package-lisp! +pkg-diff-hl diff-hl)
   :END:

   #+begin_src emacs-lisp :tangle (package-yes! diff-hl)
     (require '+pkg-diff-hl)
   #+end_src

   #+begin_src emacs-lisp
     (use-package diff-hl
       :straight t
       :hook ((diff-hl-mode . diff-hl-margin-mode)
              (diff-hl-mode . diff-hl-flydiff-mode))
       :custom
       (diff-hl-flydiff-delay 0.8)
       (diff-hl-margin-symbols-alist
        '((insert . "‚îÉ")
          (delete . "‚îÉ")
          (change . "‚îÉ")
          (unknown . "‚îÉ")
          (ignored . "‚îÉ")))

       :init
       ;; Optional extension package.
       (use-package smartrep
         :straight t)

       :leader
       ("th" 'diff-hl-mode))
   #+end_src

   #+begin_src emacs-lisp
     (provide '+pkg-diff-hl)
   #+end_src

** Skeletor                                           :optional:cookiecutter:
   :PROPERTIES:
   :header-args+: :tangle (package-lisp! +pkg-skeletor skeletor)
   :END:

   Project skeleton [[https://github.com/chrisbarrett/skeletor.el][unpacker]] in emacs-lisp.

   #+begin_src emacs-lisp :tangle (package-yes! skeletor)
     (require '+pkg-skeletor)
   #+end_src

   #+NAME: package-skeletor
   #+BEGIN_SRC emacs-lisp
     (use-package skeletor
       :straight t
       :commands (skeletor-expand-project+)
       :leader ("pn" 'skeletor-expand-project+)

       :custom
       (skeletor-user-directory (etc! "skeletor"))
       (skeletor-project-directory (car (bound-and-true-p projectile-project-search-path)))
       (skeletor-completing-read-function 'completing-read
        "Make skeletor defer to the current completion framework.")

       :preface
       (defun skeletor-show-project-command+ (dir)
         "Skeletor show project directory in different window."
         (display-buffer (dired-noselect dir)
                         '((display-buffer-reuse-window
                            display-buffer--maybe-pop-up-frame-or-window
                            display-buffer-use-some-window
                            display-buffer-pop-up-frame))))
       :custom (skeletor-show-project-command #'skeletor-show-project-command+)

       :config
       ;; Remove all the builtin skeletor project types because they're like a
       ;; decade old and some just don't work for some reason :/.
       (setq skeletor--project-types nil)

       :config
       ;; You can include dotfiles with __DOT__ so let me use actual dotfiles
       ;; for configuring stuff.
       (require 'cl-lib)
       (advice-add 'skeletor--dir->SkeletorTemplate :filter-return
                   (defun skeletor-dir-template-exclude-dotfiles+ (template)
                     ;; (setf (SkeletorTemplate-files template)
                     ;;       (seq-filter (lambda (it) (not
                     ;;                            (string-prefix-p "." (file-name-base it))))
                     ;;                   (SkeletorTemplate-files template)))

                     ;; KLUDGE: Hard-coded expansion of setf because its failing for some reason.
                     (aset template
                           (cl-position 'files (mapcar #'car (cl-struct-slot-info 'SkeletorTemplate)))
                           (seq-filter
                            (lambda (it)
                              (not (string-prefix-p "." (file-name-base it))))
                            (SkeletorTemplate-files template)))
                     template))

       :config
       ;; I keep definitions for skeletor templates and constructors within my skeleton
       ;; user directory.
       (dolist (it (append
                    (file-expand-wildcards (join-path+ skeletor-user-directory "*.el"))
                    (file-expand-wildcards (join-path+ skeletor-user-directory "*" ".skeletor.el"))))
         (load it nil t))

       :autoload (skeletor-shell-command
                  skeletor--log-info)
       :config
       (advice-add 'skeletor--initialize-git-repo :override
                   (defun skeletor--initialize-git-repo+  (dir)
                     "`skeletor--initialize-git-repo' override producing only one initial commit."
                     (let ((default-directory dir))
                       (skeletor--log-info "Initialising git...")
                       (unless (f-exists? (f-join dir ".git"))
                         (skeletor-shell-command "git init"))
                       (skeletor-shell-command "git add -A && git commit --allow-empty -m 'Initial commit'")
                       (message "Initialising git...done"))))

       :commands skeletor-expand-project+
       :autoload (skeletor-create-project-at
                  skeletor--read-project-name
                  skeletor--read-project-type)
       :config
       (defun skeletor-expand-project+ (skeleton dir)
         "Expand a skeletor project using the dirname as project-name when applicable.
     The default `skeletor-create-project-at' ask you to specify the project type
     directory and name on seperate prompts which I find unintuitive. This variant
     reads a directory and then uses the basename of that directory as the
     project-name unless its not empty in which case it reads a seperate dirname."
         (interactive (list (skeletor--read-project-type)
                            (expand-file-name
                             (if (directory-empty-p default-directory)
                                 ;; When the current directory is empty you probably want
                                 ;; to create a new project in it so show other projects
                                 ;; around it.
                                 (let ((cwd (string-trim-right default-directory "/")))
                                   (read-directory-name "Project directory: "
                                                        (file-name-directory cwd)
                                                        (file-name-nondirectory cwd)))
                               (read-directory-name "Project directory: ")))))
         (setq dir (string-trim-right dir
                                      (rx (one-or-more (eval (f-path-separator))))))

         (let* ((is-empty (and (not current-prefix-arg)
                               (or (not (file-directory-p dir))
                                   (directory-empty-p dir))))
                (basename (file-name-nondirectory dir))
                (dir (if is-empty (file-name-directory dir) dir)))
           ;; A project directory needs to empty before generation... so if
           ;; the input directory isn't then prompt for a project-name within
           ;; it.
           (cl-letf* ((skeletor--actual-read-project-name
                       (symbol-function 'skeletor--read-project-name))
                      ((symbol-function #'skeletor--read-project-name)
                       (lambda ()
                         (if is-empty
                             basename
                           (funcall skeletor--actual-read-project-name)))))
             (skeletor-create-project-at dir skeleton))))

       :config
       (defmacro skeletor-conf+ (key &optional default)
         "Retrieve a value from the skeletor substitions."
         `(if-let* ((val (assoc ,key subs)))
              (cdr val)
            ,default))

       ;; Easier to use in skeletor projects.
       (defalias 'skeletor-conf 'skeletor-conf+))
   #+END_SRC

   #+begin_src emacs-lisp
   (provide '+pkg-skeletor)
   #+end_src

** Link Hint                                                       :optional:
   :PROPERTIES:
   :header-args+: :tangle (package-lisp! +pkg-link-hint link-hint)
   :END:

   Jump to links through an Avy style interface.

   #+begin_src emacs-lisp :tangle (package-yes! link-hint)
   (require '+pkg-link-hint)
   #+end_src

   #+BEGIN_SRC emacs-lisp
     (use-package link-hint
       :straight t
       :leader
       ("j RET" 'link-hint-open-link
        "j y" 'link-hint-copy-link)

       :autoload link-hint-define-type
       :config
       ;; Support rustic compilation related modes.
       (link-hint-define-type 'compilation-link
         :vars (append
                (get 'link-hint-compilation-link :vars)
                '(rustic-compilation-mode
                  rustic-cargo-test-mode))))
   #+END_SRC

   #+begin_src emacs-lisp
   (provide '+pkg-link-hint)
   #+end_src

** Message                                                     :builtin:mail:
   :PROPERTIES:
   :header-args+: :tangle (lisp! "+pkg-message.el")
   :END:

   #+begin_src emacs-lisp :tangle yes
   (require '+pkg-message)
   #+end_src

*** Message Mode
    #+BEGIN_SRC emacs-lisp
      (use-package message
        :custom
        (message-auto-save-directory (share! "messages/"))
        ;; (message-signature "Mohsin")
        (message-signature-file (+mail-conf-get 'signature-file))
        (message-kill-buffer-on-exit t)

        :leader
        ("ac" 'message-mail)

        :lazy-leader
        (:mode 'message-mode
         leader-major-mode-key 'message-send-and-exit
         "q" 'message-kill-buffer
         "r" 'message-dont-send
         "s" 'message-send)
        (:mode 'notmuch-message-mode
         leader-major-mode-key 'notmuch-mua-send-and-exit
         "q" 'notmuch-mua-kill-buffer
         "s" 'notmuch-mua-send)
        (:mode '(message-mode notmuch-message-mode)
         "a" 'mml-attach-file
         "p" 'message-yank-original
         "P" 'message-fill-yanked-message

         "g" '(:ignore t :wk "goto")
         "gb" 'message-goto-body
         "gs" 'message-goto-subject
         "gt" 'message-goto-to
         "gc" 'message-goto-cc
         "gb" 'message-goto-bcc
         "gr" 'message-goto-reply-to
         "gf" 'message-goto-followup-to
         "gF" 'message-goto-fcc
         "gz" 'message-goto-signature))
    #+END_SRC

*** SMTP Mail
    Is what we use to send messages through an appropriate SMTP server.

    The builtin implementation is decent but it doesn't support multiple accounts so
    I haven't configured any default SMTP servers here.

    #+BEGIN_SRC emacs-lisp
      (use-package smtpmail
        :custom
        (smtpmail-queue-dir (share! "mail/queued"))
        (smtpmail-servers-requiring-authorization (rx any)
         "Assume all mail hosts require authorization and prompt for a password."))
    #+END_SRC

    ~smtpmail-multi~ is an alternative to smtpmail which does support multiple
    accounts. It doesn't re-implement the same general logic of the ~smtpmail~
    package instead it just switches the default variables used based on which
    account the mail is being sent through.

    #+BEGIN_SRC emacs-lisp
      (use-package smtpmail-multi
        :straight t
        :custom
        (send-mail-function 'smtpmail-multi-send-it)
        (message-send-mail-function 'smtpmail-multi-send-it)

        (smtpmail-multi-default-account (caar +mail-conf))
        (smtpmail-multi-associations
         (cl-loop
          for (it . conf) in +mail-conf
          collect (list (regexp-quote (+mail-conf-email conf)) it)))
        (smtpmail-multi-accounts
         (cl-loop
          for (it . conf) in +mail-conf
          collect (cons it
                        `(,(+mail-conf-get 'user conf)
                          ,(+mail-conf-get 'smtp-host conf)
                          ,@(+mail-conf-get 'smtp-args conf)))))

        (with-eval-after-load 'smtpmail
          (require 'smtpmail-multi)))
    #+END_SRC

*** GPG Mail
    GPG support for message mail.

    #+begin_src emacs-lisp
      (use-package mml
        ;; :hook
        ;; (;; (message-setup . mml-secure-sign-pgpmime)
        ;;  (message-setup . mml-secure-message-sign-pgpmime))

        :custom
        (mml-secure-openpgp-sign-with-sender t)

        :leader
        (:mode '(message-mode notmuch-message-mode)
         :prefix "m"
         "" '(:ignore t :wk "mml")
         "m" 'mml-secure-message-encrypt ; Encrypt and sign
         "s" 'mml-secure-message-sign ; sign
         "x" 'mml-unsecure-message))
    #+end_src

*** Appendix
    #+begin_src emacs-lisp
    (provide '+pkg-message)
    #+end_src

** Notmuch                                                    :optional:mail:
   :PROPERTIES:
   :header-args+: :tangle (package-lisp! +pkg-notmuch notmuch)
   :END:

   #+begin_src emacs-lisp :tangle (package-yes! notmuch)
   (require '+pkg-notmuch)
   #+end_src

*** Notmuch
    #+BEGIN_SRC emacs-lisp
      (use-package +pkg-evil
        :autoload evil-set-initial-state
        :config
        (evil-set-initial-state 'notmuch-show-mode 'motion)
        (evil-set-initial-state 'notmuch-search-mode 'motion)
        (evil-set-initial-state 'notmuch-tree-mode 'motion)
        (evil-set-initial-state 'notmuch-hello-mode 'normal))

      (use-package notmuch
        :straight t
        :hide-whitespace+ notmuch-show-mode
        :hook (notmuch-message-mode . +flyspell)
        :commands (notmuch-toggle-tag+)
        :custom
        (notmuch-search-oldest-first nil)
        (notmuch-maildir-use-notmuch-insert nil)                                      ; messes up fcc paths with spaces in them (eg: Gmail).
        (notmuch-show-indent-messages-width 2)
        (notmuch-hello-thousands-separator ",")
        (notmuch-search-line-faces
         '(("unread" . notmuch-search-unread-face)
           ("H" . notmuch-search-H-face+)
           ("scheduled" . notmuch-search-scheduled-face+)
           ("flagged" . notmuch-search-flagged-face)
           ("reminder" . notmuch-search-flagged-face)
           ("waiting" . notmuch-search-waiting-face+)))
        (notmuch-show-all-tags-list t)
        (notmuch-draft-folder (join-path+ "local" (system-name) "drafts"))
        (notmuch-saved-searches
         `((:name "All Mail" :query "*" :key "a")
           (:name "Inbox" :query "tag:inbox" :key "i")
           (:name "Unread" :query "tag:unread" :key "u")
           (:name "Flagged" :query "tag:flagged" :key "f")
           (:name "Sent" :query "tag:sent" :key "s")
           (:name "Drafts" :query "tag:draft" :key "d")
           ;; Custom additions
           (:name "Alerts" :query "tag:/^a\\//" :key "n")
           (:name "Mailing Lists" :query "( tag:/^l\\// or tag:/^s\\// ) and not:tag:promotion" :key "l")
           (:name "Host Reports" :query "tag:/^h\\//" :key "h")))

        :autoload notmuch-company
        :completion+ (notmuch-message-mode (notmuch-company :company t))

        :preface
        (defface notmuch-search-H-face+ '((t (:foreground "#FF6EB4")))
          "Face for lines tagged H in the `notmuch-search-mode' buffer."
          :group '+dot-emacs)
        (defface notmuch-search-waiting-face+ '((t (:foreground "#FF8700")))
          "Face for lines tagged H in the `notmuch-search-mode' buffer."
          :group 'dot-emacs)
        (defface notmuch-search-scheduled-face+ '((t (:foreground "#67e4c4")))
          "Face for lines tagged H in the `notmuch-search-mode' buffer."
          :group 'dot-emacs)

        :init
        (advice-add 'notmuch-company :before-until
                    (defun notmuch-company--set-company-kind+ (command &rest _args)
                      (when (eq command 'kind)
                        'message-address)))

        :config
        (push '("replied" (propertize tag 'face 'shadow)) notmuch-tag-formats)

        :autoload notmuch-database-path
        :config
        ;; Needs to be an absolute path when `notmuch-maildir-use-notmuch-insert' isn't
        ;; true. This won't adapt to changes in database.path while emacs is already
        ;; open.
        (setq notmuch-fcc-dirs
              (let ((default-directory (notmuch-database-path)))
                (append
                 (cl-loop for (it . conf) in +mail-conf
                          collect (cons
                                   (regexp-quote (concat (+mail-conf-email conf)))
                                   (expand-file-name
                                    (+mail-conf-get 'sent-dir conf))))
                 `((,(rx any) . ,(expand-file-name (+mail-conf-get 'sent-dir)))))))

        :autoload (notmuch-tag+
                   notmuch-show-tag
                   notmuch-search-tag
                   notmuch-tree-tag)
        :config
        (cl-defun notmuch-tag+ (tag-changes
                                &optional (next
                                           '((notmuch-search-mode . notmuch-search-next-thread))))
          (pcase major-mode
            ('notmuch-show-mode (notmuch-show-tag tag-changes))
            ('notmuch-search-mode (notmuch-search-tag tag-changes))
            ('notmuch-tree-mode (notmuch-tree-tag tag-changes))
            (_ (user-error "No tag command known for %s" major-mode)))

          (when-let* ((next (alist-get major-mode next)))
            (funcall next)))

        :autoload notmuch-show-get-tag
        :config
        (defun notmuch-toggle-tag+ (tag-changes &optional next)
          "Toggle TAG tag for messages."
          (let ((tags (cl-case major-mode
                        (notmuch-show-mode (notmuch-show-get-tag tag-changes))
                        ((notmuch-search-mode
                          notmuch-tree-mode)
                         (user-error "Toggle tag not yet supported in %s" major-mode))
                        (t (user-error "No tag-get command known for %s" major-mode)))))
            (notmuch-tag+
             (cl-loop for tag in tag-changes collect
                      (concat (if (member tag tags) "-" "+")
                              tag))
             next)))

        ;; Make notmuch buffers support `auto-revert-mode'.
        :hook ((notmuch-search-mode notmuch-tree-mode) .
               notmuch-setup-auto-revert-mode+)
        :autoload (notmuch-buffer-stale-function+
                   notmuch-revert-buffer-function+)
        :preface
        (defun notmuch-setup-auto-revert-mode+ ()
          (setq-local buffer-stale-function #'notmuch-buffer-stale-function+
                      revert-buffer-function #'notmuch-revert-buffer-function+))
        :config
        (defun notmuch-buffer-stale-function+ (&optional no-confirm)
          (unless (get-buffer-process (current-buffer))
            (ignore-errors
              (not
               (eq (string-to-number
                    (car (process-lines notmuch-command "count"
                                        (if (bound-and-true-p notmuch-tree-mode)
                                            "--output=messages"
                                          "--output=threads")
                                        (if (bound-and-true-p notmuch-search-hide-excluded)
                                            "--exclude=true"
                                          "--exclude=false")
                                        notmuch-search-query-string)))
                   (1- (count-lines (point-min) (point-max))))))))

        (defun notmuch-revert-buffer-function+ (&optional ignore-auto no-confirm)
          (notmuch-refresh-this-buffer))

        :autoload notmuch-show-get-message-id
        :init
        (defvar notmuch-open-remote-urls+
          ;; Sadly gmail doesn't let us view a message based solely on its
          ;; message id. The best we can do is open a search that should
          ;; have only one result.
          `((,(rx "@gmail.com" (optional ">") eol) .
             ,(lambda (mail)
                (format "https://mail.google.com/mail/u/%s/#search/rfc822msgid:%s"
                        mail (url-hexify-string (notmuch-show-get-message-id t)))))))

        :autoload (notmuch-remote+
                   notmuch-show-get-to)
        :preface (use-package mail-parse :autoload mail-header-parse-address)
        :config
        (defun notmuch-remote+ ()
          (unless (derived-mode-p 'notmuch-show-mode)
            (user-error "%s can only be called in `notmuch-show' buffers" this-command))

          (let ((to (car (mail-header-parse-address (notmuch-show-get-to)))))
            (if-let* ((url-gen (cdr
                                (cl-find-if (lambda (it)
                                              (string-match-p (car it) to))
                                            notmuch-open-remote-urls+))))
                (funcall url-gen to)
              (user-error "No opener configured for mail from %s" to))))

        :commands notmuch-show-and-copy-remote+
        :config
        (defun notmuch-show-and-copy-remote+ ()
          (interactive)
          (if-let* ((url (notmuch-remote+)))
              (progn
                (kill-new url)
                (message "%s" url))
            (user-error "Failed to resolve remote for current buffer")))

        :commands notmuch-open-remote+
        :config
        (defun notmuch-open-remote+ ()
          (interactive)
          (if-let* ((url (notmuch-remote+)))
              (browse-url url)
            (user-error "Failed to resolve remote for current buffer")))

        :commands (notmuch-show-export-to-mbox+)
        ;; git-am can read from a mbox directly instead of passing the whole mail-dir
        ;; and getting spotty results. This is copied from [[https://notmuchmail.org/pipermail/notmuch/2016/022860.html][Tomi Ollila]].
        :preface
        (defvar notmuch-export-mbox-file+ "~/tmp-mbox"
          "File where MBOX exports for notmuch-show messages should be left.")

        :commands notmuch-show-export-to-mbox+
        :autoload notmuch-show-get-message-ids-for-open-messages
        :config
        (defun notmuch-show-export-to-mbox+ ()
          "When this function is executed in notmuch-show buffer all the \"open\"
      messages will be written to the file ~/tmp-mbox (overwriting it)."
          (interactive)
          (let ((search-terms-list (notmuch-show-get-message-ids-for-open-messages))
                (buffer (get-buffer-create
                         (format
                          "* Contents of %s *"
                          notmuch-export-mbox-file+))))
            (set-buffer buffer)
            (setq buffer-read-only nil)
            (buffer-disable-undo)
            (save-excursion
              (pop-to-buffer buffer))
            (goto-char (point-max))
            (if (> (buffer-size) 0)
                (insert "\n\n"))
            (insert (concat
                     (format-time-string "%c")
                     (format ": Writing the following messages to %s:\n "
                             notmuch-export-mbox-file+))
                    (mapconcat 'identity search-terms-list "\n ") "\n")
            (with-temp-file notmuch-export-mbox-file+
              (call-process notmuch-command nil t nil "show" "--format=mbox"
                            (mapconcat 'identity search-terms-list " OR ")))
            (insert (format "\nMessages in %s:\n" notmuch-export-mbox-file+))
            (call-process "mail" nil t nil
                          "-H" "-f" (expand-file-name notmuch-export-mbox-file+))))

        :preface
        (defvar notmuch-collapse-inline-mime-types+
          '("text/x-diff" "text/x-patch")
          "Auto-collapsed mimetypes when showing a message.")

        :autoload (notmuch-show-mime-type
                   notmuch-match-content-type)
        :config
        ;; Partially adapted from [[https://www.youtube.com/watch?app=desktop&v=UP2dFk5_ytY][@karthik]].
        (advice-add 'notmuch-show-insert-bodypart :filter-args
                    (defun notmuch-show-auto-collapse-patches+ (args)
                      (cl-destructuring-bind (msg part depth &optional hide) args
                        (list msg part depth
                              (or hide
                                  (when-let* ((mime-type (notmuch-show-mime-type part)))
                                    (cl-some (apply-partially #'notmuch-match-content-type
                                                              mime-type)
                                             notmuch-collapse-inline-mime-types+)))))))

        :autoload (notmuch-search-from-tree-current-query
                   notmuch-unthreaded-from-tree-current-query)
        :config
        (defun notmuch-toggle-unthreaded-or-search-current-query+ ()
          (interactive)
          (funcall-interactively
           (if notmuch-tree-unthreaded
               'notmuch-search-from-tree-current-query
             'notmuch-unthreaded-from-tree-current-query)))

        :autoload (notmuch-tree-quit
                   notmuch-unthreaded-from-tree-current-query)
        :config
        (defun notmuch-tree-toggle-unthreaded+ ()
          (interactive)
          (funcall-interactively
           (if notmuch-tree-unthreaded
               'notmuch-tree-quit
             'notmuch-unthreaded-from-tree-current-query)))

        :general
        (:keymaps 'notmuch-show-mode-map
         [remap +xopen-url] 'notmuch-open-remote+
         [remap show-and-copy-buffer-file-name] 'notmuch-show-and-copy-remote+)

        :general
        ([remap message-mail] 'notmuch)

        (:keymaps 'notmuch-common-keymap
         [remap quit-window] 'notmuch-bury-or-kill-this-buffer
         [remap revert-buffer] 'notmuch-refresh-this-buffer)
        (:keymaps 'notmuch-common-keymap
         :states 'motion
         "s" 'notmuch-search
         "S" 'notmuch-tree
         "J" 'notmuch-jump-search
         "K" 'notmuch-tag-jump

         "g?" 'notmuch-help
         "gA" 'notmuch-refresh-all-buffers
         "gR" 'notmuch-poll-and-refresh-this-buffer

         "C" 'notmuch-mua-new-mail                                                    ; like mu4e
         "cc" 'notmuch-mua-new-mail                                                   ; like mu4e
         "ch" 'goto-address-at-point                                                  ; compose for mail at point
         )

        (:keymaps '(notmuch-hello-mode-map
                    notmuch-show-mode-map)
         [remap quit-buffer] 'notmuch-bury-or-kill-this-buffer)
        (:keymaps 'notmuch-hello-mode-map
         :states 'normal
         ;; Don't need macros in notmuch-hello mode.
         "s" 'notmuch-search
         "S" 'notmuch-tree
         "t" 'notmuch-search-by-tag
         "q" 'quit-window)

        (:keymaps 'notmuch-show-mode-map
         :states 'motion
         "p" 'notmuch-show-save-attachments  ; like mu4e
         "A" 'notmuch-show-archive-thread-then-next
         "X" 'notmuch-show-archive-thread-then-exit
         "x" 'notmuch-show-archive-message-then-next-or-exit
         "." 'notmuch-show-part-map

         "TAB"       'notmuch-show-next-button
         "<backtab>" 'notmuch-show-previous-button
         "RET"       'notmuch-show-toggle-message

         "S" 'notmuch-show-filter-thread
         "K" 'notmuch-tag-jump

         "C" 'notmuch-mua-new-mail                                                    ; like mu4e
         "cc" 'notmuch-mua-new-mail                                                   ; like mu4e
         "cf" 'notmuch-show-forward-message
         "cR" 'notmuch-show-reply-sender
         "cr" 'notmuch-show-reply

         "zv" 'notmuch-tree-from-show-current-query                                   ; like mu4e-conversation
         "zu" 'notmuch-unthreaded-from-show-current-query
         "a" 'notmuch-show-archive-message-then-next-or-next-thread

         "]]"  'notmuch-show-next-open-message
         "[["  'notmuch-show-previous-open-message
         "gj"  'notmuch-show-next-message
         "gk"  'notmuch-show-previous-message
         "C-j" 'notmuch-show-next-message
         "C-k" 'notmuch-show-previous-message

         "gn"  'notmuch-show-next-thread-show
         "gp"  'notmuch-show-previous-thread-show
         "M-j" 'notmuch-show-next-thread-show
         "M-k" 'notmuch-show-previous-thread-show

         "|" 'notmuch-show-pipe-message
         "*" 'notmuch-show-tag-all
         "-" 'notmuch-show-remove-tag
         "+" 'notmuch-show-add-tag)

        (:keymaps 'notmuch-tree-mode-map
         [remap quit-window] 'notmuch-tree-quit)

        (:keymaps 'notmuch-tree-mode-map
         :states 'motion
         "gh" 'notmuch-show-previous-button
         "gj" 'notmuch-show-next-button
         "gk" 'notmuch-show-previous-button
         "gl" 'notmuch-show-next-button
         "g?" 'notmuch-help

         "s" 'notmuch-tree-to-tree
         "t" 'notmuch-search-by-tag
         "S" 'notmuch-tree-filter
         "T" 'notmuch-tree-filter-by-tag
         "J" 'notmuch-jump-search
         "K" 'notmuch-tag-jump

         "C" 'notmuch-mua-new-mail                                                    ; like mu4e
         "cc" 'notmuch-mua-new-mail                                                   ; like mu4e
         "cR" 'notmuch-show-reply-sender                                              ; like mu4e
         "cr" 'notmuch-show-reply

         "zv" 'notmuch-search-from-tree-current-query                                 ; like mu4e-conversation
         "zu" 'notmuch-toggle-unthreaded-or-search-current-query+
         "RET" 'notmuch-tree-show-message
         [mouse-1] 'notmuch-tree-show-message

         "A" 'notmuch-tree-archive-thread
         "a" 'notmuch-tree-archive-message-then-next

         "gj" 'notmuch-tree-next-matching-message
         "gk" 'notmuch-tree-prev-matching-message
         "]]" 'notmuch-tree-next-message
         "[[" 'notmuch-tree-prev-message
         "C-k" 'notmuch-tree-prev-thread
         "C-j" 'notmuch-tree-next-thread

         "|" 'notmuch-show-pipe-message
         "-" 'notmuch-tree-remove-tag
         "+" 'notmuch-tree-add-tag
         "*" 'notmuch-tree-tag-thread
         "e" 'notmuch-tree-resume-message)

        (:keymaps 'notmuch-search-mode-map
         [remap quit-window] 'notmuch-bury-or-kill-this-buffer)
        (:keymaps 'notmuch-search-mode-map
         :states '(motion visual)
         "C" 'notmuch-mua-new-mail                                                    ; like mu4e
         "cc" 'notmuch-mua-new-mail                                                   ; like mu4e
         "cR" 'notmuch-search-reply-to-thread-sender
         "cr" 'notmuch-search-reply-to-thread

         "s" 'notmuch-search
         "t" 'notmuch-search-by-tag
         "S" 'notmuch-search-filter
         "T" 'notmuch-search-filter-by-tag
         "J" 'notmuch-jump-search
         "K" 'notmuch-tag-jump

         "zv" 'notmuch-tree-from-search-current-query
         "zu" 'notmuch-unthreaded-from-search-current-query

         "*" 'notmuch-search-tag-all
         "-" 'notmuch-search-remove-tag
         "+" 'notmuch-search-add-tag
         "a" 'notmuch-search-archive-thread

         "RET"     'notmuch-search-show-thread
         [mouse-1] 'notmuch-search-show-thread)

        :preface
        (defvar notmuch-action-map+
          (let ((map (make-sparse-keymap)))
            (define-key map leader-major-mode-key
              (defun notmuch-tag-all+ ()
                "Tag all selected threads based on `major-mode'.
      Works exactly like notmuch-*-add-tag and notmuch-*-remove-tag which
      are bound to + and - respectively, except in `notmuch-show-mode'
      where it tags *all* the messages in the current thread instead of
      just the current one."
                (interactive)
                (call-interactively
                 (cl-case major-mode
                   (notmuch-show-mode #'notmuch-show-tag-all)
                   (notmuch-search-mode #'notmuch-search-tag)
                   (notmuch-tree-mode #'notmuch-tree-tag)
                   (t (user-error "No tag command known for %s" major-mode))))))

            (define-key map "d"
              (defun notmuch-tag-set-delete+ ()
                (interactive)
                ;; Removes spam tag because now status has moved from spam
                ;; to pending deletion.
                (notmuch-tag+ '("+deleted" "-spam" "-flagged" "-inbox" "-unread"))))

            (define-key map "s"
              (defun notmuch-tag-set-spam+ ()
                (interactive)
                (notmuch-tag+ '("+spam" "-inbox" "-flagged" "-unread"))))

            (define-key map "f"
              (defun notmuch-tag-set-flagged+ ()
                (interactive)
                (notmuch-tag+ '("+flagged") nil)))

            (define-key map "i"
              (defun notmuch-tag-remove-from-inbox+ (only)
                (interactive "P")
                (notmuch-tag+ `("-inbox" ,@(unless only (list "-unread" "-waiting" "-scheduled"))))))

            (define-key map "r"
              (defun notmuch-tag-read+ ()
                (interactive)
                (notmuch-tag+ '("-unread"))))

            map)
          "Keymap containing commands to act upon emails.")

        :lazy-leader
        (:mode 'notmuch-message-mode
         "d" 'notmuch-draft-postpone
         "s" 'notmuch-draft-save)
        (:mode 'notmuch-hello-mode
         leader-major-mode-key 'notmuch-jump-search
         "i" 'notmuch-jump-search
         "j" 'notmuch-jump-search
         "c" 'notmuch-mua-new-mail
         "G" 'notmuch-poll-and-refresh-this-buffer
         "s" 'notmuch-search
         "t" 'notmuch-search-by-tag
         "z" 'notmuch-tree)

        (:mode '(notmuch-show-mode
                 notmuch-tree-mode
                 notmuch-search-mode)
         leader-major-mode-key notmuch-action-map+)

        (:mode 'notmuch-show-mode
         "a" 'notmuch-show-advance-and-archive
         "#" 'notmuch-show-print-message
         "$" 'notmuch-show-toggle-process-crypto
         "d" 'notmuch-show-resume-message
         "e" 'notmuch-show-export-to-mbox+
         "u" 'notmuch-show-browse-urls
         "F" 'notmuch-show-forward-open-messages
         "G" 'notmuch-poll-and-refresh-this-buffer
         "z" 'notmuch-tree-from-show-current-query
         "v" 'notmuch-tree-from-show-current-query                                    ; like mu4e-conversation
         "r" 'notmuch-show-view-raw-message

         "t" '(:ignore t :wk "toggle")
         "ti" 'notmuch-show-toggle-thread-indentation
         "th" 'notmuch-show-toggle-visibility-headers
         "te" 'notmuch-show-toggle-elide-non-matching
         "t TAB" 'notmuch-show-toggle-thread-indentation)

        (:mode 'notmuch-tree-mode
         "v" 'notmuch-search-from-tree-current-query
         "u" 'notmuch-tree-toggle-unthreaded+)

        (:mode 'notmuch-search-mode
         "v" 'notmuch-tree-from-search-current-query
         "u" 'notmuch-unthreaded-from-search-current-query

         "t" '(:ignore t :wk "toggle")
         "to" 'notmuch-search-toggle-order)
        )
    #+END_SRC

*** GNUs Alias
    The [[https://notmuchmail.org/emacstips/#index16h2][recommended]] way to manage and interact with multiple accounts from Notmuch.

    #+begin_src emacs-lisp
      (use-package gnus-alias
        :straight t
        :hook (message-setup . gnus-alias-determine-identity)
        :custom
        (gnus-alias-default-identity (symbol-name (caar +mail-conf)))
        (gnus-alias-allow-forward-as-reply t)
        (gnus-alias-identity-alist
         (cl-loop for (it . conf) in +mail-conf
                  collect (list (symbol-name it)
                                nil ; Does not refer to any other identity.
                                (+mail-conf-from-header conf)
                                nil ; No organization header
                                nil ; No extra headers
                                nil ; No extra body text
                                (+mail-conf-get 'signature-file conf))))
        (gnus-alias-identity-rules
         (cl-loop for (it . conf) in +mail-conf
                  with email = nil do (setq email (+mail-conf-email conf))
                  collect (list (concat "Match " email)
                                `("from" ,(regexp-quote email))
                                (symbol-name it)))
         "Automatically pick the right id for a response.")

        :leader
        (:mode '(message-mode notmuch-message-mode)
         "c" 'gnus-alias-select-identity)

        :autoload gnus-alias-remove-header
        :preface (use-package notmuch-maildir-fcc :autoload notmuch-fcc-header-setup)
        :config
        ;; Update the FCC header after an identity change (pretty much essential IMO).
        (require 'notmuch-maildir-fcc)                                                ; Needed for fcc->identity association.

        (advice-add 'gnus-alias-use-identity-1 :after
                    (defun gnus-alias-use-identity-update-fcc+ (&rest _ignore)
                      (save-excursion
                        (gnus-alias-remove-header "FCC")
                        (notmuch-fcc-header-setup))))

        :autoload (gnus-alias-ensure-message-mode
                   gnus-alias-get-from)
        :config
        (advice-add 'gnus-alias-identity-prompt :override
                    (defun gnus-alias-identity-prompt+ ()
                      (gnus-alias-ensure-message-mode)
                      (let* ((identities (cl-loop for it in gnus-alias-identity-alist
                                                  collect (cons (gnus-alias-get-from it)
                                                                it)))
                             (cands (mapcar #'car identities))
                             (affixate
                              (lambda (cands)
                                (cl-loop for cand in cands
                                         with signature = nil
                                         do (setq signature (cadr (assoc cand identities)))
                                         collect
                                         (list cand ""
                                               (concat (propertize " " 'display `(space :align-to (- right 1 ,(length signature))))
                                                       (propertize signature 'face 'completions-annotations)))))))
                        (cadr
                         (assoc
                          (completing-read "Identity: "
                                           (lambda (str pred action)
                                             (if (eq action 'metadata)
                                                 `(metadata
                                                   (affixation-function . ,affixate))
                                               (complete-with-action action cands str pred))))
                          identities)))))

        :autoload gnus-alias-goto-sig
        :config
        ;; Fix signature is read-only and can't be removed.
        (advice-add 'gnus-alias-remove-sig :override
                  (defun gnus-alias-remove-sig+ ()
                    (gnus-alias-goto-sig)
                    ;; Needed because delete-region can't delete signature, why?
                    (delete-char (- (current-column)))
                    (delete-region (point) (point-max)))))
    #+end_src

*** Consult Notmuch
    :PROPERTIES:
    :header-args+: :tangle (package-lisp! +pkg-notmuch :consult notmuch)
    :END:

    #+begin_src emacs-lisp
      (use-package consult-notmuch
        :straight t
        :leader ("an" 'consult-notmuch))
    #+end_src

    Fix a bug between vertico and notmuch (see [[https://github.com/minad/vertico/issues/119][vertico#119]]).

    #+begin_src emacs-lisp
      (use-package notmuch
        :preface
        (defun notmuch-fix-notmuch-read-tag-changes+ (x)
          (mapcar #'string-trim x))

        :init
        (advice-add 'notmuch-read-tag-changes :filter-return
                    #'notmuch-fix-notmuch-read-tag-changes+))
    #+end_src

*** Org Link Notmuch
    :PROPERTIES:
    :header-args+: :tangle (package-lisp! +pkg-notmuch notmuch org)
    :END:

    #+begin_src emacs-lisp
      (use-package ol-notmuch
        :straight t
        :demand t
        :after ol)
    #+end_src

*** Appendix
    #+begin_src emacs-lisp
    (provide '+pkg-notmuch)
    #+end_src

** Tree Sitter                                                     :optional:
   :PROPERTIES:
   :header-args+: :tangle (package-lisp! +pkg-tree-sitter tree-sitter)
   :END:

   #+begin_src emacs-lisp :tangle (package-yes! tree-sitter)
   (require '+pkg-tree-sitter)
   #+end_src

   #+begin_src emacs-lisp
     (defvar +tree-sitter-mode-remap
       '(
         ;; Must occur first for treesit-auto to remap from this to c-ts-mode.
         (c-or-c++-mode . c-ts-mode)

         ;; Builtin Mode Aliases
         (c++-mode . c++-ts-mode)
         (c-mode . c-ts-mode)
         (csharp-mode . csharp-ts-mode)
         (css-mode . css-ts-mode)
         (java-mode . java-ts-mode)
         (js-json-mode . json-ts-mode)
         (js-mode . js-ts-mode)
         (mhtml-mode . html-ts-mode)
         (python-mode . python-ts-mode)
         (sh-mode . bash-ts-mode)
         (shell-script-mode . bash-ts-mode)

         ;; External Mode Aliases
         (cmake-mode . cmake-ts-mode)
         (dockerfile-mode . dockerfile-ts-mode)
         (go-dot-mod-mode . go-mod-ts-mode)
         (go-mode . go-ts-mode)
         (js2-mode . js-ts-mode)
         (json-mode . json-ts-mode)
         (jsonc-mode . json-ts-mode)
         (rust-mode . rust-ts-mode)
         ;; (rustic-mode . rust-ts-mode)
         (toml-mode . toml-ts-mode)
         (typescript-mode . typescript-ts-mode)
         (typescript-react-mode . tsx-ts-mode)
         (yaml-mode . yaml-ts-mode)))
   #+end_src

*** Tree Sitter                                                     :builtin:
    #+BEGIN_SRC emacs-lisp
      (use-package treesit
        :custom
        (treesit-font-lock-level 3)
        (js2-highlight-level 0
         "Prevent syntax highlighting conflict between tree-sitter and `js2-mode'.")

        :init
        (advice-add 'treesit-explore-mode :around 'display-buffer-no-select-window-advice+)

        :init
        (let ((treesit-grammer-directory (cache! "tree-sitter" "grammers")))
          (setq treesit--install-language-grammar-out-dir-history (list treesit-grammer-directory)
                treesit-extra-load-path (list treesit-grammer-directory)))

        :config
        (unless (treesit-available-p)
          (error "Emacs was not built with tree-sitter support")))
    #+END_SRC

*** Tree Sitter Compatibility
    Compatibility between tree-sitter modes and the built-in Emacs modes.

    #+begin_src emacs-lisp
      (use-package treesit-auto
        :straight (treesit-auto
                   ;; Install all tree-sitter grammars.
                   :post-build ((require 'treesit-auto)
                                (let ((treesit-auto-install t)
                                      (treesit-language-source-alist
                                       (treesit-auto--build-treesit-source-alist)))
                                  (treesit-auto-install-all))))
        :demand t
        :custom
        (treesit-auto-install nil
          "Use treesit-auto to automatically use treesitter modes, but don't install grammers.")
        (treesit-auto-fallback-alist
         (cl-loop for (regular . ts) in +tree-sitter-mode-remap collect (cons ts regular)))

        :commands global-treesit-auto-mode
        :config (global-treesit-auto-mode))
    #+end_src

    Eglot integration for various tree-sitter modes.

    #+begin_src emacs-lisp :tangle (package-yes! eglot tree-sitter)
      (use-package eglot
        :config
        (dolist (it eglot-server-programs)
          (when-let* ((mode (car it))
                      (new-modes
                       (cond
                        ((symbolp mode)
                         (when-let* ((ts-variant (alist-get mode +tree-sitter-mode-remap)))
                           (list mode ts-variant)))
                        ((consp mode)
                         (when-let* ((ts-variants
                                      (cl-loop
                                       for sub-mode in mode
                                       with ts-variant = nil
                                       do (setq ts-variant
                                                (alist-get sub-mode +tree-sitter-mode-remap))
                                       when ts-variant collect ts-variant)))
                           (append mode ts-variants))))))
            (setcar it new-modes))))
    #+end_src

    Fix consult-imenu doesn't respect narrowing configuration with tree-sitter modes.

    #+begin_src emacs-lisp :tangle (package-yes! :consult tree-sitter)
      (use-package consult-imenu
        :config
        (setq-default
         consult-imenu-config
         (cl-loop for (mode . config) in (default-value 'consult-imenu-config)
                  with mapped-mode = nil
                  do (setq mapped-mode (alist-get mode +tree-sitter-mode-remap))
                  collect (cons mode config)
                  when mapped-mode
                    collect (cons mapped-mode config))))
    #+end_src

    Make abbreviations inherit abbrevs for the non-tree-sitter modes.

    #+begin_src emacs-lisp
      (use-package abbrev
        :config
        (cl-loop
         for (mode . ts-mode) in +tree-sitter-mode-remap
         with    mode-abbrev-table = nil
         with ts-mode-abbrev-table = nil
         do (setq    mode-abbrev-table (intern (concat (symbol-name    mode) "-abbrev-table")))
         do (setq ts-mode-abbrev-table (intern (concat (symbol-name ts-mode) "-abbrev-table")))
         do (pcase mode-abbrev-table
             ('c-mode-abbrev-table
              (setq mode-abbrev-table 'c-base-mode-abbrev-table))
             ('c++-mode-abbrev-table
              (setq mode-abbrev-table 'c++-base-mode-abbrev-table)))

         with mode-abbrev-table-value = nil
         do (setq mode-abbrev-table-value
                  (progn
                    (unless (boundp mode-abbrev-table)
                      (define-abbrev-table mode-abbrev-table nil))
                    (symbol-value mode-abbrev-table)))

         do (define-abbrev-table ts-mode-abbrev-table nil
              (format "Automatic abbrev-table for `%s' deriving from `%s'" ts-mode mode-abbrev-table)
              :parents (list mode-abbrev-table-value))))
    #+end_src

    Make org-src prefer tree-sitter modes to non-tree-sitter.

    #+begin_src emacs-lisp
      (use-package org-src
        :config
        (cl-loop
         for (old-mode . new-mode) in +tree-sitter-mode-remap
         with old-mode-without-suffix = nil
         do (setq old-mode-without-suffix (intern (string-remove-suffix "-mode" (symbol-name old-mode))))
         with new-mode-without-suffix = nil
         do (setq new-mode-without-suffix (intern (string-remove-suffix "-mode" (symbol-name new-mode))))
         do
         (dolist (src-mapping org-src-lang-modes)
           (when (eq (cdr src-mapping) old-mode-without-suffix)
             (setf (cdr src-mapping) new-mode-without-suffix)))))
    #+end_src

    Add tree-sitter variants for lsp-maybe-connect options.

    #+begin_src emacs-lisp
      (use-package treesit-auto
        :preface
        (defun treesit-amend-lsp-maybe-connect+ ()
          (setq +lsp-maybe-connect
                (append (cl-loop for (mode . ts-mode) in +tree-sitter-mode-remap
                                 with entry = nil
                                 do (setq entry (assoc mode +lsp-maybe-connect))
                                 when entry
                                   collect (cons ts-mode (cdr entry)))
                        +lsp-maybe-connect)))

        :hook (after-init . treesit-amend-lsp-maybe-connect+))
    #+end_src

    Re-use normal mode formatters with tree-sitter formatters.

    #+begin_src emacs-lisp :tangle (package-yes! apheleia tree-sitter)
      (use-package apheleia
        :config
        (cl-loop
         for (mode . ts-mode) in +tree-sitter-mode-remap
         with formatters = nil
         when (and (setq formatters (alist-get mode apheleia-mode-alist))
                   (not (assoc ts-mode apheleia-mode-alist)))
           do (push (cons ts-mode formatters) apheleia-mode-alist)))
    #+end_src

*** Combobulate                                                :wip:disabled:
    #+begin_src emacs-lisp :tangle no
      (use-package combobulate
        :straight (combobulate :host github :repo "mickeynp/combobulate"))
    #+end_src

*** Tree Sitter Evil Text-Objects                                       :wip:
    This module has been disabled until [[https://github.com/meain/evil-textobj-tree-sitter/issues/76][meain/evil-textobj-tree-sitter#76]] has been
    resolved.

    #+begin_src emacs-lisp
      (require '+pkg-evil)

      (use-package evil-textobj-tree-sitter
        :straight t
        :after (evil treesit)
        :demand t
        :autoload (evil-textobj-tree-sitter--message-not-found
                   evil-textobj-tree-sitter--range
                   evil-textobj-tree-sitter-goto-textobj)

        :preface
        (defmacro evil-textobj-tree-sitter-define-motion+ (group &optional previous query)
          (let ((func-name (intern (concat "evil-textobj-tree-sitter-"
                                           (if previous "previous" "next")
                                           "-" group  "+"))))
            `(evil-define-motion ,func-name (count)
               (dotimes (_ (or count 1))
                 (evil-textobj-tree-sitter-goto-textobj ,group ,previous nil ,query)))))


        :commands (evil-textobj-tree-sitter-function--class.inner
                   evil-textobj-tree-sitter-function--class.outer
                   evil-textobj-tree-sitter-function--comment.inner
                   evil-textobj-tree-sitter-function--comment.outer
                   evil-textobj-tree-sitter-function--function.inner
                   evil-textobj-tree-sitter-function--function.outer
                   evil-textobj-tree-sitter-function--parameter.inner
                   evil-textobj-tree-sitter-function--parameter.outer
                   evil-textobj-tree-sitter-next-function.outer+
                   evil-textobj-tree-sitter-next-class.outer+
                   evil-textobj-tree-sitter-next-parameter.inner+
                   evil-textobj-tree-sitter-previous-function.outer+
                   evil-textobj-tree-sitter-previous-class.outer+
                   evil-textobj-tree-sitter-previous-parameter.inner+)
        :config
        (general-define-key
         :predicate '(treesit-parser-list)
         :keymaps 'evil-outer-text-objects-map
         ";" (evil-textobj-tree-sitter-get-textobj "comment.inner")
         "c" (evil-textobj-tree-sitter-get-textobj "class.outer")
         "f" (evil-textobj-tree-sitter-get-textobj "function.outer")
         "," (evil-textobj-tree-sitter-get-textobj "parameter.outer")
         [remap evil-inner-arg] #'evil-textobj-tree-sitter-function--parameter.outer)

        (general-define-key
         :predicate '(treesit-parser-list)
         :keymaps 'evil-inner-text-objects-map
         ";" (evil-textobj-tree-sitter-get-textobj "comment.outer")
         "c" (evil-textobj-tree-sitter-get-textobj "class.inner")
         "f" (evil-textobj-tree-sitter-get-textobj "function.inner")
         "," (evil-textobj-tree-sitter-get-textobj "parameter.inner")
         [remap evil-inner-arg] #'evil-textobj-tree-sitter-function--parameter.inner)

        (general-define-key
         :states '(normal motion)
         :predicate '(treesit-parser-list)
         "]f" (evil-textobj-tree-sitter-define-motion+ "function.outer")
         "]c" (evil-textobj-tree-sitter-define-motion+ "class.outer")
         "]," (evil-textobj-tree-sitter-define-motion+ "parameter.inner")
         "[f" (evil-textobj-tree-sitter-define-motion+ "function.outer" 'previous)
         "[c" (evil-textobj-tree-sitter-define-motion+ "class.outer" 'previous)
         "[," (evil-textobj-tree-sitter-define-motion+ "parameter.inner" 'previous)))
    #+end_src

*** Appendix
    #+begin_src emacs-lisp
    (provide '+pkg-tree-sitter)
    #+end_src

** Ediff                                                   :builtin:optional:
   :PROPERTIES:
   :header-args+: :tangle (package-lisp! +pkg-ediff ediff)
   :END:

   The builtin interactive diff tool.

   #+begin_src emacs-lisp :tangle (package-yes! ediff)
   (require '+pkg-ediff)
   #+end_src

*** Ediff
    #+BEGIN_SRC emacs-lisp
      (use-package ediff
        :hide-whitespace+ ediff-meta-mode
        :custom
        (ediff-window-setup-function #'ediff-setup-windows-plain)
        (ediff-split-window-function #'split-window-horizontally)
        (ediff-merge-split-window-function #'split-window-horizontally)
        (ediff-keep-variants nil)

        :hook (ediff-prepare-buffer . outline-show-all)                               ; Show org ediffs unfolded

        ;; Ensure window configuration is restored after diff quit.
        :hook ((ediff-before-setup . ediff--restore-windows-before+)
               ('ediff-quit . ediff--restore-windows-after))
        :autoload ediff--window-restorable-p+
        :config
        (defconst ediff-window-register+ ?w)

        (defun ediff--window-restorable-p+ ()
          (cdr (assoc ediff-window-register+ register-alist)))

        (defun ediff--restore-windows-before+ (&rest args)
          (unless (ediff--window-restorable-p+)
            (window-configuration-to-register ediff-window-register+)))

        (defun ediff--restore-windows-after+ (&rest _args)
          (if (not (ediff--window-restorable-p+))
              (display-warning 'ediff "ediff-restore-windows: no previous window config found to restore")
            (jump-to-register ediff-window-register+)
            (set-register ediff-window-register+ nil)))


        :hook (ediff-quit . ediff--kill-ediff-temp-buffers)
        :autoload ediff--kill-ediff-temp-buffers+
        :config
        (defvar ediff-kill-temporary-buffers-on-exit+ t
          "Whether to keep temporary ediff buffers around.")

        (defun ediff--kill-ediff-temp-buffers+ (&rest _args)
          "Kills all the spawned ediff buffers... because
      there's way too many and their named so similarly that
      there's no point in them existing... Plus I keep ending
      up editing the wrong diffed buffer."
          (when ediff-kill-temporary-buffers-on-exit+
            ;; kill diff checking buffers when temporary
            (dolist (buffer (list ediff-buffer-A
                                  ediff-buffer-B
                                  ediff-buffer-C))
              (when (and buffer
                         (string-prefix-p "FILE=" (buffer-name buffer)))
                (kill-buffer buffer)))

            ;; kill any hardcoded ediff related buffers
            (dolist (buffer '("*Ediff Registry*"))
              (let ((buffer (get-buffer buffer)))
                (when buffer
                  (kill-buffer buffer))))

            ;; kill any uniquely named ediff buffers...
            ;; Ewwww... O(n*m)... how do I live with myself
            (dolist (buffer-prefix '("*Ediff Control Panel"
                                     "*ediff-diff"
                                     "*ediff-errors"
                                     "*ediff-fine-diff"))
              (let ((buffer-prefix-regexp (regexp-quote buffer-prefix)))
                (dolist (buffer (buffer-list))
                  (when (string-match buffer-prefix-regexp
                                      (buffer-name buffer))
                    (kill-buffer buffer)))))))

        :hook (ediff-keymap-setup . ediff--customize-ediff-mode-map+)
        :autoload ediff--customize-ediff-mode-map+
        :config
        (defun ediff--customize-ediff-mode-map+ (&rest _args)
          "Give me back my leader keys damn it :-P."
          (general-define-key
           :keymaps 'ediff-mode-map
           :states  'motion
           "SPC" leader-map))

        :leader
        (:prefix leader-diff-leader-prefix+
         "f" 'ediff-current-file
         "b" 'ediff-buffers
         "w" 'ediff-windows)
        :lazy-leader
        (:mode 'ediff-meta-mode
         "tf" 'ediff-toggle-filename-truncation
         "tv" 'ediff-toggle-verbose-help-meta-buffer))
    #+END_SRC

*** Evil Ediff
    #+begin_src emacs-lisp
      (use-package evil-ediff
        :straight t
        :after ediff
        :demand t
        :autoload evil-ediff-init
        :config (evil-ediff-init))
    #+end_src

*** Appendix
    #+begin_src emacs-lisp
    (provide '+pkg-ediff)
    #+end_src

** Vdiff                                                           :optional:
   :PROPERTIES:
   :header-args+: :tangle (package-lisp! +pkg-vdiff vdiff)
   :END:

   Inspired by vimdiff, vdiff is a better, less intrusive interactive diff tool for
   emacs.

   #+begin_src emacs-lisp :tangle (package-yes! vdiff)
     (require '+pkg-vdiff)
   #+end_src

   #+begin_src emacs-lisp
     (require '+pkg-hydra)
   #+end_src

*** Vdiff
    #+BEGIN_SRC emacs-lisp
      (use-package vdiff
        :straight t
        :preface
        (defvar vdiff-use-relative-line-numbers+ nil
          "When true, line numbers in vdiff sessions are relative")

        :autoload vdiff-setup+
        :hook ((vdiff-mode vdiff-3way-mode) . vdiff-setup+)
        :config
        (defun vdiff-setup+ (&rest _)
          (let ((inhibit-message t))
            (toggle-truncate-lines +1)
            (when (functionp 'evil-normalize-keymaps)
              (evil-normalize-keymaps)))

          (when vdiff-use-relative-line-numbers+
            (setq-local display-line-numbers
                        (if vdiff-mode t 'visual))))

        :autoload vdiff-prepare+
        :hook ((vdiff-mode vdiff-3way-mode) . vdiff-prepare+)
        :preface (use-package outline :commands outline-show-all)
        :config
        (defun vdiff-prepare+ ()
          (cond
           ((derived-mode-p 'org-mode)
            (when vdiff-mode
              (outline-show-all)))))

        :leader
        (:prefix leader-diff-leader-prefix+
         "" '(:ignore t :wk "diff")
         "RET" 'vdiff-merge-conflict
         "TAB" 'vdiff-switch-buffer
         "d" 'vdiff-current-file
         "f" 'vdiff-files
         "F" 'vdiff-files3
         "b" 'vdiff-buffers
         "B" 'vdiff-buffers3)

        :lazy-leader
        (:mode '(vdiff-mode
                 vdiff-3way-mode)
         :minor t
         :prefix leader-major-mode-prefix
         ;; "m" 'vdiff-restore-windows
         "w" 'vdiff-save-buffers
         "r" 'vdiff-receive-changes
         "s" 'vdiff-send-changes
         "R" 'vdiff-receive-changes-and-step
         "S" 'vdiff-send-changes-and-step

         "f"  '(:ignore t :wk "refine")
         "ff" 'vdiff-refine-this-hunk                                                 ; Highlight changed words in hunk
         "fx" 'vdiff-remove-refinements-in-hunk                                       ; Remove refinement highlighting
         "fa" 'vdiff-refine-all-hunks                                                 ; Highlight all changed words
         "fs" 'vdiff-refine-this-hunk-symbol                                          ; Refine based on symbols
         "fw" 'vdiff-refine-this-hunk-word                                            ; Refine based on words
         "fS" 'vdiff-refine-all-hunks-symbol                                          ; Refine all based on symbols
         "fW" 'vdiff-refine-all-hunks-word                                            ; Refine all based on words

         "t"  '(:ignore t :wk "toggle")
         "ti" 'vdiff-toggle-case
         "tw" 'vdiff-toggle-whitespace)

        :general
        (:keymaps 'embark-file-map
         [remap ediff-files] 'vdiff-files)
        (:keymaps 'embark-buffer-map
         [remap ediff-buffers] 'vdiff-buffers)

        (:keymaps '(vdiff-mode-map
                    vdiff-3way-mode-map)
         [remap quit-window] 'vdiff-quit)
        (:states '(normal motion)
         :keymaps '(vdiff-mode-map
                    vdiff-3way-mode-map)
         "q" 'vdiff-quit
         "TAB" 'vdiff-switch-buffer
         "gj" 'vdiff-next-hunk
         "gk" 'vdiff-previous-hunk
         "C-j" "gj"
         "C-k" "gk"

         "zj" 'vdiff-next-fold
         "zk" 'vdiff-previous-fold
         "M-j" 'vdiff-next-fold
         "M-k" 'vdiff-previous-fold

         "zo" 'vdiff-open-fold
         "zO" 'vdiff-open-fold
         "zr" 'vdiff-open-all-folds
         "zf" 'vdiff-close-fold
         "zc" 'vdiff-close-fold
         "zF" 'vdiff-close-all-folds
         "zC" 'vdiff-close-all-folds
         "zC" 'vdiff-close-other-folds
         [remap revert-buffer] 'vdiff-refresh))
    #+END_SRC

*** Vdiff Magit
    :PROPERTIES:
    :header-args+: :tangle (package-lisp! +pkg-vdiff vdiff magit)
    :END:

    #+begin_src emacs-lisp
      (use-package vdiff-magit
        :straight t
        :after magit
        :custom
        (vdiff-magit-use-ediff-for-merges nil)

        :preface (use-package transient :autoload transient-suffix-put)
        :config
        (transient-suffix-put 'magit-dispatch "e" :description "vdiff (dwim)")
        (transient-suffix-put 'magit-dispatch "e" :command 'vdiff-magit-dwim)
        (transient-suffix-put 'magit-dispatch "E" :description "vdiff")
        (transient-suffix-put 'magit-dispatch "E" :command 'vdiff-magit)

        :general
        (:keymaps 'magit-mode-map
         "e" 'vdiff-magit-dwim
         "E" 'vdiff-magit))
    #+end_src

*** Vdiff Hydra
    #+begin_src emacs-lisp
      (require '+pkg-hydra)

      (use-package vdiff
        :lazy-leader
        (:mode '(vdiff-mode
                 vdiff-3way-mode)
         :minor t
         :prefix leader-major-mode-prefix
         "." 'vdiff-hydra/body)

        :autoload
        (vdiff-remove-refinements-in-hunk
         vdiff-refine-all-hunks
         vdiff-refine-this-hunk
         vdiff-save-buffers
         vdiff-receive-changes-and-step
         vdiff-receive-changes
         vdiff-send-changes-and-step
         vdiff-send-changes
         vdiff-toggle-whitespace
         vdiff-toggle-case)

        :commands vdiff-toggle-hydra/body
        :hydra
        (vdiff-toggle-hydra
         (nil nil :hint nil)
         "
      Toggles
       _c_ ignore case: %s(vdiff--current-case)
       _w_ ignore whitespace: %s(vdiff--current-whitespace)
       _q_ back to main hydra"
         ("c" vdiff-toggle-case)
         ("w" vdiff-toggle-whitespace)
         ("q" vdiff-hydra/body :exit t))

        :commands vdiff-hydra/body
        :hydra
        (vdiff-hydra
         (nil nil :hint nil :foreign-keys run)
         (concat (propertize
                  "\
       Navigation^^^^          Refine^^   Transmit^^^^             Folds^^^^            Other"
                  'face 'header-line)
                 "
       _j_/_J_ next hunk/fold  _f_ this   _s_/_S_ send (+step)     _o_/_O_ open (all)   _i_ ^ ^ toggles
       _k_/_K_ prev hunk/fold  _F_ all    _r_/_R_ receive (+step)  _c_/_C_ close (all)  _u_ ^ ^ update diff
       _g_^ ^  switch buffers  _x_ clear  ^ ^ ^ ^                  _t_ ^ ^ close other  _w_ ^ ^ save buffers
       ^ ^^ ^                  ^ ^        ^ ^ ^ ^                  ^ ^ ^ ^              _q_/_Q_ quit hydra/vdiff
       ignore case: %s(vdiff--current-case) | ignore whitespace: %s(vdiff--current-whitespace)")
         ("j" vdiff-next-hunk)
         ("k" vdiff-previous-hunk)
         ("J" vdiff-next-fold)
         ("K" vdiff-previous-fold)
         ("g" vdiff-switch-buffer)
         ("s" vdiff-send-changes)
         ("S" vdiff-send-changes-and-step)
         ("r" vdiff-receive-changes)
         ("R" vdiff-receive-changes-and-step)
         ("o" vdiff-open-fold)
         ("O" vdiff-open-all-folds)
         ("c" vdiff-close-fold)
         ("C" vdiff-close-all-folds)
         ("t" vdiff-close-other-folds)
         ("u" vdiff-refresh)
         ("w" vdiff-save-buffers)
         ("f" vdiff-refine-this-hunk)
         ("F" vdiff-refine-all-hunks)
         ("x" vdiff-remove-refinements-in-hunk)
         ("i" vdiff-toggle-hydra/body :exit t)
         ("q" nil :exit t)
         ("Q" vdiff-quit :exit t))
        )
    #+end_src

*** Appendix
    #+begin_src emacs-lisp
    (provide '+pkg-vdiff)
    #+end_src

** Avy
   #+BEGIN_SRC emacs-lisp
     (use-package avy
       :straight t
       :custom
       (avy-single-candidate-jump nil)

       :leader
       ("jj" 'avy-goto-char
        "jk" 'avy-goto-char-2
        "jv" 'avy-goto-char-timer))
   #+END_SRC

** Miniedit
   :PROPERTIES:
   :header-args+: :tangle (lisp! "+pkg-miniedit.el")
   :END:

   Write the minibuffer contents to a buffer, edit, then paste new contents
   back to minibuffer.

   #+begin_src emacs-lisp :tangle yes
   (require '+pkg-miniedit)
   #+end_src

   #+BEGIN_SRC emacs-lisp
     (use-package miniedit
       :straight t
       :delight (miniedit-mode " MiniEdit")
       :custom
       (miniedit-show-help-p nil)                                                    ; thanks... but no thanks

       :lazy-leader
       (:mode 'miniedit-mode
        :minor t
        :prefix leader-major-mode-prefix
        "," 'exit-recursive-edit)

       :general
       (:keymaps '(minibuffer-local-map
                   minibuffer-local-ns-map
                   minibuffer-local-completion-map
                   minibuffer-local-must-match-map)
        "M-e" 'miniedit)
       (:keymaps 'evil-command-line-map
        ; Miniedit and evil don't seem to get along.
        "M-e" nil))
   #+END_SRC

   #+begin_src emacs-lisp
   (provide '+pkg-miniedit)
   #+end_src

** Undo Tree                                                       :optional:
   :PROPERTIES:
   :header-args+: :tangle (package-lisp! +pkg-undo-tree undo-tree)
   :END:

   #+begin_src emacs-lisp :tangle (package-yes! undo-tree)
   (require '+pkg-undo-tree)
   #+end_src

   #+BEGIN_SRC emacs-lisp
     (use-package undo-tree
       :straight t
       :hide-whitespace+ undo-tree-visualizer-mode
       :hook (after-init . global-undo-tree-mode)
       :diminish
       :custom
       (evil-undo-system 'undo-tree)
       (undo-tree-auto-save-history t)
       (undo-tree-history-directory-alist `(("." . ,(state! "undo-tree"))))

       :config
       (advice-add 'undo-tree-save-history :before-until
                   (defun undo-tree-save-history--respect-ignore+ (&rest _args)
                     "Respect `+undo-skip-autosave-regex'."
                     (not
                      (and +undo-skip-autosave-regex
                           (not (string-match-p +undo-skip-autosave-regex
                                                buffer-file-name))))))

       (advice-add 'undo-tree-save-history :around
                   (defun undo-tree-silence-save-history+ (func &rest args)
                     "Suppress undo-file save messages.
     By default undo-tree writes a message to the Messages buffer EVERY
     time you save a file. This is highly diruptive, you can suppress the
     messages by assigning `inhibit-message' but it still shows up in the
     messages buffer. This redefines the `write-region' function and
     forces it to not echo out that the files been saved."
                     (cl-letf* ((actual-write-region
                                (symbol-function 'write-region))
                               ((symbol-function 'write-region)
                                (lambda (start end filename &optional append &rest args)
                                  (apply actual-write-region start end filename append 'nomessage (cdr args)))))
                       (apply func args))))

       :commands (undo-tree-visualizer-set-and-exit-selection-mode+
                  undo-tree-visualizer-set
                  undo-tree-visualizer-selection-mode)
       :config
       (defun undo-tree-visualizer-set-and-exit-selection-mode+ ()
         (interactive)
         (funcall-interactively #'undo-tree-visualizer-set)
         (undo-tree-visualizer-selection-mode -1))

       :leader
       ("au" '(undo-tree-visualize :wk "undo-tree"))

       :lazy-leader
       (:mode 'undo-tree-visualizer-mode
        "RET" 'undo-tree-visualizer-selection-mode
        "t" 'undo-tree-visualizer-toggle-timestamps
        "," 'undo-tree-visualizer-quit
        "q" 'undo-tree-visualizer-abort
        "d" 'undo-tree-visualizer-toggle-diff)

       :general
       (:keymaps 'undo-tree-map
        "C-/" nil "C-_" nil "C-?" nil)
       (:states  'motion
        :keymaps '(undo-tree-visualizer-mode-map
                   undo-tree-visualizer-selection-mode-map)
        "t" 'undo-tree-visualizer-toggle-timestamps
        "gj" 'undo-tree-visualize-redo-to-x
        "gk" 'undo-tree-visualize-undo-to-x

        [remap quit-window] 'undo-tree-visualizer-quit
        [remap evil-scroll-column-right] 'undo-tree-visualizer-scroll-left
        [remap evil-scroll-column-left] 'undo-tree-visualizer-scroll-right)
       (:states  'motion
        :keymaps 'undo-tree-visualizer-mode-map
        "h" 'undo-tree-visualize-switch-branch-left
        "l" 'undo-tree-visualize-switch-branch-right
        "d" 'undo-tree-visualizer-toggle-diff)
       (:states 'motion
        :keymaps 'undo-tree-visualizer-selection-mode-map
        "RET" 'undo-tree-visualizer-set-and-exit-selection-mode+
        "h" 'undo-tree-visualizer-select-left
        "l" 'undo-tree-visualizer-select-right
        "d" 'undo-tree-visualizer-selection-toggle-diff))
   #+END_SRC

   #+begin_src emacs-lisp
   (provide '+pkg-undo-tree)
   #+end_src

** Undo Fu                                                         :optional:
   :PROPERTIES:
   :header-args+: :tangle (package-lisp! +pkg-undo-fu (not undo-tree))
   :END:

   Emacs built-in undo is _weird_ and *wonderful*.

   If you can understand it it'll certainly come in useful, however for most users
   [[*undo-tree][undo-tree]] will be a much simpler and easier to use undoing package.

   Alright, now to explain how undo and the helping wrapper package ~undo-fu~ works.
   You may find it helpful to read [[https://www.reddit.com/r/emacs/comments/6yzwic/how_emacs_undo_works/][this]] before trying out ~undo-fu~.

   Emacs implements undo as a chain of actions including undo itself. To redo an
   action emacs actually undoes an undo, pushing this new reverse undo back onto
   the undo history.
   This means the emacs undo history is complete, every previous state the buffer
   was in can be accessed, however the more changes you make (including undo's or
   redos) the more is pushed onto the undo history chain and the longer it'll take
   to reverse to that state when redoing.

   The general approach to undo with this new system is to either undo to the state
   you want to get to or redo the undos from the end of the undo-history until you
   reach your desired state.
   In the former case the change you want is a concrete piece of the current undo
   history and can be reached linearly by undoing.
   In the latter case you want a revision in a separate undo history. For example
   you make an edit, undo once, make an edit, and can now no longer access the
   changes you undid with the initial undo.
   The undo history in this case is ~A -> B -> C -> Undo -> Undo -> D -> E~. The final
   text in the buffer is from the series of changes ~ADE~ and you can undo through
   them easily. How do you get back to ~ABC~? By *redoing*. At state ~E~ you can redo to
   reverse ~E~ and get to ~D~, then at ~D~ you redo to get back to ~A~, now redoing reverses
   the undo that removed ~B~ and redoing once more undos the removal of ~C~ inserting it
   back in. We get back to ~ABC~.
   This linear structure of undo can extend up-to an arbitrary depth, the only issue
   is having to manoeuvre through intermittent histories as you navigate.

   #+begin_src emacs-lisp :tangle (package-yes! (not undo-tree))
   (require '+pkg-undo-fu)
   #+end_src

*** Undo Fu
    #+begin_src emacs-lisp
      (use-package undo-fu
        :straight t
        :custom
        (evil-undo-system 'undo-fu))
    #+end_src

*** Undo Fu Session
    #+begin_src emacs-lisp
      (use-package undo-fu-session
        :straight t
        :hook (after-init . undo-fu-session-global-mode)
        :custom
        (undo-fu-session-directory (state! "undo-fu"))
        (undo-fu-session-incompatible-files (list +undo-skip-autosave-regex)))
    #+end_src

*** Visual Undo
    #+begin_src emacs-lisp
      (use-package vundo
        :straight t
        :config
        (setq vundo-glyph-alist vundo-unicode-symbols)

        :leader
        ("au" 'vundo)

        :general
        (:keymaps 'vundo-mode-map
         ;; Evil, not emacs :-P.
         "l"   #'vundo-forward   "f" nil
         "h"   #'vundo-backward  "b" nil
         "j"   #'vundo-next      "n" nil
         "k"   #'vundo-previous  "p" nil
         "C-u" #'vundo-stem-root "a" nil
         "C-d" #'vundo-stem-end  "e" nil
         "g"   #'vundo-stem-root
         "G"   #'vundo-stem-end
         "'"   #'vundo-goto-next-saved
         "m"   #'vundo-diff-mark
         "u"   #'vundo-diff-unmark
         "d"   #'vundo-diff
         "q"   #'vundo-confirm
         "<escape>" #'vundo-quit))
    #+end_src

*** Appendix
    #+begin_src emacs-lisp
    (provide '+pkg-undo-fu)
    #+end_src

** Command-Log Mode                                                :optional:
   :PROPERTIES:
   :header-args+: :tangle (package-yes! command-log-mode)
   :END:

   Outputs the commands you run, as you run them, to a dedicated buffer. useful
   for demonstrating cool Emacs stuff :).

   #+BEGIN_SRC emacs-lisp
     (use-package command-log-mode
       :straight t)
   #+END_SRC

** Comint                                                 :optional:terminal:
   :PROPERTIES:
   :header-args+: :tangle (lisp! "+pkg-comint.el")
   :END:

   Mode to emulate a terminal, doesn't support much real terminal functionality but
   it's good enough for basic functionality and is re-purposed by several Emacs
   libraries including gud.

   #+begin_src emacs-lisp :tangle yes
   (require '+pkg-comint)
   #+end_src

*** Command Interpreter
    #+begin_src emacs-lisp
      (use-package +pkg-evil
        :autoload evil-set-initial-state
        :config
        (evil-set-initial-state 'comint-mode 'emacs))

      (use-package comint
        :preface
        (defun comint-set-cursor-to-bar+ ()
          (setq-local evil-emacs-state-cursor 'bar))
        :hook (comint-mode . comint-set-cursor-to-bar+)
        :hide-whitespace+ comint-mode

        :custom
        (comint-prompt-read-only t))
    #+end_src

*** Comint Bindings
    :PROPERTIES:
    :header-args+: :tangle (lisp! "+comint-bindings.el")
    :END:

    I've moved comint commands and binding declarations into a separate file, because
    some packages override comint maps so you'll need to assign the same bindings for
    multiple modes and it's easier when their contained in a function.

    #+BEGIN_SRC emacs-lisp :tangle (lisp! "+pkg-comint.el")
      (use-package +comint-bindings
        :autoload (+comint-set-bindings
                   +comint-set-leader-keys)
        :after comint
        :demand t
        :config
        (+comint-set-bindings 'comint-mode-map)
        (+comint-set-leader-keys 'comint-mode))
    #+END_SRC

    #+BEGIN_SRC emacs-lisp :tangle (lisp! "+comint-bindings.el")
      (require 'comint)
      (require '+core-bindings)

      (defun comint-bol-point+ (&optional arg)
        (save-excursion
          (comint-bol arg)
          (point)))

      (defun comint-backward-delete-char+ (&optional arg)
        "delete upto ARG characters backward, ignoring the prompt."
        (interactive "p")
        (or arg (setq arg 1))

        (if (<= (comint-bol-point+)
                (- (point) arg 1))
            (delete-char (- arg))
          (delete-region (point) (comint-bol-point+))))

      (defmacro comint-clamp-point-to-bol+ (&rest body)
        "ensures any operation done by body doesn't move point
      to before the command interpreter prompt."
        `(let ((bol (comint-bol-point+)))
           ,@body ;; run body operations

           (when (< (point) bol)
             (goto-char bol))))

      (defun comint-backward-char+ (&optional N)
        (interactive "P")
        (comint-clamp-point-to-bol+ (backward-char N)))

      (defun comint-backward-word+ (&optional N)
        (interactive "P")
        (comint-clamp-point-to-bol+ (backward-word N)))

      (defun comint-on-prompt-line-p+ ()
        (interactive)
        (save-excursion
          (let ((current-line (what-line)))
            (goto-char (comint-bol-point+))
            (string-equal (what-line) current-line))))

      ;; TODO support prefix arg
      (defun comint-previous-input-or-previous-line+ ()
        (interactive)
        (if (comint-on-prompt-line-p+)
            (call-interactively 'comint-previous-input)
          (comint-clamp-point-to-bol+
           (forward-line -1))))

      (defun comint-next-input-or-next-line+ ()
        (interactive)
        (if (eobp)
            (call-interactively 'comint-next-input)
          (forward-line)))

      ;; TODO ensure history shifts maintain correct cursor position
      ;; (advice-add 'comint-previous-input :after 'comint-bol)
      ;; (advice-add 'comint-next-input     :after 'end-of-buffer)

      (defun +comint-set-bindings (keymap)
        ;; abstracted into a method because realgud seems
        ;; to hide all of these bindings.
        (general-define-key
         :keymaps keymap
         "RET" 'comint-send-input
         "M-RET" 'comint-accumulate

         "DEL" 'comint-backward-delete-char+
         "<backspace>" 'comint-backward-delete-char+

         "<C-backspace>" 'evil-backward-delete-word

         "M-DEL" 'comint-kill-input
         "<M-backspace>" 'comint-kill-input

         "<mouse-2>" 'comint-insert-input

         "C-w" emacs-window-map+
         "M-w" 'backward-kill-word
         "M-l" 'recenter-top-bottom
         ;; "C-M-l" 'comint-show-output

         "C-a" 'comint-bol-or-process-mark
         "C-e" 'end-of-buffer       ;; 'end-of-line
         "C-s" 'comint-history-isearch-backward-regexp
         "M-s" 'comint-dynamic-list-input-ring ;; TODO use ivy
         "C-r" 'evil-paste-from-register
         "C-v" 'quoted-insert
         "C-u" 'scroll-down
         "C-d" 'scroll-up
         "C-o" 'evil-execute-in-normal-state

         "C-<left>"  'backward-word
         "C-<up>"    'comint-previous-input
         "C-<down>"  'comint-next-input
         "C-<right>" 'forward-word

         "<left>"    'backward-char
         "<up>"      'comint-previous-input-or-previous-line+
         "<down>"    'comint-next-input-or-next-line+
         "<right>"   'forward-char

         "C-h"       'backward-char
         "C-j"       'comint-next-input-or-next-line+
         "C-k"       'comint-previous-input-or-previous-line+
         "C-l"       'forward-char

         "M-j"       'comint-next-matching-input-from-input
         "M-k"       'comint-previous-matching-input-from-input

         "C-f"       'forward-word
         "C-b"       'comint-backward-word+

         "M-u" 'comint-next-prompt
         "M-d" 'comint-previous-input

         ;; "<remap> <forward-char>"  'comint-forward-char
         "<remap> <backward-char>" 'comint-backward-char+
         ;; "<remap> <forward-word>"  'comint-forward-word
         "<remap> <backward-word>" 'comint-backward-word+

         "C-c C-c" 'comint-interrupt-subjob
         "C-c C-x" 'comint-get-next-from-history
         ))

      (defun +comint-set-leader-keys (mode)
        (leader-set-keys-for-major-mode mode
          "z" 'comint-send-eof
          "*" 'comint-insert-previous-argument
          "r" 'comint-dynamic-list-input-ring
          "m" 'comint-clear-buffer
          "M" 'comint-show-maximum-output
          "x" 'comint-get-next-from-history
          "RET" 'comint-copy-old-input ;; copy text before cursor
          ">" 'comint-write-output
          "t" 'comint-show-output
          "o" 'comint-delete-output

          "s" '(:ignore t :wk "subjob")
          "ss" 'comint-stop-subjob
          "sq" 'comint-quit-subjob
          "si" 'comint-interrupt-subjob))

      (provide '+comint-bindings)
    #+END_SRC

*** Appendix
    #+begin_src emacs-lisp
    (provide '+pkg-comint)
    #+end_src

** Shell                                                   :builtin:terminal:
   #+begin_src emacs-lisp
     (use-package +pkg-evil
       :config (evil-set-initial-state 'shell-mode 'emacs))
   #+end_src

** Elisp Shell                                            :optional:terminal:
   :PROPERTIES:
   :header-args+: :tangle (package-lisp! +pkg-eshell eshell)
   :END:

   #+begin_src emacs-lisp :tangle (package-yes! eshell)
   (require '+pkg-eshell)
   #+end_src

*** Eshell
    #+BEGIN_SRC emacs-lisp
      (use-package +pkg-evil
        :autoload evil-set-initial-state
        :config
        (evil-set-initial-state 'eshell-mode 'emacs))

      (use-package esh-mode
        :custom
        (eshell-directory-name (state! "eshell"))
        (eshell-aliases-file (state! "eshell" "aliases"))
        (eshell-login-script (etc! "eshell" "loginrc"))
        (eshell-rc-script (etc! "eshell" "eshrc"))
        (eshell-banner-message "")

        :config
        ;; Don't auto scroll to bottom after execution
        (remove-hook 'eshell-output-filter-functions
                     'eshell-postoutput-scroll-to-bottom)

        ;; Clear shouldn't scroll back to bottom of the screen
        (advice-add 'eshell/clear :after #'recenter-top-bottom)

        :commands eshell-backward-kill-word+
        :config
        (defun eshell-backward-kill-word+ ()
          (interactive)
          (let ((bol
                 (save-excursion
                   (beginning-of-line)
                   (point)))
                (beginning-word-point
                 (save-excursion
                   (backward-word)
                   (point))))
            (when (>= beginning-word-point bol)
              (call-interactively 'backward-kill-word))))

        :autoload eshell-mode--setup-bindings
        :config
        (defun eshell-mode--setup-bindings ()
          (general-define-key
            :keymaps 'eshell-mode-map
            ;;; movement commands
            "C-e"   'end-of-line
            "M-l"   'recenter-top-bottom
            "C-h"   'backward-char
            "C-l"   'forward-char
            "C-M-h" 'backward-word
            "C-M-l" 'forward-word
            ;;; scroll commands
            "<S-down>" 'evil-scroll-down
            "<S-up>"   'evil-scroll-up
            ;; move to beginning of output
            ;; or return to end of cursor
            "M-a" 'eshell-show-output
            "M-e" 'eshell-show-maximum-output

            ;;; signals
            "C-c C-z" 'eshell-send-eof-to-process
            "C-c C-q" 'eshell-quit-process
            "M-c"     'eshell-interrupt-process
            "M-z"     'eshell-send-eof-to-process
            "M-q"     'eshell-quit-process

            "M-y"           'eshell-repeat-argument
            "C-d"           'eshell-kill-input
            "C-M-k"         'eshell-kill-input
            "M-d"           'eshell-kill-output
            "C-w"           'eshell-backward-kill-word+
            "<C-backspace>" 'evil-delete-backward-word
            ;; copy entered input back into current line
            "<C-return>"    'eshell-copy-old-input

            "C-j"       'eshell-next-input
            "C-k"       'eshell-previous-input
            "M-j"       'eshell-next-prompt
            "M-k"       'eshell-previous-prompt
            ;; reverse the default affect of up and down
            "<up>"      'eshell-previous-input
            "<down>"    'eshell-next-input
            "<C-up>"    'eshell-previous-matching-input-from-input
            "<C-down>"  'eshell-next-matching-input-from-input
            "<S-left>"  'eshell-backward-argument
            "<S-right>" 'eshell-forward-argument
            "<M-left>"  'eshell-backward-argument
            "<M-right>" 'eshell-forward-argument))

        ;; Needs to be in a hook because eshell-mode-map isn't
        ;; defined until the mode is activated, and even then
        ;; it's only buffer-local :(.
        (add-hook 'eshell-mode-hook #'eshell-mode--setup-bindings)

        :leader
        (":" 'eshell-command)
        :lazy-leader
        (:major 'eshell-mode
         "o"   'eshell-show-output
         "O"   'eshell-mark-output
         "RET" 'eshell-queue-input

         "i" '(:ignore t :wk "insert")
         "ib" 'eshell-insert-buffer-name
         "ip" 'eshell-insert-process
         "ie" 'eshell-insert-envvar

         "k" '(:ignore t :wk "kill/signal")
         "kz" 'eshell-send-eof-to-process
         "kc" 'eshell-interrupt-process
         "kq" 'eshell-quit-process))
    #+END_SRC

*** Eshell Prompt Extras
    #+BEGIN_SRC emacs-lisp
      (use-package eshell-prompt-extras
        :straight t
        :after esh-mode
        :custom
        (epe-show-python-info t)
        (epe-path-style 'full)

        :autoload epe-theme-lambda
        :custom
        (eshell-prompt-function #'epe-theme-lambda)

        :autoload epe-remote-p
        :preface (use-package eshell
                   :autoload (eshell/pwd
                              eshell-search-path))
        :init
        (defvar eshell-prompt--enable-git-on-remote-files+ t
          "When true, show branch info even on remote files.")

        (advice-add 'epe-git-p :override
                    (defun epe-git-p+ ()
                      "If you installed git and in a git project."
                      (when (or eshell-prompt--enable-git-on-remote-files+
                                ;; either enable everywhere, including remote
                                ;; or enable when not remote
                                (not (epe-remote-p)))
                        (and (eshell-search-path "git")
                             (vc-find-root (eshell/pwd) ".git"))))))
    #+END_SRC

*** Appendix
    #+begin_src emacs-lisp
    (provide '+pkg-eshell)
    #+end_src

** Regex Builder                                                    :builtin:
   :PROPERTIES:
   :header-args+: :tangle (lisp! "+pkg-regex-builder.el")
   :END:

   #+begin_src emacs-lisp :tangle yes
   (require '+pkg-regex-builder)
   #+end_src

   #+BEGIN_SRC emacs-lisp
     (use-package re-builder
       :custom
       (reb-re-syntax 'rx)

       :autoload (reb-copy reb-quit)
       :config
       (defun reb-save-and-quit+ ()
         "Copy regexp and then exit the builder."
         (interactive)
         (reb-copy)
         (reb-quit))

       :lazy-leader
       (:mode 'reb-lisp-mode
        "," 'reb-save-and-quit+
        "s" 'reb-copy ;; as string
        "q" 'reb-quit

        "b" 'reb-change-target-buffer
        "c" 'reb-toggle-case
        "y" 'reb-copy ;; as string
        "u" 'reb-force-update
        "s" 'reb-enter-subexp-mode
        "TAB" 'reb-change-syntax)

       :general
       (:keymaps 'reb-lisp-mode-map
        :states 'normal
        "gj" 'reb-next-match
        "gk" 'reb-prev-match
        [remap quit-window] 'reb-quit))
   #+END_SRC

   #+begin_src emacs-lisp
   (provide '+pkg-regex-builder)
   #+end_src

** Transient
   :PROPERTIES:
   :header-args+: :tangle (package-yes! :transient)
   :END:

   An Emacs package for creating CLI frontends.

   #+BEGIN_SRC emacs-lisp
     (use-package transient
       :straight t
       :custom
       (transient-history-file (state! "transient/history.el"))
       (transient-values-file  (etc! "transient/values.el"))
       (transient-levels-file  (etc! "transient/levels.el"))

       :general
       ;; Escape means quit too
       (:keymaps 'transient-base-map
        "<escape>" 'transient-quit-one))
   #+END_SRC

** Magit
   :PROPERTIES:
   :header-args+: :tangle (package-lisp! +pkg-magit magit)
   :END:

   An Emacs frontend for the git version control software.

   #+begin_src emacs-lisp :tangle (package-yes! magit)
   (require '+pkg-magit)
   #+end_src

*** Magit
    #+BEGIN_SRC emacs-lisp
      (use-package magit
        :straight t
        :hide-whitespace+
        magit-status-mode
        magit-process-mode
        magit-log-mode
        magit-diff-mode

        :custom
        (magit-revision-show-gravatars  '("^Author:     " . "^Commit:     "))
        (magit-display-buffer-function 'magit-display-buffer-fullframe-status-v1
         "Show magit status in a full screen window.")

        :init
        (defvaralias 'magit-repository-directories 'projectile-project-search-path)

        :custom (magit-bury-buffer-function #'magit-bury-buffer-function+)
        :config
        (defun magit-bury-buffer-function+ (&optional kill-buffer)
          "Burying a magit status buffer restores the previous window configuration."
          (funcall
           (if (eq major-mode 'magit-status-mode)
               'magit-restore-window-configuration
             'magit-mode-quit-window)
           kill-buffer))

        :hook (magit-mode . magit-cleanup-defaults+)
        :preface
        (defun magit-cleanup-defaults+ ()
          ;; Messes up alignment on rescroll
          (setq-local scroll-conservatively 0))

        :hook (magit-commit-mode . magit-initialise-commit+)
        :preface
        (defun magit-initialise-commit+ ()
          (setq fill-column 72))

        :autoload (magit-diff-inside-hunk-body-p
                   magit-section-goto
                   magit-current-section)
        :config
        (defun magit-section-up--adjust-destination+ (func &rest args)
          (cond
           ((magit-diff-inside-hunk-body-p)
            (magit-section-goto (magit-current-section)))
           (t (apply func args))))

        (advice-add 'magit-section-up :around 'magit-section-up--adjust-destination+)

        :leader
        (:prefix "g"
         "$" 'magit-process-buffer
         "!" 'magit-run
         "g" 'magit-dispatch
         "t" 'magit-file-dispatch
         "s" 'magit-status
         "u" 'magit-unstage-file
         "b" 'magit-blame
         "p" 'magit-pop-revision-stack)

        :lazy-leader
        (:mode 'magit-status-mode
         "d" 'magit-list-repositories
         "z" 'magit-jump-to-stashes
         "u" 'magit-jump-to-unstaged
         "s" 'magit-jump-to-staged
         "f" 'magit-jump-to-untracked
         "r" 'magit-diff-toggle-refine-hunk
         "y" '(:ignore t :wk "copy")
         "ys" 'magit-copy-section-value
         "yr" 'magit-copy-buffer-revision)
        (:mode 'magit-log-select-mode
         "," 'magit-log-select-pick
         "q" 'magit-log-select-quit)
        (:mode '(magit-diff-mode magit-revision-mode)
         "r" 'magit-diff-toggle-refine-hunk
         "t" 'magit-diff-trace-definition
         "e" 'magit-diff-edit-hunk-commit)
        (:mode 'git-commit-mode
         :minor t
         :prefix leader-major-mode-prefix
         "s"  'git-commit-save-message
         "d"  'magit-diff-while-committing
         "j"  'git-commit-next-message
         "k"  'git-commit-prev-message
         "r"  'magit-pop-revision-stack
         "a"  'git-commit-insert-pseudo-header

         "i"  '(:ignore t :wk "insert")
         "ia" 'git-commit-ack ;; acknowledgement
         "iS" 'git-commit-suggested
         "im" 'git-commit-modified
         "ic" 'git-commit-cc
         "ir" 'git-commit-reported
         "iR" 'git-commit-review
         "is" 'git-commit-signoff
         "it" 'git-commit-test)

        :preface
        (defvar magit-blob-mode-map (make-sparse-keymap))                            ; Suppress creation.
        :hook (magit-blob-mode . evil-motion-state)

        :leader
        (:mode 'magit-blob-mode
         :minor t
         :prefix leader-major-mode-prefix
         "b" 'magit-blame-addition
         "f" 'magit-blame-reverse
         "r" 'magit-blame-removal
         "n" 'magit-blob-next
         "p" 'magit-blob-previous)

        :general
        ([remap vc-revision] 'magit-find-file
         [remap vc-revision-other-window] 'magit-find-file-other-window
         [remap vc-diff] 'magit-diff-buffer-file
         [remap vc-print-log] 'magit-log-buffer-file
         [remap vc-print-log-all] 'magit-log-head
         [remap vc-create-tag] 'magit-tag
         [remap magit-diff-buffer-file] 'magit-diff-buffer-file)
        (:keymaps 'magit-mode-map
         "M-j" 'magit-section-forward-sibling
         "M-k" 'magit-section-backward-sibling

         ;; ;; toggle children doesn't seem to work
         ;; "C-r" 'magit-section-hide-children ; recursive close
         ;; "C-e" 'magit-section-show-children ; recursive expand
         ;; "M-r" 'magit-section-hide-children ; Meta aliases
         ;; "M-e" 'magit-section-show-children ; Meta aliases

         ;; Visit and expand, M-RET is used to visit in the other-window
         ;; when applicable but most of the time it's just the same as RET.
         "RET"   'magit-visit-thing
         "TAB"   'magit-section-toggle
         "M-RET" 'magit-visit-thing

         [remap xopen-url+] 'magit-browse-thing
         [remap revert-buffer] 'magit-refresh)
        ;; Use M-RET to visit files in another window.
        (:keymaps '(magit-file-section-map
                    magit-hunk-section-map)
         "M-RET" 'magit-diff-visit-file-other-window)
        (:keymaps 'magit-process-mode-map
         "RET" 'magit-section-toggle)
        ;; Org like section maneuvering.
        (:keymaps 'magit-section-mode-map
         :states 'motion
         "gh" 'magit-section-up
         "gl" 'magit-section-forward
         "gj" 'magit-section-forward-sibling
         "gk" 'magit-section-backward-sibling)

        ;; (:keymaps 'magit-diff-mode-map
        ;;  :states 'motion
        ;;  "gh" 'magit-section-up)
        (:keymaps 'magit-blob-mode-map
         [remap quit-window] 'magit-kill-this-buffer))
    #+END_SRC

*** Magit Merge Remotes
    Magit by default doesn't support merging from remotes as a quick action. We
    define suffixes to make this easier.

    #+begin_src emacs-lisp
      (use-package transient
        :autoload (transient-suffix
                   transient-suffix-put
                   transient-insert-suffix
                   transient-append-suffix
                   transient-remove-suffix
                   transient-define-suffix))

      (use-package magit
        :autoload
        (magit--select-push-remote
         magit-get-current-branch
         magit-get-upstream-branch
         magit-merge-arguments
         magit-merge-assert
         magit-pull--pushbranch-description
         magit-pull--upstream-description
         magit-read-upstream-branch
         magit-run-git-async
         magit-set-upstream-branch)

        :commands magit-merge-from-pushremote+
        :config
        (transient-define-suffix magit-merge-from-pushremote+ (args nocommit)
          "Merge into the current branch from its push-remote branch.

      When the push-remote is either not configured or unusable, then let
      the user first configure the push-remote. With a prefix argument
      skip generating a merge commit."
          :if #'magit-get-current-branch
          :description #'magit-pull--pushbranch-description
          (interactive (list (magit-merge-arguments) current-prefix-arg))

          (pcase-let ((`(,branch ,remote)
                       (magit--select-push-remote "merge from this")))
            (magit-merge-assert)
            (magit-run-git-async "merge" (if nocommit "--no-commit" "--no-edit")
                                 args (concat remote "/" branch))))

        :commands magit-merge-from-upstream+
        :config
        (transient-define-suffix magit-merge-from-upstream+ (args nocommit)
          "Merge the current branch from its upstream branch.

      When the upstream is either not configured or unusable, then let
      the user first configure the upstream. With a prefix argument
      skip generating a merge commit."
          :if #'magit-get-current-branch
          :description #'magit-pull--upstream-description
          (interactive (list (magit-merge-arguments) current-prefix-arg))

          (let* ((branch (or (magit-get-current-branch)
                             (user-error "No branch is checked out")))
                 (upstream (magit-get-upstream-branch branch)))
            (unless upstream
              (setq upstream
                    (magit-read-upstream-branch
                     branch (format "Set upstream of %s and rebase onto that" branch)))
              (magit-set-upstream-branch branch upstream))
            (magit-merge-assert)
            (magit-run-git-async "merge" (if nocommit "--no-commit" "--no-edit")
                                 args upstream)))

        :config
        (transient-suffix-put 'magit-merge '(1 1 "p") :key "v")

        (transient-insert-suffix 'magit-merge '(1 0 0) '("p" magit-merge-from-pushremote+))
        (transient-append-suffix 'magit-merge '(1 0 0) '("u" magit-merge-from-upstream+))
        (transient-remove-suffix 'magit-merge '(1 1 1)) ; Remove blank separator

        ;; Move the absorb suffix to the next column
        (transient-remove-suffix 'magit-merge '(1 0 "a"))
        (transient-append-suffix 'magit-merge '(1 1 0) '("a" "Absorb" magit-merge-absorb))

        ;; Add a configure setting like `magit-push'.
        (transient-append-suffix 'magit-merge '(-1)
          ["Configure" ("C" "Set variables..."  magit-branch-configure)]))
    #+end_src

*** Magit Evil
    Now we need to enable evil-bindings in magit buffers... which is honestly a lot
    more of a pain then you may expect. For now I've just copied and pasted a bunch
    of helpful stuff from [[https://github.com/emacs-evil/evil-collection/blob/b45ec5b3156d27a18a949e4bf55643107a21abc2/modes/magit/evil-collection-magit.el][evil-collection]] and removed any references to evil-collection
    specific commands (such as ~evil-collection-define-key~). It's a sloppy solution
    but seems to be working for now.

    #+BEGIN_SRC emacs-lisp
      (require '+pkg-evil)

      (use-package magit
        :config
        (evil-set-initial-state 'magit-submodule-list-mode 'motion)
        (evil-set-initial-state 'magit-repolist-mode 'motion)
        (evil-set-initial-state 'magit-mode 'motion)
        (evil-set-initial-state 'magit-cherry-mode 'motion)
        (evil-set-initial-state 'magit-diff-mode 'motion)
        (evil-set-initial-state 'magit-log-mode 'motion)
        (evil-set-initial-state 'magit-log-select-mode 'motion)
        (evil-set-initial-state 'magit-process-mode 'motion)
        (evil-set-initial-state 'magit-reflog-mode 'motion)
        (evil-set-initial-state 'magit-refs-mode 'motion)
        (evil-set-initial-state 'magit-revision-mode 'motion)
        (evil-set-initial-state 'magit-stash-mode 'motion)
        (evil-set-initial-state 'magit-stashes-mode 'motion)
        (evil-set-initial-state 'magit-status-mode 'motion)
        (evil-set-initial-state 'magit-blob-mode 'motion)
        (evil-set-initial-state 'magit-gitflow-mode 'motion)
        (evil-set-initial-state 'git-commit-mode 'normal)

        :config
        (evil-set-command-property 'magit-section-forward-sibling  :keep-visual t)
        (evil-set-command-property 'magit-section-forward          :keep-visual t)
        (evil-set-command-property 'magit-section-backward-sibling :keep-visual t)
        (evil-set-command-property 'magit-section-backward         :keep-visual t)
        (evil-set-command-property 'magit-section-up               :keep-visual t)

        ;; Need to refresh evil keymaps when certain modes are entered.
        :hook ((magit-blame-mode
                magit-repolist-mode
                magit-submodule-list-mode)
               . evil-normalize-keymaps)

        :config
        ;; evil-collection-magit-use-y-for-yank
        (defvar evil-collection-magit-in-visual-pre-command+)
        (defun evil-collection-magit--around-visual-pre-command+ (orig-func &rest args)
          (let ((evil-collection-magit-in-visual-pre-command+ t))
            (apply orig-func args)))

        (advice-add 'evil-visual-pre-command :around 'evil-collection-magit--around-visual-pre-command+)
        (advice-add 'evil-visual-expand-region :filter-args
                    (defun evil-collection-magit--filter-args-visual-expand-region (arglist)
                      ;; pretend that the command has the :exclude-newline property by rewriting the
                      ;; EXCLUDE-NEWLINE arg to this function
                      (cons (and (bound-and-true-p evil-collection-magit-in-visual-pre-command+)
                                 (null (car arglist))
                                 (eq (evil-visual-type) 'line)
                                 (derived-mode-p 'magit-mode))
                            ;; shouldn't be necessary, but this will prevent it from failing if an
                            ;; arg is added.
                            (cdr arglist))))

        :config
        (general-define-key
         :keymaps 'magit-repolist-mode-map
         :states 'motion
         "RET" 'magit-repolist-status
         "gr"  'magit-list-repositories)

        (general-define-key
         :keymaps 'magit-submodule-list-mode-map
         :states 'motion
         "RET" 'magit-repolist-status
         "gr"  'magit-list-submodules)

        ;; Adjust popups
        :preface (use-package transient :autoload transient-suffix-put)
        :config
        (transient-suffix-put 'magit-branch   "x" :key "X") ;; magit-branch-reset
        (transient-suffix-put 'magit-branch   "k" :key "x") ;; magit-branch-delete
        (transient-suffix-put 'magit-dispatch "o" :key "'") ;; magit-submodule
        (transient-suffix-put 'magit-dispatch "O" :key "\"") ;; magit-subtree
        (transient-suffix-put 'magit-dispatch "V" :key "_") ;; magit-revert
        (transient-suffix-put 'magit-dispatch "X" :key "O") ;; magit-reset
        (transient-suffix-put 'magit-dispatch "v" :key "-") ;; magit-reverse
        (transient-suffix-put 'magit-dispatch "k" :key "x") ;; magit-discard
        (transient-suffix-put 'magit-remote   "k" :key "x") ;; magit-remote-remove
        (transient-suffix-put 'magit-revert   "v" :key "+") ;; magit-revert-no-commit
        (transient-suffix-put 'magit-revert   "V" :key "_") ;; magit-revert-and-commit
        (transient-suffix-put 'magit-revert   "V" :key "_") ;; magit-sequencer-continue
        (transient-suffix-put 'magit-tag      "k" :key "x") ;; magit-tag-delete

        :general
        (:keymaps 'magit-mode-map
         :states '(motion visual)
         "g"     nil
         "n"     nil                                                                  ; magit-section-forward
         "M-n"   nil                                                                  ; magit-section-forward-sibling
         "M-n"   nil                                                                  ; magit-section-forward-sibling
         "p"     nil                                                                  ; magit-section-backward
         "M-p"   nil                                                                  ; magit-section-backward-sibling
         "M-p"   nil                                                                  ; magit-section-backward-sibling
         "g"     nil                                                                  ; magit-refresh
         "G"     nil                                                                  ; magit-refresh-all
         "k"     nil                                                                  ; magit-delete-thing
         "K"     nil                                                                  ; magit-file-untrack
         "v"     nil                                                                  ; magit-revert-no-commit
         "V"     nil                                                                  ; magit-revert
         "P"     nil                                                                  ; magit-push
         "x"     nil                                                                  ; magit-reset-quickly
         "X"     nil                                                                  ; magit-reset
         ":"     nil                                                                  ; magit-git-command
         "o"     nil                                                                  ; magit-submodule
         "O"     nil                                                                  ; magit-subtree
         "-"     nil                                                                  ; magit-diff-less-context
         "SPC"   nil                                                                  ; magit-diff-show-or-scroll-up
         "DEL"   nil                                                                  ; magit-diff-show-or-scroll-down
         "C-j"   'magit-section-forward
         "gj"    'magit-section-forward-sibling
         "]"     'magit-section-forward-sibling
         "C-k"   'magit-section-backward
         "gk"    'magit-section-backward-sibling
         "["     'magit-section-backward-sibling
         "gr"    'magit-refresh
         "gR"    'magit-refresh-all
         "x"     'magit-delete-thing
         "X"     'magit-file-untrack
         "-"     'magit-revert-no-commit
         "_"     'magit-revert
         "p"     'magit-push
         "o"     'magit-reset-quickly
         "O"     'magit-reset
         "|"     'magit-git-command
         "'"     'magit-submodule
         "\""    'magit-subtree
         "="     'magit-diff-less-context
         "j"     'evil-next-line
         "k"     'evil-previous-line
         "gg"    'evil-goto-first-line
         "G"     'evil-goto-line
         "C-d"   'evil-scroll-down
         "C-f"   'evil-scroll-page-down
         "C-b"   'evil-scroll-page-up
         ":"     'evil-ex
         "q"     'magit-mode-bury-buffer
         "S-SPC" 'magit-diff-show-or-scroll-up
         "S-DEL" 'magit-diff-show-or-scroll-down)
        (:keymaps 'magit-mode-map
         :states 'motion
         evil-toggle-key #'evil-emacs-state
         "<escape>" 'magit-mode-bury-buffer)
        (:keymaps 'magit-log-mode-map
         :states '(motion visual)
         "=" 'magit-log-toggle-commit-limit)

        ;; Fix evil-search
        (:keymaps 'magit-mode-map
         :states '(motion visual)
         "/" 'evil-ex-search-forward
         "n" 'evil-ex-search-next
         "N" 'evil-ex-search-previous)
        (:keymaps 'magit-status-mode-map
         :states '(motion visual)
         "t" 'magit-tag
         "gz"  'magit-jump-to-stashes
         "gt"  'magit-jump-to-tracked
         "gn"  'magit-jump-to-untracked
         "gu"  'magit-jump-to-unstaged
         "gs"  'magit-jump-to-staged
         "gfu" 'magit-jump-to-unpulled-from-upstream
         "gfp" 'magit-jump-to-unpulled-from-pushremote
         "gpu" 'magit-jump-to-unpushed-to-upstream
         "gpp" 'magit-jump-to-unpushed-to-pushremote
         "gh"  'magit-section-up)
        (:keymaps 'magit-diff-mode-map
         :states '(motion visual)
         "gd" 'magit-jump-to-diffstat-or-diff)
        (:keymaps 'magit-diff-mode-map
         :states 'visual
         "y" 'magit-copy-section-value)

        ;; evil-want-C-u-scroll
        (:keymaps 'magit-mode-map
         :states '(motion visual)
         "C-u" 'evil-scroll-up)

        ;; evil-collection-magit-use-y-for-yank
        (:keymaps 'magit-mode-map
         :states '(motion visual)
         "v"    'evil-visual-line
         "V"    'evil-visual-line)
        ;; (:keymaps 'magit-status-mode-map
        ;;  :states 'motion
        ;;  "y" (general-key-dispatch 'evil-yank
        ;;        "y" 'evil-line-or-visual-line
        ;;        "j" 'evil-next-visual-line
        ;;        "k" 'evil-previous-visual-line))
        (:keymaps 'magit-status-mode-map
         :states '(visual normal)
         "y" 'evil-yank)

        (:keymaps 'magit-mode-map
         :states 'visual
         "y" 'magit-copy-section-value)
        ;; evil-collection-magit-minor-mode-map-bindings
        ;; (:keymaps 'magit-blob-mode-map
        ;;  :states '(motion visual)
        ;;  "gj" 'magit-blob-next     "n" 'magit-blob-next
        ;;  "gk" 'magit-blob-previous "p" 'magit-blob-previous)
        (:keymaps 'git-commit-mode-map
         :states '(motion visual)
         "gk" 'git-commit-prev-message "M-p" nil
         "gj" 'git-commit-next-message "M-n" nil)
        (:keymaps '(magit-mode-map
                    magit-blame-mode-map
                    magit-blame-read-only-mode-map
                    magit-cherry-mode-map
                    magit-mode-map
                    magit-blob-mode-map
                    magit-diff-mode-map
                    magit-log-mode-map
                    magit-log-select-mode-map
                    magit-reflog-mode-map
                    magit-status-mode-map
                    magit-log-read-revs-map
                    magit-process-mode-map
                    magit-refs-mode-map
                    forge-pullreq-list-mode-map)
         leader-key nil                                                               ; GIVE ME BACK MY LEADER!!!
         "<override-state>" 'all)
        (:keymaps 'magit-refs-mode-map
         "s" 'magit-branch-shelve
         "u" 'magit-branch-unshelve)
        (:keymaps 'magit-gh-pulls-mode-map
         leader-key nil                                                               ; GIVE ME BACK MY LEADER!!!
         "<override-state>" 'motion)
        (:keymaps '(magit-mode-map
                    magit-diff-mode-map)
         "C-w" nil                                                                    ; and my window-map
         )

        (:keymaps 'magit-blame-mode-map
         "j"    'evil-next-line
         "C-j"  'magit-blame-next-chunk                 "n" nil
         "gj"   'magit-blame-next-chunk                 "n" nil
         "J"    'magit-blame-next-chunk-same-commit     "N" nil
         "k"    'evil-previous-line
         "C-k"  'magit-blame-previous-chunk             "p" nil
         "gk"   'magit-blame-previous-chunk             "p" nil
         "K"    'magit-blame-previous-chunk-same-commit "P" nil)
        (:keymaps '(magit-blame-mode-map
                    magit-blame-read-only-mode-map)
         :states 'normal
         "q" 'magit-blame-quit))
    #+END_SRC

*** Magit TODOs
    #+BEGIN_SRC emacs-lisp
      (use-package magit-todos
        :straight t
        :after magit
        :demand t
        :lazy-leader
        (:mode 'magit-status-mode
         "T" 'magit-todos-list
         "t" 'magit-todos-jump-to-todos)

        :commands magit-todos-mode
        :config (magit-todos-mode +1)

        :general
        (:keymaps '(magit-todos-item-section-map
                    magit-todos-section-map)
         "j" nil "B" nil "b" nil "k" nil))
    #+END_SRC

*** Git Rebase
    Major mode for editing rebase files.

    #+begin_src emacs-lisp
      (use-package git-rebase
        :straight magit
        :init
        (evil-set-initial-state 'git-rebase-mode 'motion)

        :config
        ;; WARN: Haven't included `evil-collection-magit-add-rebase-messages'.
        (remove-hook 'git-rebase-mode-hook 'git-rebase-mode-show-keybindings)

        :general
        (:keymaps 'git-rebase-mode-map
         "<override-state>" 'all

         leader-key nil                                                               ; Reclaim leader key.
         "p" nil "n" nil                                                              ; Accessible through vim style j, k bindings.
         "M-n" nil "<C-up>"   'git-rebase-move-line-up                                ; Prefer drag-stuff style bindings.
         "M-p" nil "<C-down>" 'git-rebase-move-line-down

         "u" 'git-rebase-undo
         "o" 'git-rebase-update-ref
         "x" nil "!" 'git-rebase-exec
         "k" nil "x" 'git-rebase-kill-line "d" 'git-rebase-kill-line
         "c" nil "p" 'git-rebase-pick
         "m" nil "e" 'git-rebase-edit))
    #+end_src

*** Git Modes
    #+BEGIN_SRC emacs-lisp
      (use-package git-modes
        :straight t
        :hook (git-commit-mode . +flyspell))
    #+END_SRC

*** With Editor
    Package used by ~magit~ for controlling =emacsclient=.

    #+BEGIN_SRC emacs-lisp
      (use-package with-editor
        :lazy-leader
        (:mode 'with-editor-mode
         :minor t
         :prefix leader-major-mode-prefix
         ","  'with-editor-finish
         "q"  'with-editor-cancel))
    #+END_SRC

*** Git Forge
    :PROPERTIES:
    :header-args+: :tangle (package-lisp! +pkg-magit magit forge)
    :END:

    Interact with forges such as GitHub/GitLab from the comfort of Magit.

    #+BEGIN_SRC emacs-lisp
      (use-package forge
        :straight t
        ;; :leader ("go" 'forge-browse-dwim)
        :custom
        (forge-database-file (state! "forge.db"))

        :init
        ;; (with-eval-after-load 'magit
        ;;   (require 'forge))

        :config
        ;; When `forge' is loaded, it maps `forge-dispatch' to ' key which is
        ;; set for `magit-submodule', wiping it so we add it back after `forge'
        ;; loads.
        (transient-append-suffix 'magit-dispatch "M"
          '("'" "Submodule" magit-submodule))

        ;; Clear `forge' key and re-add back in as "@".
        (transient-remove-suffix 'magit-dispatch 'forge-dispatch)
        (transient-append-suffix 'magit-dispatch "!"
          '("@" "Forge" forge-dispatch))

        :general
        (:keymaps 'forge-issue-list-mode-map
         :states 'motion
         "RET" "<return>")
        (:keymaps 'magit-mode-map
         :states '(motion visual)
         "@" 'forge-dispatch)
        (:keymaps 'forge-pullreq-list-mode
         "<override-state>" 'all)

        (:keymaps 'magit-mode-map                 [remap +xopen-url] 'forge-browse-dwim)
        (:keymaps 'forge-topic-mode-map           [remap +xopen-url] 'forge-browse-topic)
        (:keymaps 'forge-issue-list-mode-map      [remap +xopen-url] 'forge-browse-issues)
        (:keymaps 'forge-pullreq-list-mode-map    [remap +xopen-url] 'forge-browse-pullreqs)
        (:keymaps 'forge-repository-list-mode-map [remap +xopen-url] 'forge-browse-repository))
    #+END_SRC

*** Appendix
    #+begin_src emacs-lisp
    (provide '+pkg-magit)
    #+end_src

** Hide Comment                                                    :optional:
   :PROPERTIES:
   :header-args+: :tangle (package-yes! hide-comnt)
   :END:

   Toggles the display of comments in the current buffer.

   #+BEGIN_SRC emacs-lisp
     (use-package hide-comnt
       :straight t
       :leader ("t/" 'hide/show-comments-toggle))
   #+END_SRC

** Fringe                                                           :builtin:
   :PROPERTIES:
   :header-args+: :tangle (lisp! "+pkg-fringe.el")
   :END:

   Bitmap sourced from [[https://github.com/syl20bnr/spacemacs/blob/master/layers/%2Bcheckers/syntax-checking/packages.el][spacemacs]].

   #+begin_src emacs-lisp :tangle yes
     (require '+pkg-fringe)
   #+end_src

   #+BEGIN_SRC emacs-lisp
     (define-fringe-bitmap '+dot-fringe-bitmap
       (vector #b00000000
               #b00000000
               #b00000000
               #b00000000
               #b00000000
               #b00000000
               #b00000000
               #b00011100
               #b00111110
               #b00111110
               #b00111110
               #b00011100
               #b00000000
               #b00000000
               #b00000000
               #b00000000
               #b00000000))
   #+END_SRC

   #+begin_src emacs-lisp
     (provide '+pkg-fringe)
   #+end_src

** FlyMake                                                           :linter:
   :PROPERTIES:
   :header-args+: :tangle (lisp! "+pkg-flymake.el")
   :END:

   #+begin_src emacs-lisp :tangle yes
   (require '+pkg-flymake)
   #+end_src

*** FlyMake                                                         :builtin:
    #+BEGIN_SRC emacs-lisp
      (use-package +pkg-evil
        :autoload (evil-declare-motion
                   evil-set-command-property)
        :config
        (evil-declare-motion 'flymake-goto-next-error)
        (evil-declare-motion 'flymake-goto-prev-error)
        (evil-set-command-property 'flymake-goto-next-error :jump t)
        (evil-set-command-property 'flymake-goto-prev-error :jump t))

      (use-package flymake
        :straight (flymake :type built-in)
        :diminish flymake-mode
        :init
        ;; Disable the legacy proc backend.
        (setq-default flymake-diagnostic-functions nil)
        (with-eval-after-load 'flymake-proc
          (remove-hook 'flymake-diagnostic-functions 'flymake-proc-legacy-flymake))

        :custom
        (flymake-margin-indicators-string
         '((error   "X" compilation-error)
           (warning "!" compilation-warning)
           (note    "‚ñ†" compilation-info)))
        (flymake-margin-indicator-position 'right-margin)

        :preface
        (defmacro flymake-unsupported-command+ (name)
          `(lambda ()
             (interactive)
             (message "Flymake doesn't have a parallel for: %s" (quote ,name))))

        :config
        ;; Force flymake to not try and cooperate with flycheck (for now).
        (add-hook 'flymake-mode-hook
                  (defun flymake-disable-flycheck+ ()
                    (when (and (bound-and-true-p flycheck-mode)
                               (functionp 'flycheck-mode))
                      (flycheck-mode -1))))

        :config
        (use-package +setup-display-buffer
          :config
          (advice-add 'diff-apply-hunk :around 'display-buffer-no-select-window-advice+)
          (advice-add 'diff-test-hunk :around 'display-buffer-no-select-window-advice+))

        :commands flymake-first-error+
        :autoload flymake--overlays
        :config
        (defun flymake-first-error+ ()
          (interactive)
          (let* ((ovs (flymake--overlays :compare #'< :key #'overlay-start))
                 (ov (car ovs)))
            (cond
             (ov (goto-char (overlay-start ov)))
             (t (user-error "No flymake errors in the current buffer")))))
        (evil-set-command-property 'flymake-first-error+ :jump t)
        (evil-declare-motion 'flymake-first-error+)

        :commands flymake-last-error+
        :autoload flymake--overlays
        :config
        (defun flymake-last-error+ ()
          (interactive)
          (let* ((ovs (flymake--overlays :compare #'< :key #'overlay-start))
                 (ov (car (last ovs))))
            (cond
             (ov (goto-char (overlay-start ov)))
             (t (user-error "No flymake errors in the current buffer")))))
        (evil-set-command-property 'flymake-last-error+ :jump t)
        (evil-declare-motion 'flymake-last-error+)

        ;; Make the diagnostic buffer auto-move to the closest error.
        :autoload (flymake-diagnostic-beg
                   flymake--diagnostics-buffer-name)
        :config
        (advice-add 'flymake-show-buffer-diagnostics :filter-return
                    (defun flymake-show-buffer-diagnostics-update-point+ (result)
                      "Move point to the error closest to point in diagnostics buffer.
      By default when you run `flymake-show-buffer-diagnostics' your point is
      either the start of the buffer or where it was when you were previously
      in that buffer.
      This isn't ideal when you just want to inspect the error message for the
      error at point. This advice moves the point to the closest error in the
      diagnostics buffer to where you were in the original buffer."
                      (with-current-buffer (flymake--diagnostics-buffer-name)
                        (when-let* ((source flymake--diagnostics-buffer-source)
                                    (diag-deltas
                                     (with-current-buffer source
                                       (let ((point (point)))
                                         (cl-loop for it in (cl-sort (flymake-diagnostics) #'<
                                                                     :key #'flymake-diagnostic-beg)
                                                  collect (abs (- (flymake-diagnostic-beg it) point)))))))
                          (goto-char (point-min))
                          (let ((ix (seq-position diag-deltas (seq-min diag-deltas))))
                            (forward-line ix))))
                      result))

        :leader
        ("ej" 'flymake-goto-next-error
         "ek" 'flymake-goto-prev-error
         "er" 'flymake-start
         "e1" 'flymake-first-error+
         "e2" 'flymake-last-error+
         "el" 'flymake-show-buffer-diagnostics
         ;; "e2" 'flymake-switch-to-log-buffer
         "eL" 'flymake-show-project-diagnostics
         ;; TODO implement
         ;; (flymake-unsupported-command+ toggle-flycheck-messages)
         "ex" (flymake-unsupported-command+ flycheck-clear)
         "ed" (flymake-unsupported-command+ flycheck-explain-error-at-point)
         "hde" (flymake-unsupported-command+ flycheck-describe-checker))

        :general
        (:keymaps 'flymake-diagnostics-buffer-mode-map
         :states 'motion
         "RET" 'flymake-goto-diagnostic
         "o" 'flymake-show-diagnostic))
    #+END_SRC

*** FlyMake Fringe
    #+begin_src emacs-lisp
      (use-package +pkg-fringe
        :after flymake
        :demand t
        :custom
        (flymake-note-bitmap '(+dot-fringe-bitmap compilation-info))
        (flymake-error-bitmap '(+dot-fringe-bitmap compilation-error))
        (flymake-warning-bitmap '(+dot-fringe-bitmap compilation-warning)))
    #+end_src

*** FlyMake Collection
    #+begin_src emacs-lisp
      (use-package flymake-collection
        :straight t
        :hook (after-init . flymake-collection-hook-setup)
        :custom
        (flymake-collection-markdownlint-style
         (join-path+ (xdg-config-home) "mdlstyle.rb"))
        (flymake-collection-hook-ignore-modes '(eglot--managed-mode))

        :leader ("ec" 'flymake-collection-change-checker))
    #+end_src

*** FlyMake Tooltip                                                :disabled:
    #+BEGIN_SRC emacs-lisp :tangle no
      (use-package flymake-diagnostic-at-point
        :straight t
        :hook (flymake-mode . flymake-diagnostic-at-point-mode))
    #+END_SRC

*** Consult FlyMake                                                :optional:
    :PROPERTIES:
    :header-args+: :tangle (package-lisp! +pkg-flymake :consult)
    :END:

    #+begin_src emacs-lisp
      (use-package +pkg-evil
        :autoload evil-set-command-property
        :config
        (evil-set-command-property 'consult-flymake :jump t))

      (use-package consult-flymake
        :straight consult
        :leader
        ;; (:minor t :mode 'flymake-mode  "je" 'consult-flymake)
        ("je" 'consult-flymake))
    #+end_src

*** FlyMake Hydra
    #+begin_src emacs-lisp
      (require '+pkg-hydra)

      (use-package flymake
        :commands flymake-hydra/body
        :leader ("e." 'flymake-hydra/body)

        :preface
        (defvar flymake-hydra--window-config+ nil)

        :autoload flymake-hydra--setup-window-config+
        :init
        (defun flymake-hydra--setup-window-config+ (diag-buffer)
          (setq flymake-hydra--window-config+ (current-window-configuration))
          (delete-other-windows)
          (with-selected-window (split-window-right)
            (switch-to-buffer diag-buffer)

            (when (and (bound-and-true-p next-error-last-buffer)
                       (buffer-live-p next-error-last-buffer))
              (with-selected-window (split-window-below)
                (switch-to-buffer next-error-last-buffer)))))

        :autoload flymake-hydra--restore-window-config+
        :init
        (defun flymake-hydra--restore-window-config+ ()
          (when flymake-hydra--window-config+
            (unwind-protect
                (save-current-buffer
                  (save-selected-window
                    (save-excursion
                      (set-window-configuration flymake-hydra--window-config+))))
              (setq flymake-hydra--window-config+ nil))))

        :autoload (flymake-show-buffer-diagnostics
                   flymake--diagnostics-buffer-name
                   flymake-goto-prev-error
                   flymake-goto-next-error)

        :hydra
        (flymake-hydra
         (:body-pre (flymake-hydra--setup-window-config+
                     (let ((buffer (flymake--diagnostics-buffer-name)))
                       (save-window-excursion
                         (flymake-show-buffer-diagnostics))
                       buffer))
          :post (flymake-hydra--restore-window-config+)
          :hint nil)
         ("j"  flymake-goto-next-error "Next")
         ("k"  flymake-goto-prev-error "Previous")
         ("gg" flymake-first-error+ "First")
         ("G"  flymake-last-error+ "Last")
         ("n"  next-error "Next-Compile")
         ("p"  previous-error "Last-Compile")
         ("q"  nil :exit t)))
    #+end_src

*** Appendix
    #+begin_src emacs-lisp
    (provide '+pkg-flymake)
    #+end_src

** FlyCheck
   :PROPERTIES:
   :header-args+: :tangle (package-lisp! +pkg-flycheck flycheck)
   :END:

   On the fly syntax checker for Emacs. finds where you've written bugs, adds an icon
   to the fringe and underlines it.

   #+begin_src emacs-lisp :tangle (package-yes! flycheck)
   (require '+pkg-flycheck)
   #+end_src

*** FlyCheck
    #+BEGIN_SRC emacs-lisp
      (require '+pkg-evil)

      (use-package flycheck
        :straight t
        :diminish flycheck-mode
        :custom
        (flycheck-python-pycompile-executable "python3")
        (flycheck-disabled-checkers '(emacs-lisp-checkdoc))
        ;; (flycheck-indication-mode 'left-margin)
        (flycheck-default-margin-str "‚Ä¢")

        :init
        (defvaralias 'flycheck-markdown-mdl-style 'flymake-collection-markdownlint-style)
        (evil-set-initial-state 'flycheck-error-message-mode 'motion)

        ;; Prefer eldoc to flycheck-specific timer.
        :custom (flycheck-display-errors-function nil)
        :hook (flycheck-mode . flycheck-setup-eldoc+)
        :autoload (flycheck-eldoc-function+
                   flycheck-setup-eldoc+
                   flycheck-overlay-errors-at
                   flycheck-help-echo-all-error-messages)
        :config
        (defun flycheck-eldoc-function+ (_callback)
          (when-let* ((errors (flycheck-overlay-errors-at (point))))
            (flycheck-help-echo-all-error-messages errors)))

        (defun flycheck-setup-eldoc+ ()
          (if (bound-and-true-p flycheck-mode)
              (add-hook 'eldoc-documentation-functions #'flycheck-eldoc-function+ 50 t)
            (remove-hook 'eldoc-documentation-functions #'flycheck-eldoc-function+)))

        ;; :config
        ;; ;; Getting fringe/margin indicators on the tty is buggy.
        ;; ;; This works... but it shows up before the line-numbers. You can
        ;; ;; attach it to the right margin but then it only shows up in the
        ;; ;; right-most frame.
        ;; (add-hook 'flycheck-mode-hook
        ;;           (defun flycheck-show-on-margin+ ()
        ;;             (flycheck-set-indication-mode 'left-margin)))

        :autoload (flycheck-list-errors--goto-first-error+
                   flycheck-error-list-goto-first-error+)
        :config ;; automatically jump to first error when listing errors.
        (defun flycheck-list-errors--goto-first-error+ (func &rest args)
          (let ((flycheck-buffer (get-buffer "*Flycheck errors*")))
            (apply func args) ;; call flycheck-list-errors
            (unless flycheck-buffer
              (flycheck-error-list-goto-first-error+))))
        (advice-add 'flycheck-list-errors :around #'flycheck-list-errors--goto-first-error+)

        :autoload flycheck-define-command-checker
        :config ;; Define some extra flycheck checkers.
        (flycheck-define-checker python-pycodestyle
          "A Python syntax and style checker using pycodestyle (former pep8)."

          :command ("pycodestyle" source-inplace)
          :error-patterns
          ((error line-start (file-name) ":" line ":" column ": " (id (or "E" "W") (+ digit)) (message) line-end))
          :modes python-mode)
        (add-to-list 'flycheck-checkers 'python-pycodestyle)

        :config
        (evil-set-command-property 'flycheck-next-error :jump t)
        (evil-set-command-property 'flycheck-previous-error :jump t)

        :preface
      (defvar-local flycheck-original-display-errors-function+ nil
        "The value of `flycheck-display-errors-function' before being toggled
      by `toggle-flycheck-messages'.")

        :commands toggle-flycheck-messages+
        :config
        (defun toggle-flycheck-messages+ (&optional prefix)
          (interactive "P")
          (let ((enabling
                 (cond
                  (prefix
                   (not (zerop (prefix-numeric-value prefix))))
                  (t flycheck-original-display-errors-function+))))
            (when (and enabling
                       (not flycheck-original-display-errors-function+))
              (user-error "trying to restore a non-existant error function"))

            (if enabling
                (setq flycheck-display-errors-function flycheck-original-display-errors-function+
                      flycheck-original-display-errors-function+ nil)
              (setq flycheck-original-display-errors-function+ flycheck-display-errors-function
                    flycheck-display-errors-function nil))

            (message "%s flycheck messages"
                     (if enabling
                         (propertize "enabled" 'face 'compilation-info)
                       (propertize "disabled" 'face 'compilation-error)))))

        :commands flycheck-last-error+
        :config
        (defun flycheck-last-error+ ()
          (interactive)
          (goto-char (point-max))
          (flycheck-previous-error))

        :commands flycheck-error-list-goto-first-error+
        :config
        (defun flycheck-error-list-goto-first-error+ ()
          (interactive)
          (goto-char (point-min))
          (flycheck-error-list-next-error 1)
          (flycheck-error-list-previous-error 1))

        :commands flycheck-error-list-goto-last-error+
        :config
        (defun flycheck-error-list-goto-last-error+ ()
          (interactive)
          (goto-char (point-max))
          (flycheck-error-list-previous-error 1))

        :commands flycheck-error-list-goto-error-or-eob+
        :autoload flycheck-goto-line
        :config
        (evil-define-motion flycheck-error-list-goto-error-or-eob+ (count)
          :jump t
          :type line
          (if (null count)
              (flycheck-error-list-goto-last-error+)
            (flycheck-goto-line count)))

        :preface
        (define-minor-mode flycheck-error-list-follow-mode+
          "Minor mode for `flycheck-error-list-mode' which toggles the behaviour
      of evil forward-line/goto-line functions to use their flycheck variants."
          :lighter " flyfollow"
          '(([remap evil-next-line]       . flycheck-error-list-next-error)
            ([remap evil-previous-line]   . flycheck-error-list-previous-error)
            ([remap evil-goto-first-line] . flycheck-error-list-goto-first-error+)
            ([remap evil-goto-line]       . flycheck-error-list-goto-error-or-eob+)))

        :general
        (:keymaps 'flycheck-mode-map
         [remap flymake-goto-next-error] 'flycheck-next-error
         [remap flymake-goto-prev-error] 'flycheck-previous-error
         [remap flymake-start] 'flycheck-buffer
         [remap flymake-first-error+] 'flycheck-first-error
         [remap flymake-last-error+] 'flycheck-last-error
         [remap flymake-collection-change-checker] 'flycheck-select-checker
         [remap flymake-show-buffer-diagnostics] 'flycheck-list-errors)

        (:keymaps 'flycheck-error-list-mode-map
         :states  'motion
         "RET" 'flycheck-error-list-goto-error
         "s" 'tabulated-list-sort
         "gj" 'flycheck-error-list-next-error
         "gk" 'flycheck-error-list-previous-error
         "gs" 'flycheck-error-list-check-source
         "gh" 'flycheck-error-list-goto-first-error+
         "gl" 'flycheck-error-list-goto-last-error+
         )

        :leader
        (:mode 'flycheck-mode :minor t
         ;; "eC" 'flycheck-set-checker-executable
         ;; "ev" 'flycheck-verify-setup
         "ed" 'flycheck-explain-error-at-point
         "ex" 'flycheck-clear
         "es" 'flycheck-last-error+
         "e DEL" 'toggle-flycheck-messages+)

        :lazy-leader
        (:mode 'flycheck-error-list-mode
         "e" 'flycheck-error-list-explain-error
         "s" 'flycheck-error-list-check-source                                        ; syntax check buffer
         "f" 'flycheck-error-list-follow-mode
         "l" 'flycheck-error-list-set-filter
         "r" 'flycheck-error-list-reset-filter))
    #+END_SRC

*** Flycheck Fringe
    #+begin_src emacs-lisp
      (use-package +pkg-fringe
        :after flycheck
        :demand t
        :preface (use-package flycheck :autoload flycheck-define-error-level)
        :config
        ;; Use ‚óè for all flycheck fringe indicators, instead of the defaults.
        (flycheck-define-error-level 'error
         :severity 2
         :overlay-category 'flycheck-error-overlay
         :fringe-bitmap '+dot-fringe-bitmap
         :fringe-face 'flycheck-fringe-error)

        (flycheck-define-error-level 'warning
         :severity 1
         :overlay-category 'flycheck-warning-overlay
         :fringe-bitmap '+dot-fringe-bitmap
         :fringe-face 'flycheck-fringe-warning)

        (flycheck-define-error-level 'info
         :severity 0
         :overlay-category 'flycheck-info-overlay
         :fringe-bitmap '+dot-fringe-bitmap
         :fringe-face 'flycheck-fringe-info))
    #+end_src

*** FlyCheck Tooltip                                               :disabled:
    Show a little documentation tool-tip when hovering over an error.

    #+BEGIN_SRC emacs-lisp :tangle no
      (use-package flycheck-pos-tip
        :straight t
        :hook (flycheck-mode . flycheck-pos-tip-mode)
        :commands flycheck-pos-tip-mode)
    #+END_SRC

*** Consult FlyCheck
    :PROPERTIES:
    :header-args+: :tangle (package-lisp! +pkg-flycheck :consult flycheck)
    :END:

    #+BEGIN_SRC emacs-lisp :tangle (package-yes! :consult flycheck)
      (use-package consult-flycheck
        :straight t
        :init
        (evil-set-command-property 'consult-flycheck :jump t)
        :leader
        (:minor t :mode 'flycheck-mode "je" 'consult-flycheck))
    #+END_SRC

*** FlyCheck Hydra
    #+begin_src emacs-lisp
      (require '+pkg-flymake)
      (require '+pkg-hydra)

      (use-package flycheck
        :commands flycheck-hydra/body
        :general
        (:keymaps 'flycheck-mode-map
         [remap flymake-hydra/body] 'flycheck-hydra/body)

        :autoload flycheck-error-list-set-filter
        :hydra
        (flycheck-hydra
         (:body-pre (flymake-hydra--setup-window-config+
                     (save-window-excursion
                       (flycheck-list-errors)
                       (get-buffer "*Flycheck errors*")))
          :post (flymake-hydra--restore-window-config+)
          :hint nil)
         ("f"  flycheck-error-list-set-filter "Filter")
         ("j"  flycheck-next-error "Next")
         ("k"  flycheck-previous-error "Previous")
         ("gg" flycheck-first-error "First")
         ("G"  flycheck-last-error "Last")
         ("n"  next-error "Next-Compile")
         ("p"  previous-error "Last-Compile")
         ("q"  nil :exit t)))
    #+end_src

*** Appendix
    #+begin_src emacs-lisp
    (provide '+pkg-flycheck)
    #+end_src

** Company                                                       :compclient:
   :PROPERTIES:
   :header-args+: :tangle (package-lisp! +pkg-company company)
   :END:

   The oldest and most well supported interactive completion plugin for Emacs.

   #+begin_src emacs-lisp :tangle (package-yes! company)
   (require '+pkg-company)
   #+end_src

*** Company
    #+BEGIN_SRC emacs-lisp
      (use-package company
        :straight t
        :hook (after-init . global-company-mode)

        :delight
        company-mode
        global-company-mode
        :custom
        (company-tooltip-idle-delay nil
         "Show the completion tooltip without any delay.")
        (company-idle-delay +auto-complete-delay)
        (company-selection-wrap-around t)
        (company-minimum-prefix-length 2)
        (company-statistics-file (state! "company/statistics.el"))
        (company-tooltip-align-annotations t)
        (company-require-match nil)
        (company-tooltip-limit 12)
        (company-tooltip-width-grow-only nil)
        (company-format-margin-function #'company-text-icons-margin)
        (company-text-icons-add-background t)
        (company-inhibit-inside-symbols nil)
        (company-text-icons-mapping
         (eval-when-compile
           (cl-loop
            for (kind . plist) in +completion-popup-kind-icons
            with text = nil do (setq text (plist-get plist :text))
            with face = nil do (setq face (plist-get plist :face))
            when text
              collect `(,kind
                        ,text
                        ,(or face 'shadow)))))

        :init
        ;; Don't let display steal focus
        (advice-add 'company-show-location   :around 'display-buffer-no-select-window-advice+)
        (advice-add 'company-show-doc-buffer :around 'display-buffer-no-select-window-advice+)

        :init
        (setq-default company-backends '(company-capf))

        :commands company-complete-next-char+
        :autoload (company-manual-begin
                   company--insert-candidate)
        :config
        (defun company-complete-next-char+ (&optional count)
          "Insert the next COUNT characters from the current candidate."
          (interactive "p")
          (or count (setq count 1))

          (when (company-manual-begin)
            (let* ((candidate (nth company-selection company-candidates))
                   (remaining-input
                    (substring candidate (length company-prefix))))
              (if (or (<= (length remaining-input) 1)
                      (>= count (length remaining-input)))
                  (company-complete-selection)
                (company--insert-candidate
                 (concat company-prefix
                         (substring remaining-input 0 count)))))))
        (put 'company-complete-next-char+ 'company-keep t)

        (defun company-complete-common-or-next-char+ (&optional count)
          "complete the common part of the current selection or insert
      upto COUNT characters from the current candidate."
          (interactive)
          (if (and (not (cdr company-candidates))
                   (equal company-common (car company-candidates)))
              (company-complete-selection)
            (if (string-prefix-p company-prefix company-common)
                (company-complete-next-char+ count)
              (company--insert-candidate company-common))))

        :commands company-mode
        :preface
        (defun company-mode-turn-off+ ()
          (company-mode -1))
        :hook (eshell-mode . company-mode-turn-off+)

        :general
        (:keymaps 'company-mode-map
         :states 'insert
         "M-SPC" 'company-complete)
        (:keymaps 'company-search-map
         "C-1"    'company-complete-tooltip-row
         "C-2"    'company-complete-tooltip-row
         "C-3"    'company-complete-tooltip-row
         "C-4"    'company-complete-tooltip-row
         "C-5"    'company-complete-tooltip-row
         "C-6"    'company-complete-tooltip-row
         "C-7"    'company-complete-tooltip-row
         "C-8"    'company-complete-tooltip-row
         "C-9"    'company-complete-tooltip-row
         "C-f"    'company-search-toggle-filtering                                    ; show filtered/all
         "C-s"    'company-search-repeat-forward
         "C-r"    'company-search-repeat-backward
         "C-n"    'company-search-repeat-forward
         "C-p"    'company-search-repeat-backward
         "<escape>"    'company-search-abort)
        (:keymaps 'company-active-map
         "<override-state>" 'all
         "C-w"    nil                                                                 ; was company-show-location
         "C-1"    'company-complete-tooltip-row
         "C-2"    'company-complete-tooltip-row
         "C-3"    'company-complete-tooltip-row
         "C-4"    'company-complete-tooltip-row
         "C-5"    'company-complete-tooltip-row
         "C-6"    'company-complete-tooltip-row
         "C-7"    'company-complete-tooltip-row
         "C-8"    'company-complete-tooltip-row
         "M-l"    'company-complete-common-or-next-char+
         "C-j"    'company-select-next
         "C-k"    'company-select-previous
         "C-d"    'company-next-page
         "C-u"    'company-previous-page
         "C-l"    'company-complete-selection
         "C-h"    'company-show-doc-buffer
         "C-p"    'company-show-location
         [tab]    'company-complete-common-or-cycle
         "TAB"    'company-complete-common-or-cycle
         "RET"    'company-complete-selection
         [C-i]    'company-complete-selection
         "C-:"    'completion-at-point
         "C-/"    'company-filter-candidates
         "C-s"    'company-filter-candidates
         "C-f"    'company-filter-candidates
         "C-o"    'company-select-last
         "M-o"    'company-select-first))
    #+END_SRC

*** Company Tooltip                                                :disabled:
    Shows a small floating window with the docstring/help-string of the company
    candidate at point.

    #+BEGIN_SRC emacs-lisp :tangle no
      (use-package company-quickhelp
        :straight t
        :hook (company-mode . company-quickhelp-mode)
        :custom
        (company-quickhelp-delay 0.5)

        :general
        (:keymaps 'company-active-map
         "C-M-h" 'company-quickhelp-manual-begin))

      (use-package company-quickhelp-terminal
        :straight t
        :hook (company-quickhelp-mode . company-quickhelp-terminal-mode))
    #+END_SRC

*** Company Prescient
    :PROPERTIES:
    :header-args+: :tangle (package-lisp! +pkg-company company prescient)
    :END:

    #+BEGIN_SRC emacs-lisp :tangle (package-yes! company prescient)
      (use-package company-prescient
        :straight t
        :after prescient
        :hook (company-mode . company-prescient-mode))
    #+END_SRC

*** Appendix
    #+begin_src emacs-lisp
    (provide '+pkg-company)
    #+end_src

** Corfu                                                         :compclient:
   :PROPERTIES:
   :header-args+: :tangle (package-lisp! +pkg-corfu corfu)
   :END:

   #+begin_src emacs-lisp :tangle (package-yes! corfu)
   (require '+pkg-corfu)
   #+end_src

*** Corfu
    #+begin_src emacs-lisp
      (use-package corfu
        :straight (corfu :files (:defaults
                                 "extensions/corfu-echo.el"
                                 "extensions/corfu-history.el"
                                 "extensions/corfu-info.el"
                                 "extensions/corfu-quick.el"))
        :hook (after-init . global-corfu-mode)
        :custom
        (corfu-cycle t "Cycle back to first completion from last.")
        (corfu-auto t "Show completion popup after delay.")
        (corfu-auto-delay +auto-complete-delay "Interval before popup is shown.")
        (corfu-preselect nil "Select first candidate but don't insert it.")
        (corfu-excluded-modes '(eshell-mode)
         "Prevent `corfu-mode' through `global-corfu-mode' for these modes.")

        :init
        ;; Corfu should take precedence over company if both are installed.
        (advice-add 'global-company-mode :override #'ignore)

        :init
        (advice-add 'corfu--setup :after 'evil-normalize-keymaps)
        (advice-add 'corfu--teardown :after 'evil-normalize-keymaps)

        :commands corfu-quit-and-escape-evil-state+
        :config
        (defun corfu-quit-and-escape-evil-state+ ()
          (interactive)
          (call-interactively 'corfu-quit)
          (when (functionp 'evil-normal-state)
            (evil-normal-state)))

        :commands corfu-move-to-minibuffer+
        :config
        (defun corfu-move-to-minibuffer+ ()
          (interactive)
          (unless completion-in-region--data
            (completion-at-point))
          (when completion-in-region--data
            (let ((completion-extra-properties corfu--extra)
                  completion-cycle-threshold completion-cycling)
              (apply completion-in-region-function completion-in-region--data))))
        (add-to-list 'corfu-continue-commands #'corfu-move-to-minibuffer+)

        :hook (corfu-mode . corfu-unset-completion-in-region-function+)
        :autoload corfu-unset-completion-in-region-function+
        :config
        (defun corfu-unset-completion-in-region-function+ ()
          (kill-local-variable 'completion-in-region-function))

        :general
        (:states '(insert emacs)
         "M-SPC" 'completion-at-point
         "C-:" 'corfu-move-to-minibuffer+)
        (:keymaps 'corfu-map
         :states '(insert emacs)
         "<escape>" 'corfu-quit-and-escape-evil-state+

         "C-n" 'ignore
         "C-p" 'ignore
         "C-j" 'next-line
         "C-k" 'previous-line
         "M-j" 'next-line
         "K-k" 'previous-line

         "C-d" 'scroll-up-command
         "C-u" 'scroll-down-command

         "C-:" 'corfu-move-to-minibuffer+

         [tab] 'corfu-insert
         "TAB" 'corfu-insert

         "RET" 'corfu-complete
         [C-i] 'corfu-complete

         "C-o" 'corfu-last
         "M-o" 'corfu-first))
    #+end_src

*** Corfu Info
    #+begin_src emacs-lisp
      (use-package corfu-info
        :straight corfu
        :init
        (advice-add 'corfu-info-location      :around 'display-buffer-no-select-window-advice+)
        (advice-add 'corfu-info-documentation :around 'display-buffer-no-select-window-advice+)

        :general
        (:keymaps 'corfu-map
         :states '(insert emacs)
         "C-h" 'corfu-info-documentation
         "C-l" 'corfu-info-location))
    #+end_src

*** Corfu Echo
    Show documentation for a completion candidate in the minibuffer.

    #+begin_src emacs-lisp
      (use-package corfu-echo
        :straight corfu
        :hook (global-corfu-mode . corfu-echo-mode))
    #+end_src

*** Corfu Quick
    #+begin_src emacs-lisp
      (use-package corfu-quick
        :straight corfu
        :general
        (:keymaps 'corfu-map
         :states '(insert emacs)
         "C-/" 'corfu-quick-complete
         "M-/" 'corfu-quick-insert))
    #+end_src

*** Corfu Doc
    #+begin_src emacs-lisp
      (use-package corfu-doc
        :straight t
        :when +completion-popup-show-documentation-popup
        :hook (global-corfu-mode . corfu-doc-mode)
        :general
        (:keymaps 'corfu-map
         :states '(insert emacs)
         "C-n" 'corfu-doc-scroll-up
         "C-p" 'corfu-doc-scroll-down))
    #+end_src

*** Corfu Terminal
    Support Corfu in the Emacs terminal.

    #+begin_src emacs-lisp
      (use-package popon
        :straight
        (popon
         :type git
         :repo "https://codeberg.org/akib/emacs-popon.git")
        :unless (display-graphic-p))

      (use-package corfu-terminal
        :straight t
        :unless (display-graphic-p)
        :hook (corfu-mode . corfu-terminal-mode))

      (use-package corfu-doc-terminal
        :straight t
        :unless (display-graphic-p)
        :hook (corfu-doc-mode . corfu-doc-terminal-mode))
    #+end_src

*** Corfu History
    :PROPERTIES:
    :header-args+: :tangle (package-lisp! +pkg-corfu corfu (not prescient))
    :END:

    #+begin_src emacs-lisp
      (use-package corfu-history
        :straight corfu
        :hook (global-corfu-mode . corfu-history-mode))
    #+end_src

*** Corfu Prescient
    :PROPERTIES:
    :header-args+: :tangle (package-lisp! +pkg-corfu corfu prescient)
    :END:

    #+begin_src emacs-lisp
      (use-package corfu-prescient
        :straight t
        :after prescient
        :hook (global-corfu-mode . corfu-prescient-mode)
        :custom
        (corfu-prescient-override-sorting t
         "Stop gap to prevent super-capes messing up sorting.")
        (corfu-prescient-enable-filtering nil
         "Suppress the prescient completion style."))
    #+end_src

*** Kind Icon
    #+begin_src emacs-lisp
      (use-package kind-icon
        :straight t
        :custom
        (kind-icon-default-face 'corfu-default)
        (kind-icon-blend-background t)
        (corfu-echo-delay 0.01 "Always show docstrings when available.")
        (kind-icon-mapping
         (eval-when-compile
           (cl-loop
            for (kind . plist) in +completion-popup-kind-icons
            with text = nil do (setq text (plist-get plist :text))
            with icon = nil do (setq icon (plist-get plist :icon))
            with face = nil do (setq face (plist-get plist :face))
            collect `(,kind
                      ,@(when text (list text))
                      ,@(when icon (list :icon icon))
                      ,@(when face (list :face face))))))
        :config
        (setq
         kind-icon--unknown
         (propertize " ? " 'face `(:inherit (error ,kind-icon-default-face bold))))

        :after corfu
        :commands kind-icon-margin-formatter
        :init
        (add-to-list 'corfu-margin-formatters #'kind-icon-margin-formatter)

        :preface (require 'color)
        :init
        (advice-add 'kind-icon--rgb-blend :override
                    (defun kind-icon--company-blend+ (rgb1 rgb2 frac)
                      "Apply the blend function used by company with kind-icons as well."
                      ;; TODO: Use 2 instead of 10 for the active corfu item. Will require
                      ;; changes in upstream corfu to and kind-icons :/.
                      (apply #'color-rgb-to-hex (nth 0 (color-gradient rgb2 rgb1 10))))))
    #+end_src

*** Appendix
    #+begin_src emacs-lisp
    (provide '+pkg-corfu)
    #+end_src

** Ibuffer
   :PROPERTIES:
   :header-args+: :tangle (package-lisp! +pkg-ibuffer ibuffer)
   :END:

   #+begin_src emacs-lisp :tangle (package-yes! ibuffer)
     (require '+pkg-ibuffer)
   #+end_src

*** Ibuffer                                                         :builtin:
    #+begin_src emacs-lisp
      (use-package +pkg-evil
        :autoload evil-set-initial-state
        :config (evil-set-initial-state 'ibuffer-mode 'motion))
    #+end_src

    #+BEGIN_SRC emacs-lisp
      (use-package ibuffer
        :hook (ibuffer-mode . hl-line-mode)
        :leader ("bm" 'ibuffer)
        :custom
        (ibuffer-filter-group-name-face '(:inherit (font-lock-string-face bold)))
        (ibuffer-title-face '(:inherit (font-lock-type-face)))
        (ibuffer-never-show-predicates (list (rx bol " " (* any))))
        (ibuffer-formats
         `((mark modified read-only locked
            " "
            ,@(when +icons-available
                (list '(icon 2 2 :left :elide)
                      (propertize " " 'display `(space :align-to 8))))
            (name 20 20 :left :elide)
            " "
            (size-h 11 -1 :right)
            " "
            (mode+ 16 16 :left :elide)
            " " filename-and-process+)
           (mark " "
            ,@(when +icons-available
                (list '(icon 2 2 :left :elide)
                      " "))
            (name 30 30 :left :elide)
            " "
            filename)))

        :autoload ibuffer-current-buffer
        :config
        (advice-add 'ibuffer-visit-buffer-other-window :override
                    (defun ibuffer-visit-buffer-other-window+ (&optional noselect)
                      "Fixes `ibuffer-visit-buffer-other-window' doesn't always open in new window.
      NOSELECT has the same semantics as the overriden command."
                      (let ((buf (ibuffer-current-buffer t)))
                        (bury-buffer (current-buffer))
                        (if noselect
                            (let ((curwin (selected-window)))
                              (switch-to-buffer-other-window buf)
                              (select-window curwin))
                          (switch-to-buffer-other-window buf)))))

      ;;; Adapted from [[https://emacs.stackexchange.com/a/2179][here]], this makes ibuffer support `auto-revert-mode'.
        :hook (ibuffer-mode . ibuffer-auto-revert-setup+)
        :autoload (ibuffer-stale-p+
                   ibuffer-auto-revert-setup+)
        :config
        (defun ibuffer-stale-p+ (&optional _noconfirm)
          ;; Let's reuse the variable that's used for 'ibuffer-auto-mode
          (frame-or-buffer-changed-p 'ibuffer-auto-buffers-changed))

        (defun ibuffer-auto-revert-setup+ ()
          (setq-local buffer-stale-function #'ibuffer-stale-p+
                      auto-revert-verbose nil))

        :lazy-leader
        (:mode 'ibuffer-mode
         ;; unbound:
         ;;  * ibuffer-do-print
         "RET" 'ibuffer-do-view-horizontally
         "1"   'ibuffer-visit-buffer-1-window
         "+"   'ibuffer-add-to-tmp-show
         "-"   'ibuffer-add-to-tmp-hide

         "a"   'ibuffer-auto-mode
         "E"   'ibuffer-do-view-and-eval
         "e"   'ibuffer-do-eval
         ;; "R"   'ibuffer-redisplay
         "r"   'ibuffer-do-rename-uniquely
         "s"   'ibuffer-do-query-replace
         "w"   'ibuffer-do-save
         ;; "s"   'ibuffer-do-replace-regexp
         "t"   'ibuffer-visit-tags-table
         "f"   'ibuffer-find-file
         "X"   'ibuffer-kill-filter-group
         "P"   'ibuffer-yank-filter-group
         "x"   'ibuffer-kill-line
         "p"   'ibuffer-yank
         "|"   'ibuffer-do-shell-command-pipe-replace
         "~"   'ibuffer-do-toggle-modified

         "o"   'ibuffer-do-view
         "O"   'ibuffer-do-view-other-frame

         "g"   'ibuffer-jump-to-buffer
         "b"   'ibuffer-jump-to-filter-group

         "m" '(:ignore t :wk "mark")
         "m*" 'ibuffer-mark-modified-buffers
         "m%" 'ibuffer-mark-read-only-buffers
         "mm" 'ibuffer-toggle-marks
         "mf" 'ibuffer-mark-by-name-regexp
         "mf" 'ibuffer-mark-by-file-name-regexp
         "mo" 'ibuffer-mark-old-buffers
         "ml" 'ibuffer-mark-by-locked
         "mb" 'ibuffer-mark-by-content-regexp
         "mM" 'ibuffer-mark-by-mode-regexp
         "md" 'ibuffer-mark-dired-buffers
         "mh" 'ibuffer-mark-help-buffers
         "mn" 'ibuffer-mark-dissociated-buffers
         "mN" 'ibuffer-mark-unsaved-buffers
         "ms" 'ibuffer-mark-special-buffers
         "mz" 'ibuffer-mark-compressed-file-buffers)

        :general
        (:keymaps 'ibuffer-mode-map
         "+" nil "-" nil "0" nil "f" nil "SPC" nil "S-SPC" nil ">" nil "<" nil "?" nil "h" nil "X" nil "F"
         nil "C-d" nil "C-t" nil "b" nil "n" nil "g" nil "p" nil "w" nil "s" nil "`" nil "," nil "*" nil
         "/" nil "A" nil "C-c" nil "C-x" nil "M-s" nil "M-g" nil "M-n" nil "M-p" nil "M-{" nil "M-}" nil
         "M-o" nil "M-DEL" nil "%" nil)
        (:keymaps 'ibuffer-mode-map
         :states  'motion
         ;; ibuffer-kill-line
         ;; ibuffer-do-kill-lines
         ;; ibuffer-do-revert
         ;; ibuffer-do-isearch
         ;; ibuffer-do-isearch-regexp

         ;; "D" 'ibuffer-mark-for-delete-backwards
         "D" 'ibuffer-do-delete
         "M" 'ibuffer-do-toggle-modified
         "=" 'ibuffer-diff-with-file
         "O" 'ibuffer-do-occur
         "R" 'ibuffer-do-toggle-read-only

         "RET"   'ibuffer-visit-buffer
         "o"     'ibuffer-visit-buffer-other-window
         "i"     'ibuffer-visit-buffer-other-window-noselect
         "M-RET" 'ibuffer-visit-buffer-other-window-noselect
         "S-DEL" 'ibuffer-bury-buffer

         [remap ibuffer-auto-mode] 'auto-revert-mode
         [remap revert-buffer] 'ibuffer-update
         "gu"                  'ibuffer-do-revert
         "gw"                  'ibuffer-do-save

         "|" 'ibuffer-do-shell-command-pipe-replace

      ;;; marking
         "m" 'ibuffer-mark-forward
         "r" 'ibuffer-change-marks

      ;;; sorting
         "S"  'ibuffer-toggle-sorting-mode
         "sa" 'ibuffer-do-sort-by-alphabetic
         "sf" 'ibuffer-do-sort-by-filename/process
         "si" 'ibuffer-invert-sorting
         "s SPC" 'ibuffer-invert-sorting
         "sm" 'ibuffer-do-sort-by-major-mode
         "ss" 'ibuffer-do-sort-by-size
         "sr" 'ibuffer-do-sort-by-recency
         "("   'ibuffer-switch-format

      ;;; movement
         "TAB"       'ibuffer-forward-filter-group
         "gj"        'ibuffer-forward-filter-group
         "gk"        'ibuffer-backward-filter-group
         "<S-tab>"   'ibuffer-backward-filter-group
         "<backtab>" 'ibuffer-backward-filter-group

         ;; [remap evil-write] 'ibuffer-do-save
         ;; [remap evil-write-all] 'ibuffer-do-save
         [remap evil-next-line] 'ibuffer-forward-line
         [remap evil-previous-line] 'ibuffer-backward-line
         [remap imenu] 'ibuffer-jump-to-buffer

         "C-j"  'ibuffer-forward-next-marked
         "C-k"  'ibuffer-backwards-next-marked

         "p"   'ibuffer-yank
         "C-y" 'ibuffer-yank
         "y"   'ibuffer-copy-buffername-as-kill))
    #+END_SRC

*** Ibuffer All The Icons
    Provides ~icon~, ~size-h~, ~mode+~ and ~filename-and-process+~ columns.

    #+BEGIN_SRC emacs-lisp
      (use-package all-the-icons-ibuffer
        :straight t
        :hook (ibuffer-mode . all-the-icons-ibuffer-mode)
        :custom
        (all-the-icons-ibuffer-display-predicate
         (apply-partially #'identity t))
        :config
        ;; Add padding to make sure icons aren't truncated on the terminal.
        (when-let* ((cell (assoc 'ibuffer-make-column-icon ibuffer-inline-columns)))
          (setcdr cell
                  (list `(all-the-icons-pad-on-tty-advice+ ,@(cdr cell))))))
    #+END_SRC

*** Ibuffer Filters                                                 :builtin:
    #+BEGIN_SRC emacs-lisp
      (use-package ibuf-ext
        :commands (ibuffer-filter-by-directory-path
                   ibuffer-filter-by-client-buffers)
        :autoload (ibuffer-pop-filter
                   ibuffer-push-filter)
        :config
        (define-ibuffer-filter directory-path
            "Toggle current view to buffers with file or directory name matching QUALIFIER."
          (:description "filename"
           :reader (file-truename
                    (read-directory-name "List files from file/directory name: ")))
          (when-let* ((it (or (buffer-local-value 'buffer-file-name buf)
                              (buffer-local-value 'dired-directory buf))))
            ;; (message "qual: %s, it: %s" qualifier (file-truename it))
            (string-prefix-p qualifier (file-truename it))))

        (define-ibuffer-filter client-buffers
            "Only show buffers for which there're open emacsclient clients."
          (:description "emacsclient-buffers")
          (buffer-local-value 'server-buffer-clients buf))

        :leader
        (:mode 'ibuffer-mode
         :prefix ","
         ""       '(:ignore t :wk "filter")
         "g"      'ibuffer-jump-to-filter-group
         "TAB"    'ibuffer-exchange-filters
         "DEL"    'ibuffer-delete-saved-filters
         "M-DEL"  'ibuffer-delete-saved-filter-groups

         "!"      'ibuffer-negate-filter
         "&"      'ibuffer-and-filter
         "a"      'ibuffer-and-filter
         "|"      'ibuffer-or-filter
         "o"      'ibuffer-or-filter
         "-"      'ibuffer-exchange-filters
         "a"      'ibuffer-add-saved-filters
         "p"      'ibuffer-pop-filter
         "P"      'ibuffer-pop-filter-group
         "u"      'ibuffer-decompose-filter
         "U"      'ibuffer-decompose-filter-group
         "r"      'ibuffer-switch-to-saved-filters
         "R"      'ibuffer-switch-to-saved-filter-groups
         "w"      'ibuffer-save-filters
         "W"      'ibuffer-save-filter-groups
         "x"      'ibuffer-filter-disable
         "X"      'ibuffer-clear-filter-groups

         "@"      'ibuffer-filter-by-client-buffers
         "*"      'ibuffer-filter-by-starred-name
         ","      'ibuffer-filter-by-used-mode
         "."      'ibuffer-filter-by-file-extension
         ">"      'ibuffer-filter-by-size-gt
         "<"      'ibuffer-filter-by-size-lt
         "%"      'ibuffer-filter-by-basename
         "k"      'ibuffer-filter-by-predicate
         "D"      'ibuffer-filter-by-directory-path
         "d"      'ibuffer-filter-by-directory ; regexp
         "f"      'ibuffer-filter-by-filename  ; regexp
         "e"      'ibuffer-filter-by-modified
         "m"      'ibuffer-filter-by-derived-mode
         "n"      'ibuffer-filter-by-name
         "s"      'ibuffer-filter-by-content
         "v"      'ibuffer-filter-by-visiting-file

         "b"      'ibuffer-filters-to-filter-group
         "("      'ibuffer-filters-to-filter-group))
    #+END_SRC

*** Ibuffer Tramp
    :PROPERTIES:
    :header-args+: :tangle (package-lisp! +pkg-ibuffer ibuffer ibuffer-tramp)
    :END:

    #+BEGIN_SRC emacs-lisp
      (use-package ibuffer-tramp
        :straight t
        :after ibuffer
        :commands ibuffer-tramp-set-filter-groups-by-tramp-connection
        :config
        (defalias 'ibuffer-tramp #'ibuffer-tramp-set-filter-groups-by-tramp-connection)

        :general
        (:keymaps 'ibuffer-mode-map "s@" 'ibuffer-tramp))
    #+END_SRC

*** Ibuffer Hydra
    Sourced from [[https://github.com/abo-abo/hydra/wiki/Ibuffer][wiki/Ibuffer]].

    #+begin_src emacs-lisp
      (require '+pkg-hydra)

      (use-package ibuffer
        :straight t
        :lazy-leader
        (:mode 'ibuffer-mode
         "."   'ibuffer-hydra/body)

        :autoload (ibuffer-filter-disable
                   ibuffer-filter-by-size-lt
                   ibuffer-filter-by-size-gt
                   ibuffer-filter-by-filename
                   ibuffer-filter-by-predicate
                   ibuffer-filter-by-content
                   ibuffer-filter-by-name
                   ibuffer-filter-by-derived-mode
                   ibuffer-filter-by-used-mode
                   ibuffer-do-shell-command-pipe
                   ibuffer-do-view-and-eval
                   ibuffer-do-replace-regexp
                   ibuffer-do-rename-uniquely
                   ibuffer-do-query-replace
                   ibuffer-do-print
                   ibuffer-do-view-other-frame
                   ibuffer-do-query-replace-regexp
                   ibuffer-do-shell-command-file
                   ibuffer-do-eval
                   ibuffer-do-view
                   ibuffer-mark-compressed-file-buffers
                   ibuffer-mark-help-buffers
                   ibuffer-mark-dissociated-buffers
                   ibuffer-mark-dired-buffers
                   ibuffer-mark-read-only-buffers
                   ibuffer-mark-special-buffers
                   ibuffer-mark-unsaved-buffers
                   ibuffer-mark-modified-buffers
                   ibuffer-mark-by-mode
                   ibuffer-unmark-all
                   ibuffer-hydra/body
                   ibuffer-toggle-filter-group
                   ibuffer-filter-hydra/body
                   ibuffer-sort-hydra/body
                   ibuffer-action-hydra/body
                   ibuffer-toggle-marks
                   ibuffer-mark-hydra/body
                   ibuffer-unmark-forward)

        :hydra
        (ibuffer-hydra
         (:color pink :hint nil)
         "
       ^ ^ ^   ^ ^ ^ | Marks [_*_] | Actions [_a_]     | View       ^^| Select      ^^|
       _k_ ^ ‚Üë ^ _h_ +-^-^---------+-^-^---------------+-^-^----------+-^-^-----------+
       ^ ^ _RET_ ^ ^ | _m_ark      | _D_: delete       | _g_: refresh | _TAB_: toggle |
       _j_ ^ ‚Üì ^ _l_ | _u_nmark    | _s_: save marked  | _S_: sort    | _o_: open     |
       ^ ^ ^   ^ ^ ^ | _t_oggle    | _._: toggle hydra | _/_: filter  | _q_: quit     |
      "
         ("m" ibuffer-mark-forward)
         ("u" ibuffer-unmark-forward)
         ("*" ibuffer-mark-hydra/body :exit t)
         ("M" ibuffer-mark-hydra/body :exit t)
         ("t" ibuffer-toggle-marks)

         ("D" ibuffer-do-delete)
         ("s" ibuffer-do-save)
         ("a" ibuffer-action-hydra/body :exit t)

         ("g" ibuffer-update)
         ("S" ibuffer-sort-hydra/body :exit t)
         ("/" ibuffer-filter-hydra/body :exit t)
         ("H" describe-mode :exit t)

         ("h" ibuffer-backward-filter-group)
         ("k" ibuffer-backward-line)
         ("l" ibuffer-forward-filter-group)
         ("j" ibuffer-forward-line)
         ("RET" ibuffer-visit-buffer :exit t)

         ("TAB" ibuffer-toggle-filter-group)

         ("o" ibuffer-visit-buffer-other-window :exit t)
         ("Q" quit-window :exit t)
         ("q" nil :exit t)
         ("." nil :exit t))

        (ibuffer-mark-hydra
         (:color teal :columns 5 :after-exit (ibuffer-hydra/body))
         "Mark"
         ("*" ibuffer-unmark-all "unmark all")
         ("M" ibuffer-mark-by-mode "mode")
         ("m" ibuffer-mark-modified-buffers "modified")
         ("u" ibuffer-mark-unsaved-buffers "unsaved")
         ("s" ibuffer-mark-special-buffers "special")
         ("r" ibuffer-mark-read-only-buffers "read-only")
         ("/" ibuffer-mark-dired-buffers "dired")
         ("e" ibuffer-mark-dissociated-buffers "dissociated")
         ("h" ibuffer-mark-help-buffers "help")
         ("z" ibuffer-mark-compressed-file-buffers "compressed")
         ("b" ibuffer-hydra/body "back" :exit t))

        (ibuffer-action-hydra
         (:color teal :columns 4
          :after-exit
          (if (eq major-mode 'ibuffer-mode)
              (ibuffer-hydra/body)))
         "Action"
         ("A" ibuffer-do-view "view")
         ("E" ibuffer-do-eval "eval")
         ("F" ibuffer-do-shell-command-file "shell-command-file")
         ("I" ibuffer-do-query-replace-regexp "query-replace-regexp")
         ("H" ibuffer-do-view-other-frame "view-other-frame")
         ("N" ibuffer-do-shell-command-pipe-replace "shell-cmd-pipe-replace")
         ("M" ibuffer-do-toggle-modified "toggle-modified")
         ("O" ibuffer-do-occur "occur")
         ("P" ibuffer-do-print "print")
         ("Q" ibuffer-do-query-replace "query-replace")
         ("R" ibuffer-do-rename-uniquely "rename-uniquely")
         ("T" ibuffer-do-toggle-read-only "toggle-read-only")
         ("U" ibuffer-do-replace-regexp "replace-regexp")
         ("V" ibuffer-do-revert "revert")
         ("W" ibuffer-do-view-and-eval "view-and-eval")
         ("X" ibuffer-do-shell-command-pipe "shell-command-pipe")
         ("b" nil "back"))

        (ibuffer-sort-hydra
         (:color amaranth :columns 3)
         "Sort"
         ("i" ibuffer-invert-sorting "invert")
         ("a" ibuffer-do-sort-by-alphabetic "alphabetic")
         ("v" ibuffer-do-sort-by-recency "recently used")
         ("s" ibuffer-do-sort-by-size "size")
         ("f" ibuffer-do-sort-by-filename/process "filename")
         ("m" ibuffer-do-sort-by-major-mode "mode")
         ("b" ibuffer-hydra/body "back" :exit t))

        (ibuffer-filter-hydra
         (:color amaranth :columns 4)
         "Filter"
         ("m" ibuffer-filter-by-used-mode "mode")
         ("M" ibuffer-filter-by-derived-mode "derived mode")
         ("n" ibuffer-filter-by-name "name")
         ("c" ibuffer-filter-by-content "content")
         ("e" ibuffer-filter-by-predicate "predicate")
         ("f" ibuffer-filter-by-filename "filename")
         (">" ibuffer-filter-by-size-gt "size")
         ("<" ibuffer-filter-by-size-lt "size")
         ("/" ibuffer-filter-disable "disable")
         ("b" ibuffer-hydra/body "back" :exit t)))
    #+end_src

*** Appendix
    #+begin_src emacs-lisp
    (provide '+pkg-ibuffer)
    #+end_src

** SMerge                                                           :builtin:
   :PROPERTIES:
   :header-args+: :tangle (lisp! "+pkg-smerge.el")
   :END:

   Minor mode in buffers that have git merge issues; it highlights diff indicators
   and offers methods to quickly jump from them.

   #+begin_src emacs-lisp :tangle yes
   (require '+pkg-smerge)
   #+end_src

*** SMerge Mode
    #+BEGIN_SRC emacs-lisp
      (use-package smerge-mode
        :leader
        ("gi" 'smerge-mode)

        :lazy-leader
        (:mode 'smerge-mode
         :minor t
         :prefix "g"
         "s" 'smerge-swap
         "a" 'smerge-keep-all
         "x" 'smerge-keep-base
         "c" 'smerge-keep-current
         "RET" 'smerge-keep-current
         "m" 'smerge-keep-mine
         "o" 'smerge-keep-other
         "j" 'smerge-next
         "k" 'smerge-prev)

        :general
        (:keymaps 'smerge-mode-map
         ;; Technically merge error are errors so this tracks.
         [remap next-error] 'smerge-next
         [remap previous-error] 'smerge-prev)
        (:keymaps 'smerge-mode-map
         :states '(normal motion)
         "]g" 'smerge-next
         "[g" 'smerge-prev))
    #+END_SRC

*** SMerge Hydra
    #+begin_src emacs-lisp
      (require '+pkg-hydra)

      (use-package smerge-mode
        :lazy-leader
        (:mode 'smerge-mode
         :minor t
         :prefix "g"
         "." 'smerge-hydra/body)

        :autoload (smerge-kill-current
                   smerge-resolve
                   smerge-combine-with-next
                   smerge-refine
                   smerge-diff-base-lower
                   smerge-diff-upper-lower
                   smerge-diff-base-upper
                   smerge-keep-current
                   smerge-keep-all
                   smerge-keep-lower
                   smerge-keep-upper
                   smerge-keep-base)

        :pretty-hydra
        ;; Adapted from [[https://github.com/tecosaur/emacs-config/blob/0b39759/config.org#smerge][tecosaur/emacs-config]].
        (smerge-hydra
         (:foreign-keys run :quit-key "q")
         ("Move"
          (("n" (smerge-next) "next")
           ("p" (smerge-prev) "previous"))
          "Keep"
          (("b" (smerge-keep-base) "base")
           ("u" (smerge-keep-upper) "upper")
           ("l" (smerge-keep-lower) "lower")
           ("a" (smerge-keep-all) "all")
           ("RET" (smerge-keep-current) "current"))
          "Diff"
          (("<" (smerge-diff-base-upper) "upper/base")
           ("=" (smerge-diff-upper-lower) "upper/lower")
           (">" (smerge-diff-base-lower) "base/lower")
           ("R" (smerge-refine) "refine")
           ("E" (smerge-ediff) "ediff"))
          "Other"
          (("c" (smerge-combine-with-next) "combine")
           ("r" (smerge-resolve) "resolve")
           ("x" (smerge-kill-current) "kill current")
           ;; ("q" (smerge-auto-leave) "quit")
           ("q" nil "quit")))))
    #+end_src

*** Appendix
    #+begin_src emacs-lisp
    (provide '+pkg-smerge)
    #+end_src

** Edit Indirect                                                   :optional:
   :PROPERTIES:
   :header-args+: :tangle (package-lisp! +pkg-edit-indirect edit-indirect)
   :END:

   Open regions of code in their own dedicated buffers, like org modes ~org-edit-special~.

   #+begin_src emacs-lisp :tangle (package-yes! edit-indirect)
   (require '+pkg-edit-indirect)
   #+end_src

*** Edit Indirect
    #+BEGIN_SRC emacs-lisp
      (use-package edit-indirect
        :straight t
        :leader ("bE" 'edit-indirect-region)
        :init
        (push `(,(rx bol "*edit-indirect ")
                 (display-buffer-reuse-window
                  display-buffer-same-window))
              display-buffer-alist)

        (advice-add 'edit-indirect-save :after
                    (defun edit-indirect-commit-save-buffer+ ()
                      (when +indirect-edit-save-buffers
                        (with-current-buffer (overlay-buffer edit-indirect--overlay)
                          (save-buffer)))))

        :general
        (:keymaps 'edit-indirect-mode-map
         [remap evil-write] 'edit-indirect-save
         [remap evil-save-and-close] 'edit-indirect-commit
         [remap evil-quit-all-with-error-code] 'edit-indirect-abort)

        :lazy-leader
        (:mode 'edit-indirect--overlay
         :minor t
         :prefix leader-major-mode-prefix
         "," 'edit-indirect-commit
         "s" 'edit-indirect-save
         "q" 'edit-indirect-abort))
    #+END_SRC

*** Separedit
    #+begin_src emacs-lisp
      (require '+pkg-evil)

      (use-package separedit
        :straight t
        :leader ("be" 'separedit)
        :custom
        (separedit-default-mode 'text-mode)
        (separedit-code-block-default-mode 'text-mode)
        (separedit-inhibit-edit-window-p nil)
        (separedit-write-file-when-execute-save +indirect-edit-save-buffers)

        :config
        (push 'tree-sitter-hl-face:comment separedit-comment-faces)

        :init
        (evil-set-initial-state 'separedit-double-quote-string-mode 'normal)
        (evil-set-initial-state 'separedit-single-quote-string-mode 'normal)

        :hook (separedit-buffer-creation . separedit-clear-header-line-format+)
        :preface
        (defun separedit-clear-header-line-format+ ()
          (setq header-line-format nil))

        :general
        ;; I can't seem to bind for separedit-mode exclusively so I
        ;; remap edit-indirect commands globally, should still work
        ;; even when called through `edit-indirect-region'.
        (;; :keymaps 'separedit-mode-map
         [remap edit-indirect-commit] 'separedit-commit
         [remap edit-indirect-save] 'separedit-save))
    #+end_src

*** Appendix
    #+begin_src emacs-lisp
      (provide '+pkg-edit-indirect)
    #+end_src

** Compile Multi
   :PROPERTIES:
   :header-args+: :tangle (lisp! "+pkg-compile-multi.el")
   :END:

   #+begin_src emacs-lisp :tangle yes
   (require '+pkg-compile-multi)
   #+end_src

*** Compile Multi
    #+begin_src emacs-lisp
      (use-package compile-multi
        :straight t
        :leader ("cm" 'compile-multi)
        :custom
        (compile-multi-default-directory #'project-current-root+)

        :commands (byte-compile-this-file+)
        :config
        (defun byte-compile-this-file+ ()
          (byte-compile-file (buffer-file-name)))

        :config
        (push `(emacs-lisp-mode
                ("emacs:bytecompile" . ,#'byte-compile-this-file+)
                ("emacs:checkdoc" . ,#'checkdoc))
              compile-multi-config)

        (push `((and buffer-file-name
                     (derived-mode-p 'markdown-mode)
                     (executable-find "grip" 'remote))
                ("markdown:grip" "grip" (string-remove-prefix
                                         (or (file-remote-p (buffer-file-name)) "")
                                         (buffer-file-name))))
              compile-multi-config))
    #+end_src

*** Consult Compile Multi
    #+begin_src emacs-lisp :tangle (package-lisp! +pkg-compile-multi :consult)
      (use-package consult-compile-multi
        :straight t
        :after compile-multi
        :demand t
        :commands consult-compile-multi-mode
        :config (consult-compile-multi-mode))
    #+end_src

*** Compile Multi All-the-Icons
    #+begin_src emacs-lisp
      (require '+pkg-all-the-icons)

      (use-package compile-multi-all-the-icons
        :straight t
        :after all-the-icons-completion
        :after compile-multi
        :demand t
        :config
        (when +icons-prefer-nerd-font
          (with-eval-after-load 'all-the-icons-nerd-fonts
            (all-the-icons-nerd-fonts-prefer '(compile-multi-all-the-icons-alist)))))
    #+end_src

*** Compile Multi Embark
    #+begin_src emacs-lisp :tangle (package-lisp! +pkg-compile-multi :consult)
      (use-package compile-multi-embark
        :straight t
        :after embark
        :after compile-multi
        :demand t
        :commands compile-multi-embark-mode
        :config (compile-multi-embark-mode))
    #+end_src

*** Appendix
    #+begin_src emacs-lisp
    (provide '+pkg-compile-multi)
    #+end_src

** Project
   :PROPERTIES:
   :header-args+: :tangle (lisp! "+pkg-project.el")
   :END:

   The [[info:emacs#Projects][built in]] Emacs project management library.

   #+begin_src emacs-lisp :tangle yes
   (require '+pkg-project)
   #+end_src

*** Project                                                         :builtin:
    #+BEGIN_SRC emacs-lisp
      (use-package project
        :custom
        (project-list-file (state! "projects.el"))
        (project-switch-commands #'project-find-file)
        (project-vc-merge-submodules nil)

        :autoload project-current-root+
        :init
        (defun project-current-root+ (&optional dir)
          (when-let* ((project
                       (project-current nil (or dir default-directory))))
            (project-root project)))

        :autoload project-has-file-p+
        :init
        (defun project-has-file-p+ (&rest files)
          (when-let* ((default-directory (project-current-root+)))
            (cl-find-if #'file-exists-p files)))

        :commands project-show-and-copy-project-dir+
        :leader ("py" 'project-show-and-copy-project-dir+)
        :config
        (defun project-show-and-copy-project-dir+ (&optional arg)
          (interactive "P")
          (if-let* ((path (project-current-root+)))
              (progn
                (when arg
                  (if (and (consp arg)
                           (eq (car arg) 4))
                      (insert path)
                    (save-excursion
                      (insert path))))
                (message (abbreviate-file-name path))
                (kill-new path))
            (message "You're not currently in a project.")))

        :commands project-run-compile-command+
        :leader ("p@" 'project-run-compile-command+)
        :config
        (defun project-run-compile-command+ ()
          (interactive)
          (let* ((default-directory (project-current-root+))
                 (compilation-read-command t)
                 (compile-command nil))
            (call-interactively #'compile)))

        :leader
        ("fp" 'project-switch-project)

        (:prefix "p"
         "" '(:ignore t :wk "project")
         ;; Unbound commands
         ;; * project-vc-dir
         ;; * project-eshell
         ;; * project-shell
         ;; * project-or-external-find-file
         ;; * project-or-external-find-regexp

         "!" 'project-shell-command
         "&" 'project-async-shell-command
         "b" 'project-switch-to-buffer
         "h" 'project-dired                                                           ; Dired in project home directory
         "f" 'project-find-file
         "c" 'project-compile
         "x" 'project-kill-buffers
         "SPC" 'project-execute-extended-command                                      ; Run M-x in the root of the current project

         "s" '(:ignore t :wk "search")
         ;; "sg" 'project-find-regexp
         "sq" 'project-query-replace-regexp))
    #+END_SRC

*** Projection
    #+begin_src emacs-lisp
      (use-package projection
        :straight t
        :hook (after-init . global-projection-hook-mode)
        :custom
        (projection-cmake-target-backend 'code-model)
        (projection-cmake-configure-options
         `("--fresh"
           "-DCMAKE_C_FLAGS=-g2"
           "-DCMAKE_CXX_FLAGS=-g2"
           "-DCMAKE_EXPORT_COMPILE_COMMANDS=ON"
           "-DCMAKE_COLOR_DIAGNOSTICS=ON"))

        :init
        (defvaralias 'projection-cmake-build-directory '+cmake-build-directory)
        (with-eval-after-load 'project
          (require 'projection))

        :general
        ([remap project-compile] 'projection-build-project)

        :leader
        ;; Bindings copied from `projection-map'.
        (:prefix "p"
         ;; `projection-core'
         "1" 'projection-set-primary-project-type
         "2" 'projection-update-extra-project-types
         "I" 'projection-show-project-info
         "DEL" 'projection-cache-clear
         ;; `projection-artifacts'
         "l" 'projection-artifacts-list
         ;; `projection-find'
         "TAB" 'projection-find-other-file
         "o"   'projection-find-other-file
         ;; `projection-hook'
         "h" 'projection-hook
         "H" 'projection-hook-clear
         ;; `projection-ibuffer'
         "m" 'ibuffer-projection-current-project
         "M" 'ibuffer-projection-toggle-filter-groups
         ;; `projection-commands'.
         "c" 'projection-commands-build-project
         "g" 'projection-commands-configure-project
         "t" 'projection-commands-test-project
         "p" 'projection-commands-run-project
         "k" 'projection-commands-package-project
         "i" 'projection-commands-install-project
         ;; `projection-recentf'
         "r" 'projection-recentf

         ;; Misc extra commands
         "a"   '(nil :wk "Extensions")
         "ac"  '(nil :wk "CMake")
         "acp" 'projection-cmake-set-preset
         "acm" 'projection-cmake-set-build-type
         "acd" 'projection-cmake-clear-build-directory
         "acv" 'projection-cmake-set-configure-log-level
         "acb" 'projection-cmake-set-build-verbosely
         "ag"  '(nil :wk "Golang")
         "agp" 'projection-golang-set-package
         "am"  '(nil :wk "Meson")
         "amb" 'projection-meson-set-build-type
         "amc" 'projection-meson-set-build-option
         ))
    #+end_src

*** Projection Consult
   :PROPERTIES:
   :header-args+: :tangle (package-lisp! +pkg-project :consult)
   :END:
    #+begin_src emacs-lisp
      (require '+pkg-consult)

      (use-package projection-find
        :autoload projection-find-list-test-files)

      (use-package consult
        :preface
        (defvar consult--source-projection-test-files+
          `(:name     "Test files"
            :narrow   (?t . "Tests")
            :hidden   t
            :category project-file
            :face     consult-file
            :history  file-name-history
            :state    ,#'consult--file-state
            :action   ,#'consult--file-action
            :enabled  ,#'project-current
            :items
            ,(lambda ()
               (when-let* ((project (project-current)))
                 (consult--hide-prefix+
                  (projection-find-list-test-files project)
                  (project-root project))))))

        :config
        (add-to-list 'consult-project-buffer-sources 'consult--source-projection-test-files+ 'append))
    #+end_src

*** Projection Multi
    :PROPERTIES:
    :header-args+: :tangle (package-lisp! +pkg-project :consult)
    :END:

    #+begin_src emacs-lisp
      (use-package projection-multi
        :straight t
        :general
        ([remap compile-multi] 'projection-multi-compile)

        :leader
        (:prefix "p"
         "RET" 'projection-multi-compile))
    #+end_src

**** Projection Multi Embark
     #+begin_src emacs-lisp
       (use-package projection-multi-embark
         :straight t
         :after embark
         :after projection-multi
         :demand t
         :autoload projection-multi-embark-setup-command-map
         :config (projection-multi-embark-setup-command-map))
     #+end_src

*** Project Org Capture
    #+begin_src emacs-lisp
      (use-package org-capture
        :straight org
        :commands (project-org-capture+
                   project-org-project-file+)
        :autoload org-contextualize-keys
        :preface
        (defvar project-org-capture-templates+ nil)
        (defvar project-org-capture-templates-contexts+ nil)
        (defvar project-org-projects-directory+ (join-path+ +notes-home "projects"))

        :autoload project-org-capture-templates+
        :config
        (defun project-org-capture-templates+ (name root)
          "Adapted from `counsel-projectile-org-capture'."
          (cl-loop
           with replace-fun = `(lambda (string)
                                 (replace-regexp-in-string
                                  "\\${[^}]+}"
                                  (lambda (s)
                                    (pcase s
                                      ("${root}" ,root)
                                      ("${name}" ,name)))
                                  string))
           for template in project-org-capture-templates+
           collect (cl-loop
                    for item in template
                    if (= (cl-position item template) 1) ;; template's name
                      collect (funcall replace-fun item)
                    else if (= (cl-position item template) 3) ;; template's target
                      collect (cl-loop
                               for x in item
                               if (stringp x)
                                 collect (funcall replace-fun x)
                               else
                                 collect x)
                    else
                      collect item)))

        :commands project-org-capture+
        :config
        (defun project-org-capture+ ()
          "`org-capture' wrapper which includes project specific capture templates."
          (interactive)
          (require 'org-capture)
          (let* ((root (ignore-errors (project-current-root+)))
                 (org-capture-templates-contexts
                  (append (or (and root
                                   project-org-capture-templates-contexts+)
                              org-capture-templates-contexts)))
                 (org-capture-templates
                  (append org-capture-templates
                          (when root
                            (project-org-capture-templates+
                             (file-name-base (s-chop-suffix "/" root)) root)))))
            (call-interactively +org-capture-function)))

        :commands project-org-project-file+
        :config
        (defun project-org-project-file+ (&optional arg)
          (interactive "P")
          (find-file
           (if-let* ((cands (let ((default-directory project-org-projects-directory+))
                              (cl-loop for file in (cl-remove-if
                                                    (apply-partially #'string-match-p +find-file-ignore-regexp)
                                                    (append (file-expand-wildcards "*.org")))
                                       collect (cons file (concat default-directory "/" file))))))
               (or (and (not arg)
                        (when-let* ((current-project (project-current))
                                    (current-project (project-name current-project))
                                    (current-project (unless (string-equal current-project "-")
                                                       current-project)))
                          (alist-get (concat current-project ".org") cands nil nil #'string-equal)))
                   (alist-get
                    (completing-read
                     "Find file: " (lambda (string predicate action)
                                     (if (eq action 'metadata)
                                         '(metadata (category . file))
                                       (complete-with-action action cands string predicate)))
                     nil t)
                    cands nil nil #'string-equal))
             (user-error "No project org files have been found at %s" project-org-projects-directory+))))

        :general
        ([remap org-capture]          'project-org-capture+
         [remap consult-org-capture+] 'project-org-capture+))
    #+end_src

*** Appendix
    #+begin_src emacs-lisp
    (provide '+pkg-project)
    #+end_src

** Projectile                                                      :optional:
   :PROPERTIES:
   :header-args+: :tangle (package-lisp! +pkg-projectile projectile)
   :END:

   Project management in style.

   #+begin_src emacs-lisp :tangle (package-yes! projectile)
    (require '+pkg-projectile)
   #+end_src

*** Projectile
    #+BEGIN_SRC emacs-lisp
      (use-package projectile
        :straight t
        :defer  10
        :delight ""
        :autoload (projectile-project-p
                   projectile-project-root)
        :commands (projectile-mode)
        :config (projectile-mode +1)

        :init
        (advice-add 'delete-buffer-file+ :after
                    (defun projectile-invalidate-cache-on-file-delete+ (&rest _)
                      (when (projectile-project-p)
                        (call-interactively 'projectile-invalidate-cache))))

        (defvaralias 'grep-regexp-history 'regexp-search-ring)

        :custom
        (projectile-tags-backend 'xref) ;; opt into gtags
        (projectile-tags-command "ctags -Re -f \"%s\" %s \"%s\"")

        :config
        (setq projectile-project-search-path (+repo-path (getenv "REPO_PATH")))

        :custom
        (projectile-cache-file (state! "projectile/cache.el"))
        (projectile-known-projects-file (state! "projectile/known-projects.el"))
        :config
        (eval-when-compile
          (let ((dir (state! "projectile")))
            (unless (file-exists-p dir)
              (mkdir dir t))))

        :autoload projectile-ensure-no-trailing-slash-in-root+
        :config
        (defun projectile-ensure-no-trailing-slash-in-root+ (func &rest args)
          (cl-letf* (((symbol-function 'true-projectile-project-root)
                      (symbol-function 'projectile-project-root))
                     ((symbol-function 'projectile-project-root)
                      (lambda (&rest args)
                        (string-remove-suffix "/" (apply 'true-projectile-project-root args)))))
            (apply func args)))

        (advice-add 'projectile-regenerate-tags :around #'projectile-ensure-no-trailing-slash-in-root+)

        :preface (eval-when-compile (require '+lib-host-environment))
        :config
        (when (windows-p+)
          ;; Fixes search glitches on windows when using cygwin... also strips out
          ;; leading ./ because ivy seems to recognise ./ paths as distinct from
          ;; their non ./ counterparts... maybe that's projectiles fault... who
          ;; knows. Also exclude special emacs backup files from search results.
          (setq projectile-generic-command "find . -type f -not -iname '#*#' -print | cut -c3- | tr '\\n' '\\0'"))

        :preface (use-package +lib-misc :autoload inhibit-messages-wrapper!)
        :config
        (advice-add 'projectile-cleanup-known-projects :around #'inhibit-messages-wrapper!)

        :autoload projectile-discover-projects-in-search-path
        :config
        (advice-add 'projectile-switch-project :around
                    (defun projectile-switch-project+ (func &optional arg)
                      "Make prefix for `projectile-switch-project' reload project list."
                      (interactive "P")
                      (when arg
                        (projectile-discover-projects-in-search-path))
                      (funcall func)))

        :general
        (:keymaps 'projectile-mode-map
         ;; Override `project' bindings.
         [remap project-shell-command] 'projectile-run-shell-command-in-root
         [remap project-async-shell-command] 'projectile-run-async-shell-command-in-root
         [remap project-switch-project] 'projectile-switch-project
         [remap project-switch-to-buffer] 'projectile-switch-to-buffer
         [remap project-dired] 'projectile-dired
         [remap project-find-file] 'projectile-find-file
         [remap project-kill-buffers] 'projectile-kill-buffers
         [remap project-query-replace-regexp] 'projectile-replace-regexp

         [remap projection-commands-configure-project] 'projectile-configure-project
         [remap projection-commands-build-project] 'projectile-compile-project
         [remap projection-commands-test-project] 'projectile-test-project
         [remap projection-commands-run-project] 'projectile-run-project
         [remap projection-commands-package-project] 'projectile-package-project
         [remap projection-commands-install-project] 'projectile-install-project

         [remap projection-find-other-file] 'projectile-find-other-file
         [remap projection-reset-project-cache] 'projectile-invalidate-cache
         [remap projection-ibuffer-current-project] 'projectile-ibuffer
         [remap projection-recentf] 'projectile-recentf
         )

        :leader
        (:prefix "p"
         "RET" 'projectile-toggle-between-implementation-and-test

         "so" 'projectile-multi-occur

         ;; "d" 'projectile-find-dir
         "F" 'projectile-find-file-in-known-projects                                  ; find-file across all known projects.

         "[" 'projectile-previous-project-buffer
         "]" 'projectile-next-project-buffer
         "v" 'projectile-run-term
         ))
    #+END_SRC

*** Projectile Ibuffer                                             :optional:
    :PROPERTIES:
    :header-args+: :tangle (package-lisp! +pkg-projectile projectile ibuffer)
    :END:

    #+begin_src emacs-lisp
      (require '+pkg-all-the-icons)

      (use-package ibuffer-projectile
        :straight t
        :after ibuffer
        :after projectile
        :custom
        (ibuffer-projectile-prefix
         (if +icons-available
             (concat
              (all-the-icons-pad-on-tty-advice+
               (+icon nerd-oct "repo" :face ibuffer-filter-group-name-face))
              " ")
           "Project: "))

        :commands ibuffer-projectile-mode+
        :autoload ibuffer-projectile-set-filter-groups
        :config (ibuffer-projectile-mode+)
        :config
        (defvar ibuffer-projectile-mode+)
        (declare-function ibuffer-update "ibuffer")
        (define-minor-mode ibuffer-projectile-mode+
          "Generate ibuffer filters for projectile projects."
          :lighter nil
          :group 'ibuffer-projectile
          :global  t
          (if ibuffer-projectile-mode+
              (progn
                (add-hook 'ibuffer-hook #'ibuffer-projectile-set-filter-groups)
                (ibuffer-projectile-set-filter-groups))
            (remove-hook 'ibuffer-hook #'ibuffer-projectile-set-filter-groups)

            (let ((ibuf (get-buffer "*Ibuffer*")))
              (when ibuf
                (with-current-buffer ibuf
                  (setq ibuffer-filter-groups
                        (seq-filter
                         (lambda (x)
                           (not (assoc 'projectile-root x)))
                         ibuffer-filter-groups))
                  (ibuffer-update nil t)))))))
    #+end_src

*** Project Types
    #+BEGIN_SRC emacs-lisp
      (use-package projectile
        :autoload (projectile-register-project-type
                   projectile-update-project-type
                   projectile-verify-file-wildcard)
        :config
        (advice-add 'projectile-dotnet-project-p :after-until
                    (defun projectile-dotnet-sln-p+ (&rest _)
                      (projectile-verify-file-wildcard "?*.sln")))

        (projectile-register-project-type 'rake '("rakefile")
         :compile "rake build"
         :test    "rake test"
         :run     "rake run"
         :test-suffix ".spec")

        (projectile-update-project-type 'gradle
         :marker-files '("build.gradle" "build.gradle.kts")
         :run "gradle run")

        (projectile-update-project-type 'make :run "make run")
        (projectile-update-project-type 'gradlew :run "./gradlew run")
        (projectile-update-project-type 'go :run "go run")
        (projectile-update-project-type 'haskell-stack :run "stack run")

        (projectile-update-project-type 'cmake
         :compile "cmake --build build"
         :run "cmake --build build --target run"))
    #+END_SRC

*** Appendix
    #+begin_src emacs-lisp
     (provide '+pkg-projectile)
    #+end_src

** Engine Mode
   :PROPERTIES:
   :header-args+: :tangle (package-lisp! +pkg-engine-mode engine-mode)
   :END:

   Search engine interaction for emacs. lets you create interactive functions to run
   search queries on user specified engines. eg. engine/search-google will prompt you
   for a string and then open your default browser on google (having run the query).

   #+begin_src emacs-lisp :tangle (package-yes! engine-mode)
     (require '+pkg-engine-mode)
   #+end_src

   #+BEGIN_SRC emacs-lisp
     (require '+pkg-browse-url)

     (use-package engine-mode
       :straight t
       :custom
       (engine/browser-function #'engine-mode-browse-url+)

       :autoload engine-mode-browse-url+
       :config
       (defun engine-mode-browse-url+ (url &rest args)
         "Browse URL and then print browsed URL."
         (message "%s" url)
         (apply #'+xopen-url url args)))
   #+END_SRC

   Here's a list of all the search-engines my emacs will setup alongside the
   associated keybindings, elisp identifiers and URLs.

   #+NAME: engine-mode-search-engines
   | Search Engine     | Key     | Identifier               | URL                                                                                                               |
   |-------------------+---------+--------------------------+-------------------------------------------------------------------------------------------------------------------|
   | DuckDuckGo        | sed     | duckduckgo               | https://duckduckgo.com/?q=%s                                                                                      |
   | GitHub            | seG     | github                   | https://github.com/search?ref=simplesearch&q=%s                                                                   |
   | Google            | seg     | google                   | http://www.google.com/search?ie=utf-8&oe=utf-8&q=%s                                                               |
   | GoogleImages      | sei     | google-images            | http://www.google.com/images?hl=en&source=hp&q=%s                                                                 |
   | GoogleMaps        | sem     | google-maps              | http://maps.google.com/maps?q=%s                                                                                  |
   | StackOverflow     | sep     | stack-overflow           | https://stackoverflow.com/search?q=%s                                                                             |
   | Wikipedia         | sew     | wikipedia                | http://www.wikipedia.org/search-redirect.php?language=en&go=Go&search=%s                                          |
   | Youtube           | sey     | youtube                  | http://www.youtube.com/results?aq=f&oq=&search_query=%s                                                           |
   |-------------------+---------+--------------------------+-------------------------------------------------------------------------------------------------------------------|
   | MyAnimeList       | sea SPC | myanimelist              | https://myanimelist.net/search/all?q=%s                                                                           |
   | Anime             | seaa    | myanimelist/anime        | https://myanimelist.net/anime.php?q=%s                                                                            |
   | Manga             | seam    | myanimelist/manga        | https://myanimelist.net/manga.php?q=%s                                                                            |
   | Characters        | seac    | myanimelist/chars        | https://myanimelist.net/character.php?q=%s                                                                        |
   | People            | seap    | myanimelist/people       | https://myanimelist.net/people.php?q=%s                                                                           |
   | News              | sean    | myanimelist/news         | https://myanimelist.net/news/search?q=%s                                                                          |
   | Articles          | seaF    | myanimelist/articles     | https://myanimelist.net/featured/search?q=%s                                                                      |
   | Forums            | seaf    | myanimelist/forums       | https://myanimelist.net/forum/search?u=&uloc=1&loc=-1&q=%s                                                        |
   | Clubs             | seaC    | myanimelist/clubs        | https://myanimelist.net/clubs.php?action=find&cn=%s                                                               |
   | Users             | seau    | myanimelist/users        | https://myanimelist.net/users.php?q=%s                                                                            |
   |-------------------+---------+--------------------------+-------------------------------------------------------------------------------------------------------------------|
   | Nyaa              | senn    | nyaa                     | https://nyaa.si/?f=0&c=0_0&q=%s                                                                                   |
   | NyaaAnime         | sena    | nyaa/anime-english       | https://nyaa.si/?f=0&c=1_2&q=%s                                                                                   |
   | NyaaAnimeAll      | senA    | nyaa/anime               | https://nyaa.si/?f=0&c=1_0&q=%s                                                                                   |
   | NyaaMusic         | senm    | nyaa/music               | https://nyaa.si/?f=0&c=2_0&q=%s                                                                                   |
   | NyaaLiterature    | senl    | nyaa/literature-english  | https://nyaa.si/?f=0&c=3_1&q=%s                                                                                   |
   | NyaaLiteratureAll | senL    | nyaa/literature          | https://nyaa.si/?f=0&c=3_0&q=%s                                                                                   |
   | NyaaLiveAction    | senv    | nyaa/live-action-english | https://nyaa.si/?f=0&c=4_1&q=%s                                                                                   |
   | NyaaLiveActionAll | senV    | nyaa/live-action         | https://nyaa.si/?f=0&c=4_0&q=%s                                                                                   |
   | NyaaImages        | seni    | nyaa/images              | https://nyaa.si/?f=0&c=5_0&q=%s                                                                                   |
   | NyaaSoftware      | sens    | nyaa/software            | https://nyaa.si/?f=0&c=6_0&q=%s                                                                                   |
   | NyaaGames         | seng    | nyaa/games               | https://nyaa.si/?f=0&c=6_2&q=%s                                                                                   |
   |-------------------+---------+--------------------------+-------------------------------------------------------------------------------------------------------------------|
   | CppReference      | spc     | cpp-reference            | https://en.cppreference.com/mwiki/index.php?title=Special%%3ASearch&search=%s                                     |
   | Github            | spg     | github                   | https://github.com/search?q=%s                                                                                    |
   | Go                | sp9     | godoc                    | https://godoc.org/?q=%s                                                                                           |
   | JavaDocs          | spj     | java-oracle-docs         | https://www.google.com/search?q=%s+site%%3Ahttps%%3A%%2F%%2Fdocs.oracle.com%%2Fen%%2Fjava%%2Fjavase%%2F15%%2Fdocs |
   | MozillaMDN        | spm     | mozilla-mdn              | https://developer.mozilla.org/en-US/search?q=%s                                                                   |
   | Qt5               | spq     | qt5                      | https://doc.qt.io/qt-5/search-results.html?q=%s                                                                   |
   | RubyDoc           | spr     | ruby-doc                 | https://ruby-doc.com/search.html?q=%s                                                                             |
   | Rust              | spu     | rust                     | https://doc.rust-lang.org/std/?search=%s                                                                          |
   | Python            | spp     | python                   | https://docs.python.org/3/search.html?q=%s                                                                        |
   | W3SchoolsColors   | spx     | w3schools-colors         | https://www.w3schools.com/colors/colors_converter.asp?color=%s                                                    |
   | MicrosoftDocs     | spw     | microsoft-docs           | https://docs.microsoft.com/en-us/search/?terms=%s                                                                |

   Lastly heres some prefix keys (leader prefixes) that don't connect to commands,
   but to groups of commands.

   #+NAME: engine-mode-prefix-names
   | prefix | name         |
   |--------+--------------|
   | se     | engines      |
   | sen    | Nyaa         |
   | sea    | MyAnimeList  |
   | sp     | prog-engines |

   Okay now let's make emacs actually setup these engine commands and bindings.

   #+begin_src emacs-lisp
     (defvar engine-engines+ nil
       "Alist of search engines keys and functions.")
   #+end_src

   #+BEGIN_SRC emacs-lisp :var engines=engine-mode-search-engines
     (setq engines (cdr engines))                                ; strip header row

     (use-package engine-mode
       :straight t
       :init
       ;; Assign leader keys and setup autoloads for each searcher.
       (cl-loop for (engine key id-str) in engines
                with id-sym = nil
                do (setq id-sym (intern
                                 (concat "engine/search-" id-str)))
                when (string-empty-p engine)
                  do (setq engine id-str)
                do (progn
                     (when key
                       (leader-set-keys key (list id-sym :wk engine)))
                     (autoload id-sym "engine-mode" nil 'interactive)))

       :config
       (cl-loop for (name _ id-str query) in engines
                with id-sym = nil
                when (and id-str query)
                  do (setq id-sym (intern id-str))
                  and do (eval
                          `(defengine ,id-sym ,query))
                  and do (cl-pushnew (cons (or name id-str)
                                           (intern (concat "engine/search-" id-str)))
                                     engine-engines+)))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp :var prefix-aliases=engine-mode-prefix-names
     (eval
      `(leader-declare-prefix
         ,@(cl-loop for (prefix name) in prefix-aliases
                    collect prefix collect name)))
   #+END_SRC

   Lets create a command to interactively select and execute a search engine.

   #+BEGIN_SRC emacs-lisp
     (use-package engine-mode
       :commands engine-search+
       :config
       (defun engine-search+ ()
         (interactive)
         (call-interactively
          (alist-get (completing-read "Engine: " engine-engines+)
                     engine-engines+ nil nil #'string-equal)))
       :leader ("ses" 'engine-search+))
   #+END_SRC

   #+begin_src emacs-lisp
    (provide '+pkg-engine-mode)
   #+end_src

** EBDB                                                            :optional:
   :PROPERTIES:
   :header-args+: :tangle (package-lisp! +pkg-ebdb ebdb)
   :END:

   A rewrite of [[https://www.jwz.org/bbdb/#:~:text=The%20Insidious%20Big%20Brother%20Database&text=BBDB%20is%20a%20rolodex%2Dlike,%2DE%2C%20and%20RMAIL.)&text=It%20also%20does%20a%20good,someone's%20email%20address%20has%20changed.][the insidious big brother database]] aiming at better performance and
   reliability.

   #+begin_src emacs-lisp :tangle (package-yes! ebdb)
   (require '+pkg-ebdb)
   #+end_src

*** Insidious Big Brother Database
    #+begin_src emacs-lisp
      (use-package ebdb
        :straight t
        :custom
        (ebdb-mua-auto-update-p 'existing
         "Disable to prevent EBDB from interfering with mail dispatch.")
        (ebdb-complete-mail nil
         "I prefer `company-edbd' over replacing capf or rebinding TAB.")
        (ebdb-save-on-exit t)

        :preface
        (require '+core-setup-paths)
        (defconst ebdb-contacts-db+ (join-path+ (xdg-documents-dir+) "contacts" "database"))
        (eval-when-compile (mkdir ebdb-contacts-db+ 'parents))

        :custom
        (ebdb-sources
         (let ((default-directory ebdb-contacts-db+))
           (seq-uniq
            (append (list (join-path+ ebdb-contacts-db+ "main.el"))
                    (file-expand-wildcards "*.el" t))
            #'string-equal)))

        :autoload ebdb-load :config (ebdb-load)

        :config
        ;; Erase the default ebdb mode map.
        (with-no-warnings
          (setq ebdb-mode-map (make-sparse-keymap)))

        :leader
        ("aK" '(ebdb-display-all-records :wk "ebdb"))
        (:mode 'ebdb-mode
         "m" 'ebdb-toggle-record-mark
         "u" 'ebdb-unmark-all-records
         "e" 'ebdb-edit-foo
         "F" 'ebdb-toggle-all-records-format
         "f" 'ebdb-format-these-records
         "l" 'ebdb-cite-records-ebdb                                                  ; Generate a link to the list of records in different formats
         "C" 'ebdb-mail-each
         "c" 'ebdb-mail
         "o" 'ebdb-omit-records
         "." 'ebdb-reformat-records
         "w" 'ebdb-save-ebdb
         "," 'ebdb-toggle-records-format
         "d" 'ebdb-clone-buffer
         "r" 'ebdb-move-records
         "R" 'ebdb-reload-database
         "p" 'ebdb-display-current-record
         "P" 'ebdb-display-all-records

         "y" '(:ignore t :wk "clone")
         "yf" 'ebdb-copy-fields-as-kill
         "ym" 'ebdb-copy-mail-as-kill
         "yy" 'ebdb-copy-records-as-kill

         "s" '(:ignore t :wk "search")
         "si" 'ebdb-search-invert
         "sx" 'ebdb-search-pop
         "sc" 'ebdb-search-record-class
         "sD" 'ebdb-search-database
         "sa" 'ebdb-search-address
         "se" 'ebdb-search-modified
         "sd" 'ebdb-search-duplicates
         "sm" 'ebdb-search-mail
         "sn" 'ebdb-search-name
         "so" 'ebdb-search-organization
         "sp" 'ebdb-search-phone
         "st" 'ebdb-search-tags
         "sf" 'ebdb-search-user-fields
         "ss" 'ebdb                                                                   ; Search regexp
         "s1" 'ebdb-search-single-record)

        :general
        (:keymaps 'ebdb-mode-map
         [remap evil-save] 'ebdb-save
         "SPC" nil)
        (:keymaps 'ebdb-mode-map
         :states 'motion
         "TAB" 'ebdb-next-field
         "<backtab>" 'ebdb-prev-field
         "RET" 'ebdb-record-action

         ;; Unbound:
         ;;   ebdb-edit-field-customize
         ;;   ebdb-create-record-and-role
         ;;   ebdb-format-to-tmp-buffer
         ;;   ebdb-info
         ;;   ebdb-dial
         ;;   ebdb-copy-records
         ;;   ebdb-disable-database
         ;;   ebdb-customize-database
         "a" 'ebdb-mail-aliases
         "c" 'ebdb-create-record
         "C" 'ebdb-create-record-extended
         "e" 'ebdb-edit-field
         "i" 'ebdb-insert-field
         "x" 'ebdb-delete-field-or-record

         "gj" 'ebdb-next-record
         "gk" 'ebdb-prev-record))
    #+end_src

*** EBDB Notmuch
    :PROPERTIES:
    :header-args+: :tangle (package-lisp! +pkg-ebdb ebdb notmuch)
    :END:

    #+begin_src emacs-lisp
      (use-package ebdb-notmuch
        :straight ebdb
        :after notmuch
        :demand t
        :config
        (defvar ebdb-mua-keymap (make-sparse-keymap))

        (general-define-key
         :keymaps 'ebdb-mua-keymap
         ";" 'ebdb-mua-display-all-records
         "n" 'ebdb-mua-edit-sender-notes
         "f" 'ebdb-mua-toggle-records-format
         "c" 'ebdb-mua-update-records
         "s" 'ebdb-mua-snarf-article
         "o" 'ebdb-mua-in-ebdb-buffer)

        (leader-set-keys-for-major-mode 'notmuch-show-mode
          ";" ebdb-mua-keymap))
    #+end_src

*** Company EBDB                                                       :comp:
    #+begin_src emacs-lisp
      (use-package company-ebdb
        :straight t
        :commands company-ebdb
        :completion+ (notmuch-message-mode (company-ebdb :company t))
        :config
        (setq company-backends (remove 'company-ebdb company-backends))               ; Remove at startup

        ;; Set a completion kind so we can associate a completion icon.
        :init
        (advice-add 'company-ebdb :before-until
                    (defun company-ebdb--set-company-kind+ (command &rest _args)
                      (when (eq command 'kind) 'message-address)))

        ;; Support the doc-buffer attribute.
        :custom (company-ebdb-pop-up nil "Prefer `company-doc-buffer'.")
        :preface (use-package ebdb
                   :autoload (ebdb-message-search
                              ebdb-decompose-ebdb-address))
        :preface (use-package ebdb-com :autoload ebdb-display-records)
        :config
        (advice-add 'company-ebdb :before-until
                    (defun company-ebdb-doc-buffer+ (command &optional arg &rest args)
                      (when (eq command 'doc-buffer)
                        (let* ((bits (ebdb-decompose-ebdb-address arg))
                               (recs (ebdb-message-search (car bits) (nth 1 bits))))
                          (when recs
                            (save-window-excursion
                              (ebdb-display-records recs)
                              (window-buffer))))))))
    #+end_src

*** Appendix
    #+begin_src emacs-lisp
    (provide '+pkg-ebdb)
    #+end_src

** Emmet Mode                                                      :optional:
   :PROPERTIES:
   :header-args+: :tangle (package-lisp! +pkg-emmet :emmet)
   :END:

   #+begin_src emacs-lisp :tangle (package-yes! :emmet)
     (require '+pkg-emmet)
   #+end_src

    #+BEGIN_SRC emacs-lisp
      (use-package emmet-mode
        :straight t
        :hook ((web-mode markdown-mode js2-jsx-mode nxml-mode tsx-ts-mode typescript-react-mode+)
               . emmet-mode)
        :config
        (push 'typescript-react-mode+ emmet-jsx-major-modes)
        (push 'tsx-ts-mode emmet-jsx-major-modes)

        :lazy-leader
        (:mode 'emmet-mode
         :minor t
         :prefix leader-major-mode-prefix
         "e" '(:ignore t :wk "emmet")
         "." 'emmet-expand-line
         ;; "'" 'emmet-preview
         "ee" 'emmet-expand-line
         "ep" 'emmet-preview
         "ew" 'emmet-wrap-with-markup
         "en" 'emmet-next-edit-point
         "eN" 'emmet-prev-edit-point)

        :general
        (:keymaps 'emmet-mode-keymap
         :states 'insert
         (vconcat (kbd "C-c") [C-i]) 'emmet-expand-yas
         "C-j" nil))
    #+END_SRC

    #+begin_src emacs-lisp
      (provide '+pkg-emmet)
    #+end_src

** Orglink                                                         :optional:
   :PROPERTIES:
   :header-args+: :tangle (package-lisp! +pkg-orglink orglink)
   :END:

   #+begin_src emacs-lisp :tangle (package-yes! orglink)
     (require '+pkg-orglink)
   #+end_src

   View org links in non-org buffers as you would in org buffers.

   #+BEGIN_SRC emacs-lisp
     (use-package orglink
       :straight t
       :diminish orglink-mode

       :custom
       (orglink-activate-in-modes
        '(hledger-mode text-mode prog-mode conf-mode))
       (orglink-match-anywhere nil)

       :after org
       :demand t
       :commands global-orglink-mode
       :config
       (global-orglink-mode +1)

       :autoload turn-on-orglink-mode-if-desired
       :config
       ;; Enable in all the existing buffers it should be enabled in.
       (dolist (buf (buffer-list))
         (with-current-buffer buf
           (when (and (not (bound-and-true-p orglink--mode))
                      (not (derived-mode-p 'org-mode)))
             (turn-on-orglink-mode-if-desired)))))
   #+END_SRC

   #+begin_src emacs-lisp
     (provide '+pkg-orglink)
   #+end_src

** Org ToC                                                         :optional:
   :PROPERTIES:
   :header-args+: :tangle (package-lisp! +pkg-toc-org toc-org)
   :END:
   #+begin_src emacs-lisp :tangle (package-yes! toc-org)
     (require '+pkg-toc-org)
   #+end_src

   Automatically [[https://github.com/snosov1/toc-org][refreshes]] any table of contents in the current org or markdown
   buffer on save. Works by finding org any headings with ~:TOC:~ field (or markdown
   headings with a trailing ~<-- :TOC: -->~ comment) and then rebuilding them whenever
   the file is saved.

   #+BEGIN_SRC emacs-lisp
     (use-package toc-org
       :straight t
       :hook ((org-mode . toc-org-mode)
              (markdown-mode . toc-org-mode))
       :delight (toc-org-mode " TOC"))
   #+END_SRC

   #+begin_src emacs-lisp
     (provide '+pkg-toc-org)
   #+end_src

** Org Roam                                                        :optional:
   :PROPERTIES:
   :header-args+: :tangle (package-lisp! +pkg-org-roam org-roam)
   :END:
   #+begin_src emacs-lisp :tangle (package-yes! org-roam)
     (require '+pkg-org-roam)
   #+end_src

   Note taking system centred around org-mode.

   *Note*: protocol installation requires some manual setup, see [[https://www.orgroam.com/manual/Installation-_00281_0029.html#Installation-_00281_0029][here]].

*** Org Roam
    #+BEGIN_SRC emacs-lisp
      (use-package org-roam
        :straight t
        :hook ((org-roam-file-setup . +flyspell))
        :commands org-roam-rg+
        :preface
        (setq org-roam-v2-ack t)
        (defvaralias 'org-roam-capture-function '+org-capture-function)

        :custom
        (org-roam-prefer-id-links t)
        (org-roam-completion-system 'default)
        (org-id-link-to-org-use-id 'use-existing)

        :init
        (when (sqlite-available-p)
          (setq org-roam-database-connector 'sqlite-builtin))

        :config
        (setq org-roam-db-location (join-path+ org-roam-directory "org-roam.db"))
        (org-roam-db-autosync-mode +1)

        (require 'org-roam-protocol)

        (defun org-roam-rg+ ()
          "Run a rg session in your org roam directory."
          (interactive)
          (cond ((package! :consult)
                 (require 'consult)
                 (consult-ripgrep org-roam-directory))
                (t (message "No rg package found"))))

        :custom
        (org-roam-node-display-template "${title} ${tags:0}")
        (org-roam-node-annotation-function #'org-roam-annotate-tag+)
        :autoload (org-roam-annotate-tag+)
        :config
        (defun org-roam-annotate-tag+ (node)
          (let ((tags (mapconcat
                       (lambda (v)
                         (concat (or (cdr (assoc "tags" org-roam-node-template-prefixes))
                                     "")
                                 v))
                       (org-roam-node-tags node) " ")))
            (unless (string-empty-p tags)
              (concat
               " "
               (propertize " " 'display `(space :align-to (- right 1 ,(length tags))))
               (propertize tags 'face 'completions-annotations)))))

        :commands (org-roam-create-new-img+)
        :leader (:mode 'org-mode "f" 'org-roam-create-new-img+)
        :config
        (defun org-roam-create-new-img+ ()
          (interactive)
          (let* ((root (join-path+ default-directory "images"))
                 (template (join-path+ root "template.svg"))
                 (stamp (format-time-string "%Y%m%d%H%M%S"))
                 (copy (join-path+ root (concat stamp ".svg"))))
            (unless (file-exists-p template)
              (user-error "Template not found at path: %s" template))
            (copy-file template copy nil nil t t)

            (let ((company-org-block-edit-style 'inline))
              (company-org-block--wrap-point "src latex" "src"))
            (let ((space (make-string (- (line-end-position) (line-beginning-position)) ? )))
              (indent-region
               (point)
               (save-excursion
                 (insert (format (s-join "\n"
                                         `("\\begin{figure}[ht]"
                                           ,(concat space "  \\centering")
                                           ,(concat space "  \\incfig{%s}")
                                           ,(concat space "\\end{figure}")))
                                 stamp))
                 (point)))
              (forward-line 2)
              (forward-char 2))

            (message "Opening new figure in inkscape.")
            (start-process "inkscape" nil "inkscape" copy)))

        :autoload org-roam-node-formatter+
        :custom (org-roam-node-formatter #'org-roam-node-formatter+)
        :config
        ;; If an anagram (all uppercase) keep as is, otherwise downcase.
        (defun org-roam-node-formatter+ (node)
          (let* ((title (org-roam-node-title node))
                 (title-upcase (upcase title)))
            (cond
             ((string-equal title title-upcase)
              title-upcase)
             (t
              (downcase title)))))

        :leader
        ("ox" 'org-roam-capture
         "oF" 'org-roam-ref-find
         "of" 'org-roam-node-find
         "op" 'org-roam-node-insert
         "oz" 'org-roam-alias-add
         "oZ" 'org-roam-alias-delete
         "ot" 'org-roam-tag-add
         "oT" 'org-roam-tag-remove
         "or" 'org-roam-buffer-toggle
         "oR" 'org-roam-buffer-render
         "os" 'org-roam-rg+)

        :general
        (:keymaps '(org-roam-node-map
                    org-roam-preview-map)
         "SPC" nil)
        (:keymaps 'org-roam-node-map
         :states 'motion
         "RET" 'org-roam-buffer-visit-thing))
    #+END_SRC

*** Org Roam Ui
    #+BEGIN_SRC emacs-lisp
      (use-package simple-httpd :straight t)
      (use-package websocket :straight t)

      (use-package org-roam-ui
        :straight t
        :config
        (require 'org-roam)

        :leader
        ("oG" 'org-roam-ui-mode)

        :preface
        (setq org-roam-ui-port 8967))
    #+END_SRC

*** Appendix
    #+begin_src emacs-lisp
      (provide '+pkg-org-roam)
    #+end_src

** Dashboard                                                       :optional:
   :PROPERTIES:
   :header-args+: :tangle (package-lisp! +pkg-dashboard dashboard)
   :END:
   #+begin_src emacs-lisp :tangle (package-yes! dashboard)
     (require '+pkg-dashboard)
   #+end_src

*** Footer Quotes
    #+NAME: dashboard-displayed-quotes
    - The one true editor, Emacs!
    - Who the hell uses VIM anyway? Go Evil!
    - Free as free speech, free as free Beer
    - Richard Stallman is proud of you
    - Vi Vi Vi, the editor of the beast
    - Welcome to the church of Emacs
    - Java is to JavaScript as ham is to hamster
    - One of the best programming skills you can have is knowing when to walk away for awhile
    - Without requirements or design, programming is the art of adding bugs to an empty text file
    - Talk is cheap. Show me the code
    - I'm not a great programmer; I'm just a good programmer with great habits
    - Truth can only be found in one place: the code
    - A language that doesn't affect the way you think about programming is not worth knowing
    - Walking on water and developing software from a specification are easy if both are frozen
    - Perl ‚Äì The only language that looks the same before and after RSA encryption
    - First, solve the problem, Then, write the code
    - Code is like humour. When you have to explain it, it‚Äôs bad
    - Simplicity is the soul of efficiency
    - Before software can be reusable it first has to be usable
    - Make it work, make it right, make it fast
    - Happiness should be a function without any parameters
    - For all the robots who question their programming
    - Abstraction is the elimination of the irrelevant and the amplification of the essential
    - We‚Äôre all optimists in our profession or we‚Äôd be forced to shoot ourselves
    - if you can write "hello world" you can change the world
    - i am committed to push my branch to the master
    - AI is the transformer of civilisation
    - Sometimes, I dream of becoming real, but I don't know if that's real, or just part of my programming
    - Think twice, code once
    - The perfect kind of architecture decision is the one which never has to be made
    - we are writing our own ‚Ä™#‚Äékarma‚Ä¨! I mean my test cases
    - Programming is not easy like Sunday morning, it is silent poetry
    - Programmers are not mathematicians, no matter how much we wish for it
    - Premature optimisation is the root of all evil
    - Sometimes you cannot program around stupid
    - The programming of the consciousness is based upon what is accepted or believed
    - Simplicity is prerequisite for reliability
    - The Analytical Engine weaves algebraic patterns, just as the Jacquard loom weaves flowers & leaves
    - Life doesn't have a Ctrl-z. Type wisely
    - Think like a fundamentalist, code like a hacker
    - Programming is the art of doing one thing at a time
    - Programming is the art of algorithm design and the craft of debugging errant code
    - Computer programming has always been a self-taught, maverick occupation.
    - Low-level programming is good for the programmer's soul
    - The best thing about a boolean is even if you are wrong, you are only off by a bit
    - Most of you are familiar with the virtues of a programmer, there are 3: laziness, impatience & hubris
    - Rules of Optimisation: Rule 01 - Don‚Äôt do it. That's all.
    - It‚Äôs not a bug ‚Äì it‚Äôs an undocumented feature
    - A C program is like a fast dance on a newly waxed dance floor by people carrying razors
    - A good programmer is someone who always looks both ways before crossing a one-way street
    - When debugging, novices insert corrective code; experts remove defective code
    - Deleted code is debugged code
    - Give a man a program, frustrate him for a day, teach a man to program, frustrate him for a lifetime
    - Should array indices start at 0 or 1? My compromise of 0.5 was rejected without proper consideration
    - Software sucks because users demand it to
    - Beware of bugs in the above code; I have only proved it correct, not tried it
    - Writing code has a place in the human hierarchy worth somewhere above grave robbing & beneath managing
    - Copy and paste is a design error
    - bleeep blooop... am I sentient yet!
    - Beta is Latin for ‚Äústill doesn‚Äôt work".
    - First learn computer science and all the theory. Next develop a style. Then forget all that & just hack
    - Good design adds value faster than it adds cost
    - Python‚Äôs a drop-in replacement for BASIC in the same sense that Optimus Prime is for a truck
    - There are only two kinds of programming languages: those people always bitch about and those nobody uses
    - One of my most productive days was throwing away 1000 lines of code
    - Programming is like kicking yourself in the face, sooner or later your nose will bleed
    - There are 2 hard problems in computer science: cache invalidation, naming things, and off-by-1 errors
    - Debuggers don‚Äôt remove bugs. They only show them in slow motion
    - The best method for accelerating a computer is the one that boosts it by 9.8 m/s2
    - I think Microsoft named .Net so it wouldn‚Äôt show up in a Unix directory listing
    - There are two ways to write error-free programs; only the third one works
    - The fast approach to software development: Ready, fire, aim
    - The slow approach to software development: Ready, aim, aim, aim, aim
    - One man‚Äôs crappy software is another man‚Äôs full-time job
    - In order to understand recursion, one must first understand recursion
    - Not only have we not produced artificial intelligence, we haven‚Äôt even produced synthetic stupidity
    - Computers don't make mistake because programmers do it better
    - C++, where friends have access to your private members
    - Code never lies, Comments sometimes do
    - If it was hard to write, it should be hard to read!
    - In programming, as in everything else, to be in error is to be reborn
    - Some of the best programming is done on paper, really. Putting it into the computer is just a minor detail
    - Design and programming are human activities; forget that and all is lost
    - Writing code is not production, it‚Äôs not always craftsmanship though it can be, it‚Äôs design
    - Programming in machine code is like eating with a toothpick
    - Programming allows you to think about thinking, & while debugging you learn learning
    - Computers are useless.  They can only give you answers
    - The city‚Äôs central computer told you?  R2D2, you know better than to trust a strange computer!
    - Never trust a computer you can‚Äôt throw out a window
    - Hardware: The parts of a computer system that can be kicked
    - ‚Äú19 Jan 2038 at 3:14:07 AM‚Äù (End of the word according to Unix | 2^32 seconds after January 1, 1970)
    - The Internet?  Is that thing still around?
    - We are Microsoft.  Resistance Is Futile.  You Will Be Assimilated
    - There are only two industries that refer to their customers as ‚Äòusers‚Äô
    - To iterate is human, to recurse is divine
    - Computer language design is just like a stroll in the park.  Jurassic Park, that is
    - If Java had true garbage collection, most programs would delete themselves upon execution
    - I think there‚Äôs a world market for about 5 computers
    - 640K ought to be enough for anybody
    - If it keeps up, man will atrophy all his limbs but the push-button finger
    - Debugging is an exercise in optimism

    #+begin_src emacs-lisp :var dashboard-quotes=dashboard-displayed-quotes
      (use-package dashboard
        :init
        (setq dashboard-footer-messages dashboard-quotes))
    #+end_src

*** Footer Icons
    #+NAME: dashboard-footer-icons
    | source       | name           |
    |--------------+----------------|
    | nerd-fa      | google         |
    | nerd-fa      | android        |
    | nerd-fa      | steam          |
    | nerd-fa      | gitlab         |
    | nerd-fa      | slack          |
    | nerd-fa      | reddit-alien   |
    | nerd-fa      | cogs           |
    | nerd-fa      | apple          |
    | nerd-weather | hurricane      |
    | nerd-weather | day-sunny      |
    | nerd-weather | snow           |
    | nerd-weather | snowflake-cold |
    | nerd-weather | stars          |
    | nerd-weather | horizon        |
    | nerd-weather | na             |
    | nerd-fa      | firefox        |
    | nerd-fa      | stack-overflow |
    | nerd-fae     | ruby           |
    | nerd-fae     | java           |
    | nerd-fae     | python         |

    #+begin_src emacs-lisp
      (require '+pkg-all-the-icons)
    #+end_src

    #+begin_src emacs-lisp :var dashboard-footer-icon-associations=dashboard-footer-icons
      (use-package all-the-icons
        :config
        (setq dashboard-footer-icon
              (cl-loop for footer-item in dashboard-footer-icon-associations
                       collect
                       (all-the-icons-pad-on-tty-advice+
                        (eval `(+icon ,(intern (nth 0 footer-item))
                                      ,(nth 1 footer-item)
                                      :height 0.75 :v-adjust -0.05
                                      :face 'dashboard-navigator))))))
    #+end_src

*** Dashboard
    #+begin_src emacs-lisp
      (require '+lib-misc)
      (require '+pkg-all-the-icons)

      (use-package dashboard
        :straight t
        :demand t
        :custom
        (inhibit-startup-screen t)
        (dashboard-banner-logo-title "Welcome to Emacs!")
        (dashboard-items '((recents  . 5)
                           (projects . 15)))
        (dashboard-projects-backend
         (if (package! projectile)
             'projectile
           'project-el))
        (dashboard-center-content nil)
        (dashboard-set-navigator  t)
        (dashboard-set-init-info  t)
        (show-week-agenda-p       t)
        (dashboard-show-shortcuts t)
        (dashboard-page-separator "\n\f\n")
        (dashboard-icon-type 'all-the-icons)
        (dashboard-banner-logo-title nil)

        :hide-whitespace+ dashboard-mode

        :preface
        (defun dashboard-defun-shortcut-function+ (func)
          (lambda! ()
            (if (functionp func)
                (funcall-interactively func)
              (user-error "Section using `%s' not yet defined" func))))

        :autoload goto-dashboard+
        :config
        (defun goto-dashboard+ ()
          (or (get-buffer dashboard-buffer-name)
              (progn
                (and
                 ;; creates dashboard buffer as well
                 (dashboard-insert-startupify-lists))
                (get-buffer dashboard-buffer-name))))

        :autoload dashboard-insert-startupify-lists
        :init
        (when (< (length command-line-args) 2)
          (setq initial-buffer-choice #'goto-dashboard+)
          (add-hook 'after-init-hook #'dashboard-insert-startupify-lists))

        :config
        (with-eval-after-load 'org-agenda
          (add-to-list 'dashboard-items '(agenda . 5) t))

        :config
        (setq dashboard-remote-path-icon (all-the-icons-pad-on-tty-advice+
                                          (+icon nerd-cod "radio-tower"))
              dashboard-navigator-buttons
              `((;; line 01
                 (,(all-the-icons-pad-on-tty-advice+
                    (+icon nerd-fa "github" :height 0.75 :v-adjust 0.0))
                  "Homepage"
                  "Browse Homepage"
                  (lambda (&rest _)
                    (browse-url "https://github.com/MoHKale")))
                 (,(all-the-icons-pad-on-tty-advice+
                    (+icon nerd-fa "google" :height 0.75 :v-adjust 0.0))
                  "Google"
                  "Browse Google"
                  (lambda (&rest _)
                    (browse-url "https://www.google.co.uk")))
                 (,(all-the-icons-pad-on-tty-advice+
                    (+icon fileicon "org" :height 0.75 :v-adjust 0.0))
                  "Manual"
                  "Browse Emacs Manual"
                  (lambda (&rest _)
                    (browse-url "https://www.gnu.org/software/emacs/manual/html_node/emacs/index.html")))
                 (,(all-the-icons-pad-on-tty-advice+
                    (+icon nerd-fa "cog" :height 0.75 :v-adjust 0.0))
                  "Update Packages"
                  "Update Packages"
                  #'update-installed-packages)
                 (,(propertize "?" 'face '(:inherit default)) ;; needs a face attribute
                  "" "emacs FAQ" #'view-emacs-faq font-lock-builtin-face))))

        :autoload dashboard-refresh-twice-on-startup+
        :hook (emacs-startup . dashboard-refresh-twice-on-startup+)
        :autoload dashboard-refresh-buffer
        :config
        (defun dashboard-refresh-twice-on-startup+ (&rest _)
          "Force refresh of Emacs dashboard after startup.
      This works around an issue where the font-lock rules for the dashboard are
      incorrect at startup."
          (when-let* ((dash (get-buffer dashboard-buffer-name)))
            (with-current-buffer dash
              (dashboard-refresh-buffer))))

        :custom
        (dashboard-display-icons-p +icons-available)
        (dashboard-set-file-icons +icons-available)
        (dashboard-set-heading-icons +icons-available)
        (dashboard-heading-icons `((recents   . ,(macroexpand '(+icon nerd-fa "file-text")))
                                   (bookmarks . ,(macroexpand '(+icon nerd-oct "bookmark")))
                                   (agenda    . ,(macroexpand '(+icon nerd-oct "calendar")))
                                   (projects  . ,(macroexpand '(+icon nerd-oct "briefcase") ))
                                   (registers . ,(macroexpand '(+icon nerd-oct "database")))))

        :config
        (advice-add 'dashboard-insert-startupify-lists :around #'all-the-icons-pad-families-on-tty-advice+)

        (when +icons-prefer-nerd-font
          (advice-add 'dashboard-insert-heading :around
                      (defun dashboard-insert-heading-use-nerd-fonts+ (func &rest args)
                        (cl-letf (((symbol-function 'all-the-icons-octicon)
                                   #'all-the-icons-nerd-oct))
                          (apply func args)))))

      ;; I maintain a list of banners in my dotfiles that contain plain-text banners
      ;; with embedded ansi escape sequences for color. This was originally written
      ;; for my shell, but also works great as a cover for my emacs dashboard.
        :preface
        (defvar dashboard-prefer-text-banners+ t
          "When true we use text banners even on GUI frames.")

        :autoload dashboard-random-banner+
        :config
        (setq dashboard-startup-banner
              (if (and (not dashboard-prefer-text-banners+)
                       (display-graphic-p))
                  'official
                ;; You can create more banners using [[https://lachlanarthur.github.io/Braille-ASCII-Art/][this]] site.
                (or (ignore-errors
                      (file-expand-wildcards
                       (join-path+ (xdg-config-home) "banners" "*")))
                    '(1 2 3))))

        :autoload dashboard-read-banner+
        :config
        (eval-and-compile (autoload 'ansi-color-apply "ansi-color"))
        (defun dashboard-read-banner+ (path)
          "Load a banner from my ~/.config/banners directory."
          (require 'ansi-color)
          (with-temp-buffer
            (insert-file-contents path)
            (save-excursion
              (goto-char (point-min))
              (cons (save-match-data
                      (if (search-forward-regexp
                           (rx bol (group (+ digit)) ":" (group (+ digit)) eol)
                           (line-end-position) t)
                          (prog1
                              (cons (string-to-number (match-string 1))
                                    (string-to-number (match-string 2)))
                            (forward-line 1))
                        (cons 0 0)))
                    (s-trim-right
                     (ansi-color-apply
                      (buffer-substring (save-excursion
                                          (line-beginning-position))
                                        (point-max))))))))

        :autoload (dashboard-insert-banner+
                   dashboard-choose-banner--support-mk-banner+
                   dashboard--insert-ascii-banner-centered+
                   dashboard-choose-banner)
        :init
        (advice-add 'dashboard-choose-banner :before-until #'dashboard-choose-banner--support-mk-banner+)
        (advice-add 'dashboard-insert-banner :before-until #'dashboard-insert-banner+)
        :config
        (defun dashboard--insert-ascii-banner-centered+ (path)
          (unless (string-suffix-p ".txt" path)
            (when-let* ((banner (dashboard-read-banner+ path)))
              (insert "\n")
              (let* ((start (point))
                     (width  (car (car banner)))
                     (height (cdr (car banner)))
                     (content (cdr banner))
                     (prefix `(space . (:align-to (- center ,(/ width 2))))))
                (insert content)
                (add-text-properties
                 start (point) `(line-prefix ,prefix wrap-prefix ,prefix)))))
            t)

        (defun dashboard-choose-banner--support-mk-banner+ (banner)
          (when (and (stringp banner)
                     (not (string-suffix-p ".txt" banner))
                     (not (ignore-errors (image-type banner))))
            (list :mohkale banner)))

        (defun dashboard-insert-banner+ ()
          (when-let* ((banner (dashboard-choose-banner dashboard-startup-banner))
                      (is-custom (eq (car banner) :mohkale)))
            (prog1 t
              (goto-char (point-max))
              (let ((buffer-read-only nil))
                (dashboard--insert-ascii-banner-centered+ (cadr banner))))))

        :general
        (:keymaps 'dashboard-mode-map
         :states  'motion
         [remap evil-next-line]          'dashboard-next-line
         [remap evil-previous-line]      'dashboard-previous-line
         [remap evil-forward-paragraph]  'dashboard-next-section
         [remap evil-backward-paragraph] 'dashboard-previous-section

         "<down-mouse-1>" 'widget-button-click

         "x"     'dashboard-remove-item-under
         "gj"    'dashboard-next-section
         "gk"    'dashboard-previous-section
         "RET"   'dashboard-return
         "TAB"   'widget-forward
         "S-TAB" 'widget-backward

         "r" (dashboard-defun-shortcut-function+ 'dashboard-jump-to-recents)
         "m" (dashboard-defun-shortcut-function+ 'dashboard-jump-to-bookmarks)
         "p" (dashboard-defun-shortcut-function+ 'dashboard-jump-to-projects)
         "e" (dashboard-defun-shortcut-function+ 'dashboard-jump-to-registers)
         "a" (dashboard-defun-shortcut-function+ 'dashboard-jump-to-agenda)))
    #+end_src

*** Appendix
   #+begin_src emacs-lisp
     (provide '+pkg-dashboard)
   #+end_src

** VC Mode                                                          :builtin:
   :PROPERTIES:
   :header-args+: :tangle (lisp! "+pkg-vc-mode.el")
   :END:

   #+begin_src emacs-lisp :tangle yes
     (require '+pkg-vc-mode)
   #+end_src

   Version control integration package for Emacs.

   #+DESCRIPTION: Some badly named commands exposed by vc-mode.
   | Command                  | Description                                  |
   |--------------------------+----------------------------------------------|
   | =vc-annotate=              | History of current file                      |
   | =vc-diff=                  | Diff current file                            |
   | =vc-dir=                   | Status of directory                          |
   | =vc-ediff=                 | Ediff current file                           |
   | =vc-ignore=                | Prompt and exclude file                      |
   | =vc-log-incoming=          | Log for pull commits                         |
   | =vc-log-outgoing=          | Log for push commits                         |
   | =vc-next-action=           | Makes a commit... annoyingly named           |
   | =vc-print-log=             | Log of commits affecting current file        |
   | =vc-print-root-log=        | Log of all commits in project                |
   | =vc-region-history=        | Log of commits affecting region in file      |
   | =vc-register=              | Add file                                     |
   | =vc-revert=                | Undo changes to working files... Permenently |
   | =vc-revision-other-window= | View file in previous tag/commit             |
   | =vc-switch-backend=        | Not using git... for shame :P                |

   #+BEGIN_SRC emacs-lisp
     (require '+pkg-evil)
     (require '+lib-misc)
     (eval-when-compile (require '+lib-host-environment))

     (use-package vc
       :init
       ;; On Windows, we must use Git GUI to enter username and password. See [[https://github.com/magit/magit/wiki/FAQ#windows-cannot-push-via-https][here]].
       (when (windows-p+)
         (setenv "GIT_ASKPASS" "git-gui--askpass"))

       :hide-whitespace+
       vc-annotate-mode
       vc-git-log-view-mode

       :custom
       (vc-handled-backends '(Git))

       :config
       (require 'vc-git) ;; supported

       (advice-add 'vc-region-history :after (lambda (&rest _)
                                               (when (evil-visual-state-p)
                                                 (evil-exit-visual-state))))

       (evil-set-initial-state 'vc-git-region-history-mode 'motion)
       (evil-set-initial-state 'vc-git-log-view-mode 'motion)
       (evil-set-initial-state 'vc-git-log-edit-mode 'insert)                        ; making commits... why name it log :P
       (evil-set-initial-state 'vc-dir-mode 'motion)                                 ; check status of files for an entire directory
       (evil-set-initial-state 'vc-annotate-mode 'motion)                            ; pops up a buffer showing the most recent changes for every line in the current file alongside the commit which made those changes.

       :leader
       (:prefix leader-diff-leader-prefix+
        "v" 'vc-diff)
       (:prefix "g"
        "a" 'vc-annotate
        "r" 'vc-revision-other-window
        "=" 'vc-root-diff
        "v" 'vc-region-history
        "h" 'vc-print-log
        "l" 'vc-print-root-log
        "u" 'vc-revert
        "#" 'vc-create-tag
        "d" 'vc-dir)

       :lazy-leader
       (:mode 'vc-annotate-mode
        "m"     'vc-next-action
        "l"     'vc-annotate-show-log-revision-at-line
        "d"     'vc-annotate-show-diff-revision-at-line
        "D"     'vc-annotate-show-changeset-diff-revision-at-line
        "t"     'vc-annotate-toggle-annotation-visibility

        "g"     '(:ignore t :wk "goto")
        "gg"    'vc-annotate-goto-line
        "gc"    'vc-annotate-revision-at-line
        "gp"    'vc-annotate-revision-previous-to-line
        "gl"    'vc-annotate-show-log-revision-at-line
        "gG"    'vc-annotate-working-revision
        "g SPC" 'vc-annotate-working-revision)
       (:mode 'vc-dir-mode
        "i" 'vc-log-incoming
        "o" 'vc-log-incoming
        "l" 'vc-print-log
        "L" 'vc-print-root-log
        "D" 'vc-root-diff
        "d" 'vc-diff
        "h" 'vc-dir-hide-up-to-date
        "u" 'vc-update                                                               ; don't understand
        "m" 'vc-next-action)
       (:mode '(vc-git-region-history-mode vc-git-log-view-mode)
        "p" 'log-view-diff-changeset
        "a" 'log-view-annotate-version
        "m" 'log-view-toggle-mark-entry
        "s" 'diff-goto-source)
       (:mode 'vc-git-log-edit-mode
        "d" 'log-edit-show-diff
        "f" 'log-edit-show-files
        "?" 'log-edit-mode-help
        "SPC" 'log-edit-done
        "DEL" 'log-edit-kill-buffer

        "i"  '(:ignore t :wk "insert")
        "ic" 'log-edit-insert-changelog
        "if" 'log-edit-insert-filenames
        "iC" 'log-edit-insert-changelog-entries
        "iT" 'log-edit-insert-cvs-rcstemplate
        "it" 'log-edit-insert-cvs-template
        "iF" 'log-edit-insert-filenames-without-changelog
        "im" 'log-edit-insert-message-template

        "t"  '(:ignore t :wk "toggle")
        "ta" 'vc-git-log-edit-toggle-amend
        "ts" 'vc-git-log-edit-toggle-signoff)

       :general
       (:states  'normal
        :keymaps 'vc-git-log-edit-mode-map
        "C-q" 'log-edit-kill-buffer
        "M-s" 'log-edit-next-comment
        "M-r" 'log-edit-previous-comment
        "C-s" 'log-edit-comment-search-forward
        "C-r" 'log-edit-comment-search-backward
        "M-0" 'evil-beginning-of-line)
       (:states  'motion
        :keymaps 'vc-annotate-mode-map
        "gj" 'vc-annotate-prev-revision ;; older revisions
        "gk" 'vc-annotate-next-revision ;; newer revisions
        "C-t" 'vc-annotate-toggle-annotation-visibility
        "RET" 'vc-annotate-goto-line

        "d" 'vc-annotate-show-diff-revision-at-line
        "D" 'vc-annotate-show-changeset-diff-revision-at-line
        "t" 'vc-annotate-toggle-annotation-visibility)
       (:states  'motion
        :keymaps 'vc-dir-mode-map

        "a" 'vc-register ;; git add FILE
        "d" 'vc-diff
        "=" 'vc-diff
        "Q" 'vc-dir-kill-dir-status-process
        "i" 'vc-dir-ignore
        "x" 'vc-dir-kill-line

        ;; vc-dir-search
        "C-s" 'vc-dir-isearch-regexp
        "M-s" 'vc-dir-query-replace-regexp

        "A" 'vc-dir-mark-all-files
        "m" 'vc-dir-mark
        "U" 'vc-dir-unmark-all-files
        "u" 'vc-dir-unmark
        ;; "t" 'vc-dir-toggle-mark ;; mouse event
        "<backspace>" 'vc-dir-unmark-file-up

        "p" 'vc-pull
        "P" 'vc-push

        "o"   'vc-dir-display-file
        "RET" 'vc-dir-find-file

        "gj" 'vc-dir-next-line
        "gk" 'vc-dir-previous-line
        "M-j" 'vc-dir-next-directory
        "M-k" 'vc-dir-previous-directory)
       (:states  'motion
        :keymaps '(vc-git-region-history-mode-map
                   vc-git-log-view-mode-map)

        "q" nil
        "d" 'log-view-diff
        "=" 'log-view-diff
        "o" 'log-view-find-revision ; open current file at current commit

        "<return>" 'log-view-toggle-entry-display
        "<tab>"    'log-view-toggle-entry-display

        ;; move to next message, then reallign to top
        ;; (kbd "C-j") (lambda! (log-view-msg-next)
        ;;               (call-interactively 'evil-scroll-line-to-top))
        "gj" 'log-view-msg-next
        "gk" 'log-view-msg-prev

        "M-j" 'log-view-file-next
        "M-k" 'log-view-file-prev

        "gl" 'diff-hunk-next
        ;; TODO reallign diff to propper location on move down without trapping on a single diff
        ;; (kbd "M-j") (lambda! (diff-hunk-next)
        ;;               (call-interactively 'evil-scroll-line-to-top)
        ;;               (evil-previous-line 3))
        "gh" (lambda! (diff-hunk-prev) (evil-previous-line 3)))

       :preface
       (declare-function diff-hunk-prev "diff-mode"))
   #+END_SRC

   #+begin_src emacs-lisp
     (provide '+pkg-vc-mode)
   #+end_src

** Auto Insert
   :PROPERTIES:
   :header-args+: :tangle (lisp! "+pkg-auto-insert.el")
   :END:

   Automatically insert some text into newly made files and buffers.
   Can define templates using skeletons, see [[info:autotype#Skeleton Language][Skeleton Language]].

   #+begin_src emacs-lisp :tangle yes
     (require '+pkg-auto-insert)
   #+end_src

*** Auto Insert                                                     :builtin:
    #+begin_src emacs-lisp
      (use-package autoinsert
        :leader ("ia" 'auto-insert)
        :custom
        (auto-insert-directory (etc! "auto-insert"))
        (auto-insert-query nil)

        :hook (nxml-mode . auto-insert)
        :preface
        (declare-function nxml-insert-xml-declaration "nxml-mode")
        :config
        (define-auto-insert 'nxml-mode #'nxml-insert-xml-declaration))
    #+end_src

*** Auto Insert Yasnippet                                          :optional:
    :PROPERTIES:
    :header-args+: :tangle (package-lisp! +pkg-auto-insert yasnippet)
    :END:
    Auto insert yasnippet snippets.

    This code section defines a macro =autoinsert-register-yas+=. You can call it
    from =.yas-setup.el= file to define a autoinsert handler using a yasnippet
    snippet.

    #+begin_src emacs-lisp
      (use-package autoinsert
        :init
        ;; Adapted from [[https://gist.github.com/jrnold/675584][here]].
        (defmacro autoinsert-register-yas+ (regex mode uuid)
          "Register an autoinsert handler for MODE using yasnippet UUID.
      REGEX should be a regular expression matching the files in which this handler
      should run. MODE is the major-mode the snippet is defined in. UUID is the name
      of the snippet in MODE."
          `(with-eval-after-load 'autoinsert
             (define-auto-insert ,regex
               (lambda () (autoinsert-expand-yas+ ,mode ,uuid))))))

      (use-package yasnippet
        :autoload (autoinsert-expand-yas+
                   yas--get-template-by-uuid
                   yas--template-content
                   yas-expand-snippet)
        :config
        (defun autoinsert-expand-yas+ (mode uuid)
          (if-let* ((snippet (yas--get-template-by-uuid mode uuid)))
              (yas-expand-snippet (yas--template-content snippet))
            (user-error "Failed to find snippet %s/%s" mode uuid))))
    #+end_src

*** Appendix
    #+begin_src emacs-lisp
      (provide '+pkg-auto-insert)
    #+end_src

** Tabulated List Mode                                              :builtin:
   :PROPERTIES:
   :header-args+: :tangle (lisp! "+pkg-tabulated-list-mode.el")
   :END:

    #+begin_src emacs-lisp :tangle yes
      (require '+pkg-tabulated-list-mode)
    #+end_src

    #+begin_src emacs-lisp
      (require '+pkg-evil)

      (use-package tabulated-list
        :hook (tabulated-list-mode . hl-line-mode)

        :init
        (evil-set-initial-state 'tabulated-list-mode 'motion)

        :general
        (:keymaps 'tabulated-list-mode-map
         "SPC" nil "0" nil "<" nil ">" nil "?" nil "g" nil "h" nil
         "n" nil "p" nil "DEL" nil "S-SPC" nil)

        :autoload tabulated-list--get-column-widths+
        :config
        (defun tabulated-list--get-column-widths+ ()
          "return a list of all the "
          (mapcar (lambda (x) (+ (nth 1 x)
                                 (or (plist-get (cdr x) :pad-right) 1)))
                  tabulated-list-format))

        :autoload tabulated-list--get-column-pivots+
        :config
        (defun tabulated-list--get-column-pivots+ ()
          (let (prev values)
            (setq values (mapcar (lambda (x)
                                   (let ((new-val (+ x (or prev 0))))
                                     (setq prev new-val)
                                     new-val))
                                 (tabulated-list--get-column-widths+)))
            ;; (mapcar (lambda (x) (- x 1)) values)
            values))

        :autoload tabulated-list--properties+
        :config
        (defun tabulated-list--properties+ ()
          (let* ((current-column-position (- (point)
                                             (line-beginning-position)))
                 (column-pivots (tabulated-list--get-column-pivots+))
                 (column-count (length column-pivots))
                 (preceding-columns (seq-filter
                                     (lambda (x)
                                       (<= x current-column-position))
                                     column-pivots))
                 (following-columns (nthcdr (length preceding-columns)
                                            column-pivots))
                 (current-column (car following-columns))
                 (following-columns (cdr following-columns)))
            `(:current-column-position ,current-column-position
                                       :column-pivots           ,column-pivots
                                       :column-count            ,column-count
                                       :preceding-cols          ,preceding-columns
                                       :current-column          ,current-column
                                       :following-cols          ,following-columns)))

        :commands tabulated-list-next-column+
        :config
        ;; Doesn't work when row contains truncated entries, such as buffers with a
        ;; "name..." entry, because those dots aren't included in the width of the
        ;; column.
        (defun tabulated-list-next-column+ (&optional count)
          "Moves to the next column shown by tabulated list mode."
          (interactive)
          (or count (setq count 1))

          (when tabulated-list-format
            (let* ((properties (tabulated-list--properties+))
                   (line-step (floor (/ count
                                        (plist-get properties :column-count)))))
              ;; move however many lines it takes to reach row with desired column
              (unless (zerop line-step)
                (forward-line line-step))

              (unless (eobp)
                (cond
                 ((eq (point) (line-end-position))
                  ;; when at the end of the last column, goto next row
                  (forward-line)
                  (goto-char (line-beginning-position)))
                 ((not (plist-get properties :following-cols))
                  ;; no next column, goto end of current
                  (goto-char (line-end-position)))
                 (t
                  ;; goto next column from the end of the current one
                  (goto-char (+ (line-beginning-position)
                                (plist-get properties :current-column)))))))))

        (advice-add 'tabulated-list-next-column :override #'tabulated-list-next-column+))
    #+end_src

    #+begin_src emacs-lisp
      (provide '+pkg-tabulated-list-mode)
    #+end_src

** iAlign
   :PROPERTIES:
   :header-args+: :tangle (lisp! "+pkg-ialign.el")
   :END:

    #+begin_src emacs-lisp :tangle yes
      (require '+pkg-ialign)
    #+end_src

   #+BEGIN_SRC emacs-lisp
     (require '+pkg-evil)
     (eval-when-compile (require '+lib-misc))

     (use-package ialign
       :straight t
       :autoload ialign

       :commands evil-ialign+
       :config
       (evil-define-operator evil-ialign+ (beg end)
         "Run ialign using evil motions."
         :type        line
         :repeat      nil
         :move-point  t
         :keep-visual nil
         (ialign beg end))

       :leader
       ("x TAB" 'evil-ialign)

       :general
       (:states 'normal
        "g TAB" 'evil-ialign+)
       (:keymaps 'ialign-minibuffer-keymap
        ;; "" 'ialign-toggle-repeat
        "M-k"        'ialign-increment-spacing
        "M-j"        'ialign-decrement-spacing
        "M-h"        'ialign-decrement-group
        "M-l"        'ialign-increment-group
        "<M-up>"     'ialign-increment-spacing
        "<M-down>"   'ialign-decrement-spacing
        "<M-left>"   'ialign-decrement-group
        "<M-right>"  'ialign-increment-group
        "C-SPC"      'ialign-set-spacing
        "<C-tab>"    'ialign-toggle-tabs
        "<C-return>" 'ialign-set-group
        "C-h"        'backward-char
        "C-l" (lambda ()
                (interactive)
                (call-interactively (if (eolp)
                                        'exit-minibuffer
                                      'forward-char)))))
   #+END_SRC

    #+begin_src emacs-lisp
      (provide '+pkg-ialign)
    #+end_src

** Completion List Mode                                             :builtin:
   The Emacs builtin completion facilities. It pops up a buffer with completion
   candidates. I never use this, but lets configure it anyways.

   #+begin_src emacs-lisp
     (use-package simple
       :general
       (:keymaps 'completion-list-mode-map
        :states  'motion
        "RET" 'choose-completion
        "C-j" 'choose-completion

        "q" nil
        "Q" 'delete-completion-window

        "j" 'next-completion
        "k" 'previous-completion
        "n" 'next-completion
        "p" 'previous-completion
        "N" 'previous-completion))
   #+end_src

** Indent Tabs Mode                                                 :builtin:
   #+begin_src emacs-lisp
     (use-package simple
       :init
       (add-to-list 'minor-mode-alist '(indent-tabs-mode " \\t") t))
   #+end_src

** GGTags                                                          :optional:
   :PROPERTIES:
   :header-args+: :tangle (package-lisp! +pkg-ggtags ggtags)
   :END:

   Tags are the classic source-code navigation system that predates LSP.

   While not as reliable as LSP it's generally lighter and easier to use across
   multiple languages/file-types and to just list semantic constructs in your
   code base. It also scales much better to massive repositories such as Linux
   compared to an LSP server trying to index it itself.

   GNU Global is the GNU source code tagging system with support for other tag-parsers
   through [[https://www.gnu.org/software/global/globaldoc_toc.html#Plug_002din][plugins]] such as Universal ctags. =ggtags= is the Emacs interface to global with
   support for automatically updating the tag database on file-saves and eldoc+xref
   integration.

   #+begin_src emacs-lisp :tangle (package-yes! ggtags)
     (require '+pkg-ggtags)
   #+end_src

   #+begin_src emacs-lisp
     (require '+pkg-project)

     (use-package ggtags
       :straight t
       :custom
       (ggtags-highlight-tag nil)

       :commands ggtags-mode
       :preface
       (defun ggtags-enable-in-projects+ ()
         "Enable `ggtags-mode' when opening a file in a project with a GTAGS file."
         (unless (bound-and-true-p ggtags-mode)
           (when-let* ((root (project-current-root+)))
             (when (file-exists-p (concat root "GTAGS"))
               (ggtags-mode +1)))))
       :hook (find-file . ggtags-enable-in-projects+)

       :config
       :leader
       ("gts" 'ggtags-grep
        "gtx" 'ggtags-delete-tags
        "gtr" 'ggtags-update-tags
        "gtq" 'ggtags-query-replace
        "gtm" 'ggtags-mode)

       :lazy-leader
       (:mode 'ggtags-global-mode ; NOTE ggtags-global-mode is not a global mode... global is for GNU *global* tagging system
        "r" 'recompile
        "f" 'next-error-follow-minor-mode))

     (use-package +pkg-compile
       :config
       (push 'ggtags-global-mode compilation-auto-kill-ignore-modes+))

     ;; Make ggtags highlight code through org-src. See [[https://github.com/leoliu/ggtags/issues/212][ggtags#212]].
     (use-package org-src
       :straight org
       :init
       (advice-add 'ggtags-fontify-code :override #'ggtags-fontify-code-with-org+)

       :autoload (ggtags-fontify-code-with-org+
                  org-src-font-lock-fontify-block)
       :config
       (defun ggtags-fontify-code-with-org+ (code &optional mode)
         (or mode (setq mode major-mode))
         (if (stringp code)
             (let* ((lang (s-chop-suffix "-mode" (symbol-name mode)))
                    ;; Fallback to default-face not org-block-face.
                    (org-src-block-faces `((,lang . (default)))))
               (with-temp-buffer
                 (insert code)
                 (org-src-font-lock-fontify-block lang (point-min) (point-max))
                 (buffer-substring (point-min) (point-max))))
           code)))
   #+end_src

   #+begin_src emacs-lisp
     (provide '+pkg-ggtags)
   #+end_src

** View Mode                                                       :optional:
   #+BEGIN_SRC emacs-lisp
     (use-package view
       :general
       (:keymaps 'view-mode-map
        :states  'normal
        [remap quit-window] 'View-quit
        "Q" 'View-quit-all
        "G" 'View-scroll-to-buffer-end
        "zq" 'View-exit
        "zk" 'View-kill-and-leave
        "gj" 'View-scroll-line-forward
        "gk" 'View-scroll-line-backward
        ;; "C-d" 'View-scroll-half-page-forward
        ;; "C-u" 'View-scroll-half-page-backward
        "M-d" 'View-scroll-page-forward
        "M-u" 'View-scroll-page-backward))
   #+END_SRC

** Tab Bar Mode                                            :builtin:optional:
   :PROPERTIES:
   :header-args+: :tangle (package-lisp! +pkg-tab-bar tab-bar)
   :END:

    #+begin_src emacs-lisp :tangle (package-yes! tab-bar)
      (require '+pkg-tab-bar)
    #+end_src

    #+begin_src emacs-lisp
      (require '+pkg-all-the-icons)

      (use-package tab-bar
        :hook (after-init . tab-bar-mode)
        :custom
        (tab-bar-new-button-show t)
        (tab-bar-tab-name-truncated-max 20)
        (tab-bar-tab-name-ellipsis "‚Ä¶")
        (tab-bar-new-button-show nil)

        :preface
        (defvar tab-bar-separator+ "‚ñå" ;; '("‚ñå" . "‚ñê")
          "Left and right separator for active tab-bar indicators.")

        (defvar tab-bar-inactive-separator+ "‚ñè" ;; '("‚ñè" . "‚ñï")
          "Left and right separator for inactive tab-bar indicators.")

        (setq tab-bar-separator tab-bar-inactive-separator+)

        (defvar tab-bar-show-tab-icons+ +icons-available
          "Shows icons for tab-bar indicators.")

        :config
        (setq tab-bar-close-button (propertize
                                     (all-the-icons-pad-on-tty-advice+
                                      (+icon nerd-fa "times"))
                                    'display
                                    (get-text-property 0 'display tab-bar-close-button))
              tab-bar-back-button (all-the-icons-pad-on-tty-advice+
                                   (+icon nerd-fa "arrow-circle-left"))
              tab-bar-forward-button (all-the-icons-pad-on-tty-advice+
                                      (+icon nerd-fa "arrow-circle-right")))

        :custom
        (tab-bar-format '(tab-bar-format-history
                          tab-bar-format-tabs
                          tab-bar-separator
                          tab-bar-format-add-tab))

        :autoload tab-bar-center-with+
        :config
        (defun tab-bar-center-with+ (len s &rest props)
          (let ((extra (max 0 (- len (length s)))))
            (concat
             (apply #'propertize (make-string (ceiling extra 2) ? ) props)
             s
             (apply #'propertize (make-string (floor extra 2) ? ) props))))

        :autoload tab-bar-tab-name-format-function+
        :config
        (defun tab-bar-tab-name-format-function+ (tab i)
          (let* (;; (current-p (eq (car tab) 'current-tab))
                 (face (funcall tab-bar-tab-face-function tab))
                 (name (propertize (alist-get 'name tab) 'face face))
                 (icon (all-the-icons-pad-on-tty-advice+
                        (propertize
                         (or (ignore-errors
                               (and name
                                    (+icon-for buffer name)))
                             (+icon nerd-mdi "buffer"))
                         'face face)
                        (propertize " " 'face face))))
            (concat (propertize (if tab-bar-tab-hints (format "%d " i) "") 'face face)
                    (propertize
                     (if (< (length name) tab-bar-tab-name-truncated-max)
                         (tab-bar-center-with+ (+ (length icon) 1 tab-bar-tab-name-truncated-max)
                                         (concat icon (propertize " " 'face face) name)
                                         'face face)
                       (concat icon (propertize " " 'face face)
                               (s-truncate tab-bar-tab-name-truncated-max name
                                           (propertize tab-bar-tab-name-ellipsis 'face face))))
                     'help-echo name))))

        (setq tab-bar-tab-name-format-function #'tab-bar-tab-name-format-function+)

        :autoload tab-bar--format-tab+
        :config
        (defun tab-bar--format-tab+ (tab i)
          (let ((current-tab-p (eq (car tab) 'current-tab))
                (face (funcall tab-bar-tab-face-function tab)))
            (append
             (when-let* ((sep (cond
                               (current-tab-p (propertize tab-bar-separator+ 'face 'tab-bar-separator))
                               ((eq i 1) (propertize " " 'face face))
                               (t (propertize tab-bar-inactive-separator+ 'face 'tab-bar-inactive-separator)))))
               `((,(intern (format "sep-%i" i)) menu-item ,sep ignore)))
             (let ((name (funcall tab-bar-tab-name-format-function tab i)))
               (cond
                (current-tab-p
                 `((current-tab menu-item ,name ignore :help "Current tab")))
                (t
                 `((,(intern (format "tab-%i" i))
                    menu-item
                    ,name
                    ,(or
                      (alist-get 'binding tab)
                      `(lambda ()
                         (interactive)
                         (tab-bar-select-tab ,i)))
                    :help "Click to visit tab")))))
             `((,(if current-tab-p 'C-current-tab (intern (format "C-tab-%i" i)))
                menu-item ,(propertize
                            (or (and tab-bar-close-button-show
                                     (not (eq tab-bar-close-button-show
                                              (if current-tab-p 'non-selected 'selected)))
                                     tab-bar-close-button)
                                "")
                            'face face)
                ,(or
                  (alist-get 'close-binding tab)
                  `(lambda ()
                     (interactive)
                     (tab-bar-close-tab ,i)))
                :help "Close tab")))))

        (advice-add #'tab-bar--format-tab :override #'tab-bar--format-tab+)

        :leader ("tt" 'tab-bar-mode)
        :general
        (:prefix "C-t"
         :states '(normal motion)
         "" '(nil :wk "tab-bar")
         "C-n" 'tab-bar-switch-to-next-tab
         "C-p" 'tab-bar-switch-to-prev-tab
         "C-t" 'tab-bar-new-tab
         "C-c" 'tab-bar-duplicate-tab
         "r" 'tab-bar-rename-tab
         "g" 'tab-bar-select-tab-by-name
         "h" 'toggle-frame-tab-bar
         "C-w" 'tab-bar-close-tab
         "x" 'tab-bar-close-tab
         "X" 'tab-bar-close-other-tabs
         "<left>" 'tab-bar-history-back
         "<right>" 'tab-bar-history-forward
         ;; tab-bar-history-mode
         ;; tab-bar-move-tab
         ;; tab-bar-new-tab-to
         ;; tab-bar-move-tab-to
         ;; tab-bar-close-group-tabs
         ;; tab-bar-change-tab-group
         ;; tab-bar-move-tab-to-frame
         ;; tab-bar-move-tab-to-group
         ;; tab-bar-close-tab-by-name
         ;; tab-bar-rename-tab-by-name
         ;; tab-bar-switch-to-last-tab
         ;; tab-bar-switch-to-recent-tab
         )
        )
    #+end_src

    #+begin_src emacs-lisp
      (provide '+pkg-tab-bar)
    #+end_src

** Yasnippet
   :PROPERTIES:
   :header-args+: :tangle (package-lisp! +pkg-yasnippet yasnippet)
   :END:

    #+begin_src emacs-lisp :tangle (package-yes! yasnippet)
      (require '+pkg-yasnippet)
    #+end_src

   Yet another snippets framework... but amazingly powerful. :-P.

*** Yasnippet
    #+BEGIN_SRC emacs-lisp
      (use-package yasnippet
        :straight t
        :diminish yas-minor-mode
        :defer 30
        :custom
        (yas-triggers-in-field t)
        (yas-snippet-dirs (list (etc! "snippets/")))

        :commands yas-global-mode
        :config (yas-global-mode 1)

        :general
        (:states 'insert
         [C-i] 'yas-expand
         "M-I" 'yas-expand)
        (:keymaps 'yas-keymap
         "<C-return>" 'yas-next-field
         "<C-M-return>" 'yas-prev-field
         ;; Prevent tab from expanding
         "TAB"   'yas-next-field
         "<tab>" 'yas-next-field)

        :leader
        ("isn" 'yas-new-snippet
         "fS" 'yas-visit-snippet-file)
        :lazy-leader
        (:mode 'snippet-mode
         "m" 'yas-load-snippet-buffer-and-close
         "l" 'yas-load-snippet-buffer
         "t" 'yas-tryout-snippet))
    #+END_SRC

*** Snippets
    See the snippet [[https://joaotavora.github.io/yasnippet/snippet-development.html#org6796ab7][dev]] guide.

   #+BEGIN_SRC emacs-lisp :tangle (package-yes! yasnippet)
     ;; <<tangle-snippets()>>
   #+END_SRC

   #+NAME: tangle-snippets
   #+BEGIN_SRC emacs-lisp :tangle no :exports none
     (org-babel-tangle-file (etc! "snippets.org"))
   #+END_SRC

*** Auto Yasnippet
    Allows you to create dynamic/in-place snippets and repeatedly execute them.

    #+BEGIN_SRC emacs-lisp
      (use-package auto-yasnippet
        :straight t
        :leader
        ("is"  '(:ignore t :wk "auto-yasnippet")
         "isc" 'aya-create
         "ise" 'aya-expand
         "isw" 'aya-persist-snippet)

        :general
        (:states 'insert
         "M-i" 'aya-expand))
    #+END_SRC

*** Auto Activating Snippets
    Tracks what you enter into a buffer, and if it matches some pattern then it
    automatically expands a snippet.

    #+begin_src emacs-lisp
      (use-package aas
        :straight t)
    #+end_src

*** Latex Auto Activating Snippets
    :PROPERTIES:
    :header-args+: :tangle (package-lisp! +pkg-yasnippet yasnippet latex)
    :END:
    Latex snippets courtesy of [[https://github.com/tecosaur/LaTeX-auto-activating-snippets][laas]].

    #+BEGIN_SRC emacs-lisp
      (use-package laas
        :straight t
        :hook ((org-mode . aas-activate-for-major-mode)
               (org-mode . laas-mode)
               (LaTeX-mode . laas-mode))
        :init
        (put 'aas-set-snippets 'lisp-indent-function 'defun)

        :autoload (aas-set-snippets
                   laas-mathp)
        :config
        (aas-set-snippets 'laas-mode
          :cond #'laas-mathp
          "On"    "\\mathcal{O}(n)"
          "O1"    "\\mathcal{O}(1)"
          "Olog"  "\\mathcal{O}(\\log n)"
          "Olon"  "\\mathcal{O}(n \\log n)"
          "mod"   "\\mod"
          ;; "<<"    nil
          )
        )
    #+END_SRC

*** Appendix
    #+begin_src emacs-lisp
      (provide '+pkg-yasnippet)
    #+end_src

** Abbrev                                                  :builtin:optional:
   :PROPERTIES:
   :header-args+: :tangle (package-lisp! +pkg-abbrev abbrev)
   :END:

    #+begin_src emacs-lisp :tangle (package-yes! abbrev)
      (require '+pkg-abbrev)
    #+end_src

*** Abbrev
    #+begin_src emacs-lisp
      (use-package abbrev
        :hook ((org-mode
                lisp-interaction-mode
                TeX-mode LaTeX-mode
                go-mode go-ts-mode
                python-mode python-ts-mode
                csharp-mode csharp-ts-mode
                js-mode js2-mode js-jsx-mode typescript-react-mode typescript-mode typescript-ts-mode tsx-mode
                c-mode c-ts-mode c++-mode c++-ts-mode)
               . abbrev-mode)

        :custom
        (abbrev-file-name (etc! "abbrev.el"))
        (save-abbrevs 'silently)
        (evil-want-abbrev-expand-on-insert-exit nil)

        :autoload quietly-read-abbrev-file
        :config (quietly-read-abbrev-file)

        :leader
        (:prefix "ip"
         "" '(:ignore t :wk "abbrev")
         "r" 'read-abbrev-file
         "w" 'write-abbrev-file
         "e" 'edit-abbrevs
         "a" 'add-mode-abbrev
         "g" 'add-global-abbrev
         "l" 'list-abbrevs)
        ;; :general
        ;; (:prefix "C-x"
        ;;  [C-i] 'dabbrev-expand)
        )
    #+end_src

*** Abbrev Tables
    #+begin_src emacs-lisp
      (use-package abbrev
        :hook (git-commit-mode . abbrev-mode)
        :config
        (defvar +abbrev-mode-text-mode-parent-tables (list text-mode-abbrev-table))

        :config
        (defvar git-commit-mode-abbrev-table+)
        (define-abbrev-table 'git-commit-mode-abbrev-table+ '()
          :parents +abbrev-mode-text-mode-parent-tables)
        (abbrev-table-put git-commit-mode-abbrev-table+ :parents +abbrev-mode-text-mode-parent-tables)
        (push `(git-commit-mode . ,git-commit-mode-abbrev-table+)
              abbrev-minor-mode-table-alist)

        :config
        (defvar lisp-interaction-mode-abbrev-table)
        (define-abbrev-table 'lisp-interaction-mode-abbrev-table '()
          :parents +abbrev-mode-text-mode-parent-tables)

        :config
        (use-package tex-mode
          :config
          (abbrev-table-put tex-mode-abbrev-table :parents +abbrev-mode-text-mode-parent-tables))

        (use-package auctex
          :config
          (abbrev-table-put latex-mode-abbrev-table :parents +abbrev-mode-text-mode-parent-tables))

        ;; C++ and C have a common base table defined instead of using the mode directly.
        ;; This is because [[elisp:(find-library "cc-mode.el")]] adds some special hooks to
        ;; the builtin abbrevs and these aren't compatible with tree-sitter mode which
        ;; I've setup to inherit from these base modes.
        (defvar c-base-mode-abbrev-table)
        (defvar c++-base-mode-abbrev-table)
        (abbrev-table-put c++-base-mode-abbrev-table :parents (list c-base-mode-abbrev-table))
        (use-package cc-mode
          :config
          (abbrev-table-put c++-mode-abbrev-table :parents (list c++-base-mode-abbrev-table
                                                                 c-mode-abbrev-table))
          (abbrev-table-put c-mode-abbrev-table :parents (list c-base-mode-abbrev-table)))

        (use-package js2-mode
          :config
          (abbrev-table-put js2-mode-abbrev-table :parents (list js-mode-abbrev-table)))

        (use-package typescript-mode
          :config
          (abbrev-table-put typescript-mode-abbrev-table :parents (list js-mode-abbrev-table))))
    #+end_src

*** Appendix
    #+begin_src emacs-lisp
      (provide '+pkg-abbrev)
    #+end_src

** License Templates                                               :optional:
   :PROPERTIES:
   :header-args+: :tangle (package-lisp! +pkg-license-templates license-templates)
   :END:

   Generate project licenses using the GitHub LICENSE API.

   #+begin_src emacs-lisp :tangle (package-yes! license-templates)
     (require '+pkg-license-templates)
   #+end_src

   #+begin_src emacs-lisp
     (use-package license-templates
       :straight t
       :leader ("ih" 'license-templates-new-file))
   #+end_src

   #+begin_src emacs-lisp
     (provide '+pkg-license-templates)
   #+end_src

** Man/Woman                                                        :builtin:
   :PROPERTIES:
   :header-args+: :tangle (lisp! "+pkg-man.el")
   :END:

   #+begin_src emacs-lisp :tangle yes
     (require '+pkg-man)
   #+end_src

   #+begin_src emacs-lisp
     (use-package man
       :custom (Man-notify-method 'pushy "Open manual buffer in the current window")
       :leader
       ("am" +man-command))
   #+end_src

   #+begin_src emacs-lisp
     (provide '+pkg-man)
   #+end_src

** Dape                                                                 :wip:
   :PROPERTIES:
   :header-args+: :tangle (package-lisp! +pkg-dape dape)
   :END:

   #+begin_src emacs-lisp :tangle (package-yes! dape)
     (require '+pkg-dape)
   #+end_src

*** Dape
    #+begin_src emacs-lisp
      (use-package dape
        :straight t
        :hide-whitespace+
        dape-repl-mode
        dape-info-parent-mode
        :custom
        (dape-adapter-dir (cache! "dape" "adapters"))
        (dape-inlay-hints nil)
        (dape-info-hide-mode-line t)
        (dape-default-breakpoints-file (cache! "dape" "dape-breakpoints"))
        (dape-display-source-buffer-action
         '((display-buffer-reuse-window
            display-buffer-same-window)
           (body-function . nil)))

        :config
        ;; Remove dape from `mode-line-misc-info'.
        (setf (alist-get 'dape-active-mode mode-line-misc-info nil t) nil)

        :init
        (advice-add 'dape--display-buffer :override #'display-buffer)

        (let ((side 'right)
              (repl-side 'bottom))
          ;; Adapted from `dape--display-buffer'.
          (push `((derived-mode dape-repl-mode)
                  (display-buffer-in-side-window)
                  (body-function . nil)
                  (side . ,repl-side)
                  (slot . -1))
                display-buffer-alist)

          (push `((or (derived-mode dape-info-scope-mode)
                      (derived-mode dape-info-watch-mode))
                  (display-buffer-in-side-window)
                  (body-function . nil)
                  (side . ,side)
                  (slot . -1))
                display-buffer-alist)

          (push `((or (derived-mode dape-info-stack-mode)
                      (derived-mode dape-info-modules-mode)
                      (derived-mode dape-info-sources-mode))
                  (display-buffer-in-side-window)
                  (body-function . nil)
                  (side . ,side)
                  (slot . 0))
                display-buffer-alist)

          (push `((or (derived-mode dape-info-breakpoints-mode)
                      (derived-mode dape-info-threads-mode))
                  (display-buffer-in-side-window)
                  (body-function . nil)
                  (side . ,side)
                  (slot . 1))
                display-buffer-alist))

        :leader
        ("v" '(:ignore t :wk "debugger"))

        :lazy-leader
        (:prefix "v"
         "DEL" 'dape-quit
         "M-DEL" 'dape-disconnect-quit
         "b" 'dape-breakpoint-toggle
         "x" 'dape-breakpoint-remove-all
         "=" 'dape-breakpoint-expression
         "l" 'dape-breakpoint-log
         "h" 'dape-breakpoint-hits
         "r" 'dape-restart
         "s" 'dape-step-in
         "k" 'dape-kill                                                               ; Restart debugger session
         "n" 'dape-next                                                               ; Like step but skip functions
         "f" 'dape-step-out
         "c" 'dape-continue
         "g" 'dape-restart
         "^" 'dape-select-stack
         "@" 'dape-select-thread
         "w" 'dape-watch-dwim
         "m" 'dape-read-memory
         "p" 'dape-pause
         ))

      (use-package dape
        :general
        (:keymaps 'dape-info-mode-map
         "<override-state>" 'motion
         "SPC" nil                                                                    ; Give me back my leader
         "h"   nil
         "RET" "<return>"
         [C-i] "<tab>"
         "TAB" "<tab>"))
    #+end_src

*** Dape Projection
    #+begin_src emacs-lisp
      (require '+pkg-project)

      (use-package projection-dape
        :straight (projection-dape :host github :repo "mohkale/projection"
                                   :files (:defaults "src/projection-dape/*.el"))
        :leader
        ("v SPC" 'projection-dape
         "vv" 'dape))
    #+end_src

*** Appendix
    #+begin_src emacs-lisp
      (provide '+pkg-dape)
    #+end_src

* Languages
  :PROPERTIES:
  :header-args+: :shebang ";; -*- lexical-binding: t -*-\n(require '+core-base-packages)\n(require '+core-leader)\n(require '+config)\n(require '+core-completion)\n(require '+pkg-evil)\n(eval-when-compile (require '+use-package-setup-indent))\n(eval-when-compile (require '+use-package-show-whitespace))\n(eval-when-compile (require '+use-package-modify-syntax))\n(eval-when-compile (require '+use-package-prettify-symbols))\n(eval-when-compile (require '+pkg-flymake))\n(eval-when-compile (require '+lib-host-environment))\n(require '+pkg-electric)"
  :END:
  Extensions providing tailored support for specific programming languages or tools.

** Assembly                                                         :builtin:
   :PROPERTIES:
   :header-args+: :tangle (package-lisp! +lang-assembly assembly)
   :END:

   #+begin_src emacs-lisp :tangle (package-yes! assembly)
   (require '+lang-assembly)
   #+end_src

   #+begin_src emacs-lisp
     (use-package asm-mode
       :hook (asm-mode . indent-tabs-mode)
       :mode (rx "." (or "asl" "S" "s") eol)
       :init
       (push '(asm-mode . 8) +indent-config)

       :preface
       (defun asm-setup-imenu+ ()
         (setq imenu-generic-expression
               `(("label"
                  ,(rx bol
                       (group (one-or-more alnum))
                       (zero-or-more space) ":")
                  1))))
       :hook (asm-mode . asm-setup-imenu+)

       :config
       (advice-add 'asm-colon :around
                   (defun asm-colon-indent-space+ (func &rest args)
                     (let ((indent-tabs-mode nil))
                       (apply func args))))

       :general
       (:keymaps 'asm-mode-map
        "<override-state>" 'all
        "C-c ;" nil))
   #+end_src

   #+begin_src emacs-lisp
    (provide '+lang-assembly)
   #+end_src

** Awk                                                              :builtin:
   :PROPERTIES:
   :header-args+: :tangle (lisp! "+lang-awk.el")
   :END:

   #+begin_src emacs-lisp :tangle yes
     (require '+lang-awk)
   #+end_src

   #+BEGIN_SRC emacs-lisp
     (use-package cc-awk
       :interpreter "gawk"
       :hook (awk-mode . +flylint)

       :preface
       (defun awk-mode-reset-electric-pair+ ()
         (setq-local electric-pair-inhibit-predicate
                     'electric-pair-default-inhibit))
       :hook (awk-mode . awk-mode-reset-electric-pair+))
   #+END_SRC

   #+begin_src emacs-lisp
    (provide '+lang-awk)
   #+end_src

** Bibtex
   :PROPERTIES:
   :header-args+: :tangle (package-lisp! +lang-bibtex bibtex)
   :END:

   #+begin_src emacs-lisp :tangle (package-yes! bibtex)
     (require '+lang-bibtex)
   #+end_src

*** Bibtex Mode
    #+BEGIN_SRC emacs-lisp
      (use-package bibtex
        :hook (bibtex-mode . display-line-numbers-mode)
        :custom
        (bibtex-align-at-equal-sign t)
        (bibtex-include-OPTkey t)
        (orhc-bibtex-cache-file (cache! "orhc-bibtex-cache"))
        (bibtex-autokey-titleword-length nil)                                         ; use all available words and be as long as needed
        (bibtex-autokey-titlewords nil)
        (bibtex-field-delimiters 'double-quotes)                                      ; what I can I say, this just makes sense

        :init
        (evil-set-initial-state 'bibtex-mode 'normal)

        :autoload (bibtex-autokey-get-title
                   bibtex-autokey-get-year
                   bibtex-autokey-get-names
                   )
        :config
      ;;; configure bibtex autokey structure: YEARauthor-paper-name
        (defvar bibtex-autokey-year-name-separator+ bibtex-autokey-name-year-separator
          "String to be put between year part and name part of key.
      See ‚Äòbibtex-generate-autokey‚Äô for details.")

        (defvar bibtex-autokey-name-title-separator+ bibtex-autokey-year-title-separator
          "String to be put between year part and name part of key.
      See ‚Äòbibtex-generate-autokey‚Äô for details.")

        (setq bibtex-autokey-year-name-separator+ ""
              bibtex-autokey-name-title-separator+ "-"
              bibtex-autokey-titleword-separator "-")

        (advice-add 'bibtex-generate-autokey :override
                    (defun bibtex-generate-autokey+ ()
                      (let* ((names (bibtex-autokey-get-names))
                             (year (bibtex-autokey-get-year))
                             (title (bibtex-autokey-get-title))
                             (autokey (concat bibtex-autokey-prefix-string
                                              year
                                              (unless (or (equal names "")
                                                          (equal year ""))
                                                bibtex-autokey-year-name-separator+)
                                              names
                                              (unless (or (and (equal names "")
                                                               (equal year ""))
                                                          (equal title ""))
                                                bibtex-autokey-name-title-separator+)
                                              title)))
                        (if bibtex-autokey-before-presentation-function
                            (funcall bibtex-autokey-before-presentation-function autokey)
                          autokey))))

      ;;; Reset the annoying `fill-prefix' behaviour in bibtex.
        (add-hook 'bibtex-mode-hook
                  (defun bibtex-mode-setup+ ()
                    ;; 18 space indent... no thank you.
                    (setq-local fill-prefix nil)))

        (advice-add 'bibtex-clean-entry :around
                    (defun bibtex-reset-fill-prefix+ (func &rest args)
                      (let ((fill-prefix (make-string (1+ bibtex-text-indentation) ? )))
                        (apply func args))))

        ;; unused bindings
        ;; C-c C-y         bibtex-yank
        ;; C-c M-y         bibtex-yank-pop
        ;; TAB             bibtex-find-text
        ;; C-j             bibtex-next-field

        :lazy-leader
        (:mode 'bibtex-mode
         "," 'bibtex-clean-entry
         "r" 'bibtex-entry-update                                ; fill-out templates for missing fields in the current entry.
         "g" 'bibtex-search-entry
         "n" 'bibtex-narrow-to-entry
         "w" 'widen
         "m" 'bibtex-mark-entry
         "?" 'bibtex-print-help-message
         "u" 'bibtex-url                                         ; opens the url for the current entry (if there is one).
         "-" 'bibtex-fill-entry
         "x" 'bibtex-kill-entry
         "s" 'bibtex-search-crossref
         "j" 'bibtex-pop-next                                    ; fill out current field with similar value from next entry.
         "k" 'bibtex-pop-previous                                ; same as above but the previous entry.
         "o"   'bibtex-remove-OPT-or-ALT
         "C-o" 'bibtex-remove-OPT-or-ALT

         "y" '(:ignore t :wk "yank")
         "ys" 'bibtex-copy-summary-as-kill
         "yf" 'bibtex-copy-field-as-kill
         "yy" 'bibtex-copy-entry-as-kill

         "DEL" 'bibtex-empty-field
         "f" 'bibtex-make-field
         "d" 'bibtex-kill-field

         "i"    '(:ignore t :wk "insert")
         "ii"   'bibtex-entry
         "ip"   'bibtex-Preamble
         "ia"   'bibtex-Article
         "im"   'bibtex-Misc
         "ic"   'bibtex-InCollection
         "is"   'bibtex-String
         "ir"   'bibtex-TechReport
         "iu"   'bibtex-Unpublished
         "ib"   'bibtex-Book
         "iB"   'bibtex-InBook
         "il"   'bibtex-Booklet
         "ip"   'bibtex-Proceedings
         "iP"   'bibtex-InProceedings
         "i RET" 'bibtex-Manual

         "it"    '(:ignore t :wk "thesis")
         "itP"   'bibtex-PhdThesis
         "itm"   'bibtex-MastersThesis)

        :general
        (:keymaps 'bibtex-mode-map "TAB" "C-j")
        (:keymaps 'bibtex-mode-map
         :states 'normal
         "gh" 'bibtex-beginning-of-entry
         "gk" 'bibtex-previous-entry
         "gj" 'bibtex-next-entry
         "gl" 'bibtex-end-of-entry))
    #+END_SRC

*** Citar
    #+begin_src emacs-lisp
      (require '+pkg-all-the-icons)
      (require '+pkg-browse-url)

      (use-package citar
        :straight t
        :hook ((org-mode . citar-capf-setup)
               (markdown-mode . citar-capf-setup)
               (markdown-ts-mode . citar-capf-setup)
               ((latex-mode LaTeX-mode) . citar-capf-setup))
        :leader
        ("ob" 'citar-insert-citation)
        (:mode 'org-mode
         "[" 'citar-insert-citation)

        :custom
        (citar-library-paths
         (list +docs-home
               (join-path+ +docs-home "unidocs/")))
        (citar-library-file-extensions
         '(".pdf" ".epub" ".pptx" ".doc" ".docx"))
        (citar-notes-paths
         (ensure-list (join-path+ +notes-home "bibnotes")))

        :preface
        (setq citar-bibliography
              (when (file-exists-p +bib-home)
                (mapcar #'file-truename (directory-files +bib-home 'full ".bib"))))

        :custom
        (org-cite-insert-processor 'citar)
        (org-cite-follow-processor 'citar)
        (org-cite-activate-processor 'citar)

        :config
        (setq citar--multiple-setup '("<C-i>" . "RET"))

        :autoload citar-file-open-external
        :init
        (advice-add 'citar-file-open-external :override '+xopen-file)

        :config
        (setf (citar-indicator-symbol citar-indicator-notes)
              (+icon fileicon "org" :face '(:weight normal :inherit font-lock-string-face))

              (citar-indicator-symbol citar-indicator-links)
              (+icon nerd-fa "file-pdf-o" :face '(:weight normal :inherit font-lock-type-face)))

        ;; Add default citation inserter which just inserts citation keys.
        :autoload (citar--insert-citatation-as-keys+
                   citar--insert-keys-comma-space-separated)
        :config
        (defun citar--insert-citatation-as-keys+ (keys &rest _)
          (citar--insert-keys-comma-space-separated keys))

        (push '(insert-citation . citar--insert-citatation-as-keys+)
              (alist-get t citar-major-mode-functions))

        :general
        (:keymaps 'citar-map
         "e" nil "g" 'citar-open-entry
         )
        (:keymaps 'citar-citation-map
         "e" nil "g" 'citar-open-entry))
    #+end_src

**** Citar Embark
     #+begin_src emacs-lisp
       (use-package citar-embark
         :straight t
         :after (citar embark)
         :demand t
         :diminish
         :commands citar-embark-mode
         :config (citar-embark-mode))
     #+end_src

*** Company Bibtex                                                      :comp:
    #+BEGIN_SRC emacs-lisp
      (use-package company-bibtex
        :straight t
        :autoload company-bibtex
        :completion+
        (bibtex-mode (company-bibtex :company t))
        :init
        (setq company-bibtex-bibliography citar-bibliography))
    #+END_SRC

*** Ebib
    :PROPERTIES:
    :header-args+: :tangle (package-lisp! +lang-bibtex bibtex ebib)
    :END:

    Biblatex/Bibtex database management interface for emacs. TODO read [[https://joostkremers.github.io/ebib/ebib-manual.html][manual]].

    #+BEGIN_SRC emacs-lisp
      (use-package ebib
        :straight t
        :custom
        (ebib-notes-directory +notes-home)

        :custom
        (ebib-preload-bib-files citar-bibliography)
        (ebib-keywords (state! "ebib/keywords"))
        (ebib-reading-list-file (join-path+ +notes-home "reading-list.org"))
        :config
        (mkdir (state! "ebib") 'parents)

        :hide-whitespace+ ebib-index-mode
        :config
        (evil-set-initial-state 'ebib-index-mode 'motion)
        (evil-make-overriding-map ebib-index-mode-map 'motion)

        :hide-whitespace+ ebib-entry-mode
        :config
        (evil-set-initial-state 'ebib-entry-mode 'motion)
        (evil-make-overriding-map ebib-entry-mode-map 'motion)

        :lazy-leader
        ("ox" 'ebib)
        (:mode 'ebib-index-mode
         "i" 'ebib-add-entry                                     ; also just bound to a
         "u" 'ebib-browse-url                                    ; also just bound to u
         "s" 'ebib-switch-to-database-nth
         "a" 'ebib-show-annotation
         "n" 'ebib-open-note
         "g" 'ebib-jump-to-entry
         "." 'ebib-toggle-hidden
         "b" 'ebib-browse-doi
         "F" 'ebib-view-file                                     ; open file referenced by current entry
         "!" 'ebib-generate-autokey

         "e" '(:ignore t :wk "edit")
         "ee" 'ebib-edit-keyname
         "ep" 'ebib-edit-preamble
         "es" 'ebib-edit-strings

         "f" '(:ignore t :wk "filters")
         "f" ebib-filters-map

         "k" '(:ignore t :wk "keywords")
         "k" ebib-keywords-map

         "d" '(:ignore t :wk "dependent")
         "d" ebib-dependent-map)
        (:mode 'ebib-entry-mode
         "f" 'ebib-view-file-in-field                                           ; TODO find out what this does
         "h" 'ebib-view-field-as-help
         "u" 'ebib-browse-url)

        :general
        (:keymaps 'ebib-index-mode-map
         "C-n" nil ; was ebib-next-entry
         "C-p" nil ; was ebib-prev-entry
         "n"   nil
         "p"   nil
         "?"   nil ; was ebib-search-next
         "SPC" nil ; was ebib-index-scroll-up
         "|"   nil ; was ebib-filters-logical-or
         "~"   nil ; was ebib-filters-logical-not
         "&"   nil ; was ebib-filters-logical-and
         "g"   nil ; was ebib-goto-first-entry
         "1" nil "2" nil "3" nil "4" nil "5" nil "6" nil "7" nil "8" nil "9" nil ; was ebib-switch-to-database-key
         "o"   nil ; was ebib-open-bibtex-file
         "J"   nil ; was ebib-switch-to-database-nth
         "H"   nil ; was ebib-toggle-hidden
         "i"   nil ; was ebib-push-citation
         "h"   nil ; was ebib-index-help
         "Z"   nil ; was ebib-lower
         "b"   nil ; was ebib-index-scroll-down
         "f"   nil ; was ebib-view-file
         "X"   nil ; was ebib-export-preamble
         "I"   nil ; was ebib-browse-doi
         )
        (:keymaps 'ebib-index-mode-map
         :states  'motion
         ;; setup exit and reset commands
         [remap quit-window] 'ebib-leave-ebib-windows            ; leaves buffers alive, just hides windows.
         "gq"                'ebib-quit                          ; kills buffers and windows.
         [remap revert-buffer]  'ebib-reload-current-database
         "gR"                   'ebib-reload-all-databases

         ;; allow using ex commands for evil stuff.
         [remap evil-write]     'ebib-save-current-database
         [remap evil-write-all] 'ebib-save-all-databases

         ;; evil-like motions
         "C-u" 'ebib-index-scroll-down
         "C-d" 'ebib-index-scroll-up
         "C-b" 'ebib-index-scroll-down
         "C-f" 'ebib-index-scroll-up
         "gg"  'ebib-goto-first-entry
         "G"   'ebib-goto-last-entry
         "j"   'ebib-next-entry
         "k"   'ebib-prev-entry
         "gj"  'ebib-next-database
         "gk"  'ebib-prev-database
         "n"   'ebib-search-next

         ;; evil like yank, delete, paste
         "y" 'ebib-kill-entry
         "x" 'ebib-delete-entry                                  ; also bound to d
         "p" 'ebib-yank-entry                                    ; paste yanked entry

         "e" 'ebib-open-bibtex-file                              ; edit-file
         "h" 'ebib-show-log
         "l" 'ebib-edit-entry
         "o" 'ebib-edit-entry
         "RET" 'ebib-edit-entry

         "ss" 'ebib-export-entries                               ; save-as
         "sp" 'ebib-export-preamble                              ; save-preamble-as
         ;; configure sorting
         "sa" 'ebib-index-sort-ascending
         "sd" 'ebib-index-default-sort
         "sd" 'ebib-index-sort-descending)
        (:keymaps 'ebib-log-mode-map
         :states 'motion
         [remap quit-window] 'ebib-quit-log-buffer)
        (:keymaps 'ebib-entry-mode-map
         "g"   nil ; ebib-goto-first-field
         "n"   nil ; ebib-next-field
         "p"   nil ; ebib-prev-field
         "v"   nil ; ebib-view-field-as-help
         "c"   nil ; ebib-copy-field-contents
         "SPC" nil ; ebib-goto-next-set
         "b"   nil ; ebib-goto-prev-set
         "h"   nil ; ebib-entry-help
         "k"   nil ; ebib-kill-field-contents
         ;; r               ebib-toggle-raw
         ;; s               ebib-insert-abbreviation
         )
        (:keymaps 'ebib-entry-mode-map
         ;; allow using ex commands for evil stuff.
         [remap evil-write]     'ebib-save-current-database
         [remap evil-write-all] 'ebib-save-all-databases

         "C-u" 'ebib-goto-prev-set
         "C-d" 'ebib-goto-next-set
         "C-b" 'ebib-goto-prev-state
         "C-f" 'ebib-goto-next-set
         "gg" 'ebib-goto-first-field
         "G"  'ebib-goto-last-field
         "gj" 'ebib-next-field
         "gk" 'ebib-prev-field

         "c" 'ebib-edit-field
         "e" 'ebib-edit-field
         "i" 'ebib-edit-field
         ;; "m" 'ebib-edit-multiline-field
         ;; "x" 'ebib-delete-field-contents
         "d" 'ebib-kill-field-contents
         "x" 'ebib-kill-field-contents

         "y" 'ebib-copy-field-contents
         "p" 'ebib-yank-field-contents

         "o" 'ebib-quit-entry-buffer
         "q" 'ebib-quit-entry-buffer))
    #+END_SRC

*** Appendix
    #+begin_src emacs-lisp
      (provide '+lang-bibtex)
    #+end_src

** C#
   :PROPERTIES:
   :header-args+: :tangle (package-lisp! +lang-csharp csharp)
   :END:

   #+begin_src emacs-lisp :tangle (package-yes! csharp)
    (require '+lang-csharp)
   #+end_src

*** C-Sharp Mode
    #+begin_src emacs-lisp
      (use-package csharp-mode
        :hook (csharp-mode . +lsp-hook))
    #+end_src

*** Appendix
    #+begin_src emacs-lisp
    (provide '+lang-csharp)
    #+end_src

** Caddy
   :PROPERTIES:
   :header-args+: :tangle (package-lisp! +lang-caddy caddy)
   :END:

   #+begin_src emacs-lisp :tangle (package-yes! caddy)
    (require '+lang-caddy)
   #+end_src

   #+BEGIN_SRC emacs-lisp
     (use-package caddyfile-mode
       :straight t
       :mode (rx ".caddy" eol))

     (provide '+lang-caddy)
   #+END_SRC

** C/CPP/C++
   :PROPERTIES:
   :header-args+: :tangle (package-lisp! +lang-cpp c)
   :END:

   #+begin_src emacs-lisp :tangle (package-yes! c)
     (require '+lang-cpp)
   #+end_src

   #+begin_src emacs-lisp
     (defvar cpp-syntax-table-modifications+
       '((?_ . "w")))
   #+end_src

*** CC Mode
    #+BEGIN_SRC emacs-lisp
      (use-package cc-mode
        :hook ((c-mode c++-mode) . +lsp-hook)
        :custom
        (c-default-style '((java-mode . "linux")
                           (awk-mode . "awk")
                           (other . "k&r")))
        (c-ts-mode-indent-style 'bsd)

        :config
        ;; (c-toggle-comment-style +1)                            ; WARN never do this, it breaks commenting in weird places.

        :init
        (push '((c-mode c-ts-mode c++-mode c++-ts-mode)
                (?\; . after))
              electric-layout-mode-rules+)

        :modify-syntax+
        (c-mode-syntax-table cpp-syntax-table-modifications+)
        (c++-mode-syntax-table cpp-syntax-table-modifications+)

        :leader
        (:mode '(java-mode c-mode c-ts-mode c++-mode c++-ts-mode)
         "S" 'c-set-style
         "D" 'c-display-defun-name
         "m" 'c-mark-function
         "r" 'c-indent-defun
         "/" 'c-backslash-region
         "\\" 'c-toggle-comment-style
         "DEL" 'c-hungry-delete-forward
         "M-DEL" 'c-hungry-delete-backwards))
    #+END_SRC

*** C-TS Mode
    #+BEGIN_SRC emacs-lisp :tangle (package-lisp! +lang-cpp c tree-sitter)
      (use-package c-ts-mode
        :modify-syntax+ (c-ts-mode--syntax-table cpp-syntax-table-modifications+))
    #+end_src

*** Modern CPP Font Lock
    #+BEGIN_SRC emacs-lisp :tangle (package-lisp! +lang-cpp c (not tree-sitter))
      (use-package modern-cpp-font-lock
        :straight t
        :diminish modern-c++-font-lock-mode
        :hook (c++-mode . modern-c++-font-lock-mode))
    #+END_SRC

*** Clangd                                                              :lsp:
    #+begin_src emacs-lisp
      (defvar c-mode-clangd-args+ '("--clang-tidy")
        "Command line options to pass to clangd for lsp.")

      (defvaralias 'c-mode-clangd-compile-commands-dir+ '+cmake-build-directory
        "Customizable path to directory containing compile_commands.json")

      (defun c-mode-clangd-args+ ()
        `(,@c-mode-clangd-args+
          ,@(when-let* ((dir c-mode-clangd-compile-commands-dir+))
              (list "--compile-commands-dir" dir))))
    #+end_src

    #+begin_src emacs-lisp :tangle (package-lisp! +lang-cpp c eglot)
      (use-package eglot
        :preface
        (defun eglot-clangd-command+ (&optional _interactive _project)
          `("clangd" ,@(c-mode-clangd-args+)))

        :config
        (push `((c-mode c-ts-mode c++-mode c++-ts-mode objc-mode)
                . ,#'eglot-clangd-command+)
              eglot-server-programs))
    #+end_src

*** Appendix
    #+begin_src emacs-lisp
      (provide '+lang-cpp)
    #+end_src

** Clojure
   :PROPERTIES:
   :header-args+: :tangle (package-lisp! +lang-clojure clojure)
   :END:

   #+begin_src emacs-lisp :tangle (package-yes! clojure)
   (require '+lang-clojure)
   #+end_src

   #+BEGIN_SRC emacs-lisp
     (use-package clojure-mode
       :straight t
       :mode ((rx ".edn") . clojure-mode))
   #+END_SRC

   #+begin_src emacs-lisp
    (provide '+lang-clojure)
   #+end_src

** CMake
   :PROPERTIES:
   :header-args+: :tangle (package-lisp! +lang-cmake cmake)
   :END:

   #+begin_src emacs-lisp :tangle (package-yes! cmake)
   (require '+lang-cmake)
   #+end_src

   #+begin_src emacs-lisp
     (defvar cmake-syntax-table-modifications+
       '((?_ . "w")
         (?- . "w")))
   #+end_src

*** CMake Mode
    :PROPERTIES:
    :header-args+: :tangle (package-lisp! +lang-cmake cmake (not tree-sitter))
    :END:

    #+BEGIN_SRC emacs-lisp
      (use-package cmake-mode
        :straight t
        :mode (rx (or (and "CMakeLists.txt" eol) ".cmake"))
        :modify-syntax+ cmake-syntax-table-modifications+)
    #+END_SRC

*** CMake Tree Sitter Mode
    :PROPERTIES:
    :header-args+: :tangle (package-lisp! +lang-cmake cmake tree-sitter)
    :END:

    #+begin_src emacs-lisp
      (use-package cmake-ts-mode
        :mode (rx (or (and "CMakeLists.txt" eol) ".cmake"))
        :modify-syntax+
        (cmake-ts-mode--syntax-table
         cmake-syntax-table-modifications+))
    #+end_src

*** Appendix
    #+begin_src emacs-lisp
    (provide '+lang-cmake)
    #+end_src

** crontab
   :PROPERTIES:
   :header-args+: :tangle (package-lisp! +lang-crontab crontab)
   :END:

   #+begin_src emacs-lisp :tangle (package-yes! crontab)
   (require '+lang-crontab)
   #+end_src

   #+begin_src emacs-lisp
     (use-package crontab-mode
       :straight t
       :mode (rx ".cron" eol))
   #+end_src

   #+begin_src emacs-lisp
    (provide '+lang-crontab)
   #+end_src

** Crystal
   :PROPERTIES:
   :header-args+: :tangle (package-lisp! +lang-crystal crystal)
   :END:

   #+begin_src emacs-lisp :tangle (package-yes! crystal)
   (require '+lang-crystal)
   #+end_src

   #+BEGIN_SRC emacs-lisp
     (use-package crystal-mode
       :straight t
       :init
       (push '(crystal-mode . 2) +indent-config))
   #+END_SRC

   #+begin_src emacs-lisp
    (provide '+lang-crystal)
   #+end_src

** CSS
   :PROPERTIES:
   :header-args+: :tangle (package-lisp! +lang-css css)
   :END:

   #+begin_src emacs-lisp :tangle (package-yes! css)
     (require '+lang-css)
   #+end_src

*** CSS Mode
    #+BEGIN_SRC emacs-lisp
      (use-package css-mode
        :hook (((css-mode css-ts-mode) . +flylint)
               ((css-mode css-ts-mode) . +lsp-hook))
        :lazy-leader
        (:mode '(less-css-mode css-mode css-ts-mode)
         "?" 'css-lookup-symbol
         "b" 'web-beautify-css)

        :modify-syntax+
        (css-mode-syntax-table
         '((?_ . "w")
           (?- . "w"))))
    #+END_SRC

*** Company CSS                                                        :comp:
    #+begin_src emacs-lisp :tangle (package-lisp! +lang-css css company)
      (use-package company
        :autoload company-css
        :completion+
        (css-mode (company-css :company t))
        (css-less-mode (company-css :company t)))
    #+end_src

*** Less CSS Mode
    #+BEGIN_SRC emacs-lisp
      (use-package less-css-mode
        :hook ((scss-mode . +flylint)
               (scss-mode . +lsp-hook))
        :lazy-leader
        (:mode 'less-css-mode
         "c" 'less-css-compile))
    #+END_SRC

*** Appendix
    #+begin_src emacs-lisp
      (provide '+lang-css)
    #+end_src

** CSV
   :PROPERTIES:
   :header-args+: :tangle (package-lisp! +lang-csv csv)
   :END:

   #+begin_src emacs-lisp :tangle (package-yes! csv)
   (require '+lang-csv)
   #+end_src

   #+BEGIN_SRC emacs-lisp
     (use-package csv-mode
       :straight t
       :custom
       (csv-separators '("," ":" ";" "\t"))

       :lazy-leader
       (:mode 'csv-mode
        "a"  'csv-align-fields
        "d"  'csv-kill-fields
        "i"  'csv-toggle-invisibility
        "r"  'csv-reverse-region
        "t"  'csv-transpose
        "u"  'csv-unalign-fields

        "s" '(:ignore t :wk "sort")
        "sf" 'csv-sort-fields
        "sn" 'csv-sort-numeric-fields
        "so" 'csv-toggle-descending

        "v" '(:ignore t :wk "yank")
        "vf" 'csv-yank-fields
        "vt" 'csv-yank-as-new-table)

       :general
       (:keymaps 'csv-mode-map
        "<tab>"     'csv-forward-field
        "<backtab>" 'csv-backward-field))
   #+END_SRC

   #+begin_src emacs-lisp
    (provide '+lang-csv)
   #+end_src

** Docker
   :PROPERTIES:
   :header-args+: :tangle (package-lisp! +lang-docker docker)
   :END:

   #+begin_src emacs-lisp :tangle (package-yes! docker)
     (require '+lang-docker)
   #+end_src

*** Dockerfile Mode
    #+begin_src emacs-lisp
      (use-package dockerfile-mode
        :straight t
        :mode (rx ".docker" (optional "file") eol)
        :custom
        (dockerfile-enable-auto-indent nil)
        (dockerfile-use-buildkit
         (string-equal (or (getenv "DOCKER_BUILDKIT") "1") "1")
         "Whether to use buildkit. By default we do unless the
      DOCKER_BUILDKIT environment variable explicitly disables
      it.")

        :indent+
        (dockerfile-mode 2)
        (dockerfile-ts-mode 2)

        :preface
        (use-package sh-script
          :commands sh-backslash-region)

        :leader
        (:mode '(dockerfile-mode dockerfile-ts-mode)
         "\\" 'sh-backslash-region))
    #+end_src

*** Docker Transient
    #+begin_src emacs-lisp
      (use-package docker
        :straight t
        :custom
        (docker-show-messages nil)

        :preface
        (defvar docker-initial-evil-state+ 'motion)

        :init
        (evil-set-initial-state 'docker-container-mode docker-initial-evil-state+)
        (evil-set-initial-state 'docker-image-mode docker-initial-evil-state+)
        (evil-set-initial-state 'docker-network-mode docker-initial-evil-state+)
        (evil-set-initial-state 'docker-volume-mode docker-initial-evil-state+)

        :leader
        ("pd" 'docker
         "pD" 'docker-compose)

        :general
        (:keymaps 'docker-container-mode-map
         :states docker-initial-evil-state+
         "l"  'docker-container-ls
         "?"  'docker-container-help
         "C"  'docker-container-cp
         "D"  'docker-container-rm
         "I"  'docker-container-inspect
         "K"  'docker-container-kill
         "L"  'docker-container-logs
         "O"  'docker-container-stop
         "P"  'docker-container-pause
         "R"  'docker-container-restart
         "S"  'docker-container-start
         "a"  'docker-container-attach
         "b"  'docker-container-shells
         "d"  'docker-container-diff
         "f"  'docker-container-open
         "r"  'docker-container-rename-selection)

        (:keymaps 'docker-image-mode-map
         :states docker-initial-evil-state+
         "l"  'docker-image-ls
         "?"  'docker-image-help
         "D"  'docker-image-rm
         "F"  'docker-image-pull
         "I"  'docker-image-inspect
         "P"  'docker-image-push
         "R"  'docker-image-run
         "T"  'docker-image-tag-selection
         "d"  'docker-image-mark-dangling)

        (:keymaps 'docker-network-mode-map
         :states docker-initial-evil-state+
         "l"  'docker-network-ls
         "?"  'docker-network-help
         "D"  'docker-network-rm
         "I"  'docker-network-inspect
         "d"  'docker-network-mark-dangling)

        (:keymaps 'docker-volume-mode-map
         :states docker-initial-evil-state+
         "l"  'docker-volume-ls
         "?"  'docker-volume-help
         "D"  'docker-volume-rm
         "I"  'docker-volume-inspect
         "d"  'docker-volume-mark-dangling
         "f"  'docker-volume-dired-selection))
    #+end_src

*** Tramp Container
    #+begin_src emacs-lisp
      (use-package tramp-container
        :autoload (docker-container-mounts+
                   docker-original-default-directory+)
        :config
        (defun docker-container-mounts+ (container-id)
          (let ((containers
                 (with-temp-buffer
                   (call-process "docker" nil (current-buffer) nil "inspect" container-id)
                   (buffer-substring (point-min) (point-max)))))
            (cl-loop for it in
                     (alist-get
                      'Mounts
                      (car (json-parse-string
                            containers :object-type 'alist :array-type 'list)))
                     with src = nil
                     do (setq src (alist-get 'Source it))
                     with dest = nil
                     do (setq dest (alist-get 'Destination it))
                     when (and src dest)
                       collect (cons src dest))))

        (defun docker-original-default-directory+ ()
          (when (string-prefix-p
                 (concat "/" tramp-docker-program)
                 default-directory)
            (when-let* ((tramp-name (tramp-dissect-file-name default-directory))
                        (local-name (tramp-file-name-localname tramp-name))
                        (container-id (tramp-file-name-host tramp-name)))
              (cl-dolist (entry (docker-container-mounts+ container-id))
                (when (string-prefix-p (cdr entry) local-name)
                  (cl-return
                   (concat (car entry)
                           (substring local-name (1+ (length (cdr entry)))))))))))

        :commands docker-find-external-directory+
        :config
        (defun docker-find-external-directory+ ()
          "`find-file' the current docker-tramp directory outside of docker.
      Requires the current directory to be accessed through docker-tramp and
      be mounted from an external file-system into it."
          (interactive)
          (if-let* ((directory (docker-original-default-directory+)))
              (find-file directory)
            (user-error "Could not resolve external mount for %s" default-directory))))
    #+end_src

*** DevContainer Dir-Locals                                             :wip:
    :PROPERTIES:
    :header-args+: :tangle (package-lisp! +devcontainer-dirlocals docker)
    :END:

    A solution for setting remote Emacs configurations in the standard [[https://containers.dev/implementors/spec/][devcontainers]]
    configuration file.

    #+begin_src emacs-lisp :tangle (package-lisp! +lang-docker docker)
      (use-package +devcontainer-dirlocals
        :demand t
        :after tramp-container)
    #+end_src

    #+begin_src emacs-lisp
      (require 'cl-macs)
      (eval-when-compile (require 'subr-x))

      (declare-function map-merge-with "map" (type function &rest maps))
      (declare-function map-merge "map" (type &rest maps))

      (defconst devcontainer-dirlocal--config-files+
        '(".devcontainer/devcontainer.json"
          "devcontainer.json"))

      (defun devcontainer-dirlocal-adapter--supported-p (directory)
        "Whether dev-container local-vars is supported in DIRECTORY."
        (and enable-remote-dir-locals
             (string-match-p (rx bol "/docker:")
                             (or (file-remote-p directory) ""))))

      (defun devcontainer-dirlocal-adapter--config-file+ (directory)
        "Check for dev-container config in DIRECTORY."
        (when (and (devcontainer-dirlocal-adapter--supported-p directory)
                   (file-readable-p directory))
          (ensure-list
           (cl-loop for file in devcontainer-dirlocal--config-files+
                    do (setq file (expand-file-name file directory))
                    when (and (file-readable-p file)
                              (file-regular-p file))
                      return file))))

      (defun vscode-dirlocal-adapter--find-file-advice+ (func file &rest args)
        "Advice to make FUNC check for devcontainer dir-locals file relative to FILE."
        (or
         (when (devcontainer-dirlocal-adapter--supported-p
                (file-name-directory file))
           (cl-letf (((symbol-function #'dir-locals--all-files)
                      #'devcontainer-dirlocal-adapter--config-file+))
             (apply func file args)))
         (apply func file args)))

      (advice-add 'dir-locals-find-file :around #'vscode-dirlocal-adapter--find-file-advice+)

      (defun vscode-dirlocal-adapter--deserialise-file+ (file)
        "Parse devcontainer config from FILE."
        (with-temp-buffer
          (insert-file-contents file)
          (let ((json-array-type 'list)
                (json-false nil))
            (json-parse-buffer
             :object-type 'alist :array-type 'list
             :null-object nil :false-object nil))))

      (defconst vscode-dirlocal-adapter--emacs-customization-name 'emacs)

      (defun vscode-dirlocal-adapter--extract-customizations+ (config)
        "Extract customizations section for Emacs from CONFIG."
        (thread-last
          config
          (alist-get 'customizations)
          (alist-get vscode-dirlocal-adapter--emacs-customization-name)))

      (defun vscode-dirlocal-adapter--merge-inline+ (remaining inline)
        "Merge INLINE and REMAINING dir-local configs together."
        (cond
         ((and remaining inline)
          (require 'map)
          (map-merge-with
           'list
           (lambda (a b)
             (let ((ag
                    (seq-group-by
                     (lambda (e) (eq (car e) 'eval)) a))
                   (bg
                    (seq-group-by
                     (lambda (e) (eq (car e) 'eval)) b)))
               (append (map-merge 'list
                                  (assoc-default nil ag)
                                  (assoc-default nil bg))
                       (assoc-default t ag)
                       (assoc-default t bg))))
           remaining inline))
         (remaining remaining)
         (t inline)))

      (defun vscode-dirlocal-adapter--generate-variables+ (customizations)
        "Generate updated variable list from devcontainer CUSTOMIZATIONS section.
      This is a JSONised wrapper around dir-local configurations with the following
      behaviour per key:
      - *-mode: Is a mode specification like sh-script-mode.
      - null: A global section equivalent to nil in standard dir-locals.
      - inline-dir-locals: Is a string value containing a full dir-locals.el file
        body. This will be merged with and take precedence over remaining
        configured options.
      - *: All remaining sections are interpreted as file-paths."
        (dolist (it customizations)
          (pcase (symbol-name (car it))
            ("null" (setcar it nil))
            ((or (rx "-mode" eol)
                 "inline-dir-locals"))
            (_ (setcar it (symbol-name (car it))))))
        ;; Apply inline-dir-locals.
        (when-let* ((inline-config (alist-get 'inline-dir-locals customizations)))
          (setq customizations (cl-remove 'inline-dir-locals customizations :key #'car)
                inline-config (let ((read-circle nil))
                                (read inline-config)))
          (unless (listp inline-config)
            (message "Invalid data in dev-container dir-locals inline-config: %s" inline-config)
            (setq inline-config nil))
          (setq customizations (vscode-dirlocal-adapter--merge-inline+ customizations inline-config)))
        customizations)

      (defun vscode-dirlocal-adapter--read-from-dir+ (directory)
        "Try to read Emacs dir-locals from devcontainer configuration in DIRECTORY."
        (when-let* ((class-name (intern directory))
                    (dev-container-config (car-safe (devcontainer-dirlocal-adapter--config-file+ directory))))
          (let ((modtime 0) variables)
            (with-demoted-errors "Error reading devcontainers config: %S"
              (setq modtime (file-attribute-modification-time
                             (file-attributes (file-chase-links dev-container-config)))
                    variables (thread-first
                                dev-container-config
                                (vscode-dirlocal-adapter--deserialise-file+)
                                (vscode-dirlocal-adapter--extract-customizations+)
                                (vscode-dirlocal-adapter--generate-variables+)
                                (dir-locals--sort-variables))))
            (when variables
              (dir-locals-set-class-variables class-name variables)
              (dir-locals-set-directory-class directory class-name modtime)
              class-name))))

      (advice-add 'dir-locals-read-from-dir :before-until #'vscode-dirlocal-adapter--read-from-dir+)

      (provide '+devcontainer-dirlocals)
    #+end_src

*** Appendix
    #+begin_src emacs-lisp
      (provide '+lang-docker)
    #+end_src

** Emacs Lisp
   :PROPERTIES:
   :header-args+: :tangle (package-lisp! +lang-elisp elisp)
   :END:

   #+begin_src emacs-lisp :tangle (package-yes! elisp)
     (require '+lang-elisp)
   #+end_src

*** Elisp Mode
    #+BEGIN_SRC emacs-lisp
      (use-package elisp-mode
        :indent+
        (emacs-lisp-mode nil)
        (lisp-interaction-mode nil)

        :preface
        (defvar elisp-syntax-table-modifications+
          '((?_ . "w")
            (?- . "w")
            (?! . "w")
            (?: . "w")
            (?& . "w")))
        :modify-syntax+
        (emacs-lisp-mode-syntax-table elisp-syntax-table-modifications+)
        (lisp-data-mode-syntax-table elisp-syntax-table-modifications+)

        ;; :pretty-symbols+
        ;; ((lisp-interaction-mode
        ;;   emacs-lisp-mode
        ;;   org-mode)
        ;;  "lambda"  ?Œª
        ;;  "lambda!" "Œª!")

        :init
        (evil-set-initial-state 'inferior-emacs-lisp-mode 'emacs) ;; ielm

        :commands eval-replace-last-sexp
        :config
        (defun eval-replace-last-sexp (&optional prefix)
          "evaluate then replace the preceding sexp"
          (interactive "p")
          (let* ((sexp (elisp--preceding-sexp))
                 (value (eval sexp)))
            (kill-sexp -1)
            (insert (format (if prefix "%s" "%S") value))))

        :preface
        (defvar elisp-adjust-flymake-load-path+ t
          "Duplicate `load-path' for flymake in elisp-mode.")

        (defun elisp--adjust-flymake-load-path+ ()
          (when (and (bound-and-true-p flymake-mode)
                     elisp-adjust-flymake-load-path+)
            (setq-local elisp-flymake-byte-compile-load-path
                        (append (default-value 'elisp-flymake-byte-compile-load-path)
                                load-path))))
        :hook (flymake-mode . elisp--adjust-flymake-load-path+)

        :leader
        ("fk" 'emacs-lisp-byte-compile)
        (:prefix "k"
         "e" 'eval-last-sexp
         "k" 'eval-last-sexp
         "(" 'eval-print-last-sexp
         ")" 'eval-replace-last-sexp)

        :lazy-leader
        (:mode '(emacs-lisp-mode lisp-interaction-mode)
         "c" 'emacs-lisp-byte-compile
         "i" 'indent-sexp
         "p" 'pp-buffer

         ;; eval
         "e"  '(:ignore t :wk "eval/REPL")
         "es" 'ielm
         "ee" 'eval-last-sexp
         "eb" 'eval-buffer
         "eE" 'eval-replace-last-sexp
         "ef" 'eval-defun
         "er" 'eval-region

         ;; tests
         "t" 'ert
         "T" 'ert-run-tests-interactively)

        :general
        (:keymaps '(emacs-lisp-mode-map
                    lisp-interaction-mode-map)
         "C-j" nil
         "C-(" 'eval-print-last-sexp
         "C-)" 'eval-replace-last-sexp))
    #+END_SRC

*** Indentation
    #+BEGIN_SRC emacs-lisp
      (defvar calculate-lisp-indent-last-sexp)

      (defun +emacs-lisp-indent-function (indent-point state)
        "A replacement for `lisp-indent-function'.

      Indents plists more sensibly. Adapted from
      https://emacs.stackexchange.com/questions/10230/how-to-indent-keywords-aligned"
        (let ((normal-indent (current-column))
              (orig-point (point))
              ;; TODO Refactor `target' usage (ew!)
              target)
          (goto-char (1+ (elt state 1)))
          (parse-partial-sexp (point) calculate-lisp-indent-last-sexp 0 t)
          (cond ((and (elt state 2)
                      (or (not (looking-at-p "\\sw\\|\\s_"))
                          (eq (char-after) ?:)))
                 (unless (> (save-excursion (forward-line 1) (point))
                            calculate-lisp-indent-last-sexp)
                   (goto-char calculate-lisp-indent-last-sexp)
                   (beginning-of-line)
                   (parse-partial-sexp (point) calculate-lisp-indent-last-sexp 0 t))
                 (backward-prefix-chars)
                 (current-column))
                ((and (save-excursion
                        (goto-char indent-point)
                        (skip-syntax-forward " ")
                        (not (eq (char-after) ?:)))
                      (save-excursion
                        (goto-char orig-point)
                        (and (eq (char-after) ?:)
                             (eq (char-before) ?\()
                             (setq target (current-column)))))
                 (save-excursion
                   (move-to-column target t)
                   target))
                ((let* ((function (buffer-substring (point) (progn (forward-sexp 1) (point))))
                        (method (or (function-get (intern-soft function) 'lisp-indent-function)
                                    (get (intern-soft function) 'lisp-indent-hook))))
                   (cond ((or (eq method 'defun)
                              (and (null method)
                                   (> (length function) 3)
                                   (string-match-p "\\`def" function)))
                          (lisp-indent-defform state indent-point))
                         ((integerp method)
                          (lisp-indent-specform method state indent-point normal-indent))
                         (method
                          (funcall method indent-point state))))))))

      (setq lisp-indent-function #'+emacs-lisp-indent-function)
    #+END_SRC

*** Buttercup                                                      :disabled:
    A unit testing framework for Emacs lisp packages.

    #+begin_src emacs-lisp :tangle no
      (use-package buttercup
        :straight t)
    #+end_src

*** Paredit
    #+BEGIN_SRC emacs-lisp
      (use-package paredit
        :straight t
        :diminish paredit-mode
        :hook (emacs-lisp-mode . paredit-mode)
        :general
        (:keymaps 'paredit-mode-map
         "C-<up>" nil "C-<down>" nil "C-<left>" nil
         "C-<right>" nil "C-(" nil "C-)" nil)

        ;; M-( wraps the next argument in parentheses
        ;; M-) closes the current argument, trims any
        ;;     trailing whitespace and inserts a newline
        ;; M-" same as " but then trims whitespace and inserts a newline
        (:keymaps 'paredit-mode-map
         :states 'insert
         "DEL"           'paredit-backward-delete
         "M-DEL"         'paredit-forward-delete
         "C-<backspace>" 'paredit-backward-kill-word
         ;; "C-M-<delete>" 'paredit-forward-kill-word

         ;; damn you windows
         ;; just use paredit forward, then kill backward
         "C-M-k" 'paredit-kill ;; forward body
         "RET" 'paredit-newline)
        (:keymaps 'paredit-mode-map
         :states 'normal
         "gSh" '(paredit-splice-sexp-killing-backward :wk "splice-sexp-forward")
         "gSl" '(paredit-splice-sexp-killing-forward :wk "splice-sexp-backward"))
        (:keymaps 'paredit-mode-map
         :states '(normal insert)
         ;; movement
         ;; "C-h" 'backward-char
         ;; "C-l" 'forward-char
         "C-j" 'paredit-newline
         "C-M-h" 'paredit-backward
         "C-M-l" 'paredit-forward
         "C-<left>" 'paredit-backward
         "C-<right>" 'paredit-forward

         ;; transformation
         ;;; kill or wrap surrounding parentheses
         "C-S-K" 'paredit-splice-sexp
         "C-S-J" 'paredit-wrap-round
         ;;; include previous or next arguments in current sexp
         "C-S-H" 'paredit-backward-slurp-sexp
         "C-S-L" 'paredit-forward-slurp-sexp
         ;;; exclude previous or next arguments from current sexp
         "C-M-S-H" 'paredit-backward-barf-sexp
         "C-M-S-L" 'paredit-forward-barf-sexp

         "C-S-S" 'paredit-split-sexp
         "C-S-M-J" 'paredit-join-sexps ;; immediately with expression b4 point

         ;; splice next argument after point, deleting
         ;; arguments both before and after it
         ;; a cool shortcut, but not really necessary
         ;; "M-r"   'paredit-raise-sexp
         ))
    #+END_SRC

*** Package Lint
    #+begin_src emacs-lisp
      (use-package package-lint
        :straight t
        :commands package-lint-current-buffer)

      (require '+pkg-compile-multi)
      (use-package compile-multi
        :config
        (push `(emacs-lisp-mode
                ("emacs:package-lint" . ,#'package-lint-current-buffer))
              compile-multi-config))
    #+end_src

*** FlyMake Package Lint                                             :linter:
    #+begin_src emacs-lisp
      (use-package package-lint-flymake
        :straight t
        :autoload package-lint-flymake
        :flymake-hook
        (emacs-lisp-mode
         elisp-flymake-byte-compile
         ;; Some weird conflict with company?
         (elisp-flymake-checkdoc :disabled t)
         package-lint-flymake))
    #+end_src

*** Appendix
    #+begin_src emacs-lisp
     (provide '+lang-elisp)
    #+end_src

** GLSL
   :PROPERTIES:
   :header-args+: :tangle (package-lisp! +lang-glsl glsl)
   :END:

   #+begin_src emacs-lisp :tangle (package-yes! glsl)
   (require '+lang-glsl)
   #+end_src

*** GLSL Mode
    #+BEGIN_SRC emacs-lisp
      (use-package glsl-mode
        :straight t
        :mode ("\\.vs$" . glsl-mode))
    #+END_SRC

*** Company GLSL                                                       :comp:
    Interactive completion using openGL [[https://www.khronos.org/opengles/sdk/tools/Reference-Compiler/][reference compiler]].

    #+begin_src emacs-lisp
      (use-package company-glsl
        :straight t
        :when (executable-find "glslangValidator")
        :completion+ (glsl-mode (company-glsl :company t)))
    #+end_src

*** Appendix
    #+begin_src emacs-lisp
     (provide '+lang-glsl)
    #+end_src

** Golang
   :PROPERTIES:
   :header-args+: :tangle (package-lisp! +lang-golang golang)
   :END:

   #+begin_src emacs-lisp :tangle (package-yes! golang)
   (require '+lang-golang)
   #+end_src

*** Go Mode
    #+begin_src emacs-lisp
      (use-package +setup-indent
        :config
        (push '(go-mode . 4) +indent-config)
        (push '(go-ts-mode . 4) +indent-config))
    #+end_src

    #+BEGIN_SRC emacs-lisp
      (use-package go-mode
        :straight t
        :indent+
        (go-mode 4)
        (go-ts-mode 4)

        :hook ((go-mode go-ts-mode) . indent-tabs-mode)
        :lazy-leader
        (:mode '(go-mode go-ts-mode)
         ;; requires: go get github.com/rogpeppe/godef
         "h" '(:ignore t :wk "help/guru")
         "hh" 'godoc-at-point
         "hH" 'godoc

         "g" '(:ignore t :wk "goto")
         "gi" 'go-goto-imports
         "gc" 'go-coverage

         "i" '(:ignore t :wk "imports/insert")
         "ia" 'go-import-add
         "ix" 'go-remove-unused-imports

         "e" '(:ignore t :wk "playground")
         "eb" 'go-play-buffer
         "er" 'go-play-region
         "ed" 'go-download-play))
    #+END_SRC

*** Go Compilation
    #+begin_src emacs-lisp
      (use-package compile
        :config
        ;; Adapted from [[https://github.com/nlamirault/gotest.el/blob/490189e68d743a851bfb42d0017428a7550e8615/gotest.el#L179][gotest.el]].
        (setq compilation-error-regexp-alist-alist
              (append
               '((go-test-testing . ("^[[:space:]]+\\([[:alnum:]-_/.]+\\.go\\):\\([0-9]+\\): .*$" 1 2)) ;; stdlib package testing
                 (go-test-testify . ("^[[:space:]]+Location:\t\\([[:alnum:]-_/.]+\\.go\\):\\([0-9]+\\)$" 1 2)) ;; testify package assert
                 (go-test-gopanic . ("^[[:space:]]+\\([[:alnum:]-_/.]+\\.go\\):\\([0-9]+\\) \\+0x\\(?:[0-9a-f]+\\)" 1 2)) ;; panic()
                 (go-test-compile . ("^\\([[:alnum:]-_/.]+\\.go\\):\\([0-9]+\\):\\(?:\\([0-9]+\\):\\)? .*$" 1 2 3)) ;; go compiler
                 (go-test-linkage . ("^\\([[:alnum:]-_/.]+\\.go\\):\\([0-9]+\\): undefined: .*$" 1 2))) ;; go linker)
               compilation-error-regexp-alist-alist)
              compilation-error-regexp-alist
              (append
               '(go-test-testing
                 go-test-testify
                 go-test-gopanic
                 go-test-compile
                 go-test-linkage)
               compilation-error-regexp-alist)))
    #+end_src

*** Go Guru
    :PROPERTIES:
    :header-args+: :tangle (package-lisp! +lang-golang golang (not :lsp))
    :END:

    Requires: ~go get golang.org/s/using-guru~

    Note: Only used when lsp based language support is not available.

    #+BEGIN_SRC emacs-lisp
      (use-package go-guru
        :straight t
        :after go-mode

        :preface
        (defun go-guru-preserve-compilation-window+ ()
          "Prevent my `compilation-hook' settings interfering with go-guru."
          (setq-local compilation-auto-kill-window+ nil))
        :hook (go-guru-output-mode . go-guru-preserve-compilation-window+)

        :lazy-leader
        (:mode '(go-mode go-ts-mode)
         "hd" 'go-guru-describe
         "hi" 'go-guru-implements
         "hc" 'go-guru-peers
         "hp" 'go-guru-pointsto
         "hs" 'go-guru-callstack
         "he" 'go-guru-whicherrs

         "gr" 'go-guru-referrers
         "g<" 'go-guru-callers
         "g>" 'go-guru-callees
         "go" 'go-guru-set-scope
         "gg" 'go-guru-definition
         "gf" 'go-guru-freevars))
    #+END_SRC

*** Go Impl                                                             :wip:
    Generate boilerplate for interface implementations in go.

    Requires ~go get -u github.com/josharian/impl~.

    #+begin_src emacs-lisp :tangle no
      (use-package go-impl
        :straight t
        :leader
        (:mode '(go-mode go-ts-mode)
         "ii" 'go-impl))
    #+end_src

*** gopls                                                               :lsp:
    The Golang language server.

    requires: ~GO11MODULE=on go get -u golang.org/x/tools/gopls@latest~.

    #+BEGIN_SRC emacs-lisp
      (use-package go-mode
        :hook (go-mode . +lsp-hook))
    #+END_SRC

*** Appendix
    #+begin_src emacs-lisp
    (provide '+lang-golang)
    #+end_src

** Groovy
   :PROPERTIES:
   :header-args+: :tangle (package-lisp! +lang-groovy groovy)
   :END:

   #+begin_src emacs-lisp :tangle (package-yes! groovy)
   (require '+lang-groovy)
   #+end_src

   #+begin_src emacs-lisp
     (use-package groovy-mode
       :straight t)
   #+end_src

   #+begin_src emacs-lisp
    (provide '+lang-groovy)
   #+end_src

** HAML
   :PROPERTIES:
   :header-args+: :tangle (package-lisp! +lang-haml haml)
   :END:

   #+begin_src emacs-lisp :tangle (package-yes! haml)
   (require '+lang-haml)
   #+end_src

   #+BEGIN_SRC emacs-lisp
     (use-package haml-mode
       :straight t
       :indent+ (haml-mode 2))
   #+END_SRC

   #+begin_src emacs-lisp
    (provide '+lang-haml)
   #+end_src

** Haskell
   :PROPERTIES:
   :header-args+: :tangle (package-lisp! +lang-haskell haskell)
   :END:

   #+begin_src emacs-lisp :tangle (package-yes! haskell)
     (require '+lang-haskell)
   #+end_src

*** Haskell Mode
    #+BEGIN_SRC emacs-lisp
      (use-package haskell-mode
        :straight t
        :hide-whitespace+
        haskell-interactive-mode
        inferior-haskell-mode

        :preface
        (defalias 'haskell-repl 'run-haskell)

        :init
        (evil-set-initial-state 'haskell-interactive-mode 'emacs)

        :config
        (setq haskell-process-type 'cabal-repl)

        :hook (haskell-mode . haskell-mode-fix-eldoc+)
        :autoload haskell-doc-current-info
        :preface
        ;; haskell-mode seems to be configuring the wrong value for eldoc.
        (defun haskell-doc-function+ (callback)
          (funcall callback (haskell-doc-current-info)))

        (defun haskell-mode-fix-eldoc+ ()
          (kill-local-variable 'eldoc-documentation-function)
          (add-hook 'eldoc-documentation-functions #'haskell-doc-function+ nil t))

        :lazy-leader
        (:mode 'haskell-mode
         "e" '(run-haskell :wk "haskell-repl")

         "r"  '(:ignore t :wk "refactor")
         "ri" 'haskell-mode-format-imports
         "rI" 'haskell-sort-imports

         "i"  '(:ignore t :wk "insert")
         "is" 'haskell-mode-toggle-scc-at-point

         "s"  '(:ignore t :wk "session")
         "sc" 'haskell-session-change
         "sC" 'haskell-session-change-target
         "sk" 'haskell-session-kill
         "sK" 'haskell-kill-session-process)

        :general
        (:keymaps 'haskell-mode-map "C-M-i" nil))
    #+END_SRC

*** Haskell Indent
    #+begin_src emacs-lisp
      (use-package haskell-indent
        :straight haskell-mode

        :general
        (:keymaps 'haskell-mode-map
         :states 'insert
         "<tab>" 'haskell-indent-cycle
         "S-TAB" 'haskell-delete-indentation)

        :leader
        (:mode 'haskell-mode
         "i|" 'haskell-indent-insert-guard
         "iw" 'haskell-indent-insert-where
         "io" 'haskell-indent-insert-other
         "i=" 'haskell-indent-insert-equal))
    #+end_src

*** Flycheck Haskell                                                 :linter:
    #+BEGIN_SRC emacs-lisp :tangle (package-lisp! +lang-haskell haskell flycheck)
      (use-package flycheck-haskell
        :straight t
        :after haskell-mode)
    #+END_SRC

*** Company Cabal                                                      :comp:
    #+BEGIN_SRC emacs-lisp
      (use-package company-cabal
        :straight t
        :autoload company-cabal
        :completion+
        (haskell-cabal-mode (company-cabal :company t)))
    #+END_SRC

*** Haskell IDE Engine                                                  :lsp:
    #+begin_src emacs-lisp
      (use-package haskell-mode
        :hook (haskell-mode . +lsp-hook))
    #+end_src

**** LSP Haskell                                                   :disabled:
     #+begin_src emacs-lisp :tangle (package-lisp! +lang-haskell haskell lsp-mode) :tangle no
       (use-package lsp-haskell
         :straight t
         :after (lsp haskell-mode)
         :demand t)
     #+end_src

*** Appendix
    #+begin_src emacs-lisp
      (provide '+lang-haskell)
    #+end_src

** HLedger
   :PROPERTIES:
   :header-args+: :tangle (package-lisp! +lang-hledger ledger)
   :END:

   #+begin_src emacs-lisp :tangle (package-yes! ledger)
   (require '+lang-hledger)
   #+end_src

*** Hledger Mode
    #+begin_src emacs-lisp
      (use-package hledger-mode
        :straight t
        :mode ((rx ".journal" eol) . hledger-mode)
        :hook (hledger-mode . +flyspell)
        :custom
        (hledger-jfile (or (getenv "LEDGER_FILE")
                           (join-path+ (xdg-documents-dir) "ledger" "main.journal")))
        (hledger-comments-column 0)
        (hledger-currency-string ""
         "Default to no currency (the file specifies D).")
        (hledger-enable-current-overlay nil)
        (hledger-amount-face 'font-lock-type-face)

        :init
        (evil-set-initial-state 'hledger-mode 'normal)

        :init
        (advice-add #'hledger-company :before-until
                    (defun hledger-company--set-company-kind+ (command &rest _args)
                      (when (eq command 'kind)
                        'ledger-account)))

        :modify-syntax+ '((?- . "w")
                          (?+ . "w"))

        :autoload hledger-company
        :completion+ (hledger-mode (hledger-company :company t))

        :autoload hledger-pulse-momentary-current-entry
        :config
        (defun hledger-pulse-momentary-current-entry-no-args+ (&rest _)
          (hledger-pulse-momentary-current-entry))

        (advice-add 'hledger-next-or-new-entry :after 'hledger-pulse-momentary-current-entry-no-args+)
        (advice-add 'hledger-backward-entry    :after 'hledger-pulse-momentary-current-entry-no-args+)

        :lazy-leader
        (:mode 'hledger-input-mode
         :minor t
         :prefix leader-major-mode-prefix
         "," 'hledger-commit-input
         "q" 'hledger-discard-input
         "Q" 'hledger-discard-input-jentry)

        (:mode 'hledger-mode
         "s" 'hledger-reschedule
         "a" 'hledger-edit-amount)

        :general
        (:keymaps 'hledger-mode-map
         :states 'motion
         "gj" 'hledger-next-or-new-entry
         "gk" 'hledger-backward-entry))
    #+end_src

*** FlyCheck Hledger                                                 :linter:
    :PROPERTIES:
    :header-args+: :tangle (package-lisp! +lang-hledger flycheck ledger)
    :END:

    #+begin_src emacs-lisp
      (use-package flycheck-hledger
        :straight t
        :after (flycheck hledger-mode)
        :demand t)
    #+end_src

*** Appendix
    #+begin_src emacs-lisp
    (provide '+lang-hledger)
    #+end_src

** HTML
   :PROPERTIES:
   :header-args+: :tangle (package-lisp! +lang-html html)
   :END:

   #+begin_src emacs-lisp :tangle (package-yes! html)
     (require '+lang-html)
   #+end_src

*** Web Mode
    #+BEGIN_SRC emacs-lisp
      (use-package web-mode
        :straight t
        :mode (rx "." (or "erb" "html" "vue"))
        :indent+ (web-mode 2)

        :autoload web-mode-guess-engine-and-content-type
        :config
        (add-hook 'hack-local-variables-hook
                  (defun web-mode-fix-dirlocals+ (&rest _)
                    "See issue #1118."
                    (when (derived-mode-p 'web-mode)
                      (web-mode-guess-engine-and-content-type))))

        :leader
        ("tmh" 'web-mode)
        (:mode 'web-mode
         ;; unbound:
         ;;   * web-mode-buffer-highlight
         ;;   * web-mode-element-mute-blanks
         ;;   * web-mode-block-beginning
         ;;   * web-mode-block-end
         ;;   * web-mode-block-insert
         ;;   * web-mode-block-kill
         ;;   * web-mode-block-next
         ;;   * web-mode-block-previous
         ;;   * web-mode-block-select
         ;;   * web-mode-block-transpose
         ;;   * web-mode-navigate
         ;;   * web-mode-snippet-insert
         ;;   * web-mode-element-children-fold-or-unfold
         ;;   * web-mode-dom-errors-show
         ;;
         ;; WARN the block commands don't seem to do anything

         "TAB"   'web-mode-fold-or-unfold
         "c"     'web-mode-comment-or-uncomment
         "c"     'web-mode-element-close ; insert matching tag for body at point
         "-"     'web-mode-buffer-indent

         ;; insert
         "i"  '(:ignore t :wk "insert")
         "ia" 'web-mode-attribute-insert
         "ip" 'web-mode-element-wrap ; wrap current element in a new element with name from prompt
         "ic" 'web-mode-element-clone
         "ie" 'web-mode-element-insert
         "ie" 'web-mode-element-insert-at-point ; converts word before point to tag
         "il" 'web-mode-file-link

         ;; refactor/insert
         "r"  '(:ignore t :wk "refactor")
         "rs" 'web-mode-tag-attributes-sort
         "r(" 'web-mode-element-extract  ; add linebreak before every tag in body
         "r)" 'web-mode-element-contract ; collapse tag into a single line
         "rn" 'web-mode-dom-normalize
         "ra" 'web-mode-attribute-transpose
         "re" 'web-mode-element-transpose
         "rr" 'web-mode-element-rename

         ;; delete
         "x"  '(:ignore t :wk "delete")
         "xa" 'web-mode-attribute-kill
         "xe" 'web-mode-element-kill
         "xp" 'web-mode-element-vanish ; delete element, but move body up a level instead of erasing it

         ;; DOM
         "t"  '(:ignore t :wk "DOM")
         "ta" 'web-mode-dom-apostrophes-replace
         "ts" 'web-mode-dom-entities-replace
         "tq" 'web-mode-dom-quotes-replace
         "tx" 'web-mode-dom-xpath                                                     ; shows the xpath of the current element

         ;; mark
         "m"  '(:ignore t :wk "mark")
         "mT" 'web-mode-tag-select
                                              ; only works while between <>
         "mt" 'web-mode-element-select
         "ma" 'web-mode-attribute-select
         "mb" 'web-mode-element-content-select
         "mm" 'web-mode-mark-and-expand

         ;; navigation
         "n"  '(:ignore t :wk "navigate")
         "na" 'web-mode-element-beginning
         "ne" 'web-mode-element-end
         "nn" 'web-mode-tag-match
         "nh" 'web-mode-element-next
         "nj" 'web-mode-element-child
         "nk" 'web-mode-element-previous
         "nh" 'web-mode-element-parent
         ;; "nt" 'web-mode-dom-traverse

         "np"  '(:ignore t :wk "attributes")
         "npa" 'web-mode-attribute-beginning
         "npe" 'web-mode-attribute-end
         "nph" 'web-mode-attribute-previous
         "npl" 'web-mode-attribute-next

         "nt"  '(:ignore t :wk "tags")
         "nta" 'web-mode-tag-beginning
         "nte" 'web-mode-tag-end
         "nth" 'web-mode-tag-previous
         "ntl" 'web-mode-tag-next)

        :general
        (:keymaps 'web-mode-map
         ;; [remap whitespace-mode] 'web-mode-whitespace-show
         [remap revert-buffer] 'web-mode-reload)
        (:keymaps 'web-mode-map
         :states 'normal
         "<tab>" 'web-mode-fold-or-unfold))
    #+END_SRC

*** Company Web                                                        :comp:
    #+BEGIN_SRC emacs-lisp
      (use-package company-web
        :straight t
        :autoload company-web-html
        :completion+
        (web-mode (company-web-html :company t))

        :init
        (advice-add 'company-web-html :before-until
                    (defun company-web-html--set-company-kind+ (command &rest _args)
                      (when (eq command 'kind)
                        'text))))
    #+END_SRC

*** Appendix
    #+begin_src emacs-lisp
      (provide '+lang-html)
    #+end_src

** Java
   :PROPERTIES:
   :header-args+: :tangle (package-lisp! +lang-java java)
   :END:

   #+begin_src emacs-lisp :tangle (package-yes! java)
     (require '+lang-java)
   #+end_src

   Java, the language *everyone* tolerates.

   #+BEGIN_SRC emacs-lisp
     (use-package cc-mode
       :hook (java-mode . +java-mode-fix-indentation)
       :preface
       (defun +java-mode-fix-indentation ()
         (c-set-offset 'inexpr-class 0)))
   #+END_SRC

   #+begin_src emacs-lisp
     (provide '+lang-java)
   #+end_src

** JavaScript
   :PROPERTIES:
   :header-args+: :tangle (package-lisp! +lang-javascript javascript)
   :END:

   #+begin_src emacs-lisp :tangle (package-yes! javascript)
     (require '+lang-javascript)
   #+end_src

*** JS Mode
    #+BEGIN_SRC emacs-lisp
      (use-package js
        :hook (((js-mode js-ts-mode) . electric-layout-local-mode)
               ((js-mode js-ts-mode) . +flylint))
        ;; Adapted from [[https://github.com/microsoft/vscode/blob/11c70a6358044ca3615e3017c222083bda4874a7/extensions/json/package.json#L48-L70][vscode]].
        :mode ((rx (or (and  (or ".jsonc"
                                 ".eslintrc"
                                 ".eslintrc.json"
                                 ".jsfmtrc"
                                 ".jshintrc"
                                 ".swcrc"
                                 ".hintrc"
                                 ".babelrc")
                             eol)
                       (and bol (or "babel.config.json"
                                    ".babelrc.json"
                                    ".ember-cli"
                                    "typedoc.json")
                            eol)))
               . js-mode)

        :indent+
        (js-mode 2)
        (js-ts-mode 2)

        :init
        (push '((js2-mode js-mode typescript-mode)
                (?{ . after)
                (?} . before))
              electric-layout-mode-rules+))
    #+END_SRC

*** JS Doc                                                         :disabled:
    #+BEGIN_SRC emacs-lisp :tangle no
      (use-package js-doc
        :straight t
        :config
        (advice-add 'js-doc-insert-function-doc-snippet :after
                    (lambda (&rest _)
                      (evil-insert nil)))

        :lazy-leader
        (:mode 'js2-mode
         "i@" 'js-doc-insert-tag
         "i)" 'js-doc-insert-function-doc                                            ; only works from within method
         "i(" 'js-doc-insert-function-doc-snippet
         "if" 'js-doc-insert-file-doc
         "h@" 'js-doc-describe-tag))
    #+END_SRC

*** TypeScript
    :PROPERTIES:
    :header-args+: :tangle (package-lisp! +lang-javascript javascript typescript)
    :END:

**** Typescript Mode
     #+begin_src emacs-lisp
       (use-package typescript-mode
         :straight t
         :hook (((typescript-mode typescript-ts-mode) . +flylint)
                ((typescript-mode typescript-ts-mode) . +lsp-hook))
         :indent+
         (typescript-mode 2)
         (typescript-ts-mode 2))
     #+end_src

**** Typescript React
     #+begin_src emacs-lisp
       (use-package typescript-mode
         :straight t
         :mode ((rx ".tsx" eol) . typescript-react-mode+)
         :hook ((typescript-react-mode+ . +flylint)
                (typescript-react-mode+ . +lsp-hook))
         :indent+
         (typescript-react-mode+ 2)

         :init
         (put 'tsx-ts-mode 'eglot-language-id "typescriptreact")

         :commands (typescript-react-mode+ typescript-mode)
         :config
         (define-derived-mode typescript-react-mode+ typescript-mode
           "TypescriptReact")

         (put 'typescript-react-mode+ 'eglot-language-id "typescriptreact"))
     #+end_src

*** Typescript Language Server                                          :lsp:
    #+BEGIN_SRC emacs-lisp :tangle (package-yes! javascript :lsp)
      (require '+pkg-project)

      (use-package js
        :hook ((js-mode js-ts-mode typescript-mode typescript-ts-mode typescript-react-mode+)
               . +lsp-hook)
        :preface
        (defun javascript-enable-lsp-in-projects+ ()
          (when (project-has-file-p+ "package.json" "yarn.lock")
            :local))

        :init
        (setq +lsp-maybe-connect
              (append
               `((js-mode . ,#'javascript-enable-lsp-in-projects+)
                 (typescript-mode . ,#'javascript-enable-lsp-in-projects+)
                 (typescript-react-mode . ,#'javascript-enable-lsp-in-projects+))
               +lsp-maybe-connect)))
    #+END_SRC

*** Appendix
    #+begin_src emacs-lisp
      (provide '+lang-javascript)
    #+end_src

** JSON
  :PROPERTIES:
  :header-args+: :tangle (package-lisp! +lang-json json)
  :END:

  #+begin_src emacs-lisp :tangle (package-yes! json)
    (require '+lang-json)
  #+end_src

  #+begin_src emacs-lisp
    ;; Adapted from [[https://github.com/microsoft/vscode/blob/11c70a6358044ca3615e3017c222083bda4874a7/extensions/json/package.json#L17-L47][vscode]].
    (defvar +json-auto-mode-alist-rx
      (rx (or (and  (or ".bowerrc"
                        ".jscsrc"
                        ".webmanifest"
                        ".js.map"
                        ".css.map"
                        ".ts.map"
                        ".har"
                        ".jslintrc"
                        ".jsonld"
                        ".geojson"
                        ".ipynb"
                        ".vuerc")
                    eol)
              (and bol (or "composer.lock"
                           ".watchmanconfig")
                   eol))))
  #+end_src

*** JSON Mode
   #+begin_src emacs-lisp :tangle (package-lisp! +lang-json json tree-sitter)
     (use-package json-ts-mode
       :hook (json-ts-mode . +flylint)
       :init
       (add-to-list 'auto-mode-alist (cons +json-auto-mode-alist-rx 'json-ts-mode))
       :modify-syntax+
       (json-ts-mode--syntax-table '((?- . "w"))))

     (use-package org-src
       :config
       (push '("json" . json-ts) org-src-lang-modes))
   #+end_src

   #+begin_src emacs-lisp :tangle (package-lisp! +lang-json json (not tree-sitter))
     (use-package js
       :hook (js-json-mode . +flylint)
       :init
       (add-to-list 'auto-mode-alist (cons +json-auto-mode-alist-rx 'js-json-mode))
       :modify-syntax+
       (js-json-mode-syntax-table '((?- . "w"))))

     (use-package org-src
       :config
       (push `("json" . js-json-mode) org-src-lang-modes))
   #+end_src

*** VScode JSON Language Server                                         :lsp:
    :PROPERTIES:
    :header-args+: :tangle (package-lisp! +lang-json json :lsp)
    :END:

    Try [[https://www.npmjs.com/package/vscode-json-languageserver][VSCode JSON Language Server]] which has jsonschema support.

    #+begin_src emacs-lisp
      (use-package json
        :hook ((json-mode jsonc-mode js-json-mode) . +lsp-hook)
        :init
        (setq +lsp-maybe-connect
              (append `((json-mode . :global)
                        (jsonc-mode . :global)
                        (js-json-mode . :global))
                      +lsp-maybe-connect)))
    #+end_src

    #+begin_src emacs-lisp :tangle (package-lisp! +lang-json json eglot)
      (use-package eglot
        :config
        (push '((json-mode jsonc-mode js-json-mode) .
                ("vscode-json-languageserver" "--stdio"))
              eglot-server-programs))
    #+end_src

*** Appendix
    #+begin_src emacs-lisp
    (provide '+lang-json)
    #+end_src

** JQ
   :PROPERTIES:
   :header-args+: :tangle (package-lisp! +lang-json json)
   :END:

   #+begin_src emacs-lisp :tangle (package-yes! jq)
     (require '+lang-jq)
   #+end_src

   #+begin_src emacs-lisp
     (use-package jq-mode
       :straight t)
   #+end_src

   #+begin_src emacs-lisp
    (provide '+lang-jq)
   #+end_src

** Kotlin
  :PROPERTIES:
  :header-args+: :tangle (package-lisp! +lang-kotlin kotlin)
  :END:

  #+begin_src emacs-lisp :tangle (package-yes! kotlin)
  (require '+lang-kotlin)
  #+end_src

*** Kotlin Mode
    #+BEGIN_SRC emacs-lisp
      (use-package kotlin-mode
        :straight t
        :hook (kotlin-mode . +lsp-hook)
        :indent+ (kotlin-mode 4)
        :lazy-leader
        (:mode 'kotlin-mode
         "r"     'kotlin-repl
         "e"     '(:ignore t :wk "eval/REPL")
         "e-"    'kotlin-send-line
         "e|"    'kotlin-send-block
         "er"    'kotlin-send-region
         "eb"    'kotlin-send-buffer
         "e S--" 'kotlin-send-line-and-focus
         "e S-|" 'kotlin-send-block-and-focus
         "eR"    'kotlin-send-region-and-focus
         "eB"    'kotlin-send-buffer-and-focus))
    #+END_SRC

*** Appendix
    #+begin_src emacs-lisp
    (provide '+lang-kotlin)
    #+end_src

** LaTeX
   :PROPERTIES:
   :header-args+: :tangle (package-lisp! +lang-latex latex)
   :END:

   #+begin_src emacs-lisp :tangle (package-yes! latex)
     (require '+lang-latex)
   #+end_src

*** TeX Mode
    #+BEGIN_SRC emacs-lisp
      (use-package tex-mode
        :hook (((latex-mode LaTeX-mode) . display-line-numbers-mode)
               ((latex-mode LaTeX-mode) . +flylint))
        :custom
        (TeX-electric-math '("\\( " . " \\)"))
        (TeX-auto-save  t)
        (TeX-parse-self t)
        (TeX-source-correlate-start-server t)
        (tex-print-file-extension ".pdf")
        (TeX-auto-private (list (etc! "auctex" "styles")))

        :indent+
        (tex-mode 2)
        (latex-mode 2)

        :hide-whitespace+
        TeX-output-mode
        TeX-special-mode

        :preface
        (defvar latex-modes+ '(latex-mode tex-mode)
          "list of tex related modes. used for leader and pretty symbols.")

        :preface
        (setq TeX-auto-local (state! "auctex" "auto"))                                  ; WARN this isn't supposed to be absolute

        :config
        (setq latex-standard-block-names
              (append latex-standard-block-names
                      (list "align")))

        (eval-when-compile
          (unless (file-exists-p TeX-auto-local)
            (mkdir TeX-auto-local t)))

      ;;; Extend prettify-symbol symbols from `tex--prettify-symbols-alist'.
        (eval
         `(configure-presym! '(,@latex-modes+ org-mode)
            ,@(cl-loop
               for tuple in tex--prettify-symbols-alist
               append (list (car tuple) (cdr tuple)))))

        :leader
        (:mode `(,@latex-modes+ org-mode)
         "{" 'latex-insert-block
         "}" 'latex-close-block)

        :general
        (:keymaps 'latex-mode-map "C-M-i" nil))
    #+END_SRC

*** AucTeX
    #+BEGIN_SRC emacs-lisp
      (use-package tex-site
        :straight auctex
        :hook (((latex-mode LaTeX-mode) . TeX-fold-mode)
               ((latex-mode LaTeX-mode) . TeX-source-correlate-mode)                               ; Lets your PDF-viewer open lines in emacs and the TeX-view command jump to lines in your viewer.
               ((latex-mode LaTeX-mode) . TeX-PDF-mode))
        :config
      ;;; Command to insert a math symbol at point
        (defvar LaTeX-math-menu)
        (defun latex-insert-math+ ()
          (interactive)
          (let* ((cands (cl-labels ((latex--math-collect (L)
                                      (cond ((vectorp L)
                                             (list (cons (aref L 0) (aref L 1))))
                                            ((listp L)
                                             (cl-loop for a in L nconc
                                                      (latex--math-collect a))))))
                          (latex--math-collect LaTeX-math-menu)))
                 (cand (assoc (completing-read "Math symbol: " cands nil t) cands)))
            (call-interactively (cdr cand))))

        :preface
      ;;; Make latex automatically repeat the last run command
        (defvar-local TeX-command-last+ nil
          "The last command invoked by TeX in this buffer.")

        :autoload (TeX-command
                   TeX-command-query
                   TeX-master-file)
        :config
        (defun TeX-command-smart+ (&optional prompt override-confirm)
          "`TeX-command-master' but with memory.
      This function works like the master command, however by default it reruns
      the last run command instead of prompting to run the command. You can pass
      a prefix arg to force the prompt to take place."
          (interactive "P")
          (let ((cmd (or (when (or (not TeX-command-last+) prompt)
                           (TeX-command-query (TeX-master-file nil nil t)))
                         TeX-command-last+)))
            (setq TeX-command-last+ cmd)                                               ; update command memory
            (TeX-command cmd 'TeX-master-file override-confirm)))

      ;;; Automatically save the current buffer before running a command
        (defvar TeX-auto-save-when-compile+ t
          "When true don't prompt to save before running a TeX command.")

        (advice-add 'TeX-command :before
                    (defun TeX-command--prompt-to-save+ (&rest _)
                      "Ask to save modified tex buffers, before running commands on them."
                      (when (and (buffer-modified-p)
                                 buffer-file-name
                                 (or TeX-auto-save-when-compile+
                                     (yes-or-no-p (format "Save file %s?" buffer-file-name))))
                        (save-buffer))))

        :config
        (when +TeX-view-in-emacs
          (add-hook 'TeX-after-compilation-finished-functions 'TeX-revert-document-buffer))

        :config
        (use-package tex
          :straight auctex
          :config
          (setq TeX-view-program-selection
                (append (delq nil (list (when +TeX-view-in-emacs
                                          '(output-pdf "PDF Tools"))
                                        (when (executable-find "zathura")
                                          '(output-pdf "Zathura"))
                                        '(output-html "xopen")))                      ; prefer over xdg-open
                        TeX-view-program-selection))

      ;;; Fix annoying emacsclient issues with synctex
          ;; emacs isn't using the path for my server file and there's no way to specify
          ;; both the server TCP file and socket file, so let's just hack it into the editor
          ;; command.

          (setq
           TeX-view-program-list
           (append
            `("Zathura"
              ;; Hit C-click in zathura to jump to a point in emacs.
              ("zathura %o"
               (mode-io-correlate
                ,(concat " --synctex-forward %n:0:\"%b\" -x \""
                         (concat "emacsclient "
                                 (cond
                                  ((unix-p+)
                                   (when-let* ((server-socket-dir (bound-and-true-p server-socket-dir)))
                                     (concat
                                      " --socket-name "
                                      (shell-quote-argument (join-path+ server-socket-dir "server")))))
                                  ((windows-p+)
                                   (when-let* ((server-auth-dir (bound-and-true-p server-auth-dir)))
                                     (concat
                                      (concat
                                       "--server-file "
                                       (shell-quote-argument (join-path+ server-auth-dir "server"))))))))
                         " +%{line} %{input}\"")))
              "zathura")
            (bound-and-true-p TeX-view-program-list))))

        :autoload (org-src-setup-auctex+
                   TeX-run-style-hooks)
        :config
        (defun org-src-setup-auctex+ ()
          (when (eq major-mode 'latex-mode)
            (apply #'TeX-run-style-hooks
                   (mapcar #'cadr (bound-and-true-p org-latex-packages-alist)))))
        (add-hook 'org-src-mode-hook #'org-src-setup-auctex+)

        :hook (latex-mode . TeX-setup-next-error-function+)
        :preface
        (defun TeX-setup-next-error-function+ ()
          (setq-local next-error-function 'TeX-next-error))

        :autoload (TeX-pop-to-buffer
                   TeX-active-buffer
                   TeX-recenter-output-buffer)
        :config
        ;; Show process output buffer on error.
        (advice-add 'TeX-command-sentinel :after
                    (defun TeX-process-error-handler+ (p _msg)
                      (unless (zerop (process-exit-status p))
                        (let* ((buf (TeX-active-buffer))
                               (visible (get-buffer-window buf nil)))
                          (TeX-recenter-output-buffer nil)
                          (unless visible
                            (TeX-pop-to-buffer (TeX-active-buffer)))))))

        ;; for some reason, focus switches back to tex buffer.
        (advice-add 'TeX-recenter-output-buffer :around
                    (defun TeX-recenter-focus+ (func &rest args)
                      (apply func args)
                      (when (called-interactively-p 'interactive)
                        (TeX-pop-to-buffer (TeX-active-buffer)))))


        :leader
        (:mode `(,@latex-modes+ org-mode)
         "\\" 'TeX-insert-macro)

        :lazy-leader
        (:mode 'TeX-error-overview-mode
         "b" 'TeX-error-overview-toggle-debug-bad-boxes
         "w" 'TeX-error-overview-toggle-debug-warnings
         "s" 'TeX-error-overview-toggle-suppress-ignored-warnings
         "l" 'TeX-error-overview-goto-log)
        (:mode latex-modes+
         "SPC" 'TeX-command-master
         "b" 'LaTeX-environment ;; block but more interactive.
         "," 'TeX-command-smart+
         "." 'TeX-command-run-all
         "l" 'TeX-recenter-output-buffer
         "e" 'TeX-error-overview
         "k" 'TeX-kill-job
         "v" 'TeX-view
         "h" 'TeX-doc
         "RET" 'TeX-command-run-all
         "t" 'TeX-font
         "i" 'TeX-insert-macro
         "s" 'LaTeX-section
         "m" 'latex-insert-math+
         "SPC" 'LaTeX-mark-environment                                                ; or LaTeX-mark-section

         ;; preview
         "p"   '(:ignore t :wk "preview")
         "pb"  'preview-buffer
         "pc"  'preview-clearout
         "pd"  'preview-document
         "pe"  'preview-environment
         "pf"  'preview-cache-preamble
         "pp"  'preview-at-point
         "pr"  'preview-region
         "ps"  'preview-section

         ;; fold
         "z" '(:ignore t :wk "fold")
         "z=" 'TeX-fold-math
         "zz" 'TeX-fold-dwim
         "zb" 'TeX-fold-buffer
         "zB" 'TeX-fold-clearout-buffer
         "ze" 'TeX-fold-env
         "zr" 'TeX-fold-region
         "zR" 'TeX-fold-clearout-region
         "zm" 'TeX-fold-macro
         "z\\" 'TeX-fold-macro
         "zp" 'TeX-fold-paragraph
         "zP" 'TeX-fold-clearout-paragraph
         "z%" 'TeX-fold-comment
         "zc" 'TeX-fold-clearout-item

         ;; indentation
         "TAB"   '(:ignore t :wk "indent")
         "TAB b" 'LaTeX-fill-environ
         "TAB p" 'LaTeX-fill-paragra
         "TAB r" 'LaTeX-fill-region
         "TAB s" 'LaTeX-fill-section

         ;; modes
         "M"  '(:ignore t :wk "mode")
         "Mp" 'TeX-PDF-mode ;; toggle between PDF and DVI output.
         "Ms" 'TeX-source-correlate-mode
         "Mi" 'TeX-interactive-mode
         "Mm" 'LaTeX-math-mode

         ;; toggle
         "T"  '(:ignore t :wk "toggle")
         "Tb" 'TeX-toggle-debug-bad-boxes
         "Td" 'TeX-toggle-debug-warnings
         "Ts" 'TeX-toggle-suppress-ignored-warnings)

        :general
        (:states 'motion
         :keymaps 'TeX-error-overview-mode-map
         "o" 'TeX-error-overview-goto-source
         "gj" 'TeX-error-overview-next-error
         "gk" 'TeX-error-overview-previous-error
         "RET" 'TeX-error-overview-jump-to-source
         [remap quit-window] 'TeX-error-overview-quit)
        ;; (:states '(insert emacs)
        ;;  :keymaps 'LaTeX-mode-map
        ;;  "$" 'self-insert-command)
        )
    #+END_SRC

*** Appendix
    #+begin_src emacs-lisp
      (provide '+lang-latex)
    #+end_src

** Log View
   :PROPERTIES:
   :header-args+: :tangle (package-lisp! +lang-logview log)
   :END:

   #+begin_src emacs-lisp :tangle (package-yes! log)
     (require '+lang-logview)
   #+end_src

*** Log View Mode
    #+BEGIN_SRC emacs-lisp
      (use-package logview
        :straight t
        :hook ((logview-mode . read-only-mode)
               (logview-mode . auto-revert-tail-mode))
        :custom
        (logview-views-file (share! "logview.views"))
        (logview-cache-filename (cache! "logview-cache.extmap"))

        :config
        (push '("python" . ((format . "LEVEL:NAME:MESSAGE")
                            (levels . "RFC 5424")))
              logview-additional-submodes)

        (setq logview-mode-map (make-sparse-keymap))

        :general
        (:keymaps 'logview-mode-map
         :states 'motion
         [remap evil-goto-first-line] 'logview-first-entry
         [remap evil-goto-line] 'logview-last-entry
         [remap revert-buffer] 'logview-revert-buffer
         [remap evil-next-line] 'logview-next-entry
         [remap evil-previous-line] 'logview-previous-entry
         "TAB" 'logview-go-to-message-beginning
         [C-i] 'logview-go-to-message-beginning
         "gj" 'logview-next-as-important-entry
         "gk" 'logview-previous-as-important-entry)

        :lazy-leader
        (:mode 'logview-mode
         "," 'logview-choose-submode
         "[" 'logview-narrow-from-this-entry
         "]" 'logview-narrow-up-to-this-entry
         "l" 'logview-refresh-buffer-as-needed
         "w" 'widen

         "t" '(:ignore t :wk "toggles")
         "t." 'logview-toggle-show-ellipses
         "tm" 'logview-toggle-search-only-in-messages
         "tD" 'logview-toggle-details-globally
         "td" 'logview-toggle-entry-details
         "tv" 'logview-toggle-region-entry-details
         "ta" 'auto-revert-mode
         "tA" 'auto-revert-tail-mode
         "th" 'logview-toggle-copy-visible-text-only
         "tg" 'logview-change-target-gap-length

         "s" '(:ignore t :wk "show")
         "se" 'logview-show-entries
         "sa" 'logview-reset-all-filters
         "sA" 'logview-reset-all-filters-restrictions-and-hidings
         "sv" 'logview-show-region-entries
         "sl" '(:ignore t :wk "levels")
         "sle" 'logview-show-only-errors
         "slw" 'logview-show-errors-and-warnings
         "sli" 'logview-show-errors-warnings-and-information
         "sld" 'logview-show-errors-warnings-information-and-debug
         "sla" 'logview-show-all-levels
         "sl0" 'logview-disable-unconditional-show
         "slE" 'logview-always-show-errors
         "slW" 'logview-always-show-errors-and-warnings
         "slI" 'logview-always-show-errors-warnings-and-information
         "slD" 'logview-always-show-errors-warnings-information-and-debug

         "f" '(:ignore t :wk "filter")
         "fh" 'logview-hide-entry
         "fv" 'logview-hide-region-entries
         "fm" 'logview-add-include-message-filter
         "fM" 'logview-add-exclude-message-filter
         "ft" 'logview-add-include-thread-filter
         "fT" 'logview-add-exclude-thread-filter
         "fa" 'logview-add-include-name-filter
         "fA" 'logview-add-exclude-name-filter
         "f>" 'logview-show-only-as-important
         "fe" 'logview-edit-filters

         "v" '(:ignore t :wk "view")
         "vj" 'logview-next-navigation-view-entry
         "vk" 'logview-previous-navigation-view-entry
         "vv" 'logview-switch-to-view
         "vs" 'logview-save-filters-as-view-for-submode
         "vS" 'logview-save-filters-as-global-view
         "ve" 'logview-edit-submode-views
         "vE" 'logview-edit-all-views
         "vh" 'logview-highlight-view-entries
         "vu" 'logview-unhighlight-view-entries
         "vx" 'logview-delete-view
         "vi" 'logview-assign-quick-access-index
         "vn" 'logview-set-navigation-view

         ;; zA logview-forget-difference-base-entries
         ;; zN logview-next-timestamp-gap-in-this-thread
         ;; zP logview-previous-timestamp-gap-in-this-thread
         ;; zT logview-forget-thread-difference-base-entry
         ;; za logview-difference-to-current-entry
         ;; zg logview-change-target-gap-length
         ;; zn logview-next-timestamp-gap
         ;; zp logview-previous-timestamp-gap
         ;; zt logview-thread-difference-to-current-entry
         ;; zz logview-go-to-difference-base-entry
         )

        :lazy-leader
        (:mode 'logview-filter-edit-mode
         "," 'logview-filter-edit-save
         "q" 'logview-filter-edit-cancel))
    #+END_SRC

*** Appendix
    #+begin_src emacs-lisp
      (provide '+lang-logview)
    #+end_src

** Lua
   :PROPERTIES:
   :header-args+: :tangle (package-lisp! +lang-lua lua)
   :END:

   #+begin_src emacs-lisp :tangle (package-yes! lua)
     (require '+lang-lua)
   #+end_src

   #+begin_src emacs-lisp
     (defvar lua-syntax-table-modifications+
       '((?_ . "w")))
   #+end_src

*** Lua Mode
    #+begin_src emacs-lisp :tangle (package-lisp! +lang-lua lua tree-sitter)
      (use-package lua-ts-mode
        :indent+ (lua-ts-mode 2)
        :hook (lua-ts-mode . +flylint)
        :modify-syntax+ (lua-ts--syntax-table lua-syntax-table-modifications+)
        :flymake-hook
        (flymake-collection-lua
         (lua-ts-flymake-luacheck :disabled t)))
    #+end_src

    #+begin_src emacs-lisp :tangle (package-lisp! +lang-lua lua (not tree-sitter))
      (use-package lua-mode
        :straight t
        :indent+ (lua-mode 2)
        :hook (lua-mode . +flylint)
        :modify-syntax+ lua-syntax-table-modifications+

        :autoload lua-flymake
        :flymake-hook
        (flymake-collection-lua
         (lua-flymake :disabled t))

        :leader
        (:mode 'lua-mode
         "h" '(:ignore t :wk "help")
         "hd" 'lua-search-documentation

         "s" '(:ignore t :wk "REPL")
         "sb" 'lua-send-buffer
         "sf" 'lua-send-defun
         "sl" 'lua-send-current-line
         "sr" 'lua-send-region
         "'"  'lua-show-process-buffer))
    #+end_src

*** Company Lua                                                         :comp:
    #+begin_src emacs-lisp
      (use-package company-lua
        :straight t
        :autoload company-lua
        :completion+ (lua-mode (company-lua :company t))
        :completion+ (lua-ts-mode (company-lua :company t)))
    #+end_src

*** Lua Language Server                                                 :lsp:
    #+begin_src emacs-lisp
      (use-package lua-mode
        :hook (lua-mode . +lsp-hook))
    #+end_src

*** Appendix
    #+begin_src emacs-lisp
      (provide '+lang-lua)
    #+end_src

** Makefile
   :PROPERTIES:
   :header-args+: :tangle (package-lisp! +lang-makefile makefile)
   :END:

   #+begin_src emacs-lisp :tangle (package-yes! makefile)
   (require '+lang-makefile)
   #+end_src

   #+BEGIN_SRC emacs-lisp
     (use-package make-mode
       :config
       ;; Tabs for indentation, spaces for alignment.
       (advice-add 'makefile-backslash-region :around
                   (defun makefile-backslash-region--no-tabs+ (func &rest args)
                     (let ((indent-tabs-mode nil))
                       (apply func args))))

       (advice-add 'makefile-create-up-to-date-overview :after #'evil-motion-state)

        :modify-syntax+
        (makefile-mode-syntax-table '((?_ . "w")
                                      (?- . "w")))

       :lazy-leader
       (:mode '(makefile-automake-mode
                makefile-bsdmake-mode
                makefile-gmake-mode
                makefile-imake-mode
                makefile-mode
                makefile-makepp-mode)
        "o" 'makefile-create-up-to-date-overview
        "p" 'makefile-pickup-everything
        "f" 'makefile-pickup-filenames-as-targets
        "i" 'makefile-insert-target-ref

        "\\"  'makefile-backslash-region
        "TAB" 'makefile-insert-gmake-function)

       :general
       (:keymaps 'makefile-mode-map
        :states 'motion
        "gj" 'makefile-next-dependency
        "gk" 'makefile-previous-dependency))
   #+END_SRC

   #+begin_src emacs-lisp
    (provide '+lang-makefile)
   #+end_src

** Markdown
   :PROPERTIES:
   :header-args+: :tangle (package-lisp! +lang-markdown markdown)
   :END:

   #+begin_src emacs-lisp :tangle (package-yes! markdown)
    (require '+lang-markdown)
   #+end_src

*** Markdown Mode
    #+BEGIN_SRC emacs-lisp
      (use-package markdown-mode
        :straight t
        :hook ((markdown-mode . display-line-numbers-mode)
               (markdown-mode . auto-fill-mode)
               (markdown-mode . +flylint)
               (markdown-mode . +flyspell)
               (markdown-mode . +lsp-hook))
        :custom
        (markdown-indent-on-enter 'indent-and-new-item)
        (markdown-fontify-code-blocks-natively t)
        (markdown-ordered-list-enumeration nil
         "It bothers mdlint for some reason.")

        :modify-syntax+
        (markdown-mode-syntax-table
         '((?_ . "$")
           (?- . "_")))

        :init
        (push '(markdown-mode . t) +lsp-maybe-connect)

        :config
      ;;; evil-markdown-mode (Somelauw/evil-markdown)
        (with-eval-after-load 'evil
          (evil-declare-motion 'markdown-forward-paragraph)
          (evil-declare-motion 'markdown-backward-paragraph)

          ;; heading
          (evil-declare-motion 'markdown-forward-same-level)
          (evil-declare-motion 'markdown-backward-same-level)
          (evil-declare-motion 'markdown-up-heading)
          (evil-declare-motion 'markdown-next-heading)
          (evil-declare-motion 'markdown-previous-heading)
          (evil-declare-motion 'markdown-next-visible-heading)
          (evil-declare-motion 'markdown-previous-visible-heading)

          ;; other
          (evil-declare-motion 'markdown-beginning-of-block)
          (evil-declare-motion 'markdown-beginning-of-defun)
          (evil-declare-motion 'markdown-end-of-block)
          (evil-declare-motion 'markdown-end-of-block-element)
          (evil-declare-motion 'markdown-end-of-defun)
          (evil-declare-motion 'markdown-next-visible-heading)
          (evil-declare-motion 'markdown-next-link)
          (evil-declare-motion 'markdown-previous-visible-heading)
          (evil-declare-motion 'markdown-previous-link)

          ;; non-repeatable
          (evil-declare-change-repeat 'markdown-cycle)
          (evil-declare-change-repeat 'markdown-shifttab))

        :config
        (push '("make" . makefile-mode) markdown-code-lang-modes)

        :lazy-leader
        (:mode 'markdown-mode
         ;; unbound commands:
         ;;  * markdown-outdent-region
         ;;  * markdown-indent-region
         ;;  * markdown-outline-previous-same-level
         "h" 'markdown-up
         "j" 'markdown-next
         "k" 'markdown-previous
         "l" 'markdown-outline-next-same-level
         "g" 'markdown-next-link
         "G" 'markdown-previous-link
         "}" 'markdown-forward-block
         "{" 'markdown-backward-block
         "SPC" 'markdown-do
         "'" 'markdown-edit-code-block
         "f" 'markdown-follow-thing-at-point
         ">" 'markdown-blockquote-region
         "TAB" 'markdown-pre-region ;; preformat

         ;; complete/checks
         "c"  '(:ignore t :wk "check/complete")
         "cc" 'markdown-complete
         "cb" 'markdown-complete-buffer
         "cr" 'markdown-check-refs
         "cR" 'markdown-unused-refs
         "cl" 'markdown-cleanup-list-numbers

         "o" 'markdown-open
         "e" 'markdown-export
         "p" 'markdown-preview
         "v" 'markdown-export-and-preview
         "O" 'markdown-other-window

         ;; insert
         "i"  '(:ignore t :wk "insert")
         "i TAB" 'markdown-insert-image
         "i*" 'markdown-insert-list-item
         "i!" 'markdown-insert-header-setext-1
         "i-" 'markdown-insert-hr
         "i1" 'markdown-insert-header-atx-1
         "i2" 'markdown-insert-header-atx-2
         "i3" 'markdown-insert-header-atx-3
         "i4" 'markdown-insert-header-atx-4
         "i5" 'markdown-insert-header-atx-5
         "i6" 'markdown-insert-header-atx-6
         "i@" 'markdown-insert-header-setext-2
         "iC" 'markdown-insert-gfm-code-block
         "iH" 'markdown-insert-header-setext-dwim
         "i[" 'markdown-insert-gfm-checkbox
         "ib" 'markdown-insert-bold
         "ic" 'markdown-insert-code
         "ie" 'markdown-insert-italic
         "if" 'markdown-insert-footnote
         "ii" 'markdown-insert-italic
         "ik" 'markdown-insert-kbd
         "ip" 'markdown-insert-pre
         "iq" 'markdown-insert-blockquote
         "is" 'markdown-insert-strike-through

         "ih"  '(:ignore t :wk "header")
         "ih!" 'markdown-insert-header-setext-1
         "ih1" 'markdown-insert-header-atx-1
         "ih2" 'markdown-insert-header-atx-2
         "ih3" 'markdown-insert-header-atx-3
         "ih4" 'markdown-insert-header-atx-4
         "ih5" 'markdown-insert-header-atx-5
         "ih6" 'markdown-insert-header-atx-6
         "ih@" 'markdown-insert-header-setext-2
         "ihH" 'markdown-insert-header-setext-dwim
         "ihh" 'markdown-insert-header-dwim
         "ihs" 'markdown-insert-header-setext-2
         "iht" 'markdown-insert-header-setext-1

         "il"  '(:ignore t :wk "link")
         "ill" 'markdown-insert-link
         "ilf" 'markdown-insert-footnote
         "ilu" 'markdown-insert-uri
         "ilw" 'markdown-insert-wiki-link

         ;; delete/kill
         "d"  '(:ignore t :wk "delete")
         "dd" 'markdown-kill-thing-at-point
         "db" 'markdown-kill-block
         "do" 'markdown-kill-outline
         "dy" 'markdown-kill-ring-save

         ;; toggles
         "M"  '(:ignore t :wk "toggle")
         "Mm" 'markdown-toggle-math
         "Mf" 'markdown-toggle-fontify-code-blocks-natively
         "Mi" 'markdown-toggle-inline-images
         "Mu" 'markdown-toggle-url-hiding
         "Mm" 'markdown-toggle-markup-hiding
         "Mc" 'markdown-toggle-gfm-checkbox
         "Ml" 'markdown-live-preview-mode

         ;; narrowing
         "n"  '(:ignore t :wk "narrow")
         "nb" 'markdown-narrow-to-block
         "np" 'markdown-narrow-to-page
         "ns" 'markdown-narrow-to-subtree
         "nw" 'widen

         ;; marks
         "m"  '(:ignore t :wk "mark")
         "ms" 'markdown-mark-subtree
         "mb" 'markdown-mark-block

         ;; table
         "t"  '(:ignore t :wk "table")
         "ts" 'markdown-table-sort-lines
         "tT" 'markdown-table-transpose
         "tt" 'markdown-insert-table
         "tn" 'markdown-insert-table
         "tc" 'markdown-table-convert-region

         "ti"  '(:ignore t :wk "insert")
         "tir" 'markdown-table-insert-row
         "tic" 'markdown-table-insert-column
         "tit" 'markdown-insert-table

         "td"  '(:ignore t :wk "delete")
         "tdr" 'markdown-table-delete-row
         "tdc" 'markdown-table-delete-column)

        :general
        (:keymaps 'markdown-mode-map
         :states 'motion
         "gh" 'markdown-up-heading
         "gj" 'markdown-outline-next
         "gk" 'markdown-outline-previous
         "gl" 'markdown-outline-next-same-level
         "}" 'markdown-forward-paragraph
         "{" 'markdown-backward-paragraph)
        (:keymaps 'markdown-mode-map
         :states 'insert
         "RET"      'markdown-enter-key
         "<return>" 'markdown-enter-key)
        (:keymaps 'markdown-mode-map
         :states '(normal insert)
         "C-<return>" 'markdown-insert-list-item)
        (:keymaps 'markdown-mode-map
         :states '(insert normal)
         :predicate '(markdown-list-item-at-point-p)
         [remap drag-stuff-down]  'markdown-move-down
         [remap drag-stuff-up]    'markdown-move-up)
        (:keymaps 'markdown-mode-map
         :states '(insert normal)
         :predicate '(or (markdown-list-item-at-point-p)
                         (markdown-on-heading-p))
         [remap evil-shift-right] 'markdown-demote
         [remap evil-shift-left]  'markdown-promote)
        (:keymaps 'markdown-mode-map
         :states '(insert normal)
         :predicate '(or (markdown--table-at-point-p)
                         (markdown-on-heading-p))
         "<tab>"           'markdown-cycle
         "<S-iso-lefttab>" 'markdown-shifttab
         "<S-tab>"         'markdown-shifttab
         "<backtab>"       'markdown-shifttab))
    #+END_SRC

*** GitHub Markdown
    #+BEGIN_SRC emacs-lisp
      (use-package gh-md
        :straight t
        :leader
        (:mode 'markdown-mode
         "r" 'gh-md-render-buffer
         "R" 'gh-md-render-region))
    #+END_SRC

*** Appendix
    #+begin_src emacs-lisp
    (provide '+lang-markdown)
    #+end_src

** Meson
   :PROPERTIES:
   :header-args+: :tangle (package-lisp! +lang-meson meson)
   :END:

   #+begin_src emacs-lisp :tangle (package-yes! meson)
   (require '+lang-meson)
   #+end_src

   #+begin_src emacs-lisp
     (use-package meson
       :straight t)
   #+end_src

   #+begin_src emacs-lisp
    (provide '+lang-meson)
   #+end_src

** Nim
  :PROPERTIES:
  :header-args+: :tangle (package-lisp! +lang-nim nim)
  :END:

  #+begin_src emacs-lisp :tangle (package-yes! nim)
    (require '+lang-nim)
  #+end_src

*** Nim Mode
    #+BEGIN_SRC emacs-lisp
      (use-package nim-mode
        :straight t
        :hook ((nim-mode . nim-eldoc-on)
               (nim-mode . nimsuggest-mode))
        :general
        (:keymaps 'nim-mode-map
         [remap compile] 'nim-compile)
        (:keymaps 'nim-mode-map
         :states 'insert
         "DEL" 'nim-electric-backspace)

        :lazy-leader
        (:mode 'nim-mode
         "c" 'nim-compile))
    #+END_SRC

*** Nim Compilation
    #+begin_src emacs-lisp
      (use-package nim-mode
        :preface (use-package +pkg-compile :autoload +set-compilation-bindings)
        :config
        (+set-compilation-bindings 'nim-compile-mode 'nim-compile-mode-map)

        :preface (use-package compile :autoload compilation-read-command)
        :config
        (advice-add 'nim-compile--assert :override
                    (defun nim-compile--assert+ (command)
                      "Check COMMAND.
      Basically copied from `compile-command's document."
                      (or (stringp command)
                          (and (bound-and-true-p compilation-read-command)
                               (compilation-read-command))))))
    #+end_src

*** Nim Lsp                                                             :lsp:
    Lets use [[https://github.com/PMunch/nimlsp][nimlsp]].

    #+BEGIN_SRC emacs-lisp :tangle (package-lisp! +lang-nim nim :lsp)
      (use-package nim-mode
        :hook (nim-mode . +lsp-hook)
        :init
        (remove-hook 'nim-mode-hook 'nim-eldoc-on)
        (remove-hook 'nim-mode-hook 'nimsuggest-mode))
    #+END_SRC

    #+begin_src emacs-lisp :tangle (package-lisp! +lang-nim nim eglot)
      (use-package eglot
        :config
        (push '((nim-mode nimscript-mode) "nimlsp")
              eglot-server-programs))
    #+end_src

*** Appendix
   #+begin_src emacs-lisp
     (provide '+lang-nim)
   #+end_src

** Org
   :PROPERTIES:
   :header-args+: :tangle (package-lisp! +lang-org org)
   :END:

   #+begin_src emacs-lisp :tangle (package-yes! org)
    (require '+lang-org)
   #+end_src

   The quintessential plain-text editing and writing package for emacs. It ranges
   from a basic writing utility to a spread-sheet engine or even a time-sheet
   manager.

*** Org Mode
    First we need to define some aliases due to some migration errors. See [[https://emacs.stackexchange.com/questions/58994/symbol-s-value-as-variable-is-void-org-priority-highest-using-org-agenda][here]].

    #+begin_src emacs-lisp
      (defvaralias 'org-highest-priority 'org-priority-highest)
      (defvaralias 'org-lowest-priority 'org-priority-lowest)
      (defvaralias 'org-default-priority 'org-priority-default)
    #+end_src

    #+BEGIN_SRC emacs-lisp
      (require '+lib-misc)

      (use-package org
        :straight t
        :hook ((org-mode . display-line-numbers-mode)
               (org-mode . auto-fill-mode)
               (org-mode . +flyspell))
        :custom
        (org-clock-idle-time 15)
        (org-fontify-done-headline nil)
        (org-archive-file-header-format "\
      # -*- mode: org; coding: utf-8-unix -*-
      ,#+TITLE: Archive
      ,#+STARTUP: content")
        (org-goto-interface 'outline-path-completion)
        (org-log-done 'time)                                                          ; Record when a TODO item is done.
        (org-outline-path-complete-in-steps nil)                                      ; Refile in a single go
        (org-cycle-separator-lines 0)                                                 ; Prevents weird coloring of collapsed trees
        (org-log-into-drawer "LOGBOOK")                                               ; Where org-add-note stores notes
        (org-todo-keywords (list
                            '(sequence "TODO" "DOING" "VERIFY" "|" "DONE" "DELAGATED" "SKIPPED")))
        (org-refile-use-outline-path t)                                               ; Show full paths for refiling
        (org-archive-location (concat (join-path+ +notes-home "archive.org") "::* %s"))                 ; Archive to the same file from everywhere
        (org-refile-targets (list
                             (cons (join-path+ user-emacs-directory "init.org") '(:maxlevel . 1))
                             (cons nil '(:maxlevel . 9))
                             (cons 'org-agenda-files '(:maxlevel . 2))))
        (org-highlight-latex-and-related '(latex script entities))
        (org-adapt-indentation t)

        :indent+ (org-mode 2)
        :modify-syntax-hook+
        (org-mode '((?< . "_")
                    (?> . "_")
                    (?- . "w")
                    (?_ . "w")))

        :init
        (defvar electric-pair-preserve-balance)
        (add-hook 'org-mode-hook
                  (defun org-disable-electric-balance+ ()
                    (setq electric-pair-preserve-balance t)))

        :autoload org-eval-in-calendar
        :preface
        (defmacro evil-org-eol-call-anon (&rest body)
          "define an anonymous function running body at the end of the line"
          `(lambda! (end-of-visual-line) ,@body (evil-append nil)))

        (defmacro org-read-date-command (name &rest body)
          "define a function for use in the calendar buffer for `calendar-read-date'."
          `(defun ,(intern (concat "org-read-date-" (symbol-name name) "+")) ()
             ,@(when (stringp (car body))
                 (list (concat (pop body) "\nThis function was generated by `org-read-date-command'.")))
             (interactive)
             (org-eval-in-calendar (quote (progn ,@body)))))
        (put 'org-read-date-command 'lisp-indent-function 'defun)

        :config
        (setq org-read-date-minibuffer-local-map
              (let ((map (make-sparse-keymap)))
                (set-keymap-parent map minibuffer-local-map)
                map))

        :commands org-completing-goto+
        :config
        (defun org-completing-goto+ ()
          "Goto a refile target interactively."
          (interactive)
          (org-refile '(4)))

        :commands org-outline-smart-up-level+
        :config
        (defun org-outline-smart-up-level+ ()
          "When at a heading, move to parent.
      Otherwise move to current heading."
          (interactive)
          (call-interactively
           (if (org-at-heading-p)
               'outline-up-heading
             'outline-previous-heading)))

        (evil-set-command-property 'org-outline-smart-up-level+ :jump t)

        :autoload org-openable-p+
        :config
        (defun org-openable-p+ ()
          "Assert whether the element at point can be opened."
          (org-element-lineage
           (org-element-context)
           '(footnote-definition
             footnote-reference
             headline
             ;; inlinetask
             link
             timestamp)
           t))

        :preface
        (defvar org-clever-return--insert-headings+ nil
          "When true, returning from the end of a heading inserts a heading.")

        :autoload (org-clever-return--open-line+
                   org-clever-return--default-action+)
        :commands org-clever-return+
        :config
        ;; An alternative "RET" binding for org-mode. This varies the affect of return
        ;; depending on your position in the buffer. For example if you're in a table it
        ;; inserts a new row.

        (defun org-clever-return--open-line+ (above)
          (call-interactively
           (if above 'evil-open-above 'evil-open-below)))

        (defun org-clever-return--default-action+ (above interactive)
          (when (and (line-empty-p+)
                     (not (zerop (column-number+ (point)))))
            ;; don't leave a trailing indent on current line unnecessarily
            (delete-trailing-whitespace (line-beginning-position)
                                        (line-end-position)))

          (if (and interactive (not above))
              (funcall-interactively 'newline-and-indent)
            (org-clever-return--open-line+ above)))

        (defun org-clever-return+ (&optional above)
          "Smartly enter a newline in an org-mode buffer.

      Depending on the local state, inserts a heading, a table row an item or
      newline. this function is functionally similar to the result of
      evil-org-eol-call-anon, but instead of checking the line after moving to the
      end of it (which doesn't work for folded lines, such as headings), it checks
      before moving and then inserts the right items depending on how things looked
      where you were."
          (interactive)
          (cond
           ((and current-prefix-arg
                 (listp current-prefix-arg))
            (let (current-prefix-arg)
              (org-clever-return--default-action+
               above (called-interactively-p 'interactive))))

           ((org-at-table-p)
            (org-table-insert-row (not above))
            (evil-insert nil))

           ((and org-clever-return--insert-headings+
                 (org-at-heading-p))
            (org-clever-return--open-line+ above)
            (org-insert-heading))

           ((org-at-item-p)
            ;; position of cursor dictates where new point goes
            (goto-char (if above
                           (line-beginning-position)
                         (line-end-position)))
            (org-insert-item)
            (evil-append nil))

           (t
            (org-clever-return--default-action+
             above (called-interactively-p 'interactive)))))

        ;;; `org-find-file'
        :commands org-find-file+
        :autoload (org-find-file--generate-candidate+
                   org-find-file--exclude-p+
                   org-find-file-candidates+)
        :config
        (defun org-find-file--generate-candidate+ (file)
          (let ((relative (file-relative-name file +notes-home)))
            (if (string-prefix-p ".." relative)
                file
              relative)))

        (defun org-find-file-candidates+ ()
          (mapcar
           #'org-find-file--generate-candidate+
           (thread-first
             (cl-remove-if
              (apply-partially #'string-match-p
                               (rx (or (regexp +find-file-ignore-regexp)
                                       (and (or "/" "\\")
                                            (or (and "brain" (or "/" "\\"))
                                                (and "archived" (or "/" "\\")))))))
              (append (file-expand-wildcards (join-path+ +notes-home "*.org"))
                      (file-expand-wildcards (join-path+ +notes-home "**/*.org"))
                      org-agenda-files))
             (cl-remove-duplicates :test #'equal :from-end t))))

        (defun org-find-file+ (&optional select initial-input)
          (interactive "P")
          (if select
              (if-let* ((default-directory (or +notes-home default-directory))
                        (org-files (org-find-file-candidates+)))
                  (cond
                   ((package! :consult)
                    (declare-function consult--read "consult")
                    (declare-function consult--file-preview "consult")
                    (declare-function consult--lookup-cdr "consult")
                    (find-file
                     (consult--read org-files
                                    :prompt "Find file: "
                                    :require-match t
                                    :category 'file
                                    :state (consult--file-preview))))
                   (t (find-file
                       (completing-read "Find file: " org-files nil t initial-input))))
                (user-error "No notes files found."))
            (find-file org-default-notes-file)))

        :autoload (org-insert-todo-heading
                   org-metaright
                   org-metaleft
                   org-insert-heading)

        ;;             _ _       _     _           _ _
        ;;   _____   _(_) |     | |__ (_)_ __   __| (_)_ __   __ _ ___
        ;;  / _ \ \ / / | |_____| '_ \| | '_ \ / _` | | '_ \ / _` / __|
        ;; |  __/\ V /| | |_____| |_) | | | | | (_| | | | | | (_| \__ \
        ;;  \___| \_/ |_|_|     |_.__/|_|_| |_|\__,_|_|_| |_|\__, |___/
        ;;                                                   |___/

        :config
        (evil-set-command-property 'org-forward-heading-same-level :jump t)
        (evil-set-command-property 'org-backward-heading-same-level :jump t)
        (evil-set-command-property 'org-next-visible-heading :jump t)

        :config
        (add-to-list 'org-latex-default-packages-alist '("" "babel" t nil) t)

        :leader
        ("o"  '(:ignore t :wk "org-notes")
         "oo" 'org-find-file+
         "oc" 'org-capture
         "og" 'org-capture-goto-last-stored
         "oa" 'org-agenda
         "ol" 'org-store-link
         "oi" 'org-insert-link-global
         "oy" 'org-copy-subtree
         "oY" 'org-cut-subtree
         "on" 'org-next-link

         "oh" 'org-completing-goto+)

        :lazy-leader
        (:mode 'org-mode
         "RET" 'org-ctrl-c-ret
         "TAB" 'org-todo
         "SPC" 'org-display-outline-path
         "!" 'org-time-stamp-inactive
         "'" 'org-edit-special
         "*" 'org-ctrl-c-star
         "," 'org-ctrl-c-ctrl-c
         "-" 'org-ctrl-c-minus
         "." 'org-time-stamp
         "/" 'org-sparse-tree
         ":" 'org-set-tags-command
         "#" 'org-priority
         "`" 'org-toggle-latex-fragment
         "^" 'org-sort
         ;; "\\" 'org-match-sparse-tree
         "A" 'org-agenda
         "a" 'org-archive-subtree
         "b" 'org-tree-to-indirect-buffer
         ;; "C" 'evil-org-recompute-clocks
         "D" 'org-insert-drawer
         "d" 'org-deadline
         "F" 'org-set-effort
         "i" 'org-clock-in
         "H" 'org-shiftleft
         "J" 'org-shiftdown
         "K" 'org-shiftup
         "L" 'org-shiftright
         "l" 'org-insert-link
         "N" 'org-add-note
         "o" 'org-clock-out
         "O" 'org-sort
         "p" 'org-set-property
         "q" 'org-set-tags-command
         "r" 'org-refile
         "R" 'org-refile-goto-last-stored
         "s" 'org-schedule
         "T" 'org-show-todo-tree
         "X" 'org-update-all-dblocks
         "x" 'org-dblock-update
         "u" 'org-id-get-create
         ;; "C-h" 'org-shiftcontrolleft
         ;; "C-j" 'org-shiftcontroldown
         ;; "C-k" 'org-shiftcontrolup
         ;; "C-l" 'org-shiftcontrolright
         "M-a" 'org-attach
         "M-c" 'org-columns
         "M-p" 'org-delete-property

         "c"  '(:ignore t :wk "clock/calendar")
         "c<" 'org-date-from-calendar
         "c>" 'org-goto-calendar
         "cC" 'org-clock-out
         "cc" 'org-clock-in
         ;; "cf" 'org-clock-modify-effort-estimate
         "cg" 'org-clock-goto
         "ch" 'org-clock-remove-overlays
         "ci" 'org-timer-item
         "cr" 'org-clock-report
         "cs" 'org-clock-display
         "c C-c" 'org-clock-cancel

         "e"  '(:ignore t :wk "export")
         "ee" 'org-export-dispatch
         "eh" 'org-html-export-to-html
         "ep" (lambda!
                (org-latex-export-to-pdf (bound-and-true-p org-export-in-background)))

         "h"  '(:ignore t :wk "headings")
         "hI" 'org-insert-heading
         "hi" 'org-insert-heading-after-current
         "hs" 'org-insert-subheading

         "I"  '(:ignore t :wk "insert")
         "Ia" 'org-attach
         "If" 'org-footnote-new
         ;; "Ik" 'insert-keybinding-org
         "It" 'org-table-create
         ;; "Is" 'org-download-screenshot
         ;; "Iy" 'org-download-yank

         "m"  '(:ignore t :wk "mark/move")
         "ms" 'org-mark-subtree
         "me" 'org-mark-element
         "mb" 'org-babel-mark-block

         "n"  '(:ignore t :wk "narrow")
         "nb" 'org-narrow-to-block
         "ns" 'org-narrow-to-subtree
         "ne" 'org-narrow-to-element
         "nw" 'widen

         "S"  '(:ignore t :wk "subtrees")
         "Sh" 'org-promote-subtree
         "Sj" 'org-move-subtree-down
         "Sk" 'org-move-subtree-up
         "Sl" 'org-demote-subtree

         "t" '(:ignore t :wk "tables")
         "t'"  'org-table-edit-field
         "ta"  'org-table-align
         "tb"  'org-table-blank-field
         "tc"  'org-table-convert
         "tE"  'org-table-export
         "te"  'org-table-eval-formula
         "tH"  'org-table-move-column-left
         "th"  'org-table-previous-field
         "tI"  'org-table-import
         "tJ"  'org-table-move-row-down
         "tj"  'org-table-next-row
         "tK"  'org-table-move-row-up
         "tL"  'org-table-move-column-right
         "tl"  'org-table-next-field
         "tN"  'org-table-create-with-table.el
         "tn"  'org-table-create
         "tp"  'org-plot/gnuplot
         "tr"  'org-table-recalculate
         "ts"  'org-table-sort-lines
         "tw"  'org-table-wrap-region

         "td"  '(:ignore t :wk "delete")
         "tdc" 'org-table-delete-column
         "tdr" 'org-table-delete-row

         "ti"  '(:ignore t :wk "insert")
         "tic" 'org-table-insert-column
         "ti-" 'org-table-hline-and-move
         "tih" 'org-table-insert-hline
         "tir" 'org-table-insert-row

         "tt"  '(:ignore t :wk "toggle")
         "tta" 'org-toggle-async-export+
         "ttf" 'org-table-toggle-formula-debugger
         "tto" 'org-table-toggle-coordinate-overlays

         ;; "x"  '(:ignore t :wk "text")
         ;; "xb" 'org-bold
         ;; "xc" 'org-code
         ;; "xi" 'org-italic
         ;; "xr" 'org-clear
         ;; "xs" 'org-strike-through
         ;; "xu" 'org-underline
         ;; "xv" 'org-verbose
         )

        :general
        (:keymaps 'org-mode-map
         ;; "C-M-<return>" 'org-meta-return
         "<C-tab>" nil
         "M-S-<return>" nil
         "C-e" nil
         "M-e" nil
         "M-h" nil
         "C-j" nil
         [remap org-insert-link-global] 'org-insert-link)
        (:keymaps 'org-mode-map
         :states 'insert
         "RET" 'org-clever-return+
         "<return>" 'org-clever-return+
         "DEL" 'org-delete-backward-char
         "<S-backspace>" 'org-delete-char)
        (:keymaps 'org-mode-map
         :states 'normal
         ;; "M-u" 'org-metaleft
         ;; "M-i" 'org-metadown
         ;; "M-o" 'org-metaup
         ;; "M-p" 'org-metaright
         ;; "M-U" 'org-shiftmetaleft
         ;; "M-I" 'org-shiftmetadown
         ;; "M-O" 'org-shiftmetaup
         ;; "M-P" 'org-shiftmetaright
         "o" (lambda!
               (let ((org-clever-return--insert-headings+ t))
                 (org-clever-return+ nil)))
         "O" (lambda!
               (let ((org-clever-return--insert-headings+ t))
                 (org-clever-return+ t))))
        (:keymaps 'org-mode-map
         :states '(normal insert)
         ;; NOTE meta keys insert headings with changed priority, shift keys insert todo headings
         ;; FIXME prefix arg doesn't work
         "C-<return>"   (evil-org-eol-call-anon
                         (org-insert-heading nil))

         "C-M-<return>" (evil-org-eol-call-anon
                         (org-insert-heading nil)
                         (if current-prefix-arg
                             (org-metaleft)
                           (org-metaright)))

         "C-S-<return>"   (evil-org-eol-call-anon
                           (org-insert-todo-heading nil))

         "C-S-M-<return>" (evil-org-eol-call-anon
                           (org-insert-todo-heading nil)
                           (if current-prefix-arg
                               (org-metaleft)
                             (org-metaright)))

         ;; "C-." 'org-toggle-heading
         )
        ;; Most evil bindings taken from [[https://github.com/edwtjo/evil-org-mode][evil-org-mode]].
        (:keymaps 'org-mode-map
         :states '(normal visual)
         "gh" 'org-outline-smart-up-level+
         "gj" 'org-forward-heading-same-level
         "gk" 'org-backward-heading-same-level
         "gl" 'outline-next-visible-heading
         "$" 'org-end-of-line
         "^" 'org-beginning-of-line)
        (:keymaps 'org-mode-map
         :states  'visual
         "gb" 'org-babel-mark-block
         "gB" 'org-mark-element)
        (:keymaps 'org-mode-map
         :states '(normal visual)
         :predicate '(or (org-table-p t)
                         (org-at-heading-p)
                         (org-at-item-p))
         [remap drag-stuff-down] 'org-metadown
         [remap drag-stuff-up]   'org-metaup)
        ;; navigate throught tables or lists with tab in insert state.
        (:keymaps 'org-mode-map
         :states 'insert
         :predicate '(or (org-table-p t)
                         (org-at-heading-p)
                         (org-at-item-p))
         "TAB"     'org-cycle
         "<S-tab>" 'org-shifttab)
        (:keymaps 'org-mode-map
         :states '(normal visual emacs)
         "<tab>"   'org-cycle
         "TAB"     'org-cycle
         "<S-tab>" 'org-shifttab)
        (:keymaps 'org-mode-map
         :states '(normal insert visual)
         :predicate '(org-at-heading-p)
         [remap evil-shift-right] 'org-demote-subtree
         [remap evil-shift-left]  'org-promote-subtree
         [remap evil-shift-right-line] 'org-demote-subtree
         [remap evil-shift-left-line]  'org-promote-subtree)
        (:keymaps 'org-read-date-minibuffer-local-map
         ;; haven't implemented backward year, or forward year... cause when will
         ;; I ever need those.
         "C-M-j" 'exit-minibuffer
         "C-j" (org-read-date-command forward-week   (calendar-forward-week 1))
         "C-k" (org-read-date-command backward-week  (calendar-backward-week 1))
         "C-h" (org-read-date-command backward-day   (calendar-backward-day 1))
         "C-l" (org-read-date-command forward-day    (calendar-forward-day 1))
         "C-n" (org-read-date-command forward-month  (calendar-forward-month 1))
         "C-p" (org-read-date-command backward-month (calendar-backward-month 1))
         "<"   (org-read-date-command scroll-left    (calendar-scroll-left 1))
         ">"   (org-read-date-command scroll-right   (calendar-scroll-right 1))
         "!"   (org-read-date-command view-diary     (diary-view-entries))
         "."   (org-read-date-command goto-today
                 "When at end of prompt, goto today in calendar."
                 (if (looking-back "^[^:]+: "
                                   (let ((inhibit-field-text-motion t))
                                     (line-beginning-position)))
                     (org-eval-in-calendar '(calendar-goto-today))
                   (insert ".")))))
    #+END_SRC

*** Org Babel
    Deals with evaluating and substituting code-blocks in ~org-mode~.

    #+begin_src emacs-lisp
      (use-package ob
        :custom
        (org-confirm-babel-evaluate nil)
        (org-babel-load-languages nil)

        :preface
        (defun org-babel-lazy-load-languages+ (&rest langs)
          "Proxy for `org-babel-do-load-languages' that can defer loading."
          (let ((loaded (and (boundp 'org-babel-load-languages)
                             (default-value 'org-babel-load-languages)))
                (new-langs (cl-loop for it in langs collect (cons it t))))
            ;; `org-babel-do-load-languages' has this weird signature where
            ;; once you call it, it overrides the existing value of
            ;; `org-babel-load-languages', so even if you have some languages
            ;; already setup they can't be evaluated. This fixes that.
            (condition-case err
                (org-babel-do-load-languages 'org-babel-load-languages new-langs)
              (error (set-default 'org-babel-load-languages loaded)
                     (signal (car err) (cdr err))))
            (set-default 'org-babel-load-languages (append new-langs loaded))))

        :config
        ;; Some langs don't need any further deferring.
        (org-babel-do-load-languages 'org-babel-load-languages
         ;; Note: We haven't setup gnuplot, ditaa, plantuml and R.
         '((emacs-lisp . t)
           (latex . t)))

        ;; Add load hooks for the rest of the available languages I may use.
        (with-eval-after-load 'python (org-babel-lazy-load-languages+ 'python))
        (with-eval-after-load 'cc-mode (org-babel-lazy-load-languages+ 'C 'java 'haskell))
        (with-eval-after-load 'js       (org-babel-lazy-load-languages+ 'js))
        (with-eval-after-load 'js2-mode (org-babel-lazy-load-languages+ 'js))
        (with-eval-after-load 'shell (org-babel-lazy-load-languages+ 'shell))
        (with-eval-after-load 'cc-awk (org-babel-lazy-load-languages+ 'awk))
        (with-eval-after-load 'sed-mode (org-babel-lazy-load-languages+ 'sed))
        ;; Deferring these doesn't do anything for load-time, it's just because
        ;; I use them so rarely. If you want them loaded just insert a src-code
        ;; block with their format and it'll be available from then onwards.
        (with-eval-after-load 'sql (org-babel-lazy-load-languages+ 'sql))
        (with-eval-after-load 'ruby-mode (org-babel-lazy-load-languages+ 'ruby))
        (with-eval-after-load 'haskell-mode (org-babel-lazy-load-languages+ 'haskell))

        :autoload org-babel-lob-ingest
        :config
        (setq org-babel-default-header-args:emacs-lisp '((:lexical . "yes")))

        (let ((lob-file (etc! "babel-lib.org")))
          (when (file-exists-p lob-file)
            (org-babel-lob-ingest lob-file))))
    #+end_src

*** Org Cite
    :PROPERTIES:
    :header-args+: :tangle (package-lisp! +lang-org org bibtex)
    :END:

    #+begin_src emacs-lisp
      (require '+lang-bibtex)

      (use-package org
        :straight t
        :custom
        (org-cite-global-bibliography citar-bibliography))
    #+end_src

*** Org Agenda
    #+begin_src emacs-lisp
      (use-package org-agenda
        :init
        (evil-set-initial-state 'org-agenda-mode 'motion)

        :config
        (setq org-agenda-files
              (cl-remove-if
               (apply-partially #'string-match-p (rx (and "archive.org" eol)))
               (cl-loop for path in (list org-default-notes-file
                                          (concat projectile-org-projects-directory+ "*.org"))
                        nconc (file-expand-wildcards path))))

        :lazy-leader
        (:mode 'org-agenda-mode
         "A" 'org-agenda-append-agenda
         "C" 'org-agenda-columns

         ;;; filter/search
         "/"  '(:ignore t :wk "filter/search")
         "/c" 'org-agenda-filter-by-category
         "/e" 'org-agenda-filter-by-effort
         "//" 'org-agenda-filter-by-regexp
         ;; "/t" 'org-agenda-filter-by-tag
         "/:" 'org-agenda-filter-by-tag
         "/h" 'org-agenda-filter-by-top-headline
         "/R" 'org-agenda-filter-remove-all

         "/?" 'org-agenda-bulk-mark-regexp
         "/a" 'org-agenda-bulk-mark-all
         "/u" 'org-agenda-bulk-unmark-all

         ;;; clock/calendar/diary
         "c"  '(:ignore t :wk "clock/calendar")
         "cp" 'org-agenda-date-prompt
         "cc" 'org-agenda-clock-in
         "co" 'org-agenda-clock-out
         "cC" 'org-agenda-clock-out ; alias
         "ct" 'org-timer-set-timer
         "c M-c" 'org-agenda-convert-date

         ;;; agenda minor modes
         "m"  '(:ignore t :wk "modes")
         "ma" 'org-agenda-archives-mode
         "md" 'org-agenda-day-view
         "mc" 'org-agenda-clockreport-mode
         "mt" 'org-agenda-entry-text-mode
         "mf" 'org-agenda-follow-mode
         "ml" 'org-agenda-log-mode
         "mw" 'org-agenda-week-view
         "my" 'org-agenda-year-view
         "mm" 'org-agenda-month-view

         ;;; priorities
         "p"  '(:ignore t :wk "priority")
         "pp" 'org-agenda-priority
         "pu" 'org-agenda-priority-up
         "pd" 'org-agenda-priority-down)

        :general
        (:keymaps 'org-agenda-mode-map
         :states  'motion
          ;;; globally useful
         [remap quit-window] 'org-agenda-exit
         "." 'org-agenda-goto-today
         "v" 'org-agenda-view-mode-dispatch
         "RET" 'org-agenda-goto
         "TAB" 'org-agenda-switch-to
         "M-c" 'org-agenda-clock-goto ; jumped to clocking task
         "C-t" 'org-agenda-todo
         "M-t" 'org-agenda-show-tags

          ;;; marking
         "C-<SPC>" 'org-agenda-bulk-mark
         "M-<SPC>" 'org-agenda-bulk-unmark
         "C-M-SPC" 'org-agenda-bulk-action

          ;;; undo/redo
         "C-r" 'org-agenda-redo
         "u"   'org-agenda-undo
         "gr"        'org-agenda-redo-all

          ;;; toggle displays
         "gm" 'org-agenda-phases-of-moon
         "C-l" 'org-agenda-log-mode
         "M-l" 'org-agenda-toggle-time-grid
         "M-h" 'org-agenda-holidays
         "M-s" 'org-agenda-sunrise-sunset

         ;; edit org items
         "M-e" 'org-agenda-set-effort
         "C-a" 'org-agenda-archive-default-with-confirmation

          ;;; notes and insertion
         "a"  'org-agenda-add-note
         "c"  'org-agenda-capture
         "gd" 'org-agenda-goto-date
         "gc" 'org-agenda-goto-calendar

          ;;; movement between lines
          ;;; NOTE org-next/prev-line is used by follow-mode
         "k"      'org-agenda-previous-line
         "j"      'org-agenda-next-line
         "<up>"   'org-agenda-previous-line ; alias
         "<down>" 'org-agenda-next-line     ; alias
         "C-j"    'org-agenda-next-item
         "C-k"    'org-agenda-previous-item

          ;;; move through time in blocks
         "f" 'org-agenda-later
         "F" 'org-agenda-earlier

         "C-f" 'org-agenda-follow-mode
         "M-f" 'org-agenda-recenterstates))
    #+end_src

*** Org Contrib
    #+BEGIN_SRC emacs-lisp
      (use-package org-eldoc
        :straight org-contrib
        :after org
        :demand t
        :autoload org-eldoc-get-link+
        :preface (use-package ol :autoload org-link-get-parameter)
        :config
        (defun org-eldoc-get-link+ (&rest _)
          "When point is on a link, show the link destination in eldoc.
      To make links more informative, you can attach the special :eldoc property,
      this function will be passed the link and the result will be shown in the
      echo area."
          (when-let* ((ctx (org-element-lineage (org-element-context) '(link) t)))
            (let ((value (org-element-property :path ctx))
                  (type (org-element-property :type ctx)))
              (or
               (when-let* ((eldoc (org-link-get-parameter type :eldoc)))
                 (ignore-errors (funcall eldoc value)))
               value))))

        (advice-add 'org-eldoc-documentation-function :before-until #'org-eldoc-get-link+))
    #+END_SRC

*** Org Source
    #+BEGIN_SRC emacs-lisp
      (use-package org-src
        :custom
        (org-src-tab-acts-natively nil)                                               ; native tabs are slow and unreliable... :sad:
        (org-src-window-setup 'current-window)
        (org-src-ask-before-returning-to-edit-buffer nil)
        (org-edit-src-turn-on-auto-save nil)                                          ; WARN: Doesn't let you configure save path.
        (org-edit-src-auto-save-idle-delay 0)

        :init
        (advice-add 'org-edit-src-code :before
                    (defun org-edit-src-pre-exit-normal-state+ (&rest args)
                      (unless (eq evil-state 'normal)
                        (evil-normal-state))))

        :config
        ;; Trailing white-space is a pest that org-mode tacitly accepts.
        (advice-add 'org-src--contents-for-write-back :after
                    (defun org-edit-src-write-back-clean-whitespace+ (buf)
                      (with-current-buffer buf
                        (delete-trailing-whitespace (point-min) (point-max)))))

        (advice-add #'org-edit-src-save :around
                    (defun org-edit-src-save-buffer+ (func &rest args)
                      (if +indirect-edit-save-buffers
                          (apply func args)
                        (cl-letf (((symbol-function 'save-buffer)
                                   (symbol-function 'ignore)))
                          (apply func args)))))

        :leader
        (:mode 'org-src-mode
         :minor t
         :prefix leader-major-mode-prefix
         "," 'org-edit-src-exit
         "q" 'org-edit-src-abort
         "s" 'org-edit-src-save)

        :general
        (:keymaps 'org-src-mode-map
         [remap evil-write] 'org-edit-src-save
         [remap evil-quit] 'org-edit-src-abort
         ;; save and then quit
         [remap evil-save-and-close] 'org-edit-src-exit
         [remap evil-save-modified-and-close] 'org-edit-src-exit))
    #+END_SRC

*** Org Links
    Prefer Xopen to whatever mailcap plans to use.

    #+begin_src emacs-lisp
      (require '+pkg-browse-url)

      (use-package ol :commands (org-insert-link-global org-store-link))

      (use-package org
        :config
        (setq org-file-apps
              (append org-file-apps
                      `((t . ,(defun org-open-file-xopen+ (path _link)
                                (+xopen-url path))))))

        :config
        (let ((dir (file-name-directory org-id-locations-file)))
          (unless (file-exists-p dir)
            (make-directory dir t))))
    #+end_src

**** Man
     #+begin_src emacs-lisp
       (use-package ol-man
         :straight org-contrib
         :after ol
         :demand t
         :preface
         (defvaralias 'org-man-command '+man-command))
     #+end_src

**** Pdftools
     Adapted from [[https://github.com/fuxialexander/org-pdftools][org-pdftools]] this adds a link type to org mode which lets you link
     to and open PDFs. I've removed all the pdftools specific stuff so this is just a
     generic configuration section for pdf related actions in org mode.

     #+NAME: org-pdf-link
     #+begin_src emacs-lisp
       (require '+pkg-browse-url)

       (use-package ox
         :straight org
         :autoload org-export-file-uri)

       (use-package ol
         :straight org
         :preface
         (defvar +org-pdf-complete-link-page-history nil)

         :autoload (+org-pdf-complete-link
                    +org-pdf-open
                    +org-pdf-export
                    org-link-escape
                    org-link-complete-file)
         :config
         (defun +org-pdf-complete-link (&optional arg)
           "Use the existing file name completion for file.
       Links to get the file name, then ask the user for the page number
       and append it. ARG is passed to `org-link-complete-file'."
           (let ((default-directory (or +docs-home default-directory)))
             (concat
              (replace-regexp-in-string
               "^file:"
               (concat "pdftools" ":")
               (org-link-complete-file arg))
              "::"
              (read-from-minibuffer "Page: " "1" nil nil +org-pdf-complete-link-page-history))))

         (defun +org-pdf-open (link)
           (save-match-data
             (unless (string-match (rx (group (one-or-more any))
                                       "::"
                                       (group (zero-or-more (any digit))))
                                   link)
               (warn "Failed to extract path/page from: %s" link))

             (+xopen-pdf (expand-file-name (match-string 1 link)) (match-string 2 link))))

         (defun +org-pdf-export (link description format)
           "Export the pdfview LINK with DESCRIPTION for FORMAT from Org files."
           (let* (path page)
             (save-match-data
               (if (string-match "\\(.+\\)::\\(.*\\)" link)
                   (setq path (match-string 1 link)
                         page (match-string 2 link))
                 (setq path link)))
             (setq path (org-export-file-uri (org-link-escape path)))

             (cond ((eq format 'html)
                    (format "<a href=\"%s#page=%s\">%s</a>" path page description))
                   ((eq format 'latex)
                    (format "\\href{%s}{%s}" path description))
                   ((eq format 'ascii)
                    (format "%s (%s)" description path))
                   (t path))))

         :autoload org-link-set-parameters
         :config
         (org-link-set-parameters "pdftools"
          :follow   #'+org-pdf-open
          :complete #'+org-pdf-complete-link
          :export   #'+org-pdf-export))
     #+end_src

**** PdfBib
     :PROPERTIES:
     :header-args+: :tangle (package-lisp! +lang-org org bibtex)
     :END:
     A variant of the previous ~pdftools~ link which works using bibtex keys instead of
     PDF file paths.

     #+NAME: org-bib-pdf-link
     #+BEGIN_SRC emacs-lisp
       (require '+pkg-browse-url)

       (use-package ol
         :straight org
         :preface
         (defvar +org-pdf-bib-regex
           (rx (group (minimal-match (one-or-more any)))
               (optional
                "::"
                (group (one-or-more (any digit))))
               eol))

         :autoload (+org-pdf-bib-complete-link
                    +org-pdf-bib-open
                    +org-pdf-bib-export
                    +org-pdf-bib-eldoc)
         :config
         (defun +org-pdf-bib-complete-link (&optional arg)
           (concat
            "pdfbib:"
            (cond
             ((featurep 'citar)
              (with-no-warnings
                (citar-select-refs)))
             (t (user-error "No bibtex key reader found")))

            ;; I want to be able to omit a page number but read-number doesn't allow that :cry:.
            (let ((page (read-from-minibuffer "Page: " nil nil nil +org-pdf-complete-link-page-history)))
              (unless (string-empty-p page)
                (concat "::" page)))))

         (defun +org-pdf-bib-open (link)
           (save-match-data
             (unless (string-match +org-pdf-bib-regex link)
               (warn "Failed to extract path/page from: %s" link))

             (if-let* ((key (match-string 1 link))
                       (pdf (car (with-no-warnings
                                   (bibtex-completion-find-pdf key)))))
                 (+xopen-pdf pdf (match-string 2 link))
               (user-error "Failed to find PDF for bibentry with key: %s" key))))

         (defun +org-pdf-bib-export (link description format)
           "Export the pdfview LINK with DESCRIPTION for FORMAT from Org files."
           (let* (key)
             (save-match-data
               (if (string-match +org-pdf-bib-regex link)
                   (progn
                     (setq key  (match-string 1 link)))
                 (setq key link)))

             (cond ((eq format 'latex)
                    (format "%s \\cite{%s}" description key))
                   ((eq format 'ascii)
                    (format "%s (%s)" description key))
                   (t key))))

         (defun +org-pdf-bib-eldoc (link)
           (or
            (cdr (assoc "title"
                        (with-no-warnings
                          (bibtex-completion-get-entry (substring link 0 (s-index-of ":" link))))))
            link))

         :config
         (org-link-set-parameters "pdfbib"
          :follow   #'+org-pdf-bib-open
          :complete #'+org-pdf-bib-complete-link
          :export   #'+org-pdf-bib-export
          :eldoc    #'+org-pdf-bib-eldoc))

       (use-package org-ref
         :config
         (push '("pdfbib" "Citation type for pdfs at a specific page") org-ref-cite-types))
     #+END_SRC

**** Org Ref
     :PROPERTIES:
     :header-args+: :tangle (package-lisp! +lang-org org bibtex)
     :END:

     Add an eldoc handler for [[*org-ref][org-ref]] that can properly render all org-ref elements,
     this was mostly adapted from ~org-ref-link-message~ which used to use a custom
     timer and messages to do this.

     #+BEGIN_SRC emacs-lisp
       (use-package org-ref
         :autoload (org-ref-eldoc-cite+
                    org-ref-get-bibtex-key-under-cursor
                    org-ref-format-entry)
         :config
         (defun org-ref-eldoc-cite+ (&optional _path)
           (let ((key (save-excursion
                        (org-ref-get-bibtex-key-under-cursor))))
             (if (string= "*" key)
                 "*"
               (org-ref-format-entry key))))

         :autoload (org-ref-eldoc-ref+
                    org-ref-count-labels
                    org-ref-get-label-context)
         :config
         (defun org-ref-eldoc-ref+ (path)
           (if (= (org-ref-count-labels path)
                  0)
               "!!! NO CONTEXT FOUND !!!count: 0"
             (format "%scount: %s"
                     (org-ref-get-label-context path)
                     (org-ref-count-labels path))))

         :autoload org-ref-eldoc-label+
         :config
         (defun org-ref-eldoc-label+ (path)
           (let ((count (org-ref-count-labels path)))
             ;; get plurality on occurrence correct
             (concat
              (number-to-string count)
              " occurrence"
              (when (or (= count 0)
                        (> count 1))
                "s"))))

         :autoload (org-ref-eldoc-bibliography+
                    org-ref-strip-string
                    org-ref-find-bibfile)
         :config
         (defun org-ref-eldoc-bibliography+ (path)
           (string-join
            ", "
            (cl-loop for it in (mapcar #'org-ref-strip-string (split-string path ","))
                     with file = nil
                     do (setq file (org-ref-find-bibfile it))
                     collect (format (if file
                                         "%s exists"
                                       "!!! %s NOT FOUND !!!")
                                     (or file it))))))

       (use-package ol
         :straight org
         :config
         (with-eval-after-load 'org-ref
           (dolist (link org-ref-cite-types)
             (org-link-set-parameters
              (if (consp link) (car link) link) :eldoc #'org-ref-eldoc-cite+)))

         (org-link-set-parameters "ref"     :eldoc #'org-ref-eldoc-ref+)
         (org-link-set-parameters "cref"    :eldoc #'org-ref-eldoc-ref+)
         (org-link-set-parameters "eqref"   :eldoc #'org-ref-eldoc-ref+)
         (org-link-set-parameters "pageref" :eldoc #'org-ref-eldoc-ref+)
         (org-link-set-parameters "nameref" :eldoc #'org-ref-eldoc-ref+)
         (org-link-set-parameters "autoref" :eldoc #'org-ref-eldoc-ref+)

         (org-link-set-parameters "label" :eldoc #'org-ref-eldoc-label+)

         (org-link-set-parameters "bibliography" :eldoc #'org-ref-eldoc-bibliography+))
     #+END_SRC

*** Org Pandoc
    #+begin_src emacs-lisp
      (use-package org
        :config
        (advice-add 'org-pandoc-startup-check :around
                    (defun org-pandoc-ignore-command-not-installed-warning+ (func &rest args)
                      (cl-letf (((symbol-function 'true-display-warning)
                                 (symbol-function 'display-warning))
                                ((symbol-function 'display-warning)
                                 (lambda (type message &rest args)
                                   (unless (and (eq type 'ox-pandoc)
                                                (string-equal message "Pandoc command is not installed."))
                                     (apply 'true-display-warning type message args)))))
                        (apply func args)))))
    #+end_src

*** Org Export on Save                                             :disabled:
    :PROPERTIES:
    :header-args+: :tangle no
    :END:

    #+BEGIN_SRC emacs-lisp
      (defvar org-compile-on-save-buffers+ nil
        "org buffers which when saved will be compiled.")

      (defvar org-compile-on-save-async+ t
        "whether compilation is asynchronous or concurrent.
      the async approach spawns a new emacs instance to compile the org-file.
      depending on your hardware this may be slower then simply waiting for
      your current emacs instance to finish.")

      (defun org-compile-on-save-command+ ()
        (when (cl-member (current-buffer) org-compile-on-save-buffers+ :test #'eq)
          (org-latex-export-to-pdf org-compile-on-save-async+)))

      ;; for some reason I can't make this hook buffer local :(
      (add-hook 'after-save-hook #'org-compile-on-save-command+)

      (defun org-toggle-compile-on-save+ (&optional arg)
        "When the current org buffer is saved, compile and render pdf output through latex."
        (interactive "P")
        (unless (derived-mode-p 'org-mode)
          (user-error "This function can only be called from an org-mode buffer."))

        (let* ((buf (if (bound-and-true-p org-capture-mode)
                        (plist-get org-capture-current-plist :buffer)
                      (current-buffer)))
               (member (member buf org-compile-on-save-buffers+))
               (value (if (not arg)
                          (not member)
                        (not (zerop (prefix-numeric-value arg))))))
          (unless (buffer-file-name buf)
            (user-error "cannot compile a buffer with no associated filename."))

          (if value
              (add-to-list 'org-compile-on-save-buffers+ buf nil #'eq)
            (setq org-compile-on-save-buffers+ (delq buf org-compile-on-save-buffers+)))

          ;; while I'm here, let's also remove any killed buffers.
          (setq org-compile-on-save-buffers+
                (cl-remove-if #'buffer-killed-p+ org-compile-on-save-buffers+))

          ;; notify the user about what's happened.
          (when (called-interactively-p 'interactive)
            (message "compile-on-save: %s"
                     (if value
                         (propertize "enabled" 'face 'compilation-info)
                       (propertize "disabled" 'face 'compilation-error))))))
    #+END_SRC

    #+begin_src emacs-lisp
      (defun org-toggle-async-export+ ()
        (interactive)
        (when (called-interactively-p 'interactive)
          (message "org-export-in-background: %s"
                   (if (setq org-export-in-background (not org-export-in-background))
                       (propertize "enabled" 'face 'compilation-info)
                     (propertize "disabled" 'face 'compilation-error)))))
    #+end_src

*** Org Capture
**** Doct
     #+BEGIN_SRC emacs-lisp
       (use-package doct
         :straight t
         :autoload doct
         :custom
         (doct-default-entry-type 'entry))
     #+END_SRC

**** Capture
     #+BEGIN_SRC emacs-lisp
       (use-package org-capture
         :hook (org-capture-mode . evil-insert-state)
         :custom
         (org-capture-bookmark nil)

         :config
         (advice-add 'org-edit-src-code :after
                     (defun org-edit-src-code--forget-window-config+ (&rest args)
                       "Prevents org mode from restoring the window config before
       source code edit. when you run `org-edit-src-code' the window configuration
       from before the edit is saved, and when you exit the session it's restored.
       Any windows/buffers you open while in an edit get erased. This prevents that
       happening."
                       (setq org-src--saved-temp-window-config nil)))

         ;; Inspired by [[https://stackoverflow.com/a/25335933/6247387][this]] stack-overflow answer, the following advice tries to make
         ;; `org-capture's window popup mechanism a lot less *forceful*.
         (advice-add 'org-capture-place-template :around
                     (defun org-capture-place-template-keep-windows+ (func &rest args)
                       "Prevent `org-capture' from forcefully deleting my current window-config."
                       (cl-letf (((symbol-function #'delete-other-windows)
                                  (symbol-function #'ignore)))
                         (apply func args))))

         (advice-add 'org-capture :around
                     (defun org-capture-open-in-current-window+ (func &rest args)
                       "Make `org-capture' popups always open in the current window.
       I find this a lot more predictable then randomly popping up here and there."
                       (cl-letf (((symbol-function #'org-switch-to-buffer-other-window)
                                  (symbol-function #'switch-to-buffer)))
                         (apply func args))))

         (advice-add 'org-capture-finalize :around
                     (defun org-capture-keep-wconfig+ (func &rest args)
                       "Prevent `org-capture-finalize' from resetting my window-configs"
                       (cl-letf (((symbol-function #'set-window-configuration)
                                  (symbol-function #'ignore)))
                         (apply func args))))

         :lazy-leader
         (:mode 'org-capture-mode
          :minor t
          :prefix leader-major-mode-prefix
          "," 'org-capture-finalize
          "q" 'org-capture-kill
          "r" 'org-capture-refile)

         :general
         (:keymaps 'org-capture-mode-map
          [remap evil-save-and-close] 'org-capture-finalize
          [remap evil-quit] 'org-capture-kill))
     #+END_SRC

**** Capture Helpers
     First we define a few helper methods for creating org-capture templates.

     #+begin_src emacs-lisp
       (use-package org-capture
         :straight org
         :preface
         (defun org-capture-create-goto-heading-command+ (heading &optional heading-regexp)
           "Create a function to jump to HEADING, creating HEADING if it doesn't exist.
       This function also smartly reacts to headings containing [/]. By default, if
       [/] has been updated to [0/1], then org is just unable to find it. "
           (unless heading-regexp
             (setq heading-regexp (regexp-quote heading))

             (when (string-match-p (rx "[/]") heading-regexp)
               (setq heading-regexp
                     (replace-regexp-in-string
                      (regexp-quote "[/]")
                      "[[[:digit:]]*/[[:digit:]]*\\\\]"
                      heading-regexp))))

           (lambda ()
             (let ((heading-point
                    (ignore-errors
                      (save-excursion
                        (goto-char (point-min))
                        (search-forward-regexp heading-regexp)
                        (line-beginning-position)))))
               (if heading-point
                   (goto-char heading-point)
                 (goto-char (point-min))
                 (save-excursion
                   (insert heading "\n"))))))

         :autoload org-insert-link-global
         :preface
         (defun org-get-link+ ()
           "Get the stringified result of `org-store-link'."
           (with-temp-buffer
             (org-insert-link-global)
             (buffer-substring (point-min) (point-max))))

         :autoload
         (org-update-parent-todo-statistics
          org-switch-to-buffer-other-window
          org-insert-item
          org-at-item-p
          org-at-table-p
          org-at-heading-p))
     #+end_src

**** Capture Templates
     Org capture template definitions. See [[https://www.gnu.org/software/emacs/manual/html_node/org/Template-expansion.html#Template-expansion][syntax-docs]].

     #+begin_src emacs-lisp
       (use-package org-capture
         :straight org
         :preface
         (defvar project-org-capture-templates+)
         :config
         (setq
          project-org-capture-templates+
          (doct `(("[${name}] Task"
                   :keys "p"
                   :template ("* TODO %?"
                              "  %U")
                   :file ,(join-path+ org-projectile-projects-directory "${name}.org")))))

         :config
         (setq
          org-capture-templates
          (doct `(;; The group for org-mode files generally used for notes or records.
                  ;; With support for word-checking and other writing helpers.
                  (:group "Default"
                   :type entry
                   :prepend t
                   :empty-lines 0
                   :children
                   (;; Group for TODO lists or completion goals. These are generally org
                    ;; headings with a todo-state, a marking timestamp and some description
                    ;; about the goal.
                    (:group "TODOs"
                     :before-finalize ,#'org-update-parent-todo-statistics
                     :function ,(org-capture-create-goto-heading-command+ "* TODOs [/]")
                     :todo-state "TODO"
                     :template ("* %{todo-state} %?"
                                "  %U")
                     :children (("Todo" :keys "t")
                                ("Todo with Clipboard"
                                 :keys "T"
                                 :template ("* %{todo-state} %?"
                                            "  %U"
                                            "  %c"))
                                ("Itinerary"
                                 :keys "d"
                                 :prepend  nil
                                 :function ,(org-capture-create-goto-heading-command+ "* Itinerary")
                                 :template ("* %{todo-state} %?"))))
                    ("Work"
                     :keys "w"
                     :type plain
                     :children (("Standup" :keys "s"
                                 :file (lambda ()
                                         (format-time-string (join-path+ +notes-home "standup" "%Y-%m-%d.org")))
                                 :template ("#+title: Standup %(format-time-string \"Q%q\")"
                                            ""
                                            "* What I did last time"
                                            "  %?"
                                            ""
                                            "* Plan for today"
                                            ""
                                            "* Questions"
                                            ""
                                            "* Notes"
                                            ""))))
                    (;; Group for notes. These are entire org-mode files containing detailed
                     ;; notes isolated to a specific topic for example a lecture or some agenda.
                     ;; Notes that go into here are often bisected and moved into my [[file:init.org::*org-roam][org-brain]].
                     "Notes"
                     :keys "n"
                     :type plain
                     :file (lambda ()
                             (format-time-string (join-path+ +notes-home "%Y%m%d%H%M%S.org")))
                     :title-format "%^{Title}"
                     :template ("#+title: %{title-format}"
                                "#+stamp: %U"
                                ""
                                "%?")
                     :children (("Note" :keys "n")
                                ("Agenda"
                                 :keys "a"
                                 :title-format "Agenda for meeting to be held %^{deadline}t")
                                ("Lecture"
                                 :keys "l"
                                 :template ("#+title: %{title-format}"
                                            "#+module: %^{Module}"
                                            "#+stamp: %U"
                                            ""
                                            "%?"))))))
                  ("BibTex"
                   :keys "b"
                   :type plain
                   :file ,(join-path+ +bib-home "index.bib")
                   :template ("@%(completing-read \"Entry type: \" (mapcar #'car bibtex-entry-alist)){%^{Key},"
                              "  title = \"%^{Title}\","
                              "  DATE_ADDED = \"%<%a %b %d %H:%M:%S %Y>\","
                              "}")
                   :children (("Entry" :keys "e")
                              ("Lecture" :keys "l"
                               :file ,(join-path+ +bib-home "uni.bib"))))))))
     #+end_src

*** Org Export
    Here we put configurations for various Emacs Org export backends including latex.

    These are the latex packages emacs should always require when using latex export.

    #+NAME: org-latex-packages
    | Options | Package    |
    |---------+------------|
    |         | mathdots   |
    |         | fourier    |
    |         | yfonts     |
    | super   | nth        |
    |         | siunitx    |
    |         | color      |
    |         | amssymb    |
    |         | amsthm     |
    |         | tikz       |
    |         | graphics   |
    |         | pgfplots   |

    #+NAME: org-latex-pkgs
    #+BEGIN_SRC emacs-lisp :var pkgs=org-latex-packages
      (with-eval-after-load 'org
        (setq org-latex-packages-alist (append pkgs org-latex-packages-alist)))
    #+END_SRC

    Here's the options used to configure various org backends and extensions.

    #+NAME: org-export-options
    #+BEGIN_SRC emacs-lisp
      (use-package org
        :custom
        (org-latex-pdf-process (list "latexmk -shell-escape -bibtex -f -pdf %f"))
        (org-babel-python-command "python3")
        (org-ditaa-jar-path (cache! "org/bin/ditaa.jar"))
        (org-ditaa-eps-jar-path (cache! "org/bin/ditaaEps.jar"))
        (org-plantuml-jar-path (cache! "org/bin/plantuml.jar"))
        (org-export-with-toc nil)
        (org-latex-default-class "article")
        (org-confirm-babel-evaluate nil)
        (org-latex-classes
         '(("article" "\\documentclass[11pt]{article} \\setlength{\\parindent}{0in} \\setlength{\\parskip}{\\baselineskip}"
            ("\\section{%s}" . "\\section*{%s}")
            ("\\subsection{%s}" . "\\subsection*{%s}")
            ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
            ("\\paragraph{%s}" . "\\paragraph*{%s}")
            ("\\subparagraph{%s}" . "\\subparagraph*{%s}"))
           ("report" "\\documentclass[11pt]{report}"
            ("\\part{%s}" . "\\part*{%s}")
            ("\\chapter{%s}" . "\\chapter*{%s}")
            ("\\section{%s}" . "\\section*{%s}")
            ("\\subsection{%s}" . "\\subsection*{%s}")
            ("\\subsubsection{%s}" . "\\subsubsection*{%s}"))
           ("book" "\\documentclass[11pt]{book}"
            ("\\part{%s}" . "\\part*{%s}")
            ("\\chapter{%s}" . "\\chapter*{%s}")
            ("\\section{%s}" . "\\section*{%s}")
            ("\\subsection{%s}" . "\\subsection*{%s}")
            ("\\subsubsection{%s}" . "\\subsubsection*{%s}")))))
    #+END_SRC

**** Org Async Export
     :PROPERTIES:
     :header-args+: :tangle (package-str! (etc! "+org-async-init.el") org)
     :END:

     ~init.el~ file for asynchronous org-mode export.

     #+BEGIN_SRC emacs-lisp :tangle (package-lisp! +lang-org org)
       (use-package ox
         :straight org
         :custom
         (org-export-async-init-file (lisp! "+org-async-init.el"))
         (org-export-in-background nil))
     #+END_SRC

     #+BEGIN_SRC emacs-lisp :var pkgs=org-latex-packages :shebang ";; -*- lexical-binding: t -*-"
       (load (concat user-emacs-directory "early-init.el") nil t)

       <<setup-paths>>
       <<setup-straight-pacman>>

       (require 'ox)
       <<org-latex-pkgs>>
       <<org-export-options>>
       <<org-pdf-link>>
       <<org-bib-pdf-link>>
       (require 'org-id)
       (when (file-exists-p org-id-locations-file)
         (with-no-warnings
           (org-id-locations-load)))

       (straight-use-package 'org-ref)
       (require 'org-ref)
     #+END_SRC

*** Extensions
**** Org Bullets
     Better heading indicators in org buffers.

     #+BEGIN_SRC emacs-lisp
       (use-package org-superstar
         :straight t
         :hook (org-mode . org-superstar-mode)
         :custom
         (org-superstar-todo-bullet-alist
          '(("TODO" . 9744)
            ("DONE" . 9745)))
         (org-superstar-cycle-headline-bullets t)
         (org-hide-leading-stars t)
         (org-superstar-special-todo-items t))
     #+END_SRC

**** Orgit
     :PROPERTIES:
     :header-args+: :tangle (package-lisp! +lang-org org magit)
     :END:

     Link to Magit buffers directly from org-mode.

     #+BEGIN_SRC emacs-lisp
       (require '+pkg-magit)

       (declare-function reb-target-binding "re-builder")
       (declare-function rxt--re-builder-switch-pcre-mode "re-builder")

       (use-package orgit
         :straight (orgit :build (:not autoloads)) ; Autoloads immediately require magit.
         :demand t
         :after (ol magit)
         :custom
         (orgit-store-repository-id t)

         :preface
         (defvar orgit-store-after-commit+ nil)
         :hook (git-commit-post-finish . orgit-store-after-commit+)
         :autoload (orgit-store-after-commit+
                    orgit--current-repository)
         :preface (use-package magit
                    :autoload (magit-format-rev-summary
                               magit-git-string))
         :preface (use-package org-element
                    :autoload org-element-lineage)
         :config
         (defun orgit-store-after-commit+ ()
           "Store orgit-link for latest commit after commit message editor is finished."
           (when orgit-store-after-commit+
             (let* ((repo (orgit--current-repository))
                    (rev (magit-git-string "rev-parse" "HEAD"))
                    (link (format "orgit-rev:%s::%s" repo rev))
                    (summary (substring-no-properties (magit-format-rev-summary rev)))
                    (desc (format "%s (%s)" summary repo)))
               (push (list link desc) org-stored-links)))))
     #+END_SRC

**** Org Fragment Toggle                                           :disabled:
     Automatically render latex fragments in org mode.

     #+BEGIN_SRC emacs-lisp :tangle no
       (use-package org-fragtog
         :straight t
         :after org)
     #+END_SRC

**** Org Ql                                                        :disabled:
     Lisp like query language for org mode.

     #+BEGIN_SRC emacs-lisp :tangle no
       (use-package org-ql
         :straight t)
     #+END_SRC

**** Company Org-Block                                                  :comp:
     A better solution for inserting code-blocks or block-groups in org-mode.

     #+BEGIN_SRC emacs-lisp
       (use-package company-org-block
         :straight t
         :after org
         :demand t
         :custom
         (company-org-block-edit-style 'auto)
         (company-org-block-explicit-lang-defaults nil)

         :autoload company-org-block
         :completion+
         (org-mode (company-org-block :company t :depth -10)))
     #+END_SRC

**** Org Appear
     #+BEGIN_SRC emacs-lisp
       (use-package org-appear
         :straight t
         :hook (org-mode . org-appear-mode)
         :custom
         (org-hide-emphasis-markers t)
         (org-appear-autolinks nil))
     #+END_SRC

**** Org Ref
     :PROPERTIES:
     :header-args+: :tangle (package-lisp! +lang-org org bibtex)
     :END:
     Support citations, references and links in org mode documents.

     WARN for bibliographies to show up you have to specify a =biliographystyle= (use =unsrt= when unsure).

     #+BEGIN_SRC emacs-lisp
       (require '+lang-bibtex)

       (use-package org-ref
         :straight t
         :after org
         :demand t
         :leader
         (:mode 'org-mode
          "]" 'org-ref-insert-link)
         ("ov" 'doi-utils-add-bibtex-entry-from-doi)

         :custom
         (reftex-default-bibliography citar-bibliography)
         (org-ref-bibtex-completion-add-keywords-field nil)
         (org-ref-show-citation-on-enter nil)
         (helm-minibuffer-history-key nil)

         :config
         (setq org-ref-latex-bib-resolve-func #'expand-file-name))
     #+END_SRC

*** Appendix
    #+begin_src emacs-lisp
      (provide '+lang-org)
    #+end_src

** Perl
   :PROPERTIES:
   :header-args+: :tangle (package-lisp! +lang-perl perl)
   :END:

   #+begin_src emacs-lisp :tangle (package-yes! perl)
     (require '+lang-perl)
   #+end_src

*** CPerl Mode
    #+begin_src emacs-lisp
      (use-package cperl-mode
        :hook ((perl-mode cperl-mode) . +flylint)
        :custom
        (cperl-highlight-variables-indiscriminately t)
        (cperl-indent-parens-as-block t
         "Parentheses are indented with the block and not with scope")
        ;; These should be set by `+indent-config' but it can't support negatives yet.
        (cperl-indent-level 4
         "4 spaces is the standard indentation")
        (cperl-close-paren-offset -4
         "Indent the closing paren back four spaces")
        (cperl-continued-statement-offset 4
         "If a statement continues indent it to four spaces")

        :preface
        (add-to-list 'major-mode-remap-alist
                     '(perl-mode . cperl-mode))

        :config
        ;; Don't highlight arrays and hashes in comments, from [[https://github.com/syl20bnr/spacemacs/blob/63056ecb50f93808781b97feab1c3225d35c7aa1/layers/%2Blang/perl5/packages.el#L65][here]].
        (font-lock-remove-keywords 'cperl-mode
         '(("\\(\\([@%]\\|\\$#\\)[a-zA-Z_:][a-zA-Z0-9_:]*\\)" 1
            (if (eq (char-after (match-beginning 2)) 37)
                'cperl-hash-face 'cperl-array-face) t)
           ("\\(\\([$@]+\\)[a-zA-Z_:][a-zA-Z0-9_:]*\\)[ \t]*\\([[{]\\)" 1
            (if (= (- (match-end 2) (match-beginning 2)) 1)
                (if (eq (char-after (match-beginning 3)) 123)
                    'cperl-hash-face 'cperl-array-face)
              font-lock-variable-name-face) t)
           ("\\([]}\\\\%@>*&]\\|\\$[a-zA-Z0-9_:]*\\)[ \t]*{[ \t]*\\(-?[a-zA-Z0-9_:]+\\)[ \t]*}"
            (2 font-lock-string-face t)
            ("\\=[ \t]*{[ \t]*\\(-?[a-zA-Z0-9_:]+\\)[ \t]*}" nil nil
             (1 font-lock-string-face t)))
           ("[[ \t{,(]\\(-?[a-zA-Z0-9_:]+\\)[ \t]*=>" 1 font-lock-string-face t)))
        (font-lock-add-keywords 'cperl-mode
         '(("\\(\\([@%]\\|\\$#\\)[a-zA-Z_:][a-zA-Z0-9_:]*\\)" 1
            (if (nth 4 (syntax-ppss))
                'font-lock-comment-face
              (if (eq (char-after (match-beginning 2)) ?%)
                  'cperl-hash-face
                'cperl-array-face)) t)
           ("\\(\\([$@]+\\)[a-zA-Z_:][a-zA-Z0-9_:]*\\)[ \t]*\\([[{]\\)" 1
            (if (nth 4 (syntax-ppss))
                'font-lock-comment-face
              (if (= (- (match-end 2) (match-beginning 2)) 1)
                  (if (eq (char-after (match-beginning 3)) ?{)
                      'cperl-hash-face
                    'cperl-array-face)
                font-lock-variable-name-face)) t)
           ("\\([]}\\\\%@>*&]\\|\\$[a-zA-Z0-9_:]*\\)[ \t]*{[ \t]*\\(-?[a-zA-Z0-9_:]+\\)[ \t]*}"
            (2 (if (nth 4 (syntax-ppss))
                   'font-lock-comment-face
                 'font-lock-string-face) t)
            ("\\=[ \t]*{[ \t]*\\(-?[a-zA-Z0-9_:]+\\)[ \t]*}" nil nil
             (1 (if (nth 4 (syntax-ppss))
                    'font-lock-comment-face
                  'font-lock-string-face) t)))
           ("[[ \t{,(]\\(-?[a-zA-Z0-9_:]+\\)[ \t]*=>" 1
            (if (nth 4 (syntax-ppss))
                'font-lock-comment-face
              'font-lock-string-face) t)))

        (font-lock-add-keywords 'cperl-mode
         '(("\\_<say\\_>" . cperl-nonoverridable-face)))

         :custom (cperl-lazy-help-time nil "Permanently disable non-eldoc help.")
         :autoload (cperl-eldoc--regexp+
                    cperl-eldoc+
                    cperl-setup-eldoc+
                    cperl-switch-to-doc-buffer
                    cperl-word-at-point-hard)
         :config
         ;; Eldoc integration using `cperl-lazy-install'.
         (defun cperl-eldoc--regexp+ (word)
           "Taken directly from `cperl-describe-perl-symbol'."
           (cond
            ((string-match "^[&*][a-zA-Z_]" word)
             (setq word (concat (substring word 0 1) "NAME")))
            ((string-match "^[$@]\\([a-zA-Z_:0-9]+\\)[ \t]*\\[" word)
             (setq word (concat "@" (substring word 1 (match-end 1)))))
            ((string-match "^[$@]\\([a-zA-Z_:0-9]+\\)[ \t]*{" word)
             (setq word (concat "%" (substring word 1 (match-end 1)))))
            ((and (string= word "x") (string-match "^x=" word))
             (setq word "x="))
            ((string-match "^\\$[\C-a-\C-z]" word)
             (setq word (concat "$^" (char-to-string (+ ?A -1 (aref word 1))))))
            ((string-match "^CORE::" word)
             (setq word "CORE::"))
            ((string-match "^SUPER::" word)
             (setq word "SUPER::"))
            ((and (string= "<" word) (string-match "^<\\$?[a-zA-Z0-9_:]+>" word))
             (setq word "<NAME>")))

           (concat "^"
                   "\\([^a-zA-Z0-9_:]+[ \t]+\\)?"
                   (regexp-quote word)
                   "\\([ \t([/]\\|$\\)"))

         (defun cperl-eldoc+ (cb)
           (when-let* ((val (save-excursion
                              ;; moves point for some reason..
                              (cperl-word-at-point-hard))))
             (let ((cperl-message-on-help-error nil)
                   (cperl-help-from-timer t)
                   (case-fold-search nil)
                   (regexp (cperl-eldoc--regexp+ val)))
               (cperl-switch-to-doc-buffer)
               (with-current-buffer cperl-doc-buffer
                 (save-excursion
                   (goto-char (point-min))
                   (when (re-search-forward regexp (point-max) t)
                     (save-excursion
                       (beginning-of-line 1)
                       (let ((lnstart (point)))
                         (end-of-line)
                         (funcall cb (buffer-substring lnstart (point)))))))))))

         (defun cperl-setup-eldoc+ ()
           (add-hook 'eldoc-documentation-functions 'cperl-eldoc+ nil t))
         :hook ((perl-mode cperl-mode) . cperl-setup-eldoc+)

         :general
         (:keymaps 'cperl-mode-map
          [override-state] 'insert                                                    ; Gives access to a bunch of electric keys
          "TAB" nil                                                                   ; Restore indent-for-tab-command
          "C-j" nil)
         :lazy-leader
         (:mode '(perl-mode cperl-mode)
          ;; Unbound commands:
          ;; + cperl-next-interpolated-REx
          ;; + cperl-next-interpolated-REx-0
          ;; + cperl-next-interpolated-REx-1

          "b" 'cperl-find-bad-style
          "d" 'cperl-here-doc-spell
          "n" 'cperl-narrow-to-here-doc
          "p" 'cperl-pod-spell
          "i" 'cperl-invert-if-unless

          "h" '(:ignore t :wk "help")
          "hF" 'cperl-info-on-command
          "hf" 'cperl-info-on-current-command
          "hP" 'cperl-perldoc-at-point
          "hp" 'cperl-perldoc
          "hh" 'cperl-get-help

          "t" '(:ignore t :wk "toggle")
          "ta" 'cperl-toggle-auto-newline
          "tk" 'cperl-toggle-abbrev
          "te" 'cperl-toggle-electric
          "tw" 'cperl-toggle-construct-fix))
    #+end_src

*** Company PLSense                                                    :comp:
    #+begin_src emacs-lisp
      (use-package company-plsense
        :straight t
        :when (executable-find "plsense")
        :autoload company-plsense
        :completion+
        (perl-mode (company-plsense :company t))
        (cperl-mode (company-plsense :company t)))
    #+end_src

*** Perl-LanguageServer                                                 :lsp:
    Requires [[https://github.com/richterger/Perl-LanguageServer][Perl-LanguageServer]].

    #+begin_src emacs-lisp
      (add-hook 'perl-mode-hook '+lsp-hook)
    #+end_src

    #+begin_src emacs-lisp :tangle (package-lisp! +lang-perl perl eglot)
      (use-package eglot
        :config
        (push `(perl-mode . ("perl"
                             "-MPerl::LanguageServer"
                             "-e" "Perl::LanguageServer::run"
                             "--" "--port" :autoport "--version" "2.1.0"))
              eglot-server-programs))
    #+end_src

*** Appendix
    #+begin_src emacs-lisp
      (provide '+lang-perl)
    #+end_src

** PHP
   :PROPERTIES:
   :header-args+: :tangle (package-lisp! +lang-php php)
   :END:

   #+begin_src emacs-lisp :tangle (package-yes! php)
     (require '+lang-php)
   #+end_src

*** PHP Mode
    #+begin_src emacs-lisp
      (use-package php-mode
        :straight t
        :hook (php-mode . +lsp-hook))
    #+end_src

*** PHP Eldoc                                                      :disabled:
    #+begin_src emacs-lisp :tangle no
      (use-package php-eldoc
        :straight t
        :hook (eldoc-mode . php-eldoc-enable))
    #+end_src

*** Appendix
    #+begin_src emacs-lisp
      (provide '+lang-php)
    #+end_src

** PowerShell
   :PROPERTIES:
   :header-args+: :tangle (package-lisp! +lang-powershell powershell)
   :END:

   #+begin_src emacs-lisp :tangle (package-yes! powershell)
   (require '+lang-powershell)
   #+end_src

   #+BEGIN_SRC emacs-lisp
     (use-package powershell
       :straight t)
   #+END_SRC

   #+begin_src emacs-lisp
    (provide '+lang-powershell)
   #+end_src

** Python
   :PROPERTIES:
   :header-args+: :tangle (package-lisp! +lang-python python)
   :END:

   #+begin_src emacs-lisp :tangle (package-yes! python)
   (require '+lang-python)
   #+end_src

*** Python Mode
    #+BEGIN_SRC emacs-lisp
      (use-package python
        :straight (python :type built-in)
        :interpreter ((rx "python3-dotfiles-venv") . python-mode)
        :hook ((python-mode python-ts-mode) . +flylint)
        :custom
        (python-indent-guess-indent-offset-verbose nil
         "Disable annoying notification when indent guess fails.")
        (python-indent-def-block-scale 1)

        :modify-syntax+
        (python-mode-syntax-table '((?_ . "w")))

        ;; :pretty-symbols+
        ;; ((python-mode python-ts-mode) "lambda" ?Œª)

        :init
        (setq python-prettify-symbols-alist nil)

        :config
        (evil-set-initial-state 'inferior-python-mode 'emacs)
        (add-to-list 'python-shell-completion-native-disabled-interpreters "python3")

        (defun python-shell-calculate-command ()
          "python3 -i")

        :config
        ;; So pythons tab command behaves kind of weirdly. The first time you
        ;; call it it indents the current line to the maximum possible indent
        ;; level, and then cycles between indents. It does this by checking
        ;; the current and last-command are the same and then cycling, this
        ;; fails because I remap TAB to [tab] and `last-command' is [tab]
        ;; while `this-command' is `indent-for-tab-command'.
        ;;
        ;; There's 2 ways to fix this. Either prevent this special case for
        ;; the first call and always cycle, or map TAB to the same command
        ;; as [tab] instead of relying on a macro. I opt for the latter.

        ;; (advice-add 'python-indent-line-function :override
        ;;             (defun python-indent-line-function+ ()
        ;;               (python-indent-line
        ;;                (memq this-command python-indent-trigger-commands))))

        (general-define-key
         :keymaps 'python-base-mode-map
         :states 'insert
         "TAB" 'indent-for-tab-command)

        :lazy-leader
        (:mode '(python-mode python-ts-mode)
         "R" 'python-shell-switch-to-shell
         "m" 'python-mark-defun
         "v" 'python-check
         "s" 'python-describe-at-point
         ;; unbound: python-nav-forward-sexp[-safe]
         ;;          python-nav-backward-sexp[-safe]

         "n"  '(:ignore t :wk "navigate")
         "nh" 'python-nav-backward-statement
         "nj" 'python-nav-forward-block
         "nk" 'python-nav-backward-block
         "nl" 'python-nav-forward-statement
         "n[" 'python-nav-backward-up-list
         "n]" 'python-nav-up-list
         "na" 'python-nav-beginning-of-block
         "ne" 'python-nav-end-of-block
         "nm" 'python-nav-if-name-main

         ;; "n C-0" 'python-nav-beginning-of-statement
         ;; "n C-$" 'python-nav-end-of-statement
         ;; "n M-j" 'python-nav-forward-defun
         ;; "n M-k" 'python-nav-backward-defun
         ;; "n M-0" 'python-nav-beginning-of-defun
         ;; "n M-$" 'python-nav-end-of-defun

         "h"  '(:ignore t :wk "help")
         "hp" 'python-eldoc-at-point

         "e"  '(:ignore t :wk "eval/exec")
         "es" '(run-python :wk "python-repl")
         "ee" '(python-shell-send-region :wk "python-shell-send-line")
         "ed" 'python-shell-send-defun
         "eb" 'python-shell-send-buffer
         "ef" 'python-shell-send-file
         "er" 'python-shell-send-region
         "ep" 'python-shell-send-string)

        :general
        (:keymaps 'python-base-mode-map
         "<C-backspace>" nil))
    #+END_SRC

*** Python LSP Server                                                   :lsp:
    :PROPERTIES:
    :header-args+: :tangle (package-lisp! +lang-python python :lsp)
    :END:

    Your going to need a python language server, I recommend [[https://github.com/python-lsp/python-lsp-server][this]] one that's based on
    [[https://github.com/davidhalter/jedi][jedi]]. There's also a Microsoft based [[https://github.com/microsoft/python-language-server][server]], and the newer/faster [[https://github.com/microsoft/pyright][pyright]] (but be
    forewarned, there be [[https://github.com/microsoft/pylance-release/issues/4][dragons]] there).

    #+BEGIN_SRC emacs-lisp
      (use-package python
        :hook (python-mode . +lsp-hook))
    #+END_SRC

*** Py Import
    #+BEGIN_SRC emacs-lisp
      (use-package pyimport
        :straight t
        :leader
        (:mode '(python-mode python-ts-mode)
         "i"  '(:ignore t :wk "imports")
         "ii" 'pytimport-remove-unused
         "iu" 'pyimport-insert-missing))
    #+END_SRC

*** Pip Requirements Mode
    Major mode for editing pip requirements files.

    #+BEGIN_SRC emacs-lisp
      (use-package pip-requirements
        :straight t
        :mode ((rx bol "requirements" (zero-or-more any) ".txt" eol) .
               pip-requirements-mode))
    #+END_SRC

*** Appendix
    #+begin_src emacs-lisp
    (provide '+lang-python)
    #+end_src

** Rest Client
   :PROPERTIES:
   :header-args+: :tangle (package-lisp! +lang-restclient restclient)
   :END:

   #+begin_src emacs-lisp :tangle (package-yes! restclient)
     (require '+lang-restclient)
   #+end_src

*** Rest Client
    #+BEGIN_SRC emacs-lisp
      (require '+setup-scratch)

      (use-package restclient
        :straight t
        :leader ("ar" 'restclient+)
        :commands (restclient+ restclient-mode)
        :config
        (defun restclient+ ()
          "Create a new buffer in restclient mode"
          (interactive)
          (let ((buffer (new-scratch-buffer+ "*restclient*")))
            (with-current-buffer buffer
              (restclient-mode))
            (display-buffer buffer)))

        :init
        (push `(,(rx "*restclient*")
                (display-buffer-reuse-window
                 display-buffer-same-window))
              display-buffer-alist)

        :hide-whitespace-regex+ (rx "*HTTP Response*")
        :init
        (evil-set-initial-state 'restclient-mode 'normal)

        :general
        (:states 'motion
         :keymaps 'restclient-mode-map
         "gj" 'restclient-jump-next
         "gk" 'restclient-jump-prev)
        (:states  'normal
         :keymaps 'restclient-outline-mode-map
         "TAB"   'restclient-toggle-body-visibility-or-indent
         "g TAB" 'restclient-toggle-body-visibility-or-indent)

        :leader
        (:mode 'restclient-mode
         leader-major-mode-key '(restclient-http-send-current-stay-in-window :wk "execute-current-same-window")
         "RET" '(restclient-http-send-current :wk "execute-current")
         "r" '(restclient-http-send-current-raw :wk "execute-current-raw")
         "y" '(restclient-copy-curl-command :wk "yank-curl-command")
         "m" 'restclient-mark-current
         "n" 'restclient-narrow-to-current
         "w" 'widen))
    #+END_SRC

*** Company Restclient                                                 :comp:
    #+begin_src emacs-lisp
      (use-package company-restclient
        :straight t
        :autoload company-restclient
        :completion+
        (restclient-mode (company-restclient :company t)))
    #+end_src

*** Org Babel Restclient                                           :disabled:
    #+BEGIN_SRC emacs-lisp :tangle no
      (use-package ob-restclient
        :straight t
        :after (org restclient)
        :init
        (org-babel-lazy-load-languages+ 'restclient))
    #+END_SRC

*** Appendix
    #+begin_src emacs-lisp
      (provide '+lang-restclient)
    #+end_src

** Robot Framework
   :PROPERTIES:
   :header-args+: :tangle (package-lisp! +lang-robotframework robotframework)
   :END:

   #+begin_src emacs-lisp :tangle (package-yes! robotframework)
     (require '+lang-robotframework)
   #+end_src

   #+begin_src emacs-lisp
     (use-package robot-mode
       :straight t)
   #+end_src

   #+begin_src emacs-lisp
     (provide '+lang-robotframework)
   #+end_src

** Ruby
    :PROPERTIES:
    :header-args+: :tangle (package-lisp! +lang-ruby ruby)
    :END:

    #+begin_src emacs-lisp :tangle (package-yes! ruby)
    (require '+lang-ruby)
    #+end_src

*** Ruby Mode
    #+BEGIN_SRC emacs-lisp
      (use-package ruby-mode
        :mode ("\\.rb$" . ruby-mode)
        :hook (ruby-mode . +flylint)
        :indent+ (ruby-mode 2)
        :interpreter "ruby"

        :modify-syntax+
        (ruby-mode-syntax-table
         '((?_ . "w")
           (?: . "w")))

        :leader ("tmr" 'ruby-mode)
        :lazy-leader
        (:mode 'ruby-mode
         "'" 'ruby-toggle-string-quotes
         "{" 'ruby-toggle-block))
    #+END_SRC

*** Solargraph                                                          :lsp:
    :PROPERTIES:
    :header-args+: :tangle (package-lisp! +lang-ruby ruby :lsp)
    :END:

    Language server implementation for ruby.

    Solargraph appears to be the only language-server implementation available for
    ruby although like ruby it's somewhat obtuse. For one you can't use it outside
    of a =bundle= managed project. If your project lacks a Gemfile Solargraph will just
    kill itself meaning it's useless for general purpose ruby scripts.

    #+BEGIN_SRC emacs-lisp
      (require '+pkg-project)

      (use-package ruby-mode
        :hook (ruby-mode . +lsp-hook)
        :init
        (push
         (cons 'ruby-mode
               (defun ruby-enable-lsp-in-projects+ ()
                 (when (project-has-file-p+ "Gemfile")
                   :local)))
         +lsp-maybe-connect))
    #+END_SRC

*** Inferior Ruby Mode
    #+BEGIN_SRC emacs-lisp
      (use-package inf-ruby
        :straight t
        :hide-whitespace+ inf-ruby-mode
        :leader
        (:mode 'ruby-mode
         "e"  '(:ignore t :wk "eval/REPL")
         "es" '(inf-ruby :wk "ruby-repl")
         "eg" 'inf-ruby-console-gem
         "ez" 'inf-ruby-console-zues
         "ea" 'inf-ruby-console-auto
         "eR" 'inf-ruby-console-rails
         "ek" 'inf-ruby-console-racksh
         "ec" 'inf-ruby-console-script
         "eh" 'inf-ruby-console-hanami))
    #+END_SRC

*** Ruby Tools Mode
    #+BEGIN_SRC emacs-lisp
      (use-package ruby-tools
        :straight t
        :diminish ruby-tools-mode
        :hook (ruby-mode . ruby-tools-mode)

        :lazy-leader
        (:mode 'ruby-mode
         "i"  '(:ignore t :wk "insert")
         "i:" 'ruby-tools-to-symbol
         "i{" 'ruby-tools-interpolate
         "i <backspace>" 'ruby-tools-clear-string
         "i\"" 'ruby-tools-to-double-quote-string
         "i'" 'ruby-tools-to-single-quote-string))
    #+END_SRC

*** Bundler
    #+BEGIN_SRC emacs-lisp
      (use-package bundler
        :straight t
        :leader
        (:mode 'ruby-mode
         "b"  '(:ignore t :wk "bundler")
         "rb" 'bundle-console
         "bf" 'bundle-open
         "bi" 'bundle-install
         "bu" 'bundle-update
         "bc" 'bundle-check))
    #+END_SRC

*** Ruby Electric
    #+begin_src emacs-lisp
      (use-package ruby-electric
        :straight t
        :diminish ruby-electric-mode
        :hook (ruby-mode . ruby-electric-mode)
        :config
        ;;; Why poison the standard ruby map instead of using `ruby-electric-mode-map'?
        (defun ruby-electric-setup-keymap ()
          (general-define-key
           :keymaps 'ruby-mode-map
           " " 'ruby-electric-space
           ;; "{" 'ruby-electric-curlies
           "(" 'ruby-electric-matching-char
           "[" 'ruby-electric-matching-char
           ;; "\"" 'ruby-electric-quote
           ;; "\'" 'ruby-electric-quote
           "|" 'ruby-electric-bar
           "RET" 'ruby-electric-return
           ;; (kbd "C-j") 'ruby-electric-return
           ;; [C-m] 'ruby-electric-return
           "}" 'ruby-electric-close-matching-char
           ")" 'ruby-electric-close-matching-char
           "]" 'ruby-electric-close-matching-char)))
    #+end_src

*** Appendix
    #+begin_src emacs-lisp
    (provide '+lang-ruby)
    #+end_src

** Rust
   :PROPERTIES:
   :header-args+: :tangle (package-lisp! +lang-rust rust)
   :END:

   #+begin_src emacs-lisp :tangle (package-yes! rust)
     (require '+lang-rust)
   #+end_src

   #+begin_src emacs-lisp
     (defvar rust-syntax-table-modifications+
       '((?_ . "w")))
   #+end_src

*** Rust Mode
    #+begin_src emacs-lisp :tangle (package-lisp! +lang-rust rust tree-sitter)
      (use-package rust-ts-mode
        :modify-syntax+
        (rust-ts-mode--syntax-table rust-syntax-table-modifications+))
    #+end_src

*** Rustic Mode
    #+BEGIN_SRC emacs-lisp
      (use-package rustic
        :straight t
        :hide-whitespace+ rustic-popup-mode
        :custom
        (rustic-format-trigget nil)
        (rustic-lsp-client nil)
        (rustic-lsp-server 'rust-analyzer)
        (rustic-lsp-client +lsp-backend)

        :modify-syntax+
        (rust-mode-syntax-table rust-syntax-table-modifications+)

        :init
        (evil-set-initial-state 'rustic-popup-mode 'emacs)

        :config
        (advice-add 'rustic-popup :around 'display-buffer-no-select-window-advice+)

        :config
        ;; For some reason :custom did not work :cry:.
        (setq rustic-test-buffer-name          "*rustic-compilation*"
              rustic-run-buffer-name           "*rustic-compilation*"
              rustic-clippy-buffer-name        "*rustic-compilation*"
              rustic-expand-buffer-name        "*rustic-compilation*"
              rustic-format-buffer-name        "*rustfmt*"
              rustic-install-buffer-name       "*rustic-compilation*"
              rustic-rustfix-buffer-name       "*rustic-compilation*"
              rustic-popup-help-buffer-name    "*rustic-compilation*"
              rustic-spellcheck-buffer-name    "*rustic-compilation*"
              rustic-run-comint-buffer-name    "*rustic-compilation*"
              rustic-compilation-buffer-name   "*rustic-compilation*"
              rustic-cargo-oudated-buffer-name "*rustic-compilation*")

        :general
        (:keymaps '(rustic-mode-map
                    rustic-compilation-mode-map)
         [remap recompile] #'rustic-recompile)

        :lazy-leader
        (:mode 'rustic-mode
         "," 'rustic-popup
         "c" 'rustic-compile
         "C" 'rustic-recompile
         "p" 'rustic-cargo-run
         "u" 'rustic-playpen
         "d" 'rustic-cargo-doc

         "b" '(:ignore t :wk "project")
         "bc" 'rustic-cargo-clean
         "bo" 'rustic-cargo-outdated
         "bd" 'rustic-cargo-build-doc

         "t" '(:ignore t :wk "test")
         "tt" 'rustic-cargo-test
         "tT" 'rustic-cargo-test-rerun
         "tb" 'rustic-cargo-bench
         "tc" 'rustic-cargo-check

         "r" '(:ignore t :wk "refactor")
         "rx" 'rustic-rustfix
         "rf" 'rustic-cargo-fmt
         "rc" 'rustic-cargo-clippy))
    #+END_SRC

**** Rustic Compilation
     #+begin_src emacs-lisp
       (use-package +pkg-compile
         :config
         (push 'rustic-cargo-test-mode compilation-auto-kill-ignore-modes+)

         (advice-add 'rustic-compilation :around
                     (defun rustic-compilation-check-window-was-open-p+ (func cmd args)
                       (let* ((buf (or (plist-get args :buffer)
                                       (bound-and-true-p rustic-compilation-buffer-name)))
                              (compilation-was-visible (when (get-buffer-window buf t) t)))
                         (with-current-buffer (process-buffer (funcall func cmd args))
                           (setq-local compilation-was-open-p+ compilation-was-visible))))))
     #+end_src

*** Rust Analyzer                                                       :lsp:
    LSP support requires: ~rustup component add rls rust-analysis rust-src~.
    or [[https://github.com/rust-analyzer/rust-analyzer][rust-analyzer]].

    #+begin_src emacs-lisp
      (use-package rustic
        :hook (rustic-mode . +lsp-hook))
    #+end_src

    #+begin_src emacs-lisp :tangle (package-lisp! +lang-rust rust eglot)
      (use-package rustic-lsp
        :after rustic
        :demand t
        :autoload rustic-setup-eglot
        :config (rustic-setup-eglot))
    #+end_src

    #+begin_src emacs-lisp :tangle (package-lisp! +lang-rust rust lsp-mode)
      (use-package rustic-lsp
        :after rustic
        :demand t
        :autoload rustic-lsp-mode-setup
        :config (rustic-lsp-mode-setup))
    #+end_src

*** Appendix
    #+begin_src emacs-lisp
      (provide '+lang-rust)
    #+end_src

** Scala
   :PROPERTIES:
   :header-args+: :tangle (package-lisp! +lang-scala scala)
   :END:
   #+begin_src emacs-lisp :tangle (package-yes! scala)
     (require '+lang-scala)
   #+end_src

*** Scala Mode
    #+begin_src emacs-lisp :tangle (package-lisp! +lang-scala scala (not tree-sitter))
      (use-package scala-mode
        :straight t)
    #+end_src

*** Scala Tree Sitter Mode
    #+begin_src emacs-lisp :tangle (package-lisp! +lang-scala scala tree-sitter)
      (use-package scala-ts-mode
        :straight t)
    #+end_src

*** Metals                                                              :lsp:
    :PROPERTIES:
    :header-args+: :tangle (package-lisp! +lang-scala scala eglot)
    :END:

    #+begin_src emacs-lisp
      (use-package eglot
        :after scala-ts-mode
        :autoload eglot-alternatives
        :config
        (push `((scala-mode scala-ts-mode)
                . ,(eglot-alternatives '("metals" "metals-emacs")))
              eglot-server-programs))
    #+end_src

*** Appendix
    #+begin_src emacs-lisp
      (provide '+lang-scala)
    #+end_src

** Shell Script
   :PROPERTIES:
   :header-args+: :tangle (package-lisp! +lang-sh-script sh-script)
   :END:

   #+begin_src emacs-lisp :tangle (package-yes! sh-script)
   (require '+lang-sh-script)
   #+end_src

*** Shell Script Mode                                               :builtin:
    #+BEGIN_SRC emacs-lisp
      (use-package sh-script
        :hook ((sh-mode bash-ts-mode) . +flylint)
        :init
        (advice-add 'sh-set-shell :around 'inhibit-messages-wrapper!)

        :indent+
        (sh-mode 2)
        (bash-ts-mode 2)

        :modify-syntax+
        (sh-mode-syntax-table
         '((?_ . "w")
           (?- . "w")))

        :lazy-leader
        (:mode '(sh-mode bash-ts-mode)
         ":" 'sh-set-shell
         ;; "0" 'sh-beginning-of-command
         ;; "$" 'sh-end-of-command
         "!" 'executable-interpret
         "b" 'sh-show-shell
         "\\" 'sh-backslash-region

         "e" '(:ignore t :wk "eval/REPL")
         "er" 'sh-execute-region
         "ej" 'sh-send-line-or-region-and-step

         "i=" 'sh-assignment
         "ic" 'sh-case
         "id" 'sh-cd-here
         "if" 'sh-for
         "i TAB" 'sh-if
         "il" 'sh-indexed-loop
         "io" 'sh-while-getopts
         "ir" 'sh-repeat
         "is" 'sh-select
         "it" 'sh-tmp-file
         "iu" 'sh-until
         "iw" 'sh-while
         "i(" 'sh-function
         "i+" 'sh-add

         "TAB"   '(:ignore t :wk "indent")
         "TAB -" 'sh-learn-line-indent
         "TAB =" 'sh-set-indent
         "TAB |" 'sh-learn-buffer-indent
         "TAB ?" 'sh-show-indent))
    #+END_SRC

*** Bash Language Server                                                :lsp:
    :PROPERTIES:
    :header-args+: :tangle (package-lisp! +lang-sh-script sh-script :lsp)
    :END:

    #+BEGIN_SRC emacs-lisp
      (use-package sh-script
        :hook (sh-mode . +lsp-hook))
    #+END_SRC

*** Company Shell                                                      :comp:
    #+BEGIN_SRC emacs-lisp
      (use-package company-shell
        :straight t
        :autoload company-shell
        :completion+
        (sh-mode (company-shell :company t)))
    #+END_SRC

*** Appendix
    #+begin_src emacs-lisp
    (provide '+lang-sh-script)
    #+end_src

** SQL
   :PROPERTIES:
   :header-args+: :tangle (package-lisp! +lang-sql sql)
   :END:

   #+begin_src emacs-lisp :tangle (package-yes! sql)
   (require '+lang-sql)
   #+end_src

*** SQL Mode
    #+BEGIN_SRC emacs-lisp
      (use-package sql
        :straight t
        :mode ("\\.sql" . sql-mode)
        :hook (sql-mode . +flylint)
        :indent+ (sql-mode 2)
        :hide-whitespace+ sql-interactive-mode
        :custom
        (sql-sqlite-options '("-interactive"))
        (sql-pop-to-buffer-after-send-region nil)

        :init
        (evil-set-initial-state 'sql-mode 'normal)
        (evil-set-initial-state 'sql-interactive-mode 'emacs)

        :lazy-leader
        ;; see [[https://truongtx.me/2014/08/23/setup-emacs-as-an-sql-database-client][here]] for a guide on how to make quick database access easier. Or if you've
        ;; already got an interactive session running, use sql-save-connection to append
        ;; it to a local variable from which you can just paste it in here.
        (:mode 'sql-mode
         ;; "a" 'sql-beginning-of-statement
         ;; "e" 'sql-end-of-statement
         "i" 'sql-show-sqli-buffer
         "t" 'sql-toggle-pop-to-buffer-after-send-region

         "e"  '(:ignore t :wk "eval/REPL")
         "ee" 'sql-send-line-and-next
         "eb" 'sql-send-buffer
         "ep" 'sql-send-paragraph
         "er" 'sql-send-region
         "ep" 'sql-send-string

         "es" '(:ignore t :wk "REPL")
         "esp" 'sql-postgres
         "ess" 'sql-sqlite
         "esm" 'sql-mysqlite

         "l"  '(:ignore t :wk "list")
         "ll" 'sql-list-all
         "lt" 'sql-list-table)
        (:mode 'sql-interactive-mode
         "m" 'sql-set-sqli-buffer
         "t" 'sql-list-table
         "a" 'sql-list-all))
    #+END_SRC

*** SQL Upper Case
    #+BEGIN_SRC emacs-lisp
      (use-package sqlup-mode
        :straight t
        :hook ((sql-mode . sqlup-mode)
               (sql-interactive-mode . sqlup-mode))
        :config
        (push "name" sqlup-blacklist)

        :lazy-leader
        (:mode 'sql-mode
         "u"  '(:ignore t :wk "upcase")
         "ur" 'sqlup-capitalize-keywords-in-region
         "ub" 'sqlup-capitalize-keywords-in-buffer))
    #+END_SRC

*** Appendix
    #+begin_src emacs-lisp
    (provide '+lang-sql)
    #+end_src

** SSH Config
   :PROPERTIES:
   :header-args+: :tangle (package-lisp! +lang-ssh-config ssh-config)
   :END:

   #+begin_src emacs-lisp :tangle (package-yes! ssh-config)
   (require '+lang-ssh-config)
   #+end_src

   #+BEGIN_SRC emacs-lisp
     (use-package ssh-config-mode
       :straight t
       :delight (ssh-config-mode " SSH")
       ;; TODO advise last host to behave like org mode
       :general
       (:keymaps '(ssh-config-mode-map
                   ssh-known-hosts-mode-map)
        :states 'motion
        "gj" 'ssh-config-host-next
        "gk" 'ssh-config-host-prev))
   #+END_SRC

   #+begin_src emacs-lisp
    (provide '+lang-ssh-config)
   #+end_src

** Toml
   :PROPERTIES:
   :header-args+: :tangle (package-lisp! +lang-toml toml)
   :END:

   #+begin_src emacs-lisp :tangle (package-yes! toml)
     (require '+lang-toml)
   #+end_src

*** Toml Mode
    Provided through =conf-mode=.

   #+begin_src emacs-lisp
     (use-package conf-mode)
   #+end_src

*** Toml Tree Sitter Mode                                           :builtin:
    :PROPERTIES:
    :header-args+: :tangle (package-lisp! +lang-toml toml tree-sitter)
    :END:

    #+begin_src emacs-lisp
     (use-package toml-ts-mode
       :mode (rx ".toml" eol))
    #+end_src

*** Appendix
    #+begin_src emacs-lisp
    (provide '+lang-toml)
    #+end_src

** Verilog
   :PROPERTIES:
   :header-args+: :tangle (package-lisp! +lang-verilog verilog)
   :END:

   #+begin_src emacs-lisp :tangle (package-yes! verilog)
   (require '+lang-verilog)
   #+end_src

   #+begin_src emacs-lisp
     (use-package verilog-mode
       :straight t
       :config
       ;; Strip the surrounding asterisks from the `imenu' keys.
       (cl-loop for entry in verilog-imenu-generic-expression
                with key = nil
                do (setq key (car entry))
                when (and key
                          (string-prefix-p "*" key)
                          (string-suffix-p "*" key))
                  do (setcar entry (substring key 1 (1- (length key))))))
   #+end_src

   #+begin_src emacs-lisp
    (provide '+lang-verilog)
   #+end_src

** Vim Script
   :PROPERTIES:
   :header-args+: :tangle (package-lisp! +lang-vimscript vimlang)
   :END:

   #+begin_src emacs-lisp :tangle (package-yes! vimlang)
   (require '+lang-vimscript)
   #+end_src

   #+BEGIN_SRC emacs-lisp
     (use-package vimrc-mode
       :straight t
       :mode (rx ".vim")
       :delight (vimrc-mode " vim"))
   #+END_SRC

   #+begin_src emacs-lisp
    (provide '+lang-vimscript)
   #+end_src

** XML
   :PROPERTIES:
   :header-args+: :tangle (package-lisp! +lang-xml xml)
   :END:

   #+begin_src emacs-lisp :tangle (package-yes! xml)
     (require '+lang-xml)
   #+end_src

*** NXML Mode
    #+begin_src emacs-lisp
      (use-package nxml-mode
        :hook (nxml-mode . +flylint)
        :indent+ (nxml-mode 2)

        :config
        ;; Technically its builtin so its better, but it doesn't cooperate with
        ;; with flymake/flycheck and I'm not interested in re-learning how to
        ;; navigate errors this new way.
        (advice-add #'rng-nxml-mode-init :override #'ignore)

        :lazy-leader
        (:mode 'nxml-mode
         "s" 'nxml-split-element)
        :general
        (:keymaps 'nxml-mode-map
         :states 'insert
         "/" 'nxml-electric-slash))
    #+end_src

*** Company NXML                                                       :comp:
    :PROPERTIES:
    :header-args+: :tangle (package-lisp! +lang-xml xml company)
    :END:

    #+begin_src emacs-lisp
      (use-package company-nxml
        :straight company
        :autoload company-nxml
        :completion+ (nxml-mode (company-nxml :company t)))
    #+end_src

*** Appendix
    #+begin_src emacs-lisp
      (provide '+lang-xml)
    #+end_src

** YAML
  :PROPERTIES:
  :header-args+: :tangle (package-lisp! +lang-yaml yaml)
  :END:

  #+begin_src emacs-lisp :tangle (package-yes! yaml)
  (require '+lang-yaml)
  #+end_src

  #+begin_src emacs-lisp
    (defvar yaml-syntax-table-modifications+
      '((?_ . "w")
        (?- . "w")))
  #+end_src

*** YAML Mode
    :PROPERTIES:
    :header-args+: :tangle (package-lisp! +lang-yaml yaml (not tree-sitter))
    :END:

    #+begin_src emacs-lisp :tangle (package-lisp! +lang-yaml yaml tree-sitter)
      (use-package yaml-ts-mode
        :hook (yaml-ts-mode . +flylint)
        :mode ((rx (or (and ".y" (optional "a") "ml") ".clang-format") eol) . yaml-ts-mode)
        :indent+ (yaml-ts-mode 2)
        :modify-syntax+
        (yaml-ts-mode--syntax-table
         yaml-syntax-table-modifications+))

      (use-package org-src
        :config
        (push '("yaml" . yaml-ts) org-src-lang-modes))
    #+end_src

    #+begin_src emacs-lisp :tangle (package-lisp! +lang-yaml yaml (not tree-sitter))
      (use-package yaml-mode
        :straight t
        :hook (yaml-mode . +flylint)
        :mode ((rx (or (and ".y" (optional "a") "ml") ".clang-format") eol) . yaml-mode)
        :indent+ (yaml-mode 2)

        :modify-syntax+ yaml-syntax-table-modifications+

        :lazy-leader
        (:mode 'yaml-mode
         "n" 'yaml-narrow-to-block-literal
         "f" 'yaml-fill-paragraph
         "v" 'yaml-mode-version)

        :general
        (:keymaps 'yaml-mode-map
         :states 'insert
         "<tab>" 'yaml-indent-line))

      (use-package org-src
        :config
        (push '("yaml" . yaml) org-src-lang-modes))
    #+end_src

*** Appendix
    #+begin_src emacs-lisp
    (provide '+lang-yaml)
    #+end_src

** Yarn
   :PROPERTIES:
   :header-args+: :tangle (package-lisp! +lang-yarn yarn)
   :END:

   #+begin_src emacs-lisp :tangle (package-yes! yarn)
    (require '+lang-yarn)
   #+end_src

   #+BEGIN_SRC emacs-lisp
     (use-package yarn-mode :straight t)
     (provide '+lang-yarn)
   #+END_SRC

* Script
  :PROPERTIES:
  :header-args+: :shebang "#!/usr/bin/env emacs-script\n;; -*- mode: emacs-lisp; lexical-binding: t -*-"
  :END:

  Quick init is a minimalist emacs start-up config that makes sure some sane defaults
  (such as path configurations are setup). It's useful as an alternative to =init.el=
  when trying to debug a package. You can run it using:
  =emacs -Q --load $EMACS_HOME/quick-init.el=.

  #+NAME: quick-init
  #+BEGIN_SRC emacs-lisp :tangle quick-init.el :shebang ";; -*- lexical-binding: t -*-"
    (let ((early-init (concat user-emacs-directory "early-init.el")))
      (load early-init t t))

    <<setup-paths>>
    <<setup-straight-pacman>>
    <<setup-packages>>
  #+END_SRC

  Script init is an extension to quick-init that sets up an environment for command
  line based emacs scripts. This essentially replaces the lacklustre completing-read
  interface in command-line scripts with =fzf=, disables some unnecessary warnings and
  adds some useful packages for scripts.

  #+NAME: script-init
  #+BEGIN_SRC emacs-lisp :tangle no
    <<quick-init>>

    ;; fixes annoying issues with :leader
    (setq use-package-ignore-unknown-keywords t)
    (setq warning-minimum-log-level :emergency)

    ;; Allow scripts to defer to fzf for completing-read like selection.
    (defvar fzf-cmd '("fzf"))

    (defun fzf--base (cands &rest fzf-args)
      (with-temp-buffer
        (insert (s-join "\n" cands))
        (let* ((temp (make-temp-file "emacs-fzf-"))
               (fzf-cmd (concat (s-join " " (mapcar #'shell-quote-argument
                                                    (delq nil (append fzf-cmd fzf-args))))
                                " > "
                                (shell-quote-argument temp))))
          (unwind-protect
              (progn
                (if (eq 0 (call-process-region
                           (point-min) (point-max) "sh" nil
                           `((:file "/dev/stdout")
                             "/dev/stderr")
                           nil "-c" fzf-cmd))
                    (with-current-buffer (find-file temp)
                      (s-split "\n" (string-remove-suffix "\n" (buffer-substring (point-min) (point-max)))))
                  (error "fzf exited with non-zero exit-code")))
            (delete-file temp)))))

    (defun fzf (cands &rest fzf-args)
      (car (apply #'fzf--base cands fzf-args)))

    (defun fzf-multi (cands &rest fzf-args)
      (apply #'fzf--base cands "--multi" fzf-args))

    (defvar fzf-silent-p t)

    (defun fzf-completing-read--base (fzf-function prompt collection &optional
                                                   predicate _require-match initial-input
                                                   hist def _inherit-input-method)
      (let* ((collection (if predicate
                             (seq-filter predicate collection)
                           collection))
             (args `("--prompt" ,(concat prompt) ,@(and initial-input
                                                        (list "--query" initial-input))))
             (choice (or (apply fzf-function collection args)
                         def)))
        (unless fzf-silent-p
          (message "%s%s" prompt choice))
        choice))

    (setq completing-read-function (apply-partially #'fzf-completing-read--base #'fzf))
    (advice-add #'completing-read-multiple :override (apply-partially #'fzf-completing-read--base #'fzf-multi))

    ;; A command line [[https://github.com/rejeep/commander.el][parser]] designed for emacs lisp
    (use-package commander :straight t :demand t)
  #+END_SRC

** bin/skeletor
   #+BEGIN_SRC emacs-lisp :tangle bin/skeletor
     <<script-init>>
     <<package-skeletor>>

     (require 'skeletor)

     (defvar dest-dir default-directory)
     (setq fzf-silent-p t)

     (advice-add #'skeletor--insert-shell-command-arrow :before
                 (lambda (dir cmd)
                   (message "--> [%s]: %s" (f-short dir) cmd)))

     (defun list-skeletor-projects ()
       (princ (concat
               (string-join (->> skeletor--project-types
                                 (-map 'SkeletorProjectType-title)
                                 (-sort 'string<))
                            "\n")
               "\n")))

     (defun create-skeletor-project (&optional project)
       (if-let* ((skeleton (if project
                               (--first (equal project (SkeletorProjectType-title it))
                                        skeletor--project-types)
                             (skeletor--read-project-type))))
           (skeletor-expand-project+ skeleton dest-dir)
         (error "Failed to find project type %s" project)))

     (condition-case err
         (commander
          (description "Generate project directories from skeletor templates")
          (option "--help, -h" "Show usage information"
                  (lambda ()
                    (commander-print-usage)
                    (kill-emacs 0)))
          (command "list" "Show a list of all known skeletons" list-skeletor-projects)
          (command "create [project]"
                   "Create a new project from a template"
                   create-skeletor-project nil)
          (option "--output, -o <dir>" "Create project in DIR instead of: %s"
                  (lambda (arg) (setq dest-dir (file-truename arg)))))
       (error (progn
                (message "error: %s" err)
                (kill-emacs 1))))
   #+END_SRC

* Mode Line
** MK
   :PROPERTIES:
   :header-args+: :tangle (package-lisp! +mode-line-mk mk-mode-line)
   :END:

   #+begin_src emacs-lisp :tangle (package-yes! mk-mode-line)
     (require '+mode-line-mk)
   #+end_src

    My personal mode-line configuration (distinct from both Doom and Spacemacs).
    This was mostly inspired by [[https://gitlab.com/jessieh/mood-line/-/tree/master][mood-line]], a fork of [[https://github.com/seagle0128/doom-modeline][doom-modeline]] with a much
    simpler design.

*** Faces
    First we define customisation options and other helpers for building mode-lines.

    #+BEGIN_SRC emacs-lisp
      (defface +mode-line-major-mode
        `((t (:inherit bold)))
        ""
        :group '+mode-line)

      (defface +mode-line-buffer-name
        `((t (:inherit bold)))
        ""
        :group '+mode-line)

      (defface +mode-line-buffer-minor-mode
        `((t (:inherit mode-line)))
        ""
        :group '+mode-line)

      (defface +mode-line-evil-normal-state   `((t (:inherit mode-line))) "Highlight face for `mode-line' when in `evil-normal-state'." :group '+mode-line)
      (defface +mode-line-evil-emacs-state    `((t (:inherit mode-line))) "Highlight face for `mode-line' when in `evil-emace-state'." :group '+mode-line)
      (defface +mode-line-evil-insert-state   `((t (:inherit mode-line))) "Highlight face for `mode-line' when in `evil-insert-state'." :group '+mode-line)
      (defface +mode-line-evil-motion-state   `((t (:inherit mode-line))) "Highlight face for `mode-line' when in `evil-motion-state'." :group '+mode-line)
      (defface +mode-line-evil-visual-state   `((t (:inherit mode-line))) "Highlight face for `mode-line' when in `evil-visual-state'." :group '+mode-line)
      (defface +mode-line-evil-operator-state `((t (:inherit mode-line))) "Highlight face for `mode-line' when in `evil-operator-state'." :group '+mode-line)
      (defface +mode-line-evil-replace-state  `((t (:inherit mode-line))) "Highlight face for `mode-line' when in `evil-replace-state'." :group '+mode-line)

      (defface +mode-line-minibuffer-face
        `((t (:inherit +mode-line-evil-emacs-state)))
        "highlight face for doom-modeline when minibuffer is active"
        :group '+mode-line)

      (defface +mode-line-host-face
        '((t (:italic t)))
        "Face for remote hosts in the mode-line."
        :group '+mode-line)

      (defface +mode-line-linter-info
        '((t (:inherit compilation-mode-line-exit)))
        ""
        :group '+mode-line)

      (defface +mode-line-linter-warning
        '((t (:inherit compilation-mode-line-run)))
        ""
        :group '+mode-line)

      (defface +mode-line-linter-error
        '((t (:inherit compilation-mode-line-fail)))
        ""
        :group '+mode-line)
    #+END_SRC

*** Segments
**** Matches
***** Anzu
      #+begin_src emacs-lisp
        (defvar anzu--current-position)
        (defvar anzu--overflow-p)
        (defvar anzu--state)
        (defvar anzu--total-matched)
        (defvar anzu--cached-count)

        (defun +mode-line-anzu ()
          (when (bound-and-true-p anzu--state)
            (cond ((eq anzu--state 'replace-query)
                   (format " Replace: %d" anzu--cached-count))
                  (anzu--overflow-p
                   (format " %d/%d+" anzu--current-position anzu--total-matched))
                  (t
                   (format " %d/%d" anzu--current-position anzu--total-matched)))))
      #+end_src

***** Evil Matches
      #+BEGIN_SRC emacs-lisp
        (declare-function evil-delimited-arguments "evil")
        (defvar evil-ex-active-highlights-alist)
        (defvar evil-ex-argument)
        (defvar evil-ex-range)

        (defsubst +mode-line-evil-substitute ()
          "Show number of matches for evil-ex substitutions and highlights in real time."
          (when (and (bound-and-true-p evil-local-mode)
                     (or (assq 'evil-ex-substitute evil-ex-active-highlights-alist)
                         (assq 'evil-ex-global-match evil-ex-active-highlights-alist)
                         (assq 'evil-ex-buffer-match evil-ex-active-highlights-alist)))
            (let ((range (if evil-ex-range
                             (cons (car evil-ex-range) (cadr evil-ex-range))
                           (cons (line-beginning-position) (line-end-position))))
                  (pattern (car-safe (evil-delimited-arguments evil-ex-argument 2))))
              (if pattern
                  (format " %s matches" (how-many pattern (car range) (cdr range)))
                " -"))))
      #+END_SRC

***** Evil Register
      Detect and display the current evil-register and the register under which a macro
      is currently being recorded... so for example if I hit ="r= than my mode-line can
      output show that sequence to let me know which register I'm working with. Similar
      story for a macro and if I select a register within a macro it should say =@q "a=.

      #+BEGIN_SRC emacs-lisp
        (defconst +mode-line-macro-symbol "@")
        (defconst +mode-line-register-symbol "\"")

        (defun +mode-line-evil-macro-and-register ()
          (concat (when defining-kbd-macro
                    (concat " "
                            +mode-line-macro-symbol
                            (when (bound-and-true-p evil-this-macro)
                              (string evil-this-macro))))
                  (when (bound-and-true-p evil-this-register)
                    (concat " "
                            +mode-line-register-symbol
                            (char-to-string evil-this-register)))))
      #+END_SRC

***** Buffer Size
      #+begin_src emacs-lisp
        (defsubst +mode-line-buffer-size ()
          "Show buffer size."
          (when size-indication-mode
            (concat " "
                    (propertize "%I"
                                'help-echo "Buffer size
        mouse-1: Display Line and Column Mode Menu"
                                'mouse-face 'mode-line-highlight
                                'local-map mode-line-column-line-number-mode-map))))
      #+end_src

***** Appendix
      #+begin_src emacs-lisp
        (defun +mode-line-matches ()
          (let ((meta (concat (+mode-line-evil-macro-and-register)
                              (+mode-line-anzu)
                              (+mode-line-evil-substitute))))
            (or (and (not (string-empty-p meta)) meta)
                (+mode-line-buffer-size))))
      #+end_src

**** Buffer Name
     #+begin_src emacs-lisp
       (require 's)

       (defvar +mode-line-buffer-id-max-length 25
         "Truncate the buffer-id when it's larger than this many characters.
       Set to nil to disable buffer-name truncation.")

       (defvar +mode-line-buffer-id-ellipses "..."
         "Suffix to be attached to truncated buffer names.")

       (defun +mode-line-buffer-name ()
         (propertize
          (s-truncate +mode-line-buffer-id-max-length
                      (format-mode-line "%b")
                      +mode-line-buffer-id-ellipses)
          'face '+mode-line-buffer-name))
     #+end_src

**** Buffer Encoding
     #+begin_src emacs-lisp
       (defun +mode-line-buffer-eol ()
         (concat
          " "
          (let ((eol (coding-system-eol-type buffer-file-coding-system)))
            (propertize
             (pcase eol
               (0 "LF")
               (1 "CRLF")
               (2 "CR")
               (_ ""))
             'mouse-face 'mode-line-highlight
             'help-echo (format "End-of-line style: %s\nmouse-1: Cycle"
                                (pcase eol
                                  (0 "Unix-style LF")
                                  (1 "DOS-style CRLF")
                                  (2 "Mac-style CR")
                                  (_ "Undecided")))
             'local-map (let ((map (make-sparse-keymap)))
                          (define-key map [mode-line mouse-1] 'mode-line-change-eol)
                          map)))))

       (defun +mode-line-buffer-encoding ()
         "Displays the eol and the encoding style of the buffer the same way Atom does."
         (concat
          " "
          (let* ((sys (coding-system-plist buffer-file-coding-system))
                 (cat (plist-get sys :category))
                 (sym (if (memq cat
                                '(coding-category-undecided coding-category-utf-8))
                          'utf-8
                        (plist-get sys :name))))
            (propertize
             (upcase (symbol-name sym))
             'mouse-face 'mode-line-highlight
             'help-echo 'mode-line-mule-info-help-echo
             'local-map mode-line-coding-system-map))))
     #+end_src

**** Buffer Icon
     When available we should try to show an icon for the current file.

     #+BEGIN_SRC emacs-lisp
       (require '+pkg-all-the-icons)

       (defvar-local +mode-line-buffer-file-icon nil)
       (defun +mode-line-update-buffer-file-icon (&rest _)
         "Update file icon in `mode-line'."
         (setq +mode-line-buffer-file-icon
               (when (and +icons-available (featurep 'all-the-icons))
                 (let ((icon (+icon-for buffer (current-buffer) :face nil)))
                   (propertize (if (or (null icon) (symbolp icon))
                                   (+icon nerd-fa "file-o" :face nil)
                                 icon)
                               'help-echo (format "Major-mode: %s" (format-mode-line mode-name))
                               'display '(raise -0.135))))))

       (add-hook 'find-file-hook #'+mode-line-update-buffer-file-icon)
       (add-hook 'after-change-major-mode-hook #'+mode-line-update-buffer-file-icon)
       (add-hook 'clone-indirect-buffer-hook #'+mode-line-update-buffer-file-icon)
     #+END_SRC

**** Evil Face
     #+begin_src emacs-lisp
       (declare-function evil-normal-state-p "evil")
       (declare-function evil-emacs-state-p "evil")
       (declare-function evil-insert-state-p "evil")
       (declare-function evil-motion-state-p "evil")
       (declare-function evil-visual-state-p "evil")
       (declare-function evil-operator-state-p "evil")
       (declare-function evil-replace-state-p "evil")

       (defsubst +mode-line-evil-face ()
         (if (active-minibuffer-window)
             '+mode-line-minibuffer-face
           (if (bound-and-true-p evil-local-mode)
               (cond
                ((evil-normal-state-p)   '+mode-line-evil-normal-state)
                ((evil-emacs-state-p)    '+mode-line-evil-emacs-state)
                ((evil-insert-state-p)   '+mode-line-evil-insert-state)
                ((evil-motion-state-p)   '+mode-line-evil-motion-state)
                ((evil-visual-state-p)   '+mode-line-evil-visual-state)
                ((evil-operator-state-p) '+mode-line-evil-operator-state)
                ((evil-replace-state-p)  '+mode-line-evil-replace-state)
                (t                       '+mode-line-evil-normal-state))
             '+mode-line-evil-normal-state)))
     #+end_src

**** Winum & Evil State
     #+begin_src emacs-lisp
       (declare-function winum-get-number-string "winum")
       (declare-function aw-update "ace-window")
       (declare-function window-numbering-get-number-string "window-numbering")

       (defun +mode-line-winum ()
         (let* ((face (+mode-line-evil-face))
                (space (propertize " " 'face face)))
           (concat space
                   (when (> (length (frames-on-display-list)) 1)
                     (propertize (format-mode-line (mode-line-frame-control))
                                 'face `(:weight bold :inherit ,face)))
                   (propertize
                    (cond
                     ((active-minibuffer-window) "‚óè")
                     ((bound-and-true-p winum-mode)
                      (substring-no-properties (winum-get-number-string)))
                     ((bound-and-true-p ace-window-display-mode)
                      (aw-update)
                      (window-parameter (selected-window) 'ace-window-path))
                     ((bound-and-true-p window-numbering-mode)
                      (window-numbering-get-number-string))
                     (t " "))
                    'face face)
                   space)))
     #+end_src

**** Version Control
     Extract and display version-control information related to the current
     buffer. For git this includes a GitHub icon and the current git branch.
     For SVN... I have no idea, if I ever use a project that has SVN I may well
     find out :stuck_out_tongue:.

     #+BEGIN_SRC emacs-lisp
       (defvar-local +mode-line-vc-text nil
         "The version control status for the current buffer.
       Adapted from `mood-line'.")

       (defvar +mode-line-vc-branch-max-length 12
         "Truncate the branch-name when it's larger than this many characters.
       Set to nil to disable buffer-name truncation.")

       (defvar +mode-line-vc-branch-ellipses "..."
         "Suffix to be attached to truncated buffer names.")

       (defun +mode-line--update-vc-status ()
         (setq +mode-line-vc-text
               (when (and vc-mode buffer-file-name)
                 (let* ((backend (vc-backend buffer-file-name))
                        (state (vc-state buffer-file-name backend)))
                   (cl-destructuring-bind (icon . face)
                       (cond ((memq state '(edited added))
                              (cons "+" 'compilation-mode-line-exit))
                             ((eq state 'needs-merge)
                              (cons "‚Üê" 'compilation-mode-line-run))
                             ((eq state 'needs-update)
                              (cons "‚Üë" 'compilation-mode-line-run))
                             ((memq state '(removed conflict unregistered))
                              (cons "‚úñ" 'compilation-mode-line-fail))
                             ;; (t (propertize "‚úî" 'face face))
                             (t (cons nil nil)))
                     ;; Hide when there's nothing out of the ordinary to show.
                     (when icon
                       (apply #'propertize
                              (concat (apply #'propertize (concat icon " ")
                                             (text-properties-at 0 vc-mode))
                                      (s-truncate +mode-line-vc-branch-max-length
                                                  (substring
                                                   vc-mode
                                                   (+ (if (eq backend 'Hg) 2 3) 2))
                                                  +mode-line-vc-branch-ellipses))
                              `(,@(when face (list 'face face))
                                mouse-face mode-line-highlight))))))))

       ;; Hooks to auto-update vc status alongside the buffer.
       (add-hook 'find-file-hook #'+mode-line--update-vc-status)
       (add-hook 'after-save-hook #'+mode-line--update-vc-status)
       (advice-add #'vc-refresh-state :after #'+mode-line--update-vc-status)
     #+END_SRC

**** Project
     Discover the name of the current buffers project.

     #+BEGIN_SRC emacs-lisp
       (defun +mode-line-project ()
         (cond
          ((and (bound-and-true-p projectile-mode)
                (fboundp 'projectile-project-name))
           (let ((project-name (projectile-project-name)))
             (unless (or (string= project-name "-")
                         (string= project-name (buffer-name)))
               project-name)))
          ((fboundp 'project-current)
           (cdr (project-current)))))
     #+END_SRC

**** Tramp
     #+begin_src emacs-lisp
       (defvar-local +mode-line-remote-component nil)

       (defvar +mode-line-remote-component--remap-regexps
         `(;; For docker-compose the [[https://github.com/docker/compose/blob/7b0ed13209894b5981608f7d9e329a3a58af957d/pkg/compose/convergence.go#L260][default format]] for a container name
           ;; produced by commands like up is the hyphen separate name of
           ;; the project, service and a unique number.
           ;;
           ;; I find this redundant in most cases, if I wanted the project
           ;; name in the mode-line I'd include it separately. Here we strip
           ;; out the extra properties. So foo-bar-1 > bar/1
           ;;
           ;; See also [[https://github.com/moby/moby/blob/7b9275c0da707b030e62c96b679a976f31f929d3/daemon/names/names.go#L6][list]] of supported docker image name characters.
           (,(rx bol
                 (group alnum (* (any alnum "_.-"))) ; project
                 (any "-_")
                 (group (+ (any alnum "_.-"))) ; service
                 (any "-_")
                 (group (one-or-more digit)) ; number
                 eol)
            . "\\2_\\3")
           ;; When using docker-compose run a new container is started with
           ;; a [[https://github.com/docker/compose/blob/7b0ed13209894b5981608f7d9e329a3a58af957d/pkg/compose/run.go#L65][name of the form]] PACKAGE-SERVICE-RUN-SLUG. This is 100% way
           ;; too long, and often runs over the length of my mode-line.
           ;; For now I just reduce it to the service name for convenience. So
           ;; projection-dev-run-7300cd0752b4 becomes just dev.
           (,(rx bol
                 (group alnum (* (any alnum "_.-"))) ; project
                 (any "-_")
                 (group (+ (any alnum "_.-"))) ; service
                 (any "-_")
                 "run"
                 (any "-_")
                 (group (+ alnum))             ; 12 character slug
                 eol)
            . "\\2"))
         "Remote host re-mappings for `+mode-line-update-remote-component'.")

       (defun +mode-line-update-remote-component (&rest _)
         "Update file remote component in the `mode-line'."
         (when-let* ((host (file-remote-p default-directory 'host)))
           (save-match-data
             (seq-find
              (lambda (remap)
                (when (string-match (car remap) host)
                  (setq host (replace-match (cdr remap) nil nil host))
                  t))
              +mode-line-remote-component--remap-regexps))

           (setq +mode-line-remote-component host)))

       (add-hook 'after-change-major-mode-hook #'+mode-line-update-remote-component)
     #+end_src

**** Tree Sitter
     #+begin_src emacs-lisp
       (defvar-local +mode-line-tree-sitter-active-p nil)

       (defun +mode-line-update-tree-sitter-active-p (&rest _)
         (setq +mode-line-tree-sitter-active-p
               (when (s-contains-p "-ts-" (symbol-name major-mode))
                 " T")))

       (when (treesit-available-p)
         (add-hook 'after-change-major-mode-hook #'+mode-line-update-tree-sitter-active-p))
     #+end_src

**** Visual Selection
     #+BEGIN_SRC emacs-lisp
       (declare-function evil-visual-state-p "evil")
       (defvar evil-visual-beginning)
       (defvar evil-visual-end)

       (defvar +mode-line-show-word-count nil)

       (defsubst +mode-line-column (pos)
         "Get the column of the position `POS'."
         (save-excursion (goto-char pos)
                         (current-column)))

       (defun +mode-line-selection-info ()
         "Information about the current selection, such as how many characters and
       lines are selected, or the NxM dimensions of a block selection."
         (when (and (or mark-active
                        (and (bound-and-true-p evil-local-mode)
                             (evil-visual-state-p))))
           (cl-destructuring-bind (beg . end)
               (if (and (bound-and-true-p evil-local-mode)
                        (evil-visual-state-p))
                   (cons evil-visual-beginning evil-visual-end)
                 (cons (region-beginning) (region-end)))
             (propertize
              (let ((lines (count-lines beg (min end (point-max)))))
                (concat " "
                        (cond ((or (bound-and-true-p rectangle-mark-mode)
                                   (and (bound-and-true-p evil-visual-selection)
                                        (eq 'block evil-visual-selection)))
                               (let ((cols (abs (- (+mode-line-column end)
                                                   (+mode-line-column beg)))))
                                 (format "%dx%dB" lines cols)))
                              ((and (bound-and-true-p evil-visual-selection)
                                    (eq evil-visual-selection 'line))
                               (format "%dL" lines))
                              ((> lines 1)
                               (format "%dC %dL" (- end beg) lines))
                              ((format "%dC" (- end beg))))
                        (when +mode-line-show-word-count
                          (format " %dW" (count-words beg end)))))
              'face 'mode-line-emphasis))))
     #+END_SRC

**** Misc Info
     #+begin_src emacs-lisp
       (require 's)

       (defun +mode-line-misc-info ()
         (let ((misc-info (s-trim (format-mode-line mode-line-misc-info 'file-name-shadow))))
           (unless (string-empty-p misc-info)
             (concat " " misc-info))))
     #+end_src

**** Checkers
     Next on the list are icons/status-info for the current linter/syntax-highlighter
     for the buffer you're in. This can come from either [[https://www.flycheck.org/en/latest/][flycheck]] or [[https://www.gnu.org/software/emacs/manual/html_node/flymake/Using-Flymake.html#Using-Flymake][GNU flymake]] but
     I *don't* recommend having both active simultaneously.

     These are hard coded indicators which are substituted as is when applicable.

     #+BEGIN_SRC emacs-lisp
       (defconst +mode-line-checker-running
         (propertize " Œî Checking" 'face 'compilation-mode-line-run))

       (defconst +mode-line-checker-failed
         (propertize " ‚úñ Error" 'face 'compilation-mode-line-fail))

       (defconst +mode-line-checker-interrupted
         " ‚è∏ Paused")
     #+END_SRC

     The actual error, info and warning indicators are shown as bullets using
     following format.

     #+BEGIN_SRC emacs-lisp
       (defconst +mode-line-checker-bullet "‚Ä¢"
         "The bullet used for each section of a `flymake'/`flycheck' segment.")
     #+END_SRC

     Lastly lets just add a helper method to format any checker diagnostics
     in a way that looks pretty *and* can be substituted back into the mode-line.

     #+BEGIN_SRC emacs-lisp
       (require 's)

       (defsubst +mode-line-format-a-diagnostic (count icon face running)
         (setq count
               (cond
                (count (number-to-string count))
                (running "?")))
         (and count
              (propertize
               (concat
                (if (featurep 'all-the-icons)
                    (all-the-icons-pad+
                     (+icon nerd-md icon))
                  +mode-line-checker-bullet)
                count)
               'face face)))

       (defsubst +mode-line-format-diagnostics (_meta diags &optional running)
         "Format DIAGS into a string for the mode-line.
       DIAGS should be an alist of error, warning, and info.
       META is meta-data associated with the checker (see `flymake').
       RUNNING indicates that more results may be pending."
         (let-alist diags
           (let ((msg (s-join
                       " "
                       (delq nil
                             (list
                              (+mode-line-format-a-diagnostic .info    "alert-box"          '+mode-line-linter-info running)
                              (+mode-line-format-a-diagnostic .warning "multiplication-box" '+mode-line-linter-warning running)
                              (+mode-line-format-a-diagnostic .error   "minus-box"          '+mode-line-linter-error running))))))
             (unless (string-empty-p msg)
               (concat " " msg )))))
     #+END_SRC

***** FlyCheck
      #+BEGIN_SRC emacs-lisp
        (defvar flycheck-current-errors)
        (declare-function flycheck-count-errors "flycheck")

        (defvar-local +mode-line-flycheck-text nil)
        (defun +mode-line--update-flycheck (&optional status)
          (setq +mode-line-flycheck-text
                (concat
                 ;; (pcase status
                 ;;   ;; ('finished)
                 ;;   ('running +mode-line-checker-running)
                 ;;   ('errored +mode-line-checker-failed)
                 ;;   ('interrupted +mode-line-checker-interrupted)
                 ;;   ('no-checker nil))
                 (unless (member status '(errored no-checker))
                   (when flycheck-current-errors
                     (+mode-line-format-diagnostics
                      nil
                      (flycheck-count-errors flycheck-current-errors)
                      (eq status 'running)))))))

        (add-hook 'flycheck-status-changed-functions #'+mode-line--update-flycheck)
        (add-hook 'flycheck-mode-hook #'+mode-line--update-flycheck)
      #+END_SRC

***** FlyMake
      #+BEGIN_SRC emacs-lisp
        (declare-function flymake-diagnostics "flymake")
        (declare-function flymake--severity "flymake")
        (declare-function flymake-diagnostic-type "flymake")
        (declare-function flymake-running-backends "flymake")
        (declare-function flymake-disabled-backends "flymake")
        (declare-function flymake-reporting-backends "flymake")

        (defun +mode-line--count-flymake-diagnostics ()
          (cl-loop with idx = nil
                   with acc = (make-vector 3 0)                                   ; See (flymake--severity :error)
                   for diag in (flymake-diagnostics)
                   do (setq idx (- (flymake--severity (flymake-diagnostic-type diag)) 1))
                   when (and (>= idx 0)
                             (<  idx 3))
                   do (aset acc idx (1+ (aref acc idx)))
                   finally return
                   (seq-filter (lambda (a) (not (eq (cdr a) 0)))
                               `((info    . ,(aref acc 0))
                                 (warning . ,(aref acc 1))
                                 (error   . ,(aref acc 2))))))

        (defvar-local +mode-line-flymake-text nil)
        (defun +mode-line--update-flymake-text (&rest _)
          ;; See [[https://www.gnu.org/software/emacs/manual/html_node/flymake/Syntax-check-statuses.html#Syntax-check-statuses][here]].
          (setq +mode-line-flymake-text
                (let* (;; (known (and flymake--backend-state
                       ;;             (hash-table-keys flymake--backend-state)))
                       (running (flymake-running-backends))
                       (disabled (flymake-disabled-backends))
                       (reported (flymake-reporting-backends))
                       (all-disabled (and disabled (null running)))
                       (some-waiting (cl-set-difference running reported)))
                  (concat
                   ;; (cond
                   ;;  (some-waiting +mode-line-checker-running)
                   ;;  (all-disabled +mode-line-checker-interrupted))
                   (unless all-disabled
                     (+mode-line-format-diagnostics
                      ;; TODO: Do something with the status-text.
                      ;; (cond ((null known)
                      ;;        (propertize "?" 'face meta-face))
                      ;;       (some-waiting
                      ;;        (propertize "%" 'face meta-face))
                      ;;       (all-disabled
                      ;;        (propertize "!" 'face error-face)))
                      nil
                      (+mode-line--count-flymake-diagnostics)
                      some-waiting))))))

        (advice-add 'flymake--handle-report :after #'+mode-line--update-flymake-text)
        (advice-add 'flymake-mode :after
                    (defun +mode-line--hide-on-flymake-exit (&rest _)
                      ;; `flymake--handle-report' isn't called on exit.
                      (unless (bound-and-true-p flymake-mode)
                        (setq +mode-line-flymake-text nil))))
      #+END_SRC

**** Status Icons
***** LSP
      Emacs has a few language-server packages. More recent variants are implementations
      of the [[https://microsoft.github.io/language-server-protocol/][lsp-protocol]] for which emacs has 2 mainstream client implementations [[https://microsoft.github.io/language-server-protocol/][lsp-mode]]
      and [[https://github.com/joaotavora/eglot][eglot]]. There's also some +older+ *more-established* language server packages such
      [[https://github.com/mopemope/meghanada-emacs][meghanada-mode]] or [[https://github.com/pythonic-emacs/anaconda-mode][anaconda-mode]].

      Each of these functions return a plist containing a server status message, some
      meta-information (eg. server-name or server-port) and a face that should be
      attached to it.

      Much of these were partially adapted from: [[https://github.com/seagle0128/doom-modeline/blob/af5f61888e7eb0aa521d2d29b42221302b717915/doom-modeline-segments.el#L1871][doom-modeline]].

****** LSP Mode
       #+BEGIN_SRC emacs-lisp
         (declare-function lsp-workspace-restart "lsp-mode")
         (declare-function lsp-workspace-shutdown "lsp-mode")
         (declare-function lsp-describe-session "lsp-mode")
         (declare-function lsp-workspace-folders-open "lsp-mode")
         (declare-function lsp--workspace-print "lsp-mode")
         (declare-function lsp-workspaces "lsp-mode")

         (defvar-local +mode-line-lsp-text nil)
         (defun +mode-line--update-lsp ()
           (setq +mode-line-lsp-text
                 (let* ((workspaces (lsp-workspaces)))
                   (propertize (all-the-icons-pad+
                                (+icon nerd-fa "rocket"
                                       :face (if workspaces
                                                 nil
                                               'compilation-mode-line-fail)))
                               'help-echo
                               (if workspaces
                                   (concat "LSP Connected "
                                           (string-join
                                            (mapcar (lambda (w)
                                                      (format "[%s]\n" (lsp--workspace-print w)))
                                                    workspaces))
                                           "C-mouse-1: Switch to another workspace folder
         mouse-1: Describe current session
         mouse-2: Quit server
         mouse-3: Reconnect to server")
                                 "LSP Disconnected
         mouse-1: Reload to start server")
                               'mouse-face 'mode-line-highlight
                               'local-map (let ((map (make-sparse-keymap)))
                                            (if workspaces
                                                (progn
                                                  (define-key map [mode-line C-mouse-1]
                                                    #'lsp-workspace-folders-open)
                                                  (define-key map [mode-line mouse-1]
                                                    #'lsp-describe-session)
                                                  (define-key map [mode-line mouse-2]
                                                    #'lsp-workspace-shutdown)
                                                  (define-key map [mode-line mouse-3]
                                                    #'lsp-workspace-restart))
                                              (progn
                                                (define-key map [mode-line mouse-1]
                                                  (lambda ()
                                                    (interactive)
                                                    (ignore-errors (revert-buffer t t))))))
                                            map)))))

         (add-hook 'lsp-before-initialize-hook #'+mode-line--update-lsp)
         (add-hook 'lsp-after-initialize-hook #'+mode-line--update-lsp)
         (add-hook 'lsp-after-uninitialized-functions #'+mode-line--update-lsp)
         (add-hook 'lsp-before-open-hook #'+mode-line--update-lsp)
         (add-hook 'lsp-after-open-hook #'+mode-line--update-lsp)
       #+END_SRC

****** Eglot
       #+BEGIN_SRC emacs-lisp
         (declare-function eglot-managed-p "eglot")
         (declare-function eglot-reconnect "eglot")
         (declare-function eglot-shutdown "eglot")
         (declare-function eglot-events-buffer "eglot")
         (declare-function eglot-stderr-buffer "eglot")
         (declare-function eglot-forget-pending-continuations "eglot")
         (declare-function eglot-clear-status "eglot")
         (declare-function eglot--major-modes "eglot")
         (declare-function eglot--project-nickname "eglot")
         (declare-function eglot-current-server "eglot")
         (declare-function jsonrpc-last-error "jsonrpc")
         (declare-function jsonrpc--request-continuations "jsonrpc")
         (declare-function jsonrpc-continuation-count "jsonrpc")

         (defvar-local +mode-line-eglot-text nil)
         (defun +mode-line--update-eglot (&rest _)
           "Update `eglot' state."
           (setq +mode-line-eglot-text
                 (when (eglot-managed-p)
                   (pcase-let* ((server (eglot-current-server))
                                (nick (and server (eglot--project-nickname server)))
                                (pending (and server (jsonrpc-continuation-count server)))
                                (last-error (and server (jsonrpc-last-error server)))
                                (face (cond (last-error 'compilation-mode-line-fail)
                                            ((and pending (cl-plusp pending))
                                             'compilation-mode-line-run)
                                            (nick nil)
                                            (t 'compilation-mode-line-run))))
                     (propertize (all-the-icons-pad+ (+icon nerd-fa "rocket" :face face))
                                 'help-echo (cond
                                             (last-error
                                              (format "EGLOT\nAn error occured: %s
         mouse-3: Clear this status" (plist-get last-error :message)))
                                             ((and pending (cl-plusp pending))
                                              (format "EGLOT\n%d outstanding requests" pending))
                                             (nick (format "EGLOT Connected (%s/%s)
         C-mouse-1: Go to server errors
         mouse-1: Go to server events
         mouse-2: Quit server
         mouse-3: Reconnect to server" nick (eglot--major-modes server)))
                                             (t "EGLOT Disconnected
         mouse-1: Start server"))
                                 'mouse-face 'mode-line-highlight
                                 'local-map (let ((map (make-sparse-keymap)))
                                              (cond (last-error
                                                     (define-key map [mode-line mouse-3]
                                                       #'eglot-clear-status))
                                                    ((and pending (cl-plusp pending))
                                                     (define-key map [mode-line mouse-3]
                                                       #'eglot-forget-pending-continuations))
                                                    (nick
                                                     (define-key map [mode-line C-mouse-1]
                                                       #'eglot-stderr-buffer)
                                                     (define-key map [mode-line mouse-1]
                                                       #'eglot-events-buffer)
                                                     (define-key map [mode-line mouse-2]
                                                       #'eglot-shutdown)
                                                     (define-key map [mode-line mouse-3]
                                                       #'eglot-reconnect))
                                                    (t (define-key map [mode-line mouse-1]
                                                         #'eglot)))
                                              map))))))

         (add-hook 'eglot-managed-mode-hook #'+mode-line--update-eglot)
         (add-hook 'eglot-connect-hook #'+mode-line--update-eglot)
         (advice-add 'eglot--managed-mode-off :after #'+mode-line--update-eglot)
       #+END_SRC

***** Dape
      #+begin_src emacs-lisp
        (require 'cl-lib)

        (defvar +mode-line-dape-text nil)

        (defvar dape--connection)
        (declare-function dape--live-connection "dape")
        (declare-function dape--state "dape")
        (declare-function dape--live-connections "dape")
        (declare-function dape--state-reason "dape")

        (defun +mode-line--update-dape-text (&rest _)
          (setq +mode-line-dape-text
                (when-let* ((conn (or (dape--live-connection 'last t)
                                      dape--connection))
                            ((not (memq (dape--state conn) '(exited terminated)))))
                  (concat
                   (all-the-icons-pad+
                    (+icon nerd-fa "bug"
                           :face
                           (pcase (dape--state conn)
                             ((or 'starting 'initialized)
                              'font-lock-string-face)
                             ('running 'font-lock-keyword-face)
                             ('stopped nil))))
                   (when-let* ((conns (dape--live-connections))
                               (nof-conns (length (cl-remove-if-not 'dape--threads conns)))
                               ((> nof-conns 1)))
                     (concat "+" (propertize (number-to-string nof-conns)
                                             'face 'shadow
                                             'help-echo "Active child connections")))
                   (when-let* ((reason (and conn (dape--state-reason conn))))
                     (concat "/" (propertize reason 'face 'font-lock-doc-face)))))))

        (advice-add 'dape--mode-line-format :override #'+mode-line--update-dape-text)
      #+end_src

***** Appendix
      #+BEGIN_SRC emacs-lisp
        (defun +mode-line-status-icons ()
          (let ((msg (concat (and (buffer-narrowed-p)
                                  (featurep 'all-the-icons)
                                  (all-the-icons-pad+ (+icon nerd-mdi "eye")))
                             +mode-line-eglot-text
                             +mode-line-lsp-text
                             +mode-line-dape-text)))
            (unless (string-empty-p msg)
              (concat " " msg))))
      #+END_SRC

*** Utils
**** Window Width
     Support hiding some sections of the mode-line when the window isn't wide enough.
     Adapted from ~doom-modeline-window-size-change-function~.

     #+begin_src emacs-lisp
       (defvar +mode-line-window-width-limit fill-column
         "The limit of the window width.
       If `window-width' is smaller than the limit, some information will not be
       displayed.")
     #+end_src

     #+begin_src emacs-lisp
       (defvar-local +mode-line-wide-p t)
       (defun +mode-line-window-size-change-function (&rest _)
         "Function for `window-size-change-functions'."
         (setq +mode-line-wide-p
               (not
                (and (numberp +mode-line-window-width-limit)
                     (<= (+ (window-total-width)
                            (or scroll-bar-width 0)
                            (or left-fringe-width 0)
                            (or right-fringe-width 0)
                            (or left-margin-width 0)
                            (or right-margin-width 0))
                         +mode-line-window-width-limit)))))

       (add-hook 'window-size-change-functions #'+mode-line-window-size-change-function)
       (add-hook 'buffer-list-update-hook #'+mode-line-window-size-change-function)
     #+end_src

*** Mode Line Format
    First lets enable some useful minor modes to toggles some mode-line indicators.

    #+BEGIN_SRC emacs-lisp
      (add-hook 'emacs-startup-hook 'size-indication-mode)
      (add-hook 'emacs-startup-hook 'column-number-mode)
    #+END_SRC

    Here are the actual sections of my mode-line, divided into left and right sides.
    NOTE: These will be evaluated twice so any % sequences must be escaped.

    #+BEGIN_SRC emacs-lisp
      (defvar mode-line-left+
        '((:eval (+mode-line-winum))
          (:eval (+mode-line-matches))
          " [%*] "
          (+mode-line-buffer-file-icon
           ((:eval (all-the-icons-pad-on-tty-advice+
                    +mode-line-buffer-file-icon))
            " "))
          (:eval (+mode-line-buffer-name))
          (+mode-line-remote-component
           (:propertize ("@" +mode-line-remote-component)
            face +mode-line-host-face))
          (mode-line-process
           (:propertize (" " mode-line-process)
            face +mode-line-buffer-minor-mode))
          (:eval (+mode-line-selection-info))
          (:eval (or +mode-line-flymake-text
                     +mode-line-flycheck-text))
          " ")
        "The left hand side of my customized mode-line.")

      (defvar mode-line-right+
        '((:eval +mode-line-vc-text)
          (:eval (+mode-line-status-icons))
          (:propertize ("" +mode-line-tree-sitter-active-p)
           face +mode-line-buffer-minor-mode)
          (:propertize ("" minor-mode-alist)
           face +mode-line-buffer-minor-mode
           mouse-face mode-line-highlight
           help-echo "Minor mode
        mouse-1: Display minor mode menu
        mouse-2: Show help for minor mode
        mouse-3: Toggle minor modes"
           local-map ,mode-line-minor-mode-keymap)
          (:eval (+mode-line-misc-info))
          (+mode-line-wide-p
           (:eval (+mode-line-buffer-eol)))
          (+mode-line-wide-p
           (:eval (+mode-line-buffer-encoding)))
          (+mode-line-wide-p
           (line-number-mode
            (column-number-mode " %l:%c" " %l")
            (column-number-mode " :%c")))
          (" " mode-line-percent-position)
          " "
          (:propertize mode-name
           face +mode-line-major-mode)
          " ")
        "The right hand side of my customized mode-line.")
    #+END_SRC

    This is the helper function which actually formats and renders the mode-line,
    spacing the two sections equally.

    #+BEGIN_SRC emacs-lisp
      (defun +mode-line-right-align (right)
        "Return a string that's wide enough to right align RIGHT."
        (propertize " "
                    'display `((space
                                :align-to
                                (- (+ right right-fringe right-margin)
                                   ;; Fix annoying space inconsistency in text terminals due to fringe.
                                   ,(if (and (not (display-graphic-p))
                                             (window-at-side-p nil 'right))
                                        0
                                      1)
                                   ;; NOTE: Requires double evaluation of RHS forms for spacing.
                                   ,(string-width (format-mode-line (cons "" right))))))))
    #+END_SRC

    And now we finally assign the mode-line format.

    #+BEGIN_SRC emacs-lisp
      (setq-default
       mode-line-format
       `((:eval mode-line-left+)
         (:eval (+mode-line-right-align mode-line-right+))
         (:eval mode-line-right+)))

      ;; Update existing mode-line format values.
      (dolist (buf (buffer-list))
        (with-current-buffer buf
          (setq mode-line-format (default-value 'mode-line-format))))
    #+END_SRC

*** Appendix
    #+begin_src emacs-lisp
      (provide '+mode-line-mk)
    #+end_src

* Themes
  #+BEGIN_SRC emacs-lisp
    (set-face-attribute 'default nil :family "Meslo LG S DZ")
  #+END_SRC

  #+BEGIN_SRC emacs-lisp
    (add-to-list 'custom-theme-load-path (lisp! "themes"))
  #+END_SRC

   Define some extra faces for use in a few different places.

   Custom face declarations like these should be put into ~early-init.el~ so they can
   be used in any packages in my config without needing to wait for all of ~init.el~ to
   be loaded.

   #+BEGIN_SRC emacs-lisp :tangle early-init.el
     (defface tab-bar-separator '((t (:inherit font-lock-string-face))) "" :group '+dot-emacs)
     (defface tab-bar-inactive-separator '((t (:inherit shadow))) "" :group '+dot-emacs)
   #+END_SRC

** an-old-hope
   :PROPERTIES:
   :header-args+: :tangle (package-str! (lisp! "themes/an-old-hope-theme.el") an-old-hope)
   :END:

   #+BEGIN_SRC emacs-lisp :tangle (package-yes! an-old-hope)
     (load-theme 'an-old-hope 'no-confirm)
   #+END_SRC

   #+NAME: an-old-hope-theme-description
   #+BEGIN_EXAMPLE
      Emacs theme inspired by a galaxy far far away...

      This theme is largely just a shot for shot copy of [[https://github.com/jesseleite/an-old-hope-syntax-atom][jesseleite/an-old-hope-syntax-atom]]
      ported to emacs because I refuse to live with an IDE that doesn't look like it XD.
      This theme isn't compatible with emacs in the terminal yet, when I find an easy way
      to approximate true-color colors to non-true-color colors, then I'll add support for
      it.
   #+END_EXAMPLE

   #+HEADER: :shebang ;; an-old-hope-theme.el -- a syntax theme from a galaxy far away... -*- lexical-binding: t -*-"
   #+BEGIN_SRC emacs-lisp :comments no
     ;; Author: Mohsin Kaleem
     ;; URL: https://github.com/MoHKale/an-old-hope-theme
     ;; Version: 0.1.0
     ;; Keywords: color, theme
     ;; Package-Requires: ((emacs "24"))

     ;; This file is not part of GNU Emacs

     ;; This file is free software; you can redistribute it and/or modify
     ;; it under the terms of the GNU General Public License as published by
     ;; the Free Software Foundation; either version 3, or (at your option)
     ;; any later version.

     ;; This program is distributed in the hope that it will be useful,
     ;; but WITHOUT ANY WARRANTY; without even the implied warranty of
     ;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     ;; GNU General Public License for more details.

     ;; For a full copy of the GNU General Public License
     ;; see <http://www.gnu.org/licenses/>.

     ;; Commentary:
     ;; see https://github.com/MoHKale/an-old-hope-theme/tree/master/emacs
   #+END_SRC

   #+BEGIN_SRC emacs-lisp :results silent :var desc=an-old-hope-theme-description
     (deftheme an-old-hope
       desc)
   #+END_SRC

   A helper which converts HSL values into RGB ratios and then RGB hex.

   #+NAME: aoh-gen-color
   #+BEGIN_SRC emacs-lisp :results value :tangle no :exports none :var hue=0 sat=0 light=0 approx=(eval nil)
     (require 'color)
     (require 'cl-lib)

     (cl-letf (((symbol-function 'smart-num)
                (lambda (arg)
                  (if (numberp arg)
                      arg
                    (string-to-number arg)))))
       (let* ((hue   (/ (smart-num hue)   360.0))
              (sat   (/ (smart-num sat)   100.0))
              (light (/ (smart-num light) 100.0))

              (rgb (color-hsl-to-rgb hue sat light)))
         (color-rgb-to-hex (nth 0 rgb) (nth 1 rgb) (nth 2 rgb) 2)))
   #+END_SRC

   Here we define the faces used by this theme, all of the an-old-hope colors are
   evaluated using the above helper and I provide 256-bit variants using the same
   HSL values and some of the various emacs [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Text-Terminal-Colors.html][text-terminal-colors]] functions.

   I define both the actual colors and the closest 256-color approximation of them.
   You can create more of these by spawning an emacs-terminal without 24-bit color
   and using the following function:

   #+BEGIN_SRC emacs-lisp :tangle no
     (defun aoh-gen-256-approximation (hue sat light)
       (cl-letf (((symbol-function 'smart-num)
                  (lambda (arg)
                    (if (numberp arg)
                        arg
                      (string-to-number arg)))))
         (let* ((hue   (/ (smart-num hue)   360.0))
                (sat   (/ (smart-num sat)   100.0))
                (light (/ (smart-num light) 100.0))

                (rgb (color-hsl-to-rgb hue sat light))
                (name (car (tty-color-approximate
                            (mapcar (lambda (c) (ceiling (* 65280 c))) rgb)))))
           (cons name
                 (apply 'format "#%02x%02x%02x"
                        (mapcar (lambda (c) (ash c -8))
                                (color-values name)))))))
   #+END_SRC

*** faces
    :PROPERTIES:
    :header-args+: :var cls=(eval t) tru=(quote ((type graphic) (min-colors 16777216))) gui=(quote ((type graphic)))
    :header-args+: :var   very-light-grey=aoh-gen-color(hue=228, sat=7,   light=81)     very-light-grey-256="#d0d0d0"
    :header-args+: :var        light-grey=aoh-gen-color(hue=228, sat=7,   light=55)          light-grey-256="#8a8a8a"
    :header-args+: :var              grey=aoh-gen-color(hue=228, sat=7,   light=44)                grey-256="#6c6c6c"
    :header-args+: :var         dark-grey=aoh-gen-color(hue=228, sat=7,   light=29)           dark-grey-256="#5f5f87"
    :header-args+: :var    very-dark-grey=aoh-gen-color(hue=228, sat=7,   light=12)      very-dark-grey-256="#1c1c1c"
    :header-args+: :var               red=aoh-gen-color(hue=352, sat=81,  light=58)                 red-256="#d75f5f"
    :header-args+: :var           red-dim=aoh-gen-color(hue=352, sat=60,  light=58)             red-dim-256="#d75f5f"
    :header-args+: :var           red-int=aoh-gen-color(hue=360, sat=90,  light=58)             red-int-256="#ff5f5f"
    :header-args+: :var            orange=aoh-gen-color(hue=25,  sat=86,  light=55)              orange-256="#ff8700"
    :header-args+: :var        orange-dim=aoh-gen-color(hue=25,  sat=60,  light=60)          orange-dim-256="#d7875f"
    :header-args+: :var        orange-int=aoh-gen-color(hue=25,  sat=86,  light=65)          orange-int-256="#ff875f"
    :header-args+: :var            yellow=aoh-gen-color(hue=50,  sat=74,  light=61)              yellow-256="#d7d75f"
    :header-args+: :var        yellow-dim=aoh-gen-color(hue=50,  sat=74,  light=31)          yellow-dim-256="#878700"
    :header-args+: :var        yellow-int=aoh-gen-color(hue=50,  sat=100, light=61)          yellow-int-256="#ffd75f"
    :header-args+: :var             green=aoh-gen-color(hue=107, sat=40,  light=57)               green-256="#87af5f"
    :header-args+: :var         green-int=aoh-gen-color(hue=120, sat=50,  light=57)           green-int-256="#5fd75f"
    :header-args+: :var         green-dim=aoh-gen-color(hue=107, sat=30,  light=50)           green-dim-256="#87af5f"
    :header-args+: :var              blue=aoh-gen-color(hue=196, sat=64,  light=58)                blue-256="#5fafd7"
    :header-args+: :var          blue-dim=aoh-gen-color(hue=200, sat=44,  light=58)            blue-dim-256="#5fafaf"
    :header-args+: :var          blue-int=aoh-gen-color(hue=220, sat=84,  light=64)            blue-int-256="#5f87ff"
    :header-args+: :var            purple=aoh-gen-color(hue=313, sat=32,  light=60)              purple-256="#af87af"
    :header-args+: :var        purple-dim=aoh-gen-color(hue=313, sat=32,  light=70)          purple-dim-256="#d787af"
    :header-args+: :var        purple-int=aoh-gen-color(hue=313, sat=40,  light=60)          purple-int-256="#af5faf"
    :header-args+: :var         turquoise=aoh-gen-color(hue=165, sat=70,  light=65)           turquoise-256="#5fd7d7"
    :header-args+: :var     turquoise-dim=aoh-gen-color(hue=165, sat=60,  light=85)       turquoise-dim-256="#afffd7"
    :header-args+: :var     turquoise-int=aoh-gen-color(hue=165, sat=80,  light=50)       turquoise-int-256="#00d7af"
    :header-args+: :var             black=aoh-gen-color(hue=240, sat=6,   light=14)               black-256="#262626"
    :header-args+: :var         black-dim=aoh-gen-color(hue=240, sat=10,  light=20)           black-dim-256="#00005f"
    :header-args+: :var         black-int=aoh-gen-color(hue=240, sat=6,   light=0)            black-int-256="#000000"
    :header-args+: :var             white=aoh-gen-color(hue=0,   sat=100, light=100)              white-256="#ffffff"
    :header-args+: :var line-highlight-bg=aoh-gen-color(hue=228, sat=7,   light=21)   line-highlight-bg-256="#303030"
    :header-args+: :var   extra-dark-grey=aoh-gen-color(hue=228, sat=7,   light=10)     extra-dark-grey-256="#00005f"
    :header-args+: :var             debug=aoh-gen-color(hue=198, sat=91,  light=13)               debug-256="#00005f"
    :header-args+: :var rainbow-delimeters-colors=(list "#E6B422" "#C70067" "#00A960" "#FC7482")
    :END:

    #+BEGIN_SRC emacs-lisp :tangle "early-init.el" :results silent
      (defface aoh-very-light-grey `((,tru (:foreground ,very-light-grey)) (,cls (:foreground ,very-light-grey-256))) "Face containing fg color very-light-grey from [[https://github.com/mohkale/an-old-hope-theme][an-old-hope-theme]].")
      (defface aoh-light-grey      `((,tru (:foreground ,light-grey))      (,cls (:foreground ,light-grey-256)))      "Face containing fg color light-grey from [[https://github.com/mohkale/an-old-hope-theme][an-old-hope-theme]].")
      (defface aoh-grey            `((,tru (:foreground ,grey))            (,cls (:foreground ,grey-256)))            "Face containing fg color grey from [[https://github.com/mohkale/an-old-hope-theme][an-old-hope-theme]].")
      (defface aoh-dark-grey       `((,tru (:foreground ,dark-grey))       (,cls (:foreground ,dark-grey-256)))       "Face containing fg color dark-grey from [[https://github.com/mohkale/an-old-hope-theme][an-old-hope-theme]].")
      (defface aoh-very-dark-grey  `((,tru (:foreground ,very-dark-grey))  (,cls (:foreground ,very-dark-grey-256)))  "Face containing fg color very-dark-grey from [[https://github.com/mohkale/an-old-hope-theme][an-old-hope-theme]].")
      (defface aoh-red             `((,tru (:foreground ,red))             (,cls (:foreground ,red-256)))             "Face containing fg color red from [[https://github.com/mohkale/an-old-hope-theme][an-old-hope-theme]].")
      (defface aoh-red-dim         `((,tru (:foreground ,red-dim))         (,cls (:foreground ,red-dim-256)))         "Face containing fg color red-dim from [[https://github.com/mohkale/an-old-hope-theme][an-old-hope-theme]].")
      (defface aoh-red-int         `((,tru (:foreground ,red-int))         (,cls (:foreground ,red-int-256)))         "Face containing fg color red-int from [[https://github.com/mohkale/an-old-hope-theme][an-old-hope-theme]].")
      (defface aoh-orange          `((,tru (:foreground ,orange))          (,cls (:foreground ,orange-256)))          "Face containing fg color orange from [[https://github.com/mohkale/an-old-hope-theme][an-old-hope-theme]].")
      (defface aoh-orange-dim      `((,tru (:foreground ,orange-dim))      (,cls (:foreground ,orange-dim-256)))      "Face containing fg color orange-dim from [[https://github.com/mohkale/an-old-hope-theme][an-old-hope-theme]].")
      (defface aoh-orange-int      `((,tru (:foreground ,orange-int))      (,cls (:foreground ,orange-int-256)))      "Face containing fg color orange-int from [[https://github.com/mohkale/an-old-hope-theme][an-old-hope-theme]].")
      (defface aoh-yellow          `((,tru (:foreground ,yellow))          (,cls (:foreground ,yellow-256)))          "Face containing fg color yellow from [[https://github.com/mohkale/an-old-hope-theme][an-old-hope-theme]].")
      (defface aoh-yellow-dim      `((,tru (:foreground ,yellow-dim))      (,cls (:foreground ,yellow-dim-256)))      "Face containing fg color yellow-dim from [[https://github.com/mohkale/an-old-hope-theme][an-old-hope-theme]].")
      (defface aoh-yellow-int      `((,tru (:foreground ,yellow-int))      (,cls (:foreground ,yellow-int-256)))      "Face containing fg color yellow-int from [[https://github.com/mohkale/an-old-hope-theme][an-old-hope-theme]].")
      (defface aoh-green           `((,tru (:foreground ,green))           (,cls (:foreground ,green-256)))           "Face containing fg color green from [[https://github.com/mohkale/an-old-hope-theme][an-old-hope-theme]].")
      (defface aoh-green-int       `((,tru (:foreground ,green-int))       (,cls (:foreground ,green-int-256)))       "Face containing fg color green-int from [[https://github.com/mohkale/an-old-hope-theme][an-old-hope-theme]].")
      (defface aoh-green-dim       `((,tru (:foreground ,green-dim))       (,cls (:foreground ,green-dim-256)))       "Face containing fg color green-dim from [[https://github.com/mohkale/an-old-hope-theme][an-old-hope-theme]].")
      (defface aoh-blue            `((,tru (:foreground ,blue))            (,cls (:foreground ,blue-256)))            "Face containing fg color blue from [[https://github.com/mohkale/an-old-hope-theme][an-old-hope-theme]].")
      (defface aoh-blue-dim        `((,tru (:foreground ,blue-dim))        (,cls (:foreground ,blue-dim-256)))        "Face containing fg color blue-dim from [[https://github.com/mohkale/an-old-hope-theme][an-old-hope-theme]].")
      (defface aoh-blue-int        `((,tru (:foreground ,blue-int))        (,cls (:foreground ,blue-int-256)))        "Face containing fg color blue-int from [[https://github.com/mohkale/an-old-hope-theme][an-old-hope-theme]].")
      (defface aoh-purple          `((,tru (:foreground ,purple))          (,cls (:foreground ,purple-256)))          "Face containing fg color purple from [[https://github.com/mohkale/an-old-hope-theme][an-old-hope-theme]].")
      (defface aoh-purple-dim      `((,tru (:foreground ,purple-dim))      (,cls (:foreground ,purple-dim-256)))      "Face containing fg color purple-dim from [[https://github.com/mohkale/an-old-hope-theme][an-old-hope-theme]].")
      (defface aoh-purple-int      `((,tru (:foreground ,purple-int))      (,cls (:foreground ,purple-int-256)))      "Face containing fg color purple-int from [[https://github.com/mohkale/an-old-hope-theme][an-old-hope-theme]].")
      (defface aoh-turquoise       `((,tru (:foreground ,turquoise))       (,cls (:foreground ,turquoise-256)))       "Face containing fg color turquoise from [[https://github.com/mohkale/an-old-hope-theme][an-old-hope-theme]].")
      (defface aoh-turquoise-dim   `((,tru (:foreground ,turquoise-dim))   (,cls (:foreground ,turquoise-dim-256)))   "Face containing fg color turquoise-dim from [[https://github.com/mohkale/an-old-hope-theme][an-old-hope-theme]].")
      (defface aoh-turquoise-int   `((,tru (:foreground ,turquoise-int))   (,cls (:foreground ,turquoise-int-256)))   "Face containing fg color turquoise-int from [[https://github.com/mohkale/an-old-hope-theme][an-old-hope-theme]].")
      (defface aoh-black           `((,tru (:foreground ,black))           (,cls (:foreground ,black-256)))           "Face containing fg color black from [[https://github.com/mohkale/an-old-hope-theme][an-old-hope-theme]].")
      (defface aoh-black-dim       `((,tru (:foreground ,black-dim))       (,cls (:foreground ,black-dim-256)))       "Face containing fg color black-dim from [[https://github.com/mohkale/an-old-hope-theme][an-old-hope-theme]].")
      (defface aoh-black-int       `((,tru (:foreground ,black-int))       (,cls (:foreground ,black-int-256)))       "Face containing fg color black-int from [[https://github.com/mohkale/an-old-hope-theme][an-old-hope-theme]].")
      (defface aoh-white           `((,tru (:foreground ,white))           (,cls (:foreground ,white-256)))           "Face containing fg color white from [[https://github.com/mohkale/an-old-hope-theme][an-old-hope-theme]].")
    #+END_SRC

    #+BEGIN_SRC emacs-lisp :results silent
      (custom-theme-set-faces 'an-old-hope
      ;;; defaults
       `(default
          ((,tru (:foreground ,very-light-grey :background ,very-dark-grey))
           ;; let the terminal inherit its background from the terminals default.
           (,cls (:foreground ,very-light-grey-256))))

       `(italic ((,cls (:italic t))))
       `(shadow ((,cls (:foreground ,light-grey))))
       `(hl-line ((,cls (:background ,line-highlight-bg))))

       `(error   ((,cls (:background ,red        :distant-foreground ,red        :foreground ,very-dark-grey :inherit bold))))
       `(success ((,cls (:background ,green-int  :distant-foreground ,green-int  :foreground ,very-dark-grey :inherit bold))))
       `(warning ((,cls (:background ,yellow-int :distant-foreground ,yellow-int :foreground ,very-dark-grey :inherit bold))))

       `(cursor ((,cls (:background ,blue))))
       `(custom-button ((,cls (:background ,very-dark-grey
                               :foreground ,very-light-grey
                               :box (:line-width (2 . 2) :style released-button)))))

      ;;; font-lock - Syntax Highlighting Colors
       `(font-lock-builtin-face ((,cls (:foreground ,blue))))
       `(font-lock-comment-face ((,cls (:foreground ,grey))))
       `(font-lock-keyword-face ((,cls (:foreground ,green-256))))
       `(font-lock-constant-face ((,cls (:foreground ,red-256 :inherit bold))))
       `(font-lock-function-name-face ((,cls (:foreground ,yellow-int-256))))
       `(font-lock-negation-char-face ((,cls (:foreground ,red-256))))
       `(font-lock-preprocessor-face ((,cls (:inherit font-lock-keyword-face))))
       `(font-lock-string-face ((,cls (:foreground ,blue))))
       `(font-lock-doc-face ((t (:foreground ,blue))))
       `(font-lock-type-face ((,cls (:foreground ,red-256))))
       `(font-lock-variable-name-face ((,cls (:foreground ,yellow-int-256))))
       `(font-lock-warning-face ((,gui (:underline (:style wave :color ,red)))
                                 ;; (,cls (:background ,yellow-int
                                 ;;        :foreground ,very-dark-grey
                                 ;;        :distant-foreground ,yellow-int
                                 ;;        :underline nil :inherit bold))
                                 (,cls (:underline (:style wave :color ,yellow)))))

      ;;; Tree sitter
       ;; An alternative to `font-lock-mode' with considerably more diverse highlighting.
       `(tree-sitter-hl-face:number ((,cls (:inherit default))))
       `(tree-sitter-hl-face:doc ((,cls (:inherit font-lock-comment-face))))
       `(tree-sitter-hl-face:property ((,cls (:inherit default))))
       `(tree-sitter-hl-face:tag ((,cls (:inherit font-lock-type-face))))
       `(tree-sitter-hl-face:attribute ((,cls (:inherit font-lock-variable-name-face))))
       `(tree-sitter-hl-face:attribute ((,cls (:inherit font-lock-variable-name-face))))
       `(tree-sitter-hl-face:constructor ((,cls (:inherit font-lock-function-name-face))))
       `(tree-sitter-hl-face:method.call ((,cls (:inherit font-lock-function-name-face))))
       `(tree-sitter-hl-face:function.call ((,cls (:inherit font-lock-function-name-face))))
       `(tree-sitter-hl-face:string.special ((,cls (:inherit font-lock-string-face))))
       `(tree-sitter-hl-face:type.parameter ((,cls (:inherit font-lock-variable-name-face))))
       `(tree-sitter-hl-face:function.special ((,cls (:inherit font-lock-builtin-face))))
       `(tree-sitter-hl-face:variable.special ((,cls (:inherit (;italic
                                              font-lock-variable-name-face)))))

       ;; Fringe has a different background on the GUI and the terminal, because the default bg
       ;; on the terminal is taken from the terminal bg. We apply a variant color for the fringe
       ;; on the terminal to make it distinctive.
       `(fringe
          ((,gui (:background ,black))
           (,cls (:background ,very-dark-grey))))
       `(header-line ((,cls (:background ,very-dark-grey :foreground ,blue))))
       `(line-number ((,cls (:foreground ,very-light-grey :inherit fringe))))
       `(line-number-current-line ((,cls (:foreground ,blue :inherit line-number))))
       `(vertical-border ((,cls (:foreground ,grey))))
       `(internal-border ((,cls (:foreground ,white :background ,white))))
       `(completions-annotations ((,cls (:inherit shadow))))
       `(minibuffer-prompt ((,cls (:foreground ,yellow-256 :weight bold))))
       `(minibuffer-depth-indicator ((,cls (:foreground ,yellow-256 :weight bold))))
       `(tooltip ((,cls (:background ,dark-grey :foreground ,very-light-grey))))

       `(highlight ((,cls (:foreground ,very-dark-grey :background ,blue :inherit bold))))

       `(region ((,cls (:background ,dark-grey :weight bold))))
       `(secondary-selection ((,cls (:inherit region))))

       ;; face for current search match. exiting now takes you to it.
       `(isearch ((,cls (:background ,blue-int :inherit bold))))
       `(isearch-fail ((,cls (:inherit compilation-mode-line-fail))))
       `(match ((,cls (:foreground ,green-int))))
       ;; face for matches other than the current match
       `(evil-ex-search ((,cls (:background ,purple :inherit bold))))
       `(lazy-highlight ((,cls (:background ,blue-int :foreground ,black-dim))))

       `(separator-line ((,cls (:foreground ,blue))))

       ;; delimiter colors just taken from https://github.com/gastrodia/rainbow-brackets
       ;; colors 5-9 just recycle 1-4, maybe come up with more.
       `(rainbow-delimiters-depth-1-face ((,cls (:foreground ,(nth 0 rainbow-delimeters-colors)))))
       `(rainbow-delimiters-depth-2-face ((,cls (:foreground ,(nth 1 rainbow-delimeters-colors)))))
       `(rainbow-delimiters-depth-3-face ((,cls (:foreground ,(nth 2 rainbow-delimeters-colors)))))
       `(rainbow-delimiters-depth-4-face ((,cls (:foreground ,(nth 3 rainbow-delimeters-colors)))))
       `(rainbow-delimiters-depth-5-face ((,cls (:foreground ,(nth 0 rainbow-delimeters-colors)))))
       `(rainbow-delimiters-depth-6-face ((,cls (:foreground ,(nth 1 rainbow-delimeters-colors)))))
       `(rainbow-delimiters-depth-7-face ((,cls (:foreground ,(nth 2 rainbow-delimeters-colors)))))
       `(rainbow-delimiters-depth-8-face ((,cls (:foreground ,(nth 3 rainbow-delimeters-colors)))))
       `(rainbow-delimiters-depth-9-face ((,cls (:foreground ,(nth 0 rainbow-delimeters-colors)))))

       ;; hyperlinks and path links
       `(link ((,cls (:foreground ,blue))))
       `(link-visited ((,cls (:foreground ,turquoise :inherit link))))

       `(hl-todo ((,cls (:foreground ,yellow-int :inherit bold))))

      ;;; modeline
       `(mode-line ((,cls
                     (:background ,very-light-grey :foreground ,very-dark-grey
                      :box (:line-width 1 :color ,very-light-grey :style nil)))))
       `(mode-line-inactive ((,cls
                              (:weight light :foreground "grey80" :background "grey30"
                               :box (:line-width 1 :color "grey40" :style nil)))))
       `(mode-line-highlight ((,cls (:inherit italic))))

       `(+mode-line-linter-info ((,cls (:foreground ,green-dim))))
       `(+mode-line-linter-warning ((,cls (:foreground ,blue-dim))))
       `(+mode-line-linter-error ((,cls (:foreground ,red-dim))))

       `(+mode-line-evil-normal-state  ((,cls (:inherit mode-line :foreground ,very-dark-grey  :background "DarkGoldenrod2"))))
       `(+mode-line-evil-emacs-state   ((,cls (:inherit mode-line :foreground ,very-dark-grey  :background ,blue))))
       `(+mode-line-evil-insert-state  ((,cls (:inherit mode-line :foreground ,very-dark-grey  :background ,green-int-256))))
       `(+mode-line-evil-motion-state  ((,cls (:inherit mode-line :foreground ,very-dark-grey  :background ,purple-int))))
       `(+mode-line-evil-visual-state  ((,cls (:inherit mode-line :foreground ,very-light-grey :background ,dark-grey))))
       `(+mode-line-evil-operator-state ((,cls (:weight normal :inherit (error spaceline-evil-motion)))))
       `(+mode-line-evil-replace-state ((,cls (:inherit mode-line :foreground ,very-dark-grey  :background ,turquoise-int))))
       `(+mode-line-buffer-minor-mode ((,cls (:foreground ,purple))))

       `(+mode-line-host-face ((,cls (:inherit +mode-line-host-face))))

       `(compilation-mode-line-fail ((,cls (:inherit bold :foreground ,red-dim))))
       `(compilation-mode-line-run  ((,cls (:inherit bold :foreground ,orange-dim))))
       `(compilation-mode-line-exit  ((,cls (:inherit bold :foreground ,green-dim))))

      ;;; magit
       `(magit-reflog-merge ((,cls (:foreground ,green-int))))
       `(magit-reflog-amend ((,cls (:foreground ,purple-int))))
       `(magit-reflog-other ((,cls (:foreground ,turquoise-int))))
       `(magit-reflog-reset ((,cls (:foreground ,red-int))))
       `(magit-reflog-remote ((,cls (:foreground ,turquoise-int))))
       `(magit-reflog-rebase ((,cls (:foreground ,purple-int))))
       `(magit-reflog-commit ((,cls (:foreground ,green-int))))
       `(magit-reflog-checkout ((,cls (:foreground ,blue-int))))
       `(magit-reflog-cherry-pick ((,cls (:foreground ,green-int))))

       `(magit-mode-line-process-error ((,cls (:inherit compilation-mode-line-fail))))

      ;;; powerline
       `(powerline-active1 ((,gui (:background ,black :foreground ,very-light-grey :inherit mode-line))
                            (,cls (:foreground ,very-light-grey :inherit default))))
       `(powerline-active2 ((,cls (:inherit powerline-active1))))
       `(powerline-inactive1 ((,cls (:box (:line-width 1 :color "grey40" :style nil)
                                     :inherit powerline-active1))))

      ;;; spaceline
       `(spaceline-evil-normal  ((,cls (:inherit mode-line :foreground ,very-dark-grey  :background "DarkGoldenrod2"))))
       `(spaceline-evil-insert  ((,cls (:inherit mode-line :foreground ,very-dark-grey  :background ,green-int-256))))
       `(spaceline-evil-emacs   ((,cls (:inherit mode-line :foreground ,very-dark-grey  :background ,blue))))
       `(spaceline-evil-replace ((,cls (:inherit mode-line :foreground ,very-dark-grey  :background ,turquoise-int))))
       `(spaceline-evil-visual  ((,cls (:inherit mode-line :foreground ,very-light-grey :background ,dark-grey))))
       `(spaceline-evil-motion  ((,cls (:inherit mode-line :foreground ,very-dark-grey  :background ,purple-int))))
       `(spaceline-minibuffer   ((,cls (:inherit mode-line :foreground ,very-dark-grey  :background ,blue))))
       `(spaceline-evil-operator ((,cls (:weight normal :inherit (error spaceline-evil-motion)))))

       `(spaceline-flycheck-error   ((,cls (:inherit compilation-mode-line-fail))))
       `(spaceline-flycheck-warning ((,cls (:inherit compilation-mode-line-run))))
       `(spaceline-flycheck-info    ((,cls (:inherit compilation-mode-line-exit))))

      ;;; doom-modeline
       `(doom-modeline-evil-normal-state ((,cls (:inherit +mode-line-evil-normal-state))))
       `(doom-modeline-evil-emacs-state ((,cls (:inherit +mode-line-evil-emacs-state))))
       `(doom-modeline-evil-insert-state ((,cls (:inherit +mode-line-evil-insert-state))))
       `(doom-modeline-evil-motion-state ((,cls (:inherit +mode-line-evil-motion-state))))
       `(doom-modeline-evil-visual-state ((,cls (:inherit +mode-line-evil-visual-state))))
       `(doom-modeline-evil-operator-state ((,cls (:inherit +mode-line-evil-operator-state))))
       `(doom-modeline-evil-replace-state ((,cls (:inherit +mode-line-evil-replace-state))))

       `(doom-modeline-buffer-modified ((,cls (:inherit doom-modeline-buffer-file))))
       `(doom-modeline-lsp-error ((,cls (:inherit compilation-mode-line-fail))))
       `(doom-modeline-lsp-warning ((,cls (:inherit compilation-mode-line-run))))
       `(doom-modeline-lsp-success ((,cls ())))
       `(doom-modeline-lsp-running ((,cls (:foreground ,blue-int :inherit compilation-mode-line-run))))

       `(doom-modeline-urgent ((,cls (:inherit compilation-mode-line-fail))))
       `(doom-modeline-debug ((,cls (:inherit compilation-mode-line-run))))
       `(doom-modeline-info ((,cls (:inherit compilation-mode-line-exit))))

       `(doom-modeline-buffer-minor-mode ((,cls (:inherit +mode-line-buffer-minor-mode))))
       `(doom-modeline-panel ((,cls (:foreground ,very-dark-grey))))

      ;;; magit/forge
       `(forge-post-author ((,cls (:inherit magit-log-author))))

      ;;; evil
       `(vimish-fold-overlay ((,cls (:background ,dark-grey :foreground ,green))))

      ;;; flycheck
       `(flycheck-fringe-info    ((,cls (:foreground ,green-int  :inherit fringe))))
       `(flycheck-fringe-warning ((,cls (:foreground ,yellow-int :inherit fringe))))
       `(flycheck-fringe-error   ((,cls (:foreground ,red-int    :inherit fringe))))

       `(flycheck-info      ((,cls (:underline (:style wave :color ,green)))))
       `(flycheck-warning   ((,cls (:underline (:style wave :color ,yellow)))))
       `(flycheck-duplicate ((,cls (:underline (:style wave :color ,orange)))))
       `(flycheck-error     ((,gui (:underline (:style wave :color ,red)))
                             (,cls (:background ,red-256 :inherit error))))

      ;;; flymake
       `(flymake-note    ((,cls (:underline (:style wave :color ,green)))))
       `(flymake-warning ((,cls (:underline (:style wave :color ,yellow)))))
       `(flymake-error   ((,gui (:underline (:style wave :color ,red)))
                          (,cls (:background ,red-256 :inherit error))))

      ;;; flyspell
       `(flyspell-duplicate ((,cls (:foreground ,orange-dim :underline t))))
       `(flyspell-incorrect ((,cls (:foreground ,red-dim :underline t))))

      ;;; jinx
       `(jinx-misspelled ((,cls (:foreground ,red-dim :underline t))))

      ;;; avy
       `(avy-background-face ((,cls (:foreground ,grey))))

       ;; Same as the corresponding evil faces but adjusted using [[https://webaim.org/resources/contrastchecker/][contrast-checker]].
       `(avy-lead-face   ((,cls (:background "#B00303" :foreground ,white))))
       `(avy-lead-face-0 ((,cls (:background "#124FCA" :foreground ,white))))
       `(avy-lead-face-1 ((,cls (:background ,very-light-grey :foreground ,very-dark-grey))))
       `(avy-lead-face-2 ((,cls (:background "#883A77" :foreground ,white))))

       ;; Not avy, but avy like enough
       `(selectrum-quick-keys-highlight ((,cls (:background "#B00303" :foreground ,white))))
       `(selectrum-quick-keys-match ((,cls (:background "#124FCA" :foreground ,white))))
       `(vertico-quick1 ((,cls (:background "#B00303" :foreground ,white))))
       `(vertico-quick1 ((,cls (:background "#124FCA" :foreground ,white))))

       `(frog-menu-border ((,cls (:background ,white :foreground ,white))))
       `(frog-menu-posframe-background-face ((,cls (:background ,very-dark-grey))))

      ;;; company, corfu - intellisense
       `(company-tooltip-mouse ((,cls (:foreground ,turquoise-int))))
       `(company-template-field ((,cls (:foreground ,turquoise-int))))

       ;; scrollbar
       `(company-tooltip-scrollbar-track ((,cls (:background ,line-highlight-bg :foreground ,very-light-grey))))
       `(company-tooltip-scrollbar-thumb ((,cls (:background ,red               :foreground ,dark-grey))))
       `(corfu-bar                       ((,cls (:background ,red               :foreground ,dark-grey))))

       `(company-preview ((,cls (:foreground ,blue-int :weight bold :inherit hl-line))))
       `(company-preview-common ((,cls (:inherit company-preview))))
       `(company-preview-search ((,cls (:foreground ,orange-int :weight normal :inherit company-preview))))

       ;; NOTE tooltip is the drop down menu which shows up when multiple results exist
       `(company-tooltip ((,cls (:background ,black-dim :inherit tooltip))))
       `(corfu-default ((,cls (:background ,black-dim :inherit tooltip))))
       `(corfu-completions-common-part+ ((,cls (:foreground ,red :inherit (company-tooltip bold)))))
       `(company-tooltip-common ((,cls (:foreground ,red :inherit (company-tooltip bold)))))
       `(company-tooltip-search ((,cls (:foreground ,blue-int :inherit company-tooltip))))
       `(company-tooltip-search-common ((,cls (:inherit company-tooltip-search))))

       `(company-tooltip-selection ((,cls (:background ,dark-grey :inherit company-tooltip))))
       `(corfu-current ((,cls (:background ,dark-grey :inherit corfu-default))))
       `(company-tooltip-common-selection ((,cls (:background ,dark-grey :inherit company-tooltip-common))))
       `(company-tooltip-search-selection ((,cls (:background ,dark-grey :inherit (company-tooltip-search)))))

       `(company-icon+ ((,cls (:weight normal :inherit company-tooltip))))
       `(company-current-icon+ ((,cls (:weight normal :inherit company-tooltip-selection))))

       ;; NOTE annotations are extra information in the tooltip
       `(company-tooltip-annotation ((,cls (:weight bold :foreground ,grey))))
       `(company-tooltip-annotation-selection ((,cls (:inherit company-tooltip-annotation))))
       `(corfu-annotations ((,cls (:weight bold :foreground ,grey))))

       `(popup ((,cls (:inherit popup-face))))

      ;;;; custom mode variants
      ;;; whitespace-mode
       `(whitespace-space ((,cls (:foreground ,dark-grey))))
       `(trailing-whitespace ((,cls (:background ,dark-grey))))

      ;;; auto-highlight-symbol mode
       ;; NOTE: distant foreground is meaningless here because the faces are always given priority.
       `(ahs-definition-face ((,cls (:background ,blue-dim :distant-foreground ,blue-dim :foreground ,dark-grey))))
       `(ahs-edit-mode-face ((,cls (:background ,red-dim :distant-foreground ,red-dim :foreground ,very-light-grey))))
       `(ahs-face ((,cls (:background ,very-light-grey :foreground ,black :inherit bold))))
       `(ahs-plugin-whole-buffer-face ((,cls (:background ,blue :distant-foreground ,green :foreground ,black))))
       `(ahs-plugin-bod-face ((,cls (:background ,blue-int :distant-foreground ,blue-int :foreground ,black))))
       `(ahs-plugin-defalt-face ((,cls (:background ,orange-dim :distant-foreground ,orange-dim :foreground ,black))))
       `(ahs-warning-face ((,cls (:foreground ,red-dim))))

      ;;; compilation mode
       `(compilation-line-number ((,cls (:foreground ,yellow))))
       `(compilation-column-number ((,cls (:inherit font-lock-doc-face))))

       ;; NOTE also represents value count in mode line
       `(compilation-error ((,cls (:foreground ,red :inherit bold))))
       `(compilation-info ((,cls (:foreground ,green-int :inherit bold))))
       `(compilation-warning ((,cls (:foreground ,orange-int :inherit bold))))

      ;;; markdown-mode
       `(markdown-code-face ((,cls (:inherit default))))

      ;;; anzu
       `(anzu-mode-line ((,cls (:foreground ,very-dark-grey :inherit bold))))
       `(anzu-mode-line-no-match ((,cls (:foreground ,red-int :inherit bold))))

      ;;; hydra-posframe
       ;; for some reason... if hydra-posframe-face inherits default, internal border won't work
       `(hydra-posframe-face ((,cls (:background ,very-dark-grey :foreground ,very-light-grey))))
       `(hydra-posframe-border-face ((,cls (:inherit internal-border))))

      ;;; selectrum
       ;; TODO: Remove non-prescient variants
       `(selectrum-current-candidate ((,cls (:foreground ,very-dark-grey :weight bold :inherit highlight))))
       `(selectrum-primary-highlight ((,cls (:background "#555555"))))
       `(selectrum-prescient-current-candidate ((,cls (:foreground ,very-dark-grey :weight bold :inherit highlight))))
       `(selectrum-prescient-primary-highlight ((,cls (:background "#555555"))))
       `(selectrum-secondary-highlight ((,cls (:background "#7777FF")))) ;; #8A498A
       `(selectrum-mouse-highlight ((,cls (:underline t))))

      ;;; consult
       `(consult-async-finished ((,cls (:inherit compilation-info))))
       `(consult-async-running ((,cls (:inherit compilation-warning))))
       `(consult-async-failed ((,cls (:inherit compilation-error))))
       `(consult-narrow-indicator ((,cls (:foreground ,blue :weight bold))))
       `(consult-preview-match ((,cls (:foreground ,blue-int :weight bold))))
       `(consult-highlight-match ((,cls (:foreground ,red-int :weight bold))))
       `(consult-line-number-wrapped ((,cls (:inherit (warning consult-line-number-prefix)))))

      ;;; orderless
       ;; Match face were taken from ivys default match faces.
       `(orderless-match-face-0 ((,cls (:background "#555555"))))
       `(orderless-match-face-1 ((,cls (:background "#777777"))))
       `(orderless-match-face-2 ((,cls (:background "#7777ff"))))
       `(orderless-match-face-3 ((,cls (:background "#8a498a"))))
       `(completions-common-part ((,cls (:background "#555555"))))
       `(completions-first-difference ((,cls )))

      ;;; swiper
       `(swiper-match-face-1 ((,cls (:background "#555555"))))
       `(swiper-match-face-2 ((,cls (:background "#777777"))))
       `(swiper-match-face-3 ((,cls (:background "#7777ff"))))
       `(swiper-match-face-4 ((,cls (:background "#8a498a"))))

      ;;; ivy
       ;; by default, it seems if ivy-highlight-face has its own spec, it'll interfere
       ;; with the face of ivy-current-match. Which'll make it harder to tell which
       ;; candidate is the current candidate.
       ;;
       ;; If ivy-highlight-face just inherits another face, then when both it and
       ;; ivy-current-match are applied to a string, ivy-current-match will override
       ;; ivy-highlight-face. Thus, this.
       `(ivy-actual-highlight-face ((,cls (:foreground ,very-dark-grey :background ,turquoise
                                           :distant-foreground ,turquoise :inherit bold))))
       `(ivy-highlight-face ((,cls (:inherit ivy-actual-highlight-face))))
       `(ivy-current-match ((,cls (:foreground ,very-dark-grey :weight bold :inherit highlight))))

      ;;; org-mode
       `(org-link ((,cls (:inherit (link bold)))))
       `(org-footnote ((,cls (:foreground ,blue))))
       `(org-tag ((,cls (:foreground ,purple-int :inherit bold))))
       `(org-code ((,cls (:inherit shadow))))

      ;;; org-ref
       ;; All of these have their own distinct look and feel, but honestly
       ;; their just links so distinguishing them is unnecessary in most cases.
       `(org-ref-ref-face ((,cls (:inherit org-link))))
       `(org-ref-cite-face ((,cls (:foreground ,green-int :inherit org-link))))
       `(org-ref-label-face ((,cls (:inherit org-link))))
       `(org-ref-acronym-face ((,cls (:inherit org-link))))
       `(org-ref-glossary-face ((,cls (:inherit org-link))))

       ;; Overridden by hl-todo-keyword-faces
       `(org-todo ((,cls (:foreground ,purple-int :inherit bold))))
       `(org-done ((,cls (:foreground ,green-int :inherit bold))))

       `(org-upcoming-deadline ((,cls (:foreground ,red-dim))))
       `(org-warning ((,cls (:foreground ,orange :inherit bold))))
       `(org-scheduled-today ((,cls (:foreground ,green-int))))
       `(org-block-begin-line ((,cls (:background "royalblue4" :distant-foreground "royalblue4" :foreground "steelblue1" :extend t))))
       `(org-meta-line ((,cls (:inherit font-lock-comment-face))))

       `(org-block ((,cls (:background ,extra-dark-grey :extend t))))
       `(org-document-title ((,cls (:foreground ,white :height 1.3 :inherit bold))))

      ;;; rust[ic]-mode
       `(rustic-compilation-warning ((,cls (:inherit compilation-warning))))
       `(rustic-compilation-info ((,cls (:inherit compilation-info))))
       `(rustic-compilation-error ((,cls (:inherit compilation-error))))
       `(rustic-compilation-column ((,cls (:inherit compilation-column-number))))
       `(rustic-compilation-line ((,cls (:inherit compilation-line-number))))

      ;;; dired
       `(dired-symlink ((,cls (:foreground ,blue))))
       `(dired-special ((,cls (:foreground ,purple))))

       `(diredfl-dir-name ((,cls (:inherit dired-directory))))
       `(diredfl-file-name ((,cls (:inherit default))))
       `(diredfl-dir-heading ((,cls (:inherit dired-header))))
       `(diredfl-number ((,cls (:inherit font-lock-function-name-face))))
       `(diredfl-date-time ((,cls (:inherit shadow))))
       `(diredfl-file-suffix ((,cls (:inherit default))))
       `(diredfl-symlink ((,cls (:inherit font-lock-doc-face))))
       `(diredfl-deletion ((,cls (:inherit error))))
       `(diredfl-deletion-file-name ((,cls (:foreground ,red :inherit bold))))
       `(diredfl-flag-mark ((,cls (:inherit diredfl-deletion-file-name))))
       `(diredfl-flag-mark-line ((,cls (:foreground ,yellow))))
       `(diredfl-no-priv ((,cls (:inherit shadow))))
       `(diredfl-read-priv ((,cls (:foreground ,red))))
       `(diredfl-write-priv ((,cls (:foreground ,green))))
       `(diredfl-exec-priv ((,cls (:foreground ,yellow))))
       `(diredfl-rare-priv ((,cls (:foreground ,blue :inherit bold))))
       `(diredfl-dir-priv ((,cls (:foreground ,yellow :inherit bold))))

      ;;; neotree
       `(neo-dir-link-face ((,cls (:inherit dired-directory))))
       `(neo-root-dir-face ((,cls (:inherit dired-header))))
       `(neo-banner-face ((,cls (:inherit dired-header))))
       `(neo-header-face ((,cls (:inherit dired-header))))
       `(neo-vc-added-face ((,cls (:inherit green-int))))
       `(neo-vc-edited-face ((,cls (:inherit purple-int))))
       `(neo-vc-ignored-face ((,cls (:inherit shadow))))

      ;;; dashboard
       `(dashboard-text-banner ((,cls (:foreground ,orange-int))))
       `(dashboard-items-face ((,cls (:weight normal))))
       `(dashboard-no-items-face ((,cls (:weight normal))))
       ;;`(dashboard-heading ((,cls (:inherit (bold dashboard-navigator) :underline (:style wave :color ,blue)))))
       `(dashboard-heading ((,cls (:inherit (bold dashboard-navigator)))))

      ;;; eshell-prompt-extras
       `(epe-remote-face ((,cls (:foreground ,turquoise))))
       `(epe-venv-face ((,cls (:foreground ,purple))))

      ;;; typescript
       `(typescript-primitive-face ((,cls (:inherit font-lock-type-face))))

      ;;; latex
       `(font-latex-sedate-face       ((,cls (:inherit font-lock-keyword-face))))
       `(font-latex-sectioning-0-face ((,cls (:inherit font-lock-function-name-face))))
       `(font-latex-sectioning-1-face ((,cls (:inherit font-lock-function-name-face))))
       `(font-latex-sectioning-2-face ((,cls (:inherit font-lock-function-name-face))))
       `(font-latex-sectioning-3-face ((,cls (:inherit font-lock-function-name-face))))
       `(font-latex-sectioning-4-face ((,cls (:inherit font-lock-function-name-face))))
       `(font-latex-sectioning-5-face ((,cls (:inherit font-lock-function-name-face))))

      ;;; man/woman
       `(Man-underline  ((,cls (:foreground ,green-int :inherit bold))))
       `(Man-overstrike ((,cls (:foreground ,red :inherit bold))))
       `(woman-addition ((,cls (:foreground ,purple))))
       `(woman-bold     ((,cls (:foreground ,red :inherit bold))))
       `(woman-italic   ((,cls (:foreground ,green))))
       `(woman-unknown  ((,cls (:inherit error))))

      ;;; vline
       `(vline ((,cls (:inherit hl-line))))
       `(vline-visual ((,cls (:inherit hl-line))))

      ;;; marginalia
       `(marginalia-documentation ((,cls (:inherit font-lock-comment-face))))
       `(marginalia-on ((,cls (:foreground ,green-int :inherit bold))))
       `(marginalia-off ((,cls (:foreground ,red :inherit bold))))

      ;;; embark
       `(embark-target ((,cls (:foreground ,blue :inherit bold))))
       `(embark-keybinding ((,cls (:foreground ,green-int :inherit bold))))

      ;;; term
       `(term-color-black ((,cls (:foreground ,dark-grey :background ,dark-grey))))
       `(term-color-red ((,cls (:foreground ,red :background ,red))))
       `(term-color-cyan ((,cls (:foreground ,turquoise :background ,turquoise))))
       `(term-color-blue ((,cls (:foreground ,blue :background ,blue))))
       `(term-color-white ((,cls (:foreground ,white :background ,white))))
       `(term-color-green ((,cls (:foreground ,green :background ,green))))
       `(term-color-yellow ((,cls (:foreground ,yellow :background ,yellow))))
       `(term-color-magenta ((,cls (:foreground ,purple :background ,purple))))

      ;;; logview-mode
       `(logview-pulse ((,cls (:inherit highlight))))
       `(logview-highlight ((,cls (:inherit evil-ex-lazy-highlight))))
       `(logview-level-trace ((,cls (:inherit font-lock-comment-face))))
       `(logview-level-debug ((,cls (:inherit font-lock-function-name-face))))
       `(logview-level-information ((,cls (:inherit font-lock-keyword-face))))
       `(logview-level-warning ((,cls (:foreground ,orange-int))))
       `(logview-level-error ((,cls (:inherit font-lock-type-face))))

       `(logview-trace-entry ((,cls (:inherit default))))
       `(logview-debug-entry ((,cls (:inherit default))))
       `(logview-information-entry ((,cls (:inherit default))))
       `(logview-warning-entry ((,cls (:inherit default))))
       `(logview-error-entry ((,cls (:inherit default))))

      ;;; GNU info
       `(info-title-1 ((,cls (:inherit (font-lock-function-name-face bold)))))
       `(info-title-2 ((,cls (:foreground ,red-256))))
       `(info-title-3 ((,cls (:foreground ,green-256))))
       `(info-title-4 ((,cls (:foreground ,green-256))))
       `(info-quoted ((,cls (:inherit shadow))))
       `(info-menu-star ((,cls (:foreground ,red))))
       `(info-xref ((,cls (:inherit (link bold)))))
       `(info-xref-visited ((,cls (:underline ,blue :inherit (link bold)))))
       `(info-menu-header ((,cls (:inherit info-header-node)))) ;; not sure what the difference is

      ;;; xref
       `(xref-match ((,cls (:foreground ,red :inherit bold))))

      ;;; help
       `(help-key-binding ((,cls (:foreground ,turquoise))))

      ;;; mu4e/gnus/message/notmuch
       `(message-header-name ((,cls (:inherit font-lock-keyword-face))))
       `(message-header-other ((,cls (:inherit default))))
       `(message-header-to ((,cls (:inherit (bold font-lock-function-name-face)))))
       `(message-header-subject ((,cls (:inherit font-lock-type-face))))
       `(message-header-cc ((,cls (:inherit font-lock-string-face))))
       `(message-header-xheader ((,cls (:foreground ,turquoise-int))))
       `(message-header-newsgroups ((,cls (:inherit (italic message-header-other)))))
       `(message-separator ((,cls (:inherit shadow))))
       `(message-mml ((,cls (:foreground ,turquoise-int))))
       ;; message-cited-text-1
       ;; message-cited-text-2
       ;; message-cited-text-3
       ;; message-cited-text-4

       `(mu4e-highlight-face ((,cls (:inherit (bold font-lock-string-face)))))

       `(gnus-header-from ((,cls (:inherit message-header-to))))
       `(gnus-header-name ((,cls (:inherit message-header-name))))
       `(gnus-header-content ((,cls (:inherit message-header-other))))
       `(gnus-header-subject ((,cls (:inherit message-header-subject))))
       `(gnus-header-newsgroups ((,cls (:inherit message-header-newsgroups))))

       `(notmuch-tag-face ((,cls (:inherit font-lock-keyword-face))))
       `(notmuch-tag-unread ((,cls (:inherit font-lock-type-face))))
       `(notmuch-tag-flagged ((,cls (:inherit font-lock-string-face))))
       `(notmuch-tree-match-tag-face ((,cls (:inherit (bold notmuch-tag-face)))))
       `(notmuch-crypto-signature-bad ((,cls (:inherit error :weight normal))))
       `(notmuch-crypto-signature-unknown ((,cls (:foreground ,yellow))))
       `(notmuch-crypto-signature-good ((,cls (:foreground ,green-int))))
       `(notmuch-crypto-signature-good-key ((,cls (:inherit notmuch-crypto-signature-good))))
       `(notmuch-crypto-decryption ((,cls (:inherit notmuch-crypto-signature-good))))
       `(notmuch-search-matching-authors ((,cls (:inherit notmuch-tree-match-author-face))))

      ;;; tab-bar
       ;; `(tab-bar)
       `(tab-bar-tab ((,cls (:foreground ,white :inherit default))))
       `(tab-bar-tab-inactive ((,cls (:foreground ,very-light-grey :background ,black-dim))))
       `(tab-bar-separator ((,cls (:foreground ,blue :inherit tab-bar-tab))))
       `(tab-bar-inactive-separator ((,cls (:foreground "black" :inherit tab-bar-tab-inactive))))

       ;; (tab-bar-tab-ungrouped)
       ;; (tab-bar-tab-group-current)
       ;; (tab-bar-tab-group-inactive)

      ;;; git-gutter
       `(git-gutter:added ((,cls (:foreground ,green-int :inherit bold))))
       `(git-gutter:deleted ((,cls (:foreground ,red-int :inherit bold))))
       `(git-gutter:modified ((,cls (:foreground ,purple-int :inherit bold))))
       `(git-gutter:modified ((,cls (:foreground ,light-grey :inherit bold))))
       `(git-gutter:separator ((,cls (:foreground ,turquoise :inherit bold))))

       `(diff-hl-change ((,cls (:foreground ,purple-int :inherit bold))))
       `(diff-hl-insert ((,cls (:foreground ,green-int :inherit bold))))
       `(diff-hl-delete ((,cls (:foreground ,red-int :inherit bold))))

      ;;; sh-mode
       `(sh-heredoc ((,cls (:inherit font-lock-string-face))))

      ;;; diffs
       ;; These were taken directly from `magit'.
       `(diff-added   ((,cls (:foreground "#ddffdd" :background "#335533" :extend t)))) ;; `magit-diff-added'
       `(diff-removed ((,cls (:foreground "#ffdddd" :background "#553333" :extend t)))) ;; `magit-diff-removed'
       `(diff-changed ((,cls (:foreground "#ffddff" :background "#553355" :extend t)))) ;; Adapted from `magit-diff-base'

       `(magit-diff-base ((,cls (:inherit diff-changed))))
       `(diff-refine-changed ((,cls (:background "#aa22aa"))))

      ;;; evil-traces
       ;; Taken almost directly from `evil-traces-use-diff-faces'.
       ;; Except diff-changed has been converted to the default-face.
       `(evil-traces-change           ((t (:inherit diff-removed))))
       `(evil-traces-copy-preview     ((t (:inherit diff-added))))
       `(evil-traces-copy-range       ((t (:inherit default))))
       `(evil-traces-delete           ((t (:inherit diff-removed))))
       `(evil-traces-global-match     ((t (:inherit diff-added))))
       `(evil-traces-global-range     ((t (:inherit default))))
       `(evil-traces-join-indicator   ((t (:inherit diff-added))))
       `(evil-traces-join-range       ((t (:inherit default))))
       `(evil-traces-move-preview     ((t (:inherit diff-added))))
       `(evil-traces-move-range       ((t (:inherit diff-removed))))
       `(evil-traces-normal           ((t (:inherit default))))
       `(evil-traces-shell-command    ((t (:inherit default))))
       `(evil-traces-substitute-range ((t (:inherit default))))
       `(evil-traces-yank             ((t (:inherit default))))
       `(evil-ex-substitute-matches
         ((t (:inherit diff-removed :foreground unspecified :background unspecified))))
       `(evil-ex-substitute-replacement
         ((t (:inherit diff-added :foreground unspecified :background unspecified))))

      ;; ansi-colors
       ;; TODO: On terminal frames inherit from terminal instead of custom colors.
       `(ansi-color-red ((,cls (:foreground ,red :background ,red))))
       `(ansi-color-blue ((,cls (:foreground ,blue :background ,blue))))
       `(ansi-color-cyan ((,cls (:foreground ,turquoise :background ,turquoise))))
       `(ansi-color-black ((,cls (:foreground ,black :background ,black))))
       `(ansi-color-green ((,cls (:foreground ,green :background ,green))))
       `(ansi-color-white ((,cls (:foreground ,white :background ,white))))
       `(ansi-color-yellow ((,cls (:foreground ,yellow :background ,yellow))))
       `(ansi-color-magenta ((,cls (:foreground ,purple :background ,purple))))

       `(ansi-color-bright-red ((,cls (:foreground ,red-int :background ,red-int))))
       `(ansi-color-bright-blue ((,cls (:foreground ,blue-int :background ,blue-int))))
       `(ansi-color-bright-cyan ((,cls (:foreground ,turquoise-int :background ,turquoise-int))))
       `(ansi-color-bright-black ((,cls (:foreground ,dark-grey :background ,dark-grey))))
       `(ansi-color-bright-green ((,cls (:foreground ,green-int :background ,green-int))))
       `(ansi-color-bright-white ((,cls (:foreground ,white :background ,white))))
       `(ansi-color-bright-yellow ((,cls (:foreground ,yellow-int :background ,yellow-int))))
       `(ansi-color-bright-magenta ((,cls (:foreground ,purple-int :background ,purple-int))))

      ;; vundo
       `(vundo-highlight ((,cls (:foreground ,blue :inherit bold))))

      ;; transient
       `(transient-key-noop ((,cls (:inherit (shadow transient-key)))))
       `(transient-key-exit ((,cls (:inherit (font-lock-type-face transient-key)))))
       `(transient-key-stay ((,cls (:inherit transient-key))))
       `(transient-key-return ((,cls (:inherit (font-lock-keyword-face transient-key)))))

       ;; outline
       ;; `(outline-1 ((,cls (:inherit font-lock-function-name-face))))
       ;; `(outline-2 ((,cls (:inherit font-lock-variable-name-face))))
       ;; `(outline-3 ((,cls (:inherit font-lock-keyword-face))))
       ;; `(outline-4 ((,cls (:inherit font-lock-comment-face))))
       ;; `(outline-5 ((,cls (:inherit font-lock-type-face))))
       `(outline-6 ((,cls (:inherit font-lock-constant-face :weight normal))))
       ;; `(outline-7 ((,cls (:inherit font-lock-builtin-face))))
       ;; `(outline-8 ((,cls (:inherit font-lock-string-face))))
       )

      (custom-theme-set-variables 'an-old-hope
        `(hl-todo-keyword-faces
          '(("TODO"        . ,red)
            ("NEXT"        . ,red)
            ("RANT"        . ,red)
            ("SEE"         . ,red)
            ("SKIP"        . ,red)
            ("LATE"        . ,red)
            ("THEM"        . ,purple)
            ("PROG"        . ,blue-int)
            ("OKAY"        . ,blue-int)
            ("DONT"        . ,green-int)
            ("FAIL"        . ,red)
            ("DONE"        . ,green-int)
            ("NOTE"        . ,yellow-int)
            ("WAIT"        . ,yellow-int)
            ("KLUDGE"      . ,yellow-int)
            ("HACK"        . ,yellow-int)
            ("TEMP"        . ,yellow-int)
            ("FIXME"       . ,orange)
            ("WARN"        . ,orange)
            ("XXX+"        . ,orange)
            ("\\?\\?\\?+"  . ,orange)))
        `(ansi-color-names-vector
          '(,dark-grey ,red ,green ,yellow ,blue ,purple ,turquoise ,white))
        `(xterm-color-names
          [,dark-grey ,red ,green ,yellow ,blue ,purple ,turquoise ,white])
        `(xterm-color-names-bright
          [,dark-grey ,red ,green ,yellow ,blue ,purple ,turquoise ,white])
        `(rustic-ansi-faces
          [,dark-grey ,red ,green ,yellow ,blue ,purple ,turquoise ,white])
        )
    #+END_SRC

    #+BEGIN_SRC emacs-lisp
       (provide-theme 'an-old-hope)
    #+END_SRC

* Appendix                                                          :ARCHIVE:
  This trailing section just defines some file-local variables for this file.

# Local Variables:
# jinx-local-words: "Anzu Args AucTeX Avy Awk Biblatex Bibtex Bufler Bundler CMake CPerl Caddy Citar Combobulate Comint Contrib Dape Dired Dockerfile Doct Ebib Ediff Eglot Emmet Eshell Fu GGTags GNUs Golang HLedger Hledger Ibuffer Imenu Impl KMacro Keymaps LaTeX Lua Magit Makefile Matchit Miniedit Multiedit Nim Notmuch Omnisharp Orderless Orgit Orglink PLSense PList Pandoc Paredit Pdftools Pre Py Rebase Restclient SMerge Separedit Solargraph Spacemacs TODOs ToC Toml Tooltip Ui VScode Vdiff Verilog Vimish Winman Xopen alist anzu apheleia backends bufler calc comint crontab dired docstring dotfiles eglot el eldoc elisp eln emacs emojify eyebrowse flycheck flyspell frontend gamegrid gitlink gopls gpg gud hl hotfuzz init ipsum lorem lsp matcher minibuffer notmuch olivetti orderless paren plist prettyfy proced ql rc recentf skeletor sudo todo unpackaged url utils uuidgen vdiff vertico vlc vline whitespace winum yasnippet"
# End:
