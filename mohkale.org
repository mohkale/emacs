# -*- mode: org; encoding: utf-8 -*-
#+TITLE: mohkale.org

#+PROPERTY: header-args    :tangle yes


* Initial Config
** Mohkale
sets up mohkale utility functions. This includes, but is not limited to:
- functions to jump to package files
- shortcuts to re-evaluate this file
- configure the root directory for package files

#+begin_src emacs-lisp
  ;; -*- lexical-binding: t -*-

  (defun join-dirs (root &rest dirs)
    "Joins a series of directories together, like Python's os.path.join,
    (dotemacs-joindirs \"/tmp\" \"a\" \"b\" \"c\") => /tmp/a/b/c"

    (if (not dirs)
        root
      (apply 'join-dirs
            (expand-file-name (car dirs) root)
            (cdr dirs))))

  (defvar mohkale-root (join-dirs dotspacemacs-directory "mohkale")
    "root directory for mohkale package scripts")

  (defmacro mohkale/defun-mohkale-find-package-file (file-type file-path &optional root)
    (or root (setq root mohkale-root))

    `(defun ,(intern (concat "mohkale/find-" (symbol-name file-type) "-file")) ()
      (interactive)
      (if (not (file-directory-p ,root))
          (error (format "mohkale::error() : mohkale root path not found: %s" ,root))
        (find-file (join-dirs ,root ,file-path)))))

  ;; (defun-mohkale-find-package-file key-bindings "key-bindings.el")
  ;; (defun-mohkale-find-package-file startup "startup.el")
  ;; (defun-mohkale-find-package-file methods "methods.el")
  (mohkale/defun-mohkale-find-package-file capture-notes "org/notes.org")
  (mohkale/defun-mohkale-find-package-file org-university "org/university.org")

  (let* ((config-file "mohkale.org")
         (config-parent-directory dotspacemacs-directory)
         (full-config-file (join-dirs config-parent-directory config-file)))
    (mohkale/defun-mohkale-find-package-file configuration "mohkale.org" dotspacemacs-directory)

    (defun mohkale/eval-configuration-file ()
      (interactive)
      (org-babel-load-file full-config-file))

    (defun mohkale/build-configuration-file ()
      (interactive)
      (org-babel-tangle-file full-config-file)))

  (spacemacs/set-leader-keys
    "fec" 'mohkale/find-configuration-file
    "feb" 'mohkale/build-configuration-file
    "fer" 'mohkale/eval-configuration-file
    "oon" 'mohkale/find-capture-notes-file
    "oou" 'mohkale/find-org-university-file)
#+end_src

** Frame
#+begin_src emacs-lisp
  (setq frame-title-format
        ;; sets the title string displayed on the frame above. Format of the command is
        ;; a printf like string. Wrap any code you want evaluated conditionally into a list
        ;; and if the first value of that list is a string, it will be evaluated. You can
        ;; include variables anywhere in the string, including sublists, but no functions.
        ;;
        ;; See the format guide here: https://www.emacswiki.org/emacs/FrameTitle
        `(,(user-login-name) "@" ,(system-name) " [%*] %m" major-mode (buffer-file-name " : %f")))
#+end_src

** Variables
#+begin_src emacs-lisp :tangle yes
  (dolist (path '("~/.spacemacs.d"))
    (add-to-list 'load-path path t))

  (setq powerline-default-separator 'slant
        visible-bell 1 ;; no annoying rings
    )
#+end_src
** Post Init
#+begin_src emacs-lisp
  (let* ((self-path "~/.spacemacs.d/mohkale.org")
         (self-name (file-name-sans-extension self-path))
         (compiled-path (concat self-name ".el")))
    (eval-after-load compiled-path
      (progn
        (require 'smartparens-config)
        (require 'server)
        (require 'evil-vimish-fold)
        (require 'evil-surround)
        (require 'evil-matchit)
        (require 'auto-highlight-symbol)
        (require 'vlc-rc)
        (unless (server-running-p) (server-start)))))
#+end_src
** Global
#+begin_src emacs-lisp
  (setq-default sp-escape-quotes-after-insert nil)

  ;; minibuffer can open other minibuffers
  (setq enable-recursive-minibuffers t)

  ;;; filter completion popup depending on items
  ;; cycle completions when <= val options
  (setq completion-cycle-threshold 7)

  ;;; delete line also removes \n
  (setq kill-whole-line t)

  ;;; set evil configurations
  ;; allow moving back to end of previous line
  ;; or forward to beginning of next line
  (setq evil-cross-lines t)

  ;;; speed up cursor movements
  ;; not really sure what this does
  (setq auto-window-vscroll nil)

  ;;; enable tooltip documentation
  (setq auto-completion-enable-help-tooltip t)
#+end_src
** Indentation
Prefer spaces over tabs and prefer an indentation of 4 by default.

#+begin_src emacs-lisp :tangle yes
  (setq-default indent-tabs-mode nil)
  (setq c-default-style "stroustrup")

  (let ((preferred-indent 4))
    (setq c-basic-offset preferred-indent)

    (use-package ruby-mode
      :init
      (setq ruby-indent-level preferred-indent))

    (use-package js
      :config
      ;;; coffeescript
      (setq coffee-tab-width preferred-indent)
      ;;; javascript-mode
      (setq javascript-indent-level preferred-indent)
      (setq js-indent-level preferred-indent))

    (use-package js2-mode
      :config
      (setq js2-basic-offset preferred-indent))

    (use-package web-mode
      :init
      (setq css-indent-offset preferred-indent)
      :config
      (setq web-mode-markup-indent-offset preferred-indent)
      (setq web-mode-css-indent-offset preferred-indent)
      (setq web-mode-code-indent-offset preferred-indent)))
#+end_src

Allow underscores in words for the following language modes:

#+NAME: underscore-supported-modes
- c++
- c
- python
- markdown
- lisp
- sh

#+begin_src emacs-lisp :var modes=underscore-supported-modes :results none
  (dolist (mode modes)
    (let ((mode-name (concat (car mode) "-mode-hook")))
      (add-hook (intern mode-name) #'(lambda () (modify-syntax-entry ?_ "w")))))
#+end_src

** Aliases
#+begin_src emacs-lisp :tangle yes
(defalias 'evil-jump-item 'evilmi-jump-items)
#+end_src
** Bindings
default bindings in global keymap

#+begin_src emacs-lisp :tangle yes
  (dolist (binding-tuple `(("C-M-|" . shell-command-on-buffer)
                           ("C-/"   . toggle-comment-at-point)

                           ("C-M-h" . left-word)
                           ("C-M-l" . right-word)

                           ("M-j"   . custom-insert-line-below)
                           ("M-k"   . custom-insert-line-above)
                           ("C-q"   . quit-window)

                           ("C-j" . newline-and-indent)
                           ("C-k" . evil-join-backwards)

                           ("C-`"   . helm-resume)))
    (let ((key-binding (car binding-tuple))
          (key-command (cdr binding-tuple)))
      (global-set-key (kbd key-binding) key-command)))

  (define-key help-mode-map "q" 'quit-window)
#+end_src
** Startup Enhancements
Gotto go faster! Gotto go faster! Gotto go faster! 

#+begin_src emacs-lisp :tangle yes
  ;; ;; make garbage collector less invasive
  ;; (setq gc-cons-threshold 402653184
  ;;       gc-cons-percentage 0.6)

  ;; ;; not needed at startup
  ;; (defvar default-file-name-handler-alist file-name-handler-alist)
  ;; (setq file-name-handler-alist nil)

  ;; (add-hook 'after-init-hook
  ;;            (lambda ()
  ;;              (message "startup hook")
  ;;              ;; reset optimasation changes
  ;;              (setq gc-cons-threshold 16777216
  ;;                    gc-cons-percentage 0.1)

  ;;              (setq file-name-handler-alist default-file-name-handler-alist)))
#+end_src
* Spacemacs
** Layouts
*** Image Dired
A layout to use spacemacs like an image viewer. Layout will be setup with image thumbnails in a left aligned window and the actual image will be shown in the right window.

#+begin_src emacs-lisp :tangle yes
  (defvar dired-slideshow|thumbnail-column-count 2
    "number of columns of thumbnails shown on each row")

  (defvar dired-slideshow|dedicate-image-windows t
    "whether to dedicate thumbnail and display windows")

  ;; NOTE keep setq because defvar doesn't work for repeated calls
  ;; (setq dired-slideshow|thumbnail-column-count 3)
  ;; (setq dired-slideshow|dedicate-image-windows t)

  (spacemacs|define-custom-layout "@dired-slideshow"
    :binding "s"
    :body
    (kill-all-windows-and-return-to-home) ; splitting issues with layout

    (let* ((thumbnails-buffer-name "*image-dired*")
            (display-buffer-name "*image-dired-display-image*")

            ;; only load when buffer doesn't exist and user allows it
            (load-directory (and (not (get-buffer thumbnails-buffer-name))
                                (y-or-n-p "would you like to load an image directory")))

            (thumbnails-buffer (get-buffer-create thumbnails-buffer-name))
            (display-buffer (get-buffer-create display-buffer-name)))
      (split-window-right) ; left window is for thumbnails, right for display

      (let* ((thumbnails-window (selected-window))
              (display-window    (window-right thumbnails-window)))
        (if load-directory (call-interactively 'image-dired))

        (persp-add-buffer `(,thumbnails-buffer ,display-buffer))

        ;; setup thumbnail window
        (with-selected-window thumbnails-window
          (switch-to-buffer thumbnails-buffer)

          (unless (eq major-mode 'image-dired-thumbnail-mode)
            (image-dired-thumbnail-mode))

          ;; set number of columns in view
          (let ((image-dired-thumbs-per-row dired-slideshow|thumbnail-column-count))
            (image-dired-line-up))

          (let* ((thumbnail-window-width (* image-dired-thumb-width dired-slideshow|thumbnail-column-count))
                  (delta-width (- thumbnail-window-width (window-pixel-width))))
            (unless (> (abs delta-width) (window-pixel-width))
              (window-resize thumbnails-window delta-width t nil t)))

          (window-preserve-size thumbnails-window t)
          (and dired-slideshow|dedicate-image-windows (spacemacs/toggle-current-window-dedication)))

        ;; setup display window
        (with-selected-window display-window
          (switch-to-buffer display-buffer)

          (and dired-slideshow|dedicate-image-windows (spacemacs/toggle-current-window-dedication))

          (unless (eq major-mode 'image-dired-display-image-mode)
            (image-dired-display-image-mode)))

        (select-window thumbnails-window)

        (message "completed creation of slideshow layout"))))
#+end_src

* Methods
** File Hooks/Handlers
carriage returns in files are EVIL!!! avoid them like the plague :P.

#+begin_src emacs-lisp
  (defun no-junk-please-were-unixish ()
    (let ((coding-str (symbol-name buffer-file-coding-system)))
      (when (string-match "-\\(?:dos\\|mac\\)$" coding-str)
        (set-buffer-file-coding-system 'unix))))

  (add-hook 'find-file-hooks 'no-junk-please-were-unixish)
#+end_src
** Buffer Jumping
#+begin_src emacs-lisp :tangle yes
(defun goto-messages-buffer ()
  "switches to messages buffer"
  (interactive)
  (switch-to-buffer (messages-buffer)))
#+end_src
** Window Manipulation
#+begin_src emacs-lisp :tangle yes
(defun force-set-all-visible-windows-dedication (&optional dedicate)
  "allows you to set the dedication of all visible windows
dedicate if truthy, will result in all windows recieving a dedication.
if falsy, all windows will have their dedication removed"
  (interactive "P")
  (and dedicate (setq dedicate t))   ; rationalise value as bool
  (or  dedicate (setq dedicate nil)) ; rationalise value as nil

  (dolist (window (window-list))
    (if (not (eq dedicate (window-dedicated-p window)))
        (with-selected-window window
          (set-window-dedicated-p window dedicate)))))

#+end_src
** Text
*** Querying
functions for querying information about the text at point or retrieve other relevent information.

#+begin_src emacs-lisp :tangle yes
(defun line-width (char-pos)
  "returns the number of columns on the line at char-pos"
  (interactive (if current-prefix-arg
                   (list current-prefix-arg)
                 (list (point))))
  (save-excursion
    (if (not (eql char-pos (point)))
      (goto-char char-pos))
    (let ((line-width (max (- (line-end-position) (line-beginning-position) 1) 0)))
      (if (called-interactively-p 'any)
          (message (format "Line Width: %03d" line-width)))

      line-width)))

(defun column-number (point)
  "returns the column number at point"
  (interactive "")
  (save-excursion
    (goto-char point)
    (current-column)))

(defun point-to-coordinates (&optional point)
  "convert a point to an XY coordinate alist"
  (or point (setq point (point)))
  `(,(line-number-at-pos point) . ,(column-number point)))

(defun line-empty-p (&optional point)
  (save-excursion
    (and point (goto-char point))
    (beginning-of-line)
    (looking-at "[[:space:]]*$")))

(defun list-faces (&optional point)
  (interactive "d")
  (or point (setq point (point)))
  (let ((faces (remq nil
                     `(,(get-char-property point 'read-face-name)
                       ,(get-char-property point 'face)
                       ,(plist-get (text-properties-at point) 'face)))))
    (and (called-interactively-p 'any) (message (format "%s" faces)))
    faces))
#+end_src
*** Formatting
manipulate chunks of text, such as leading indentation or sequential padding.

#+begin_src emacs-lisp :tangle yes
(defun pad-line-with-char-to-length (desired-length char)
  "appends char as many times as required from cursor position"
  (interactive "Nline length: \nccharacter: \nd")
  (barf-if-buffer-read-only) ; can't pad read only buffer

  (save-excursion
    (let* ((line-char-count (line-width (point))))
      (if (>= line-char-count desired-length)
          (error (format "line of length %03d is already larger than desired: %03d" line-char-count desired-length))
        (insert (make-string (- desired-length line-char-count) char))))))

(defun pad-line-with-space-to-length (desired-length)
  "invokes pad-line-with-char-to-length with char as space"
  (interactive "Nline length: \n")
  (pad-line-with-char-to-length desired-length ?\s))

;; (defun remove-indentation-spaces ()
;;   "remove TAB-WIDTH spaces from the beginning of this line"
;;   (interactive)
;;   (if (save-excursion (re-search-backward "[^ \t]" (line-beginning-position) t))
;;       (delete-backward-char 1)
;;     (indent-rigidly (line-beginning-position) (line-end-position) (- tab-width))))

(defun remove-all-trailing-whitespace (start end)
  "removes all trailing whitespace from every line in buffer"
  (interactive (if (region-active-p)
                   (list (region-beginning) (region-end))
                 (list (point-min) (point-max))))

  (barf-if-buffer-read-only) ; can't remove from current buffer

  (save-excursion
    (goto-char end) ; start from end so delete can work forward

    (while (and (> (point) start)
                (re-search-backward " +$" nil t))
      (delete-region (point) (line-end-position)))))
#+end_src

comment regions of text or by default, the current line.

#+begin_src emacs-lisp :tangle yes
(defun toggle-comment-at-point (start end)
  "toggle comment on line or region
pass a prefix argument to bulk toggle across multiple lines.
This function will always comment the line your point is on,

Prefix Behaviour:
| Prefix Range | Behaviour                                       |
|--------------+-------------------------------------------------|
| 0            | current line only                               |
| >1           | current line and upto PREFIX lines after  point |
| <1           | current line and upto PREFIX lines before point |

This behaviour is exactly mapped to the relative lines numbers emacs
can display, ergo adjust howfar you wish to comment using the linum
fringe."
  (interactive (let ((prefix current-prefix-arg))
                 (if (region-active-p)
                     ;; always use region when region available
                     (list (region-beginning) (region-end))
                   (if (or (not prefix)
                           (listp prefix) ;; regular prefix
                           (zerop prefix))
                       ;; no prefix, comment current line only
                       (list (line-beginning-position) (line-end-position))
                     ;; prefix given, use it to determine comment region
                     (let* ((prefix-positive (> prefix 0))
                            (current-pos (if prefix-positive
                                             (line-beginning-position)
                                           (line-end-position))))
                       (save-excursion
                         (evil-next-line prefix)
                         (if prefix-positive
                             `(,current-pos ,(line-end-position))
                           `(,(line-beginning-position) ,current-pos))))))))
  (comment-or-uncomment-region start end))
#+end_src

line insertion and joining functions.

#+begin_src emacs-lisp :tangle yes
(defun custom-insert-line (&optional prefix)
  "inserts a line above or below point

if a prefix argument of 0 or more (or none) is given, the
line is inserted below the point. Otherwise its inserted
above the point.

The absolute value of the prefix determines how many lines
are inserted.

Eg: A prefix of:
  * nil - inserts a single line below the cursor
  * -1  - inserts a single line above the cursor
  * 0   - inserts a single line below the cursor
  * 1   - inserts a single line below the cursor
  * -10 - inserts 10 lines above the cursor
  * 10  - inserts 10 lines below the cursor"
  (interactive "P")

  (save-excursion
    (let ((move-arg (if (or (not prefix)
                            (>= prefix 0))
                        nil ; if prefix xor prefix >= 0
                      0)))
      (move-end-of-line move-arg)
      (open-line (max 1 (abs prefix))))))

(defun custom-insert-line-below (&optional prefix)
  (interactive "P")
  (custom-insert-line (abs (or prefix 1))))

(defun custom-insert-line-above (&optional prefix)
  (interactive "P")
  (custom-insert-line (- (abs (or prefix 1)))))

(defun evil-join-backwards (&optional prefix)
  "same as join line, except joins line immeadiately before point"
  (interactive "p")
  (let ((start nil)
        (end   nil))
    (if (evil-visual-state-p)
        (let ((range (evil-visual-range)))
          (setq start (nth 0 range))
          (setq end   (nth 1 range)))
      ;; not visual, calculate ranges
      (setq end (point))
        (save-excursion
          (forward-line (- (abs prefix)))
          (setq start (point))))
    ;; remove excursion block if you wan't to
    ;; reallign point to start of line on join
    (save-excursion
      (if (line-empty-p start)
          ;; when joining onto an empty line
          ;; maintain leading whitespace
          (evil-join-whitespace start end)
        ;; otherwise trim to single space
        (evil-join start end)))))
#+end_src
** Buffers, Windows & Frames
#+begin_src emacs-lisp :tangle yes
(defun kill-this-buffer-and-window-maybe ()
  "kills the currently open buffer and the window if another is open"
  (interactive)
  (let ((window-count (length (window-list))))
    (if (> window-count 1)
        (kill-buffer-and-window)
      (kill-this-buffer))))

(defun kill-all-windows-and-return-to-home ()
  "kills every other window and returns to spacemacs home"
  (interactive)
  (dolist (window (cdr (window-list)))
    ;; window-list starts with current window
    (delete-window window))
  (spacemacs/home))

(defun shell-command-on-buffer ()
  "Asks for a command and executes it in inferior shell with current buffer
as input."
  (interactive)
  (shell-command-on-region
   (point-min) (point-max)
   (read-shell-command "Shell command on buffer: ")))
#+end_src
** Layout & Perspective Interactions
#+begin_src emacs-lisp :tangle yes
(defun spacemacs//layout-contains-buffer-p (buffer)
  "returns true if the given buffer is in the current layout"
  (not (spacemacs//layout-not-contains-buffer-p buffer)))

(defun get-buffers-in-current-layout ()
  "returns all buffers tied to the current spacemacs layout"
  (seq-filter #'spacemacs//layout-contains-buffer-p (buffer-list)))

;; WARN this is insanely convoluted, turns out helm is tough :(
;; (defun helm-toggle-buffers-in-layout ()
;;   "use helm to select the buffers in your current layout"
;;   (interactive)
;;   (helm :sources helm-source-buffers-list
;;         :buffer "*Toggle Perspective Buffers*")
;;   )

(defun persp-add-current-buffer ()
  "adds current buffer to current perspective"
  (interactive)
  (persp-add-buffer (current-buffer)))

(defun persp-remove-current-buffer ()
  "removes current buffer from current persp"
  (interactive)
  (persp-remove-buffer (current-buffer)))

#+end_src

* Package Config
** bookmark
prioritise recently used bookmarks over just the default list.

#+begin_src emacs-lisp :tangle yes
  (use-package bookmark
    :config
    (defadvice bookmark-jump (after bookmark-jump activate)
      (let ((latest (bookmark-get-bookmark bookmark)))
        (setq bookmark-alist (delq latest bookmark-alist))
        (add-to-list 'bookmark-alist latest))))
#+end_src
** calendar
#+begin_src emacs-lisp :tangle yes
  (use-package calendar
    :config
    (evil-set-initial-state 'calendar-mode 'normal)

    (evil-define-key 'normal calendar-mode-map
      ;;; see also https://github.com/emacs-evil/evil-collection/blob/master/evil-collection-calendar.el
      ;; globally useful
      "q"  'calendar-exit
      "p"  'calendar-print-day-of-year
      "c"  'calendar-count-days-region
      "?"  'calendar-goto-info-node
      (kbd "C-r") 'calendar-redraw

      ;; jumpt to date
      "."  'calendar-goto-today
      "h"  'calendar-backward-day
      "j"  'calendar-forward-week
      "k"  'calendar-backward-week
      "l"  'calendar-forward-day
      "0"  'calendar-beginning-of-week
      "$"  'calendar-end-of-week
      "[[" 'calendar-backward-year
      "]]" 'calendar-forward-year
      "("  'calendar-beginning-of-month
      ")"  'calendar-end-of-month
      "{"  'calendar-backward-month
      "}"  'calendar-forward-month
      "/"  'calendar-goto-date

      (kbd "C-h") 'calendar-backward-month
      (kbd "C-l") 'calendar-forward-month
      (kbd "C-j") 'calendar-scroll-left-three-months
      (kbd "C-k") 'calendar-scroll-right-three-months

      ;; marking and unmarking
      "X"  'calendar-unmark
      "v"  'calendar-set-mark
      "x"  'calendar-mark-holidays

      ;; diary interaction
      "D"  'diary-view-other-diary-entries
      "d"  'diary-view-entries
      "m"  'diary-mark-entries
      "s"  'diary-show-all-entries))
#+end_src
** company
#+begin_src emacs-lisp :tangle yes
(use-package company
  :config
  (global-company-mode)
  :bind* (:map company-active-map
          ("C-1"       . company-complete-number)
          ("C-2"       . company-complete-number)
          ("C-3"       . company-complete-number)
          ("C-4"       . company-complete-number)
          ("C-5"       . company-complete-number)
          ("C-6"       . company-complete-number)
          ("C-7"       . company-complete-number)
          ("C-8"       . company-complete-number)
          ("C-9"       . company-complete-number)
          ("C-M-h"     . company-show-doc-buffer)
          ("C-h"       . company-quickhelp-manual-begin)
          ("C-j"       . company-select-next)
          ("C-k"       . company-select-previous)
          ("<C-tab>"   . company-complete-common-or-cycle)
          ("<tab>"     . company-complete-selection)
          ("C-:"       . helm-company)
          ("C-/"       . company-filter-candidates)

          :map company-search-map
          ("C-1"       . company-complete-number)
          ("C-2"       . company-complete-number)
          ("C-3"       . company-complete-number)
          ("C-4"       . company-complete-number)
          ("C-5"       . company-complete-number)
          ("C-6"       . company-complete-number)
          ("C-7"       . company-complete-number)
          ("C-8"       . company-complete-number)
          ("C-9"       . company-complete-number)
          ("C-j"       . company-select-next)
          ("C-k"       . company-select-previous)
          ("<tab>"     . company-complete-selection)
          ("C-v"       . company-search-toggle-filtering) ; show filtered/all
          ("ESC"       . company-search-abort)
          ("<escape>"  . company-search-abort)))
#+end_src
** compile
setup some custom bindings and assign a post compilation hook which will automatically kill the compilation window.

#+begin_src emacs-lisp :tangle yes
  (use-package compile
    :init
    (setq compilation-read-command nil)

    (defvar compilation-auto-kill-window 2
      "if non-nil, after a successfull compilation the compilation
    window, if open, will automatically be deleted. If set to
    a numerical value, window will be deleted after that many
    seconds.")

    (defvar compilation-dont-auto-kill-window-when '(warnings)
      "specify not to kill the window when warning, error or info given.
    a list which can take in any symbol from (errors infos warnings). If any
    of the corresponding notifications are encountered during compilation
    the window will not be autokilled.")
    :config
    (evil-define-key 'normal compilation-mode-map
      "0" 'evil-digit-argument-or-evil-beginning-of-line
      "h" 'evil-backward-char)

    (defun compilation-finish-function (buf str)
      "post compilation command hook
    uses the above two variables to determine whether or not (and when)
    to kill the compilation window. By default, no attempt to kill will
    take place when compilation-auto-kill-window is nil. Otherwise the
    window will be killed unless the compilation processes exit code is
    non 0.

    UPDATE added compilation-dont-auto-kill-window-when option so window
    kill can be aborted should any important information be given during
    the compilation process."
      (if (and compilation-auto-kill-window
              (null (string-match ".*exited abnormally.*" str)))
          ;; no abnormalities prepare to exit compilation window
          (progn
            (let ((compilation-buffer (get-buffer-create "*compilation*"))
                  (terminate-window t)) ; terminate it unless you find you shouldn't

              ;; check if config variable determines window should be kept open
              (if compilation-dont-auto-kill-window-when ; non nil
                  (progn
                    (unless (listp compilation-dont-auto-kill-window-when)
                      (error (format "compilation-dont-auto-kill-window-when failed listp")))

                    (let ((encountered-errors '()))
                      (and (member 'errors compilation-dont-auto-kill-window-when)
                          (> compilation-num-errors-found 0)
                          (add-to-list 'encountered-errors "errors"))
                      (and (member 'warnings compilation-dont-auto-kill-window-when)
                          (> compilation-num-warnings-found 0)
                          (add-to-list 'encountered-errors "warnings"))
                      (and (member 'infos compilation-dont-auto-kill-window-when)
                          (> compilation-num-infos-found 0)
                          (add-to-list 'encountered-errors "information"))
                      (if (> (length encountered-errors) 0)
                          (progn
                            (message "window kill suspended due to encountering: %s"
                                      (combine-and-quote-strings encountered-errors))
                            (setq terminate-window nil))))))

              (if terminate-window
                (if (numberp compilation-auto-kill-window)
                    (run-at-time (concat (number-to-string compilation-auto-kill-window)
                                        " sec")
                                  nil 'delete-windows-on compilation-buffer)
                  (delete-windows-on compilation-buffer)))))))

    ;; NOTE setq kept for debug purposes, defvar only works on first call
    ;; (setq compilation-auto-kill-window 2)
    ;; (setq compilation-dont-auto-kill-window-when '(warnings))
    (setq compilation-finish-function #'compilation-finish-function)

    :bind* (:map compilation-mode-map
            ("M-n" . compilation-next-error)
            ("M-N" . compilation-previous-error)
            ("M-j" . compilation-next-file)
            ("M-k" . compilation-previous-file)))
#+end_src
** dired
#+begin_src emacs-lisp :tangle yes
  (use-package dired
    :config
    (require 'dired-x)
    (setq ls-lisp-dirs-first t)
    (setq ls-lisp-use-insert-directory-program t)
    (setq dired-listing-switches "-laXhv --group-directories-first")
    (add-hook 'dired-mode-hook 'dired-omit-mode)
    (setq dired-omit-files (concat dired-omit-files
                                   "\\|^__pycache__$"
                                   "\\|^\\.pytest_cache$"
                                   "\\|^\\.sass-cache$"
                                   "\\|^\\.git$"
                                   "\\|^Pipfile"))
    :bind* (:map dired-mode-map
            ;; remove dir-tree from dired buffer
            ("C-M-d" . dired-kill-subdir) ; TODO consider switching to C-M-d, usse C-d to scroll
            ;; support vim like movement functions
            ("g"   . nil) ;; reassign to use as prefix
            ("gr"  . revert-buffer)
            ("gg"  . evil-goto-first-line)
            ("G"   . evil-goto-line)
            ("n"   . evil-search-next)
            ("N"   . evil-search-previous)
            ("M-n" . dired-next-marked-file)
            ("M-n" . dired-prev-marked-file)
            ("C-h" . dired-goto-min-subdir)
            ("C-j" . dired-next-subdir)
            ("M-j" . dired-next-dirline)
            ("M-k" . dired-prev-dirline)
            ("C-k" . dired-prev-subdir)
            ("C-l" . dired-goto-max-subdir)))
#+end_src
*** image-dired
#+begin_src emacs-lisp :tangle yes
(use-package image-dired
  :config
  ;;; fixed weird moves line, not thumbnail
  (defun image-dired-slideshow-step ()
    "Step to next file, if `image-dired-slideshow-times' has not been reached."
    (if (< image-dired-slideshow-count image-dired-slideshow-times)
        (progn
          (message "%s" (1+ image-dired-slideshow-count))
          (setq image-dired-slideshow-count (1+ image-dired-slideshow-count))
          (image-dired-display-next-thumbnail-original))
      (image-dired-slideshow-stop)))

  (evil-define-key '(normal visual) image-dired-thumbnail-mode-map
    "q" nil

    "h" 'image-dired-backward-image
    "j" 'image-dired-next-line
    "k" 'image-dired-previous-line
    "l" 'image-dired-forward-image
    (kbd "<left>")  'image-dired-forward-image
    (kbd "<right>") 'image-dired-previous-image

    "x" 'image-dired-delete-char
    "m" 'image-dired-mark-thumb-original-file
    "u" 'image-dired-unmark-thumb-original-file
    "c" 'image-dired-comment-thumbnail
    "d" 'image-dired-flag-thumb-original-file
    "D" 'image-dired-thumbnail-set-image-description
    "s" 'image-dired-slideshow-start
    "t" 'image-dired-toggle-mark-thumb-original-file
    "gr" 'image-dired-refresh-thumb
    "gc" 'image-dired-create-thumbs
    "gg" #'(lambda () (interactive) (evil-goto-first-line) (evil-beginning-of-line))
    "G"  #'(lambda () (interactive) (end-of-buffer) (image-dired-backward-image))

    (kbd "C-s") 'image-save ; NOTE originally was bound to o

    (kbd "<C-SPC>")    'image-dired-mark-thumb-original-file
    (kbd "<M-SPC>")    'image-dired-unmark-thumb-original-file

    (kbd "<C-return>") 'image-dired-display-current-image-full
    (kbd "<RET>")      'image-dired-display-thumbnail-original-image
    (kbd "C-l")        'image-dired-display-next-thumbnail-original
    (kbd "C-h")        'image-dired-display-previous-thumbnail-original
    ;;; column view aliases
    "J" 'image-dired-display-next-thumbnail-original
    "K" 'image-dired-display-previous-thumbnail-original
    ;; "o" 'image-dired-display-thumbnail-original-image
    "v" 'image-dired-display-thumbnail-original-image

    (kbd "<mouse-1>") 'image-dired-mouse-select-thumbnail
    (kbd "<mouse-2>") 'image-dired-mouse-display-image)

  (spacemacs/declare-prefix-for-mode 'image-dired-thumbnail-mode
    "mt" "tagging" "tag/describe images")
  (spacemacs/declare-prefix-for-mode 'image-dired-thumbnail-mode
    "me" "edit" "edit images")

  (spacemacs/set-leader-keys-for-major-mode 'image-dired-thumbnail-mode
    "g" 'image-dired-jump-original-dired-buffer
    "m" 'image-dired

    "td" 'image-dired-thumbnail-set-image-description
    "tt"  'image-dired-tag-thumbnail
    "tT"  'image-dired-tag-thumbnail-remove

    "el" 'image-dired-rotate-thumbnail-left
    "eL" 'image-dired-rotate-original-left
    "er" 'image-dired-rotate-thumbnail-right
    "eR" 'image-dired-rotate-original-right

    "." 'image-dired-track-original-file
    "o" 'image-dired-thumbnail-display-external

    ;; [re]set number of columns per row
    "s" 'image-dired-line-up-interactive
    "S" 'image-dired-line-up-dynamic)

  ;;; image view
  (evil-define-key 'normal image-dired-display-image-mode-map
    "f" 'image-dired-display-current-image-full
    "F" 'image-dired-display-current-image-sized
    "s" 'image-dired-display-current-image-sized

    "h" 'image-scroll-right
    "l" 'image-scroll-left
    "k" 'image-scroll-down
    "j" 'image-scroll-up
    ;; horizontal line by line movement
    (kbd "C-d") 'image-scroll-up
    (kbd "C-u") 'image-scroll-down
    (kbd "C-e") 'image-next-line
    (kbd "C-y") 'image-previous-line
    ;; Arrow Keys Alias hjkl
    (kbd "<left>")  'image-backward-hscroll
    (kbd "<right>") 'image-forward-hscroll
    (kbd "<up>")    'image-scroll-down
    (kbd "<down>")  'image-scroll-up)

  (spacemacs/set-leader-keys-for-major-mode 'image-dired-display-image-mode
    "h" 'image-bol ; far left   edge
    "j" 'image-eob ; far bottom edge
    "k" 'image-bob ; far top    edge
    "l" 'image-eol ; far right  edge
    "g" 'image-dired-jump-thumbnail-buffer))
#+end_src
** evil
#+begin_src emacs-lisp :tangle yes
  (use-package evil
    :config
    (setq evil-search-module 'evil-search)

    (evil-define-key 'normal map
      "gj" 'evil-next-visual-line
      "gk" 'evil-prev-visual-line

      ;; (kbd "<S-down>") #'(lambda (interactive) (message "Shift Down"))
      ;; (kbd "<S-up>")   #'(lambda (interactive) (message "Shift Up"))

      (kbd "C->") 'evil-shift-right-line
      (kbd "C-<") 'evil-shift-left-line

      ;; fold maneuvering
      "zn" 'evil-vimish-fold/next-fold
      "zN" 'evil-vimish-fold/previous-fold)

    ;; for some reason 'insert map doesn't work
    (evil-define-key nil evil-insert-state-map
      (kbd "C-y")   'yank
      (kbd "M-y")   'evil-copy-from-above
      (kbd "C-k")   'evil-join-backwards
      (kbd "C-M-k") 'evil-join-backwards
      (kbd "C-$")   (lambda () (interactive) (evil-end-of-line) (unless (line-empty-p) (forward-char)))
      (kbd "C-Â£")   'evil-beginning-of-line
      (kbd "C-M-y") 'helm-show-kill-ring
      (kbd "C-e")   'evil-copy-from-above
      (kbd "M-e")   'evil-copy-from-below
      (kbd "M-k")   nil ; erase
      ;; (kbd "C-M-k") 'evil-insert-digraph
      (kbd "C-l")   'forward-char
      (kbd "C-h")   'backward-char
      (kbd "C-n")   'evil-next-line
      (kbd "C-p")   'evil-previous-line
      (kbd "C-i")   'spacemacs/auto-yasnippet-expand
      (kbd "C-M-i") 'spacemacs/helm-yas
      (kbd "TAB")   nil ;; ANNOYING

      (kbd "C-<up>")   'drag-stuff-up
      (kbd "C-<down>") 'drag-stuff-down

      ;; (kbd "<C-return>") 'custom-insert-line-below ; reverse return
      ;; WARN overshadowed by yasnippet

      ;; allow reindenting during insertion
      (kbd "C-d") nil ; erase
      (kbd "C-t") nil ; erase
      (kbd "C-<") 'evil-shift-left-line
      (kbd "C->") 'evil-shift-right-line)

    (evil-define-key 'normal map
      (kbd "C-M-y") 'helm-show-kill-ring)

    :bind* (("<f12>" . evil-motion-state)
            :map evil-motion-state-map
            ;;; erase useless bindings
            ("C-w b"   . nil)
            ("C-w c"   . nil)
            ("C-w p"   . nil)
            ("C-w q"   . nil)
            ("C-w t"   . nil)
            ("C-w w"   . nil)
            ("C-w W"   . nil)
            ("C-w |"   . nil)
            ("C-w C-_" . nil)
            ("-" . negative-argument)
            ;;;  these aren't configured the same as they would be in vim
            ("C-w H"     . buf-move-left)
            ("C-w J"     . buf-move-down)
            ("C-w K"     . buf-move-up)
            ("C-w L"     . buf-move-right)
            ;;; keep the control key please, gives that emacs magic
            ("C-w C-h" . evil-window-left)
            ("C-w C-j" . evil-window-bottom)
            ("C-w C-k" . evil-window-top)
            ("C-w C-l" . evil-window-right)
            ;;; add alternative bindings for overwritten bindings
            ("C-w C-M-h" . evil-window-move-far-left)
            ("C-w C-M-j" . evil-window-move-very-bottom)
            ("C-w C-M-k" . evil-window-move-very-top)
            ("C-w C-M-l" . evil-window-move-far-right)
            ;;; misc
            ("C-w ." . spacemacs/window-manipulation-transient-state/body)
            ;;; line transposition bindings such as in vscode
            ("C-<up>"   . drag-stuff-up)
            ("C-<down>" . drag-stuff-down)
            ;;; allow cycling buffers using <ctrl>-<tab> & <ctrl-shift-tab>
            ("C-<tab>"         . evil-next-buffer)
            ("C-S-<tab>"       . evil-prev-buffer)
            ("C-<iso-lefttab>" . evil-prev-buffer) ; for arch linux
            ;;; move & manipulate open windows in current frame
            ("C-w d" . evil-window-delete)
            ("C-w n" . evil-window-next)
            ("C-w N" . evil-window-prev)
            ("C-w s" . evil-window-split)
            ("C-w S" . split-window-below-and-focus)
            ("C-w v" . evil-window-vsplit)
            ("C-w V" . split-window-right-and-focus)
            ("C-w C-d" . evil-window-delete)
            ("C-w C-s" . split-window-below-and-focus)
            ("C-w C-v" . split-window-right-and-focus)
            ("C-w M-s" . split-window-below-and-focus)
            ("C-w M-v" . split-window-right-and-focus)
            ;;; auto highlight mode
            ("M-n" . ahs-forward)
            ("M-N" . ahs-backward)

            :map evil-window-map
            ;;; erase
            ("C-S-h" . nil)
            ("C-S-j" . nil)
            ("C-S-k" . nil)
            ("C-S-l" . nil)

            :map evil-ex-completion-map
            ;;; move to start
            ("C-a" . move-beginning-of-line)

            :map evil-normal-state-map
            ;;; incrementing is essential
            ("C-S-a" . evil-numbers/inc-at-pt)
            ("C-S-x" . evil-numbers/dec-at-pt)

            :map evil-normal-state-map
            ;;; command repitition
            ("C-." . repeat)))
#+end_src

*** ex commands
#+begin_src emacs-lisp :tangle yes
(evil-ex-define-cmd "W[RITE]" 'evil-write)
(evil-ex-define-cmd "Wa[LL]"  'evil-write-all)
(evil-ex-define-cmd "WA[LL]"  'evil-write-all)
;; (evil-ex-define-cmd "noh[lsearch]" 'evil-search-clear-highlight)
#+end_src
*** evil-matchit
provides better support for jumping to matching pairs (include speech marks).

#+begin_src emacs-lisp :tangle yes
  (use-package evil-matchit
    :config
    (global-evil-matchit-mode 1))
#+end_src
*** evil-surround
#+begin_src emacs-lisp :tangle yes
  (use-package evil-surround
    :config
    (setq-default evil-surround-pairs-alist
                  '((?\( . ("(" . ")"))
                    (?\[ . ("[" . "]"))
                    (?\{ . ("{" . "}"))

                    (?\) . ("(" . ")")) ; alias above
                    (?\] . ("[" . "]")) ; alias above
                    (?\} . ("{" . "}")) ; alias above

                    (?# . ("#{" . "}")) ; ruby string interpolation
                    (?b . ("(" . ")"))
                    (?B . ("{" . "}"))
                    (?> . ("<" . ">"))
                    (?t . evil-surround-read-tag)
                    (?< . evil-surround-read-tag)
                    (?f . evil-surround-function))))
#+end_src
*** evil-vimish-fold
#+begin_src emacs-lisp :tangle yes
  (use-package evil-vimish-fold
    :config
    (evil-vimish-fold-mode 1))
#+end_src
*** vi-tilde-fringe
#+begin_src emacs-lisp :tangle yes
  (use-package vi-tilde-fringe
    :config
    ;;; Enable vi like ~ on empty lines
    (global-vi-tilde-fringe-mode t))
#+end_src
** flycheck
#+begin_src emacs-lisp :tangle yes
(use-package flycheck
  :init
  (setq flycheck-python-pycompile-executable "python3")
  :config
  (global-flycheck-mode)
  (evil-define-key 'normal flycheck-mode-map
    "gn"    'flycheck-next-error
    "gN"    'flycheck-previous-error)
  (spacemacs/set-leader-keys
    "o C-l" 'flycheck-list-errors))
#+end_src
** helm
#+begin_src emacs-lisp :tangle yes
(use-package helm
  :bind* (:map helm-map
          ;;; movement bindings in normal mode
          ("<left>"  . evil-backward-char)
          ("<right>" . evil-forward-char)
          ;; "C-d" 'helm-buffer-run-kill-buffers
          ("C-M-k" . kill-sentence)
          ("M-k"   . backward-kill-sentence)
          ("M-j"   . ace-jump-helm-line) ; Alternative = C-q
          ("C-d"   . helm-next-page)
          ("C-u"   . helm-previous-page)
          ;; NOTE C-w reads a word in from buffer at point
          ("M-("   . helm-prev-visible-mark)
          ("M-)"   . helm-next-visible-mark)

          :map helm--minor-mode-map
          ("<C-backspace>" . backward-kill-word)

          :map helm-find-files-map
          ("<C-backspace>" . nil)

          :map helm-buffer-map
          ("M-d" . helm-buffer-run-kill-buffers)
          ("M-D" . nil) ;; override existing
          ("M-s" . helm-buffer-save-persistent) ; save but don't kill helm
          ("C-." . helm-buffers-toggle-show-hidden-buffers)))
#+end_src
** isearch
#+begin_src emacs-lisp :tangle yes
(use-package isearch
  ;; TODO look into more bindings
  :bind (:map isearch-mode-map
         ("DEL" . isearch-delete-char)))

#+end_src
** languages
*** c
#+begin_src emacs-lisp :tangle yes
(use-package cc-mode
  :bind* (:map c-mode-map
          ("M-j"   . nil)
          ("C-M-h" . nil)))
#+end_src
*** shell-script
#+begin_src emacs-lisp :tangle yes
(use-package sh-script
  :config
  (spacemacs/set-leader-keys-for-major-mode 'sh-mode
    (kbd "TAB") 'sh-if
    "(" 'sh-function
    "+" 'sh-add
    ":" 'sh-set-shell
    "<" 'sh-learn-line-indent
    ">" 'sh-learn-buffer-indent
    "=" 'sh-set-indent
    "?" 'sh-show-indent

    (kbd "C-\\") 'sh-backslash-region
    (kbd "C-c") 'sh-case
    (kbd "C-d") 'sh-cd-here
    (kbd "C-f") 'sh-for
    (kbd "C-l") 'sh-indexed-loop
    (kbd "C-n") 'sh-send-line-or-region-and-step
    (kbd "C-o") 'sh-while-getopts
    (kbd "C-r") 'sh-repeat
    (kbd "C-s") 'sh-select
    (kbd "C-t") 'sh-temp-file
    (kbd "C-u") 'sh-until
    (kbd "C-x") 'executable-interpret
    (kbd "C-z") 'sh-show-shell))
#+end_src
*** markdown
#+begin_src emacs-lisp :tangle yes
  (use-package markdown
    :config
    (evil-define-key 'normal markdown-mode-map
      "gj" nil ; outline-forward-same-level
      "gk" nil ; outline-backward-same-level
      )
    :bind (:map markdown-mode-map
           ("M-n" . nil)
           ("M-N" . nil)
           ("M-j" . nil)
           ("M-k" . nil)
           ("C-<up>"   . markdown-move-up)
           ("C-<down>" . markdown-move-down)
           ("C-<left>" . markdown-promote)
           ("C-<right>" . markdown-demote)))
#+end_src
** magit
#+begin_src emacs-lisp :tangle yes
(use-package magit
  :bind* (:map magit-mode-map
          ("p" . evil-search-previous)
          ("n" . evil-search-next)
          ("P" . magit-push)
          ;; "C-j" magit-section-forward-sibling
          ;; "C-k" magit-section-backward-sibling
          ("M-j" . magit-section-forward-sibling)
          ("M-k" . magit-section-backward-sibling)
          ;; toggle children doesn't seem to work
          ("C-r" . magit-section-hide-children) ; recursive close
          ("C-e" . magit-section-show-children) ; recursive expand
          ("M-r" . magit-section-hide-children) ; Meta aliases
          ("M-e" . magit-section-show-children) ; Meta aliases
          ;; visit and expand
          ("RET"   . magit-section-toggle)
          ("TAB"   . magit-section-toggle)
          ("M-RET" . magit-visit-thing)

          :map magit-log-mode-map
          ("RET" . magit-visit-thing)))
#+end_src
** org
# TODO take loaded languages out of code block
#+begin_src emacs-lisp :tangle yes
(use-package org
  :config
  (setq org-todo-keywords
        '((sequence "TODO" "DOING" "VERIFY" "|" "DONE" "DELAGATED" "SKIPPED")))
  (setq org-src-window-setup 'current-window)

  (add-hook 'org-capture-mode-hook (lambda () (evil-append nil)) t)

  (let ((org-root (concat mohkale-root "/org/")))
    (setq org-default-notes-file (concat org-root "notes.org"))
    (setq org-agenda-files (file-expand-wildcards (concat org-root "*.org")))

    (setq org-capture-templates
          `(("f" "File Task" entry (file ,org-default-notes-file)
             "* TODO %?\n  %a"
             :kill-buffer t)
            ("t" "Todo" entry (file ,org-default-notes-file)
             "* TODO %?\n%U")
            ("T" "Todo with Clipboard" entry (file ,org-default-notes-file)
             "* TODO %?\n%U\n   %c")
            ("h" "Homework" entry (file+headline ,(concat org-root "university.org") "Homework")
             "* TODO%? %^g\n  DEADLINE: %^{Deadline}t\n  :LOGBOOK:\n  - Added %u\n  :END:"
             :kill-buffer t))))

  (spacemacs/declare-prefix "oo" "org" "org mode bindings")

  (spacemacs/set-leader-keys
    ;; "oo" 'mohkale-find-capture-notes-file
    "oO"  'org-capture
    "oon" 'mohkale-find-capture-notes-file
    "oou" 'mohkale-find-org-university-file
    "ooa" 'org-agenda
    "ooy" 'org-copy-subtree
    "ooc" 'org-cut-subtree)

  (spacemacs/set-leader-keys-for-major-mode 'org-mode "c" nil)
  (spacemacs/declare-prefix-for-mode 'org-mode "mc" "clock/calendar")

  (org-babel-do-load-languages
   'org-babel-load-languages
   '((emacs-lisp . t)
     (awk . t)
     (C . t)
     (awk . t)
     (java . t)
     (js . t)
     (python . t)
     (ruby . t)
     (sed . t)
     (shell . t)
     (R . t)))

  ;;; major mode dependent leader keys
  (spacemacs/set-leader-keys-for-major-mode 'org-mode
    "R"     nil
    "M-p"   'org-delete-property
    ":"     'org-set-tags-command ; name mispelt in actual binding
    "M-c"   'org-columns
    "M-a"   'org-attach
    "C"     'org-capture
    "r"     'org-refile
    "u"     'org-dblock-update
    "U"     'org-update-all-dblocks
    "n"     'org-add-note
    "N"     nil
    "eh"    'org-html-export-to-html
    "c>"    'org-goto-calendar
    "c<"    'org-date-from-calendar
    "cc"    'org-clock-in
    "cC"    'org-clock-out
    "cs"    'org-clock-display
    "ch"    'org-clock-remove-overlays
    "cg"    'org-clock-goto
    "cr"    'org-clock-report
    "cf"    'org-clock-modify-effort-estimate
    "ci"    'org-timer-item ; insert descriptive li with timer
    "c C-c" 'org-clock-cancel)

  (evil-define-key '(normal insert) org-mode-map
    (kbd "C-<return>")   (lambda nil (interactive) (evil-org-eol-call (lambda nil (org-insert-heading nil))))
    (kbd "C-S-<return>") (lambda nil (interactive) (evil-org-eol-call (lambda nil (org-insert-todo-heading nil))))
    (kbd "C-.") 'org-toggle-heading
    (kbd "C->") 'org-demote-subtree
    (kbd "C-<") 'org-promote-subtree)

  (evil-define-key 'normal org-mode-map
    (kbd "C-j") 'org-metadown
    (kbd "C-k") 'org-metaup)

  (evil-define-key '(insert normal) evil-org-mode-map
    (kbd "M-j") nil
    (kbd "M-k") nil)

  :bind* (:map org-mode-map
          ;; "C-M-<return>" org-meta-return)
          ("C-s" . org-sort)
          ("M-S-<return>" . nil)))
#+end_src
*** org-agenda
#+begin_src emacs-lisp :tangle yes
(use-package org-agenda
  :config
  (evil-set-initial-state 'org-agenda-mode 'normal)

  (spacemacs/set-leader-keys-for-major-mode 'org-agenda-mode "p" nil) ; reused as prefix

  ;; TOOO simplify
  (spacemacs/declare-prefix-for-mode 'org-agenda-mode "mc" "clock/calendar" "time management based prefix keys")
  (spacemacs/declare-prefix-for-mode 'org-agenda-mode "mm" "modes" "minor modes to support agenda mode")
  (spacemacs/declare-prefix-for-mode 'org-agenda-mode "mp" "priority" "alter/view an entries priority")
  (spacemacs/declare-prefix-for-mode 'org-agenda-mode "m/" "search/filter" "search / filter org agenda")

  (spacemacs/set-leader-keys-for-major-mode 'org-agenda-mode
    "A" 'org-agenda-append-agenda
    "C" 'org-agenda-columns

    ;;; filter/search
    "/c" 'org-agenda-filter-by-category
    "/e" 'org-agenda-filter-by-effort
    "//" 'org-agenda-filter-by-regexp
    ;; "/t" 'org-agenda-filter-by-tag
    "/:" 'org-agenda-filter-by-tag
    "/h" 'org-agenda-filter-by-top-headline
    "/R" 'org-agenda-filter-remove-all

    "/?" 'org-agenda-bulk-mark-regexp
    "/a" 'org-agenda-bulk-mark-all
    "/u" 'org-agenda-bulk-unmark-all

    ;;; clock/calendar/diary
    "cp" 'org-agenda-date-prompt
    "cc" 'org-agenda-clock-in
    "co" 'org-agenda-clock-out
    "cC" 'org-agenda-clock-out ; alias
    "ct" 'org-timer-set-timer
    "c M-c" 'org-agenda-convert-date

    ;;; agenda minor modes
    "ma" 'org-agenda-archives-mode
    "md" 'org-agenda-day-view
    "mc" 'org-agenda-clockreport-mode
    "mt" 'org-agenda-entry-text-mode
    "mf" 'org-agenda-follow-mode
    "ml" 'org-agenda-log-mode
    "mw" 'org-agenda-week-view
    "my" 'org-agenda-year-view
    "mm" 'org-agenda-month-view

    ;;; priorities
    "pp" 'org-agenda-priority
    "pu" 'org-agenda-priority-up
    "pd" 'org-agenda-priority-down)

  (evil-define-key 'normal org-agenda-mode-map
    ;;; globally useful
    "q" 'org-agenda-exit
    "." 'org-agenda-goto-today
    "v" 'org-agenda-view-mode-dispatch
    (kbd "RET") 'org-agenda-goto
    (kbd "TAB") 'org-agenda-switch-to
    (kbd "M-c") 'org-agenda-clock-goto ; jumped to clocking task
    (kbd "C-t") 'org-agenda-todo
    (kbd "M-t") 'org-agenda-show-tags

    ;;; marking
    (kbd "C-<SPC>") 'org-agenda-bulk-mark
    (kbd "M-<SPC>") 'org-agenda-bulk-unmark
    (kbd "C-M-SPC") 'org-agenda-bulk-action

    ;;; undo/redo
    (kbd "C-r") 'org-agenda-redo
    (kbd "u")   'org-agenda-undo
    "gr"        'org-agenda-redo-all

    ;;; toggle displays
    "gm" 'org-agenda-phases-of-moon
    (kbd "C-l") 'org-agenda-log-mode
    (kbd "M-l") 'org-agenda-toggle-time-grid
    (kbd "M-h") 'org-agenda-holidays
    (kbd "M-s") 'org-agenda-sunrise-sunset

    ;; edit org items
    (kbd "M-e") 'org-agenda-set-effort
    (kbd "C-a") 'org-agenda-archive-default-with-confirmation

    ;;; notes and insertion
    "a"  'org-agenda-add-note
    "c"  'org-agenda-capture
    "gd" 'org-agenda-goto-date
    "gc" 'org-agenda-goto-calendar

    ;;; movement between lines
    ;;; NOTE org-next/prev-line is used by follow-mode
    "k"            'org-agenda-previous-line
    "j"            'org-agenda-next-line
    (kbd "<up>")   'org-agenda-previous-line ; alias
    (kbd "<down>") 'org-agenda-next-line     ; alias
    (kbd "C-j")    'org-agenda-next-item
    (kbd "C-k")    'org-agenda-previous-item

    ;;; move through time in blocks
    "f" 'org-agenda-later
    "F" 'org-agenda-earlier

    (kbd "C-f") 'org-agenda-follow-mode
    (kbd "M-f") 'org-agenda-recenter))
#+end_src
** parentheses
*** smartparens
#+begin_src emacs-lisp :tangle yes
  (use-package smartparens-config
    :config
    (smartparens-global-mode t))
#+end_src
*** paren
auto highlight matching parentheses

#+begin_src emacs-lisp :tangle yes
  (use-package paren
    :init
    (setq sp-highlight-pair-overlay nil)
    :config
    (show-paren-mode 1))
#+end_src
** proced
#+begin_src emacs-lisp :tangle yes
(use-package proced
  :config
  (evil-set-initial-state 'proced-mode 'normal)

  (evil-define-key 'normal proced-mode-map
    "q" 'quit-window
    (kbd "C-?") 'proced-help

    (kbd "<C-SPC>") 'proced-mark
    "a" 'proced-mark
    "A" 'proced-mark-all
    "u" 'proced-unmark
    "U" 'proced-unmark-all
    "p" 'proced-mark-parents
    "P" 'proced-mark-children
    "M" 'proced-toggle-marks
    (kbd "<DEL>") 'proced-unmark-backward

    "x" 'proced-send-signal
    (kbd "C-k") 'proced-send-signal

    (kbd "<M-SPC>") 'proced-toggle-tree
    "gr" 'revert-buffer

    "r" 'proced-refine
    "R" 'proced-renice

    "o" 'proced-omit-processes

    (kbd "<C-M-SPC>") 'proced-format-interactive

    "sS" 'proced-sort-interactive
    "sc" 'proced-sort-pcpu
    "sm" 'proced-sort-pmem
    "sp" 'proced-sort-pid
    "ss" 'proced-sort-start
    "st" 'proced-sort-time
    "su" 'proced-sort-user
    "S"  'proced-filter-interactive))
#+end_src
** projectile
#+begin_src emacs-lisp :tangle yes
  (use-package projectile
    :config
    (projectile-register-project-type 'rake '("rakefile")
                                      :compile "rake build"
                                      :test    "rake test"
                                      :run     "rake run"
                                      :test-suffix ".spec")
    (setq projectile-project-search-path '("~/programming/projects/"
                                           "~/programming/repos"
                                           "~/programming/"))
    ;; (setq dotspacemacs-search-tools `("rg" "ag" "pt" "ack" "grep"))
    (unless (eq system-type 'gnu/linux)
      (setq projectile-generic-command "find . -type f -print0")))
#+end_src
** simple
#+begin_src emacs-lisp :tangle yes
  (use-package simple
    :config

    (dolist (map `(,messages-buffer-mode-map
                   ,special-mode-map
                   ,message-mode-map))
      (evil-define-key* 'normal map "q" 'quit-window)))
#+end_src
** spacemacs
globally assigned spacemacs dependent configuration.

#+begin_src emacs-lisp :tangle yes
  (spacemacs/declare-prefix "o" "custom" "custom functions")
  (spacemacs/declare-prefix "of" "format" "format document")
  (spacemacs/declare-prefix "oe" "emacs" "emacs related")
  (spacemacs/declare-prefix "od" "diff" "diff and merge")
  (spacemacs/declare-prefix "ow" "window" "window based")
  (spacemacs/declare-prefix "ot" "text" "text attributes")
  (spacemacs/declare-prefix "M" "modes" "mode shortcuts")
  (spacemacs/declare-prefix "Md" "dired" "dired editable mode")
  (spacemacs/declare-prefix "M-t" "timers" "org mode timer control")

  (spacemacs/set-leader-keys
    ;;; Globally Useful
    "." 'repeat
    "-" 'line-width
    "fF"  'find-file-at-point
    "o C-M-k" 'kill-all-windows-and-return-to-home
    "wT" 'force-set-all-visible-windows-dedication
    "otp" 'describe-text-properties
    "otf" 'list-faces
    "&" 'async-shell-command

    ;;; Buffer Manipulation
    "bm" 'buffer-menu
    "bM" 'goto-messages-buffer
    "b M-k" 'spacemacs/kill-other-buffers
    "bk" 'kill-this-buffer-and-window-maybe
    "bK" 'kill-this-buffer ; keeps window open

    ;;; processes
    "ac" 'calendar
    "af" 'list-faces-display
    "ae" 'package-list-packages
    "am" 'man
    "aM" 'helm-man-woman
    "at" 'helm-top
    "aC" 'calc-dispatch
    "a M-c" 'customize

    ;;; files
    "fi" 'helm-semantic-or-imenu
    "fI" 'imenu-list
    "f M-f" 'find-name-dired
    "f M-r" 'revert-buffer

    ;;; Buffer
    ;; jumping
    "jb" 'frog-jump-buffer
    "bj" 'frog-jump-buffer ; alias
    ;; Restore Jb Binding Replaced Above
    "jB" 'avy-pop-mark
    ;; perspectives
    "ba" 'persp-add-current-buffer
    "bA" 'persp-add-buffer
    "br" 'persp-remove-current-buffer
    "bR" 'persp-remove-buffer
    "bS" 'helm-regexp

    ;;; Text Formatting Shortcuts
    "oft" 'remove-all-trailing-whitespace
    "ofC" 'capitalize-region
    "ofu" 'upcase-region
    "ofd" 'downcase-region
    "ofc" 'toggle-comment-at-point
    "ofp" 'pad-line-with-space-to-length
    "ofP" 'pad-line-with-char-to-length
    ;; Remove Existing Unused Bindings
    "xu" nil ; was upcase-region
    "xU" nil ; was downcase-region
    ;; diff and working with files edited outside of emacs
    "odf" 'ediff-current-file
    "odF" 'diff-buffer-with-file
    "odb" 'ediff-buffers
    "odw" 'ediff-windows
    "odv" 'vc-ediff
    "odV" 'vc-diff

    ;;; Emacs Related
    "oef" 'make-frame
    "oeF" 'delete-frame

    ;;; magit
    "gm" 'magit-dispatch
    "g!" 'magit-run

    ;;; projectile
    "pp" 'projectile-run-project
    "pP" 'helm-projectile-switch-project
    "pt" 'projectile-test-project
    "pT" 'neotree-find-project-root
    "p/" 'spacemacs/helm-project-smart-do-search

    ;;; timers
    "M-t s" 'org-timer-start
    "M-t e" 'org-timer-stop
    "M-t c" 'org-timer-set-timer
    "M-t t" 'org-timer-pause-or-continue
    "M-t i" 'org-timer

    ;;; Mode Shortcuts
    "Mz" 'zone ; not really a mode
    "Ml" 'emacs-lisp-mode
    "Mc" 'c++-mode
    "MC" 'c-mode
    "Mf" 'fundamental-mode
    "Mp" 'python-mode
    "Mr" 'ruby-mode
    "Ms" 'shell-script-mode
    "Mw" 'whitespace-mode
    "Mo" 'org-mode
    "Mi" 'imenu
    "Mh" 'hexl-mode
    "MI" 'imenu-list
    "M M-d" 'decipher
    "M M-r" 'toggle-rot13-mode
    ;; qverq
    "Mdd" 'toggle-editable-dired
    "Mde" 'invoke-editable-dired
    "Md <escape>" 'wdired-abort-changes
    "Mdq" 'wdired-abort-changes ; alias
    )
#+end_src
** tags
#+begin_src emacs-lisp :tangle yes
  (use-package ctags-update
    :config
    (ctags-global-auto-update-mode)
    (setq tags-revert-without-query 1)

    ; you need manually create TAGS in your project
    (setq ctags-update-prompt-create-tags nil))
#+end_src
** transient
#+begin_src emacs-lisp :tangle yes
(use-package transient
  :bind* (:map transient-base-map
          ;;; Escape means quit too you know
          ("ESC" . transient-quit-one)))
#+end_src
** version-control
#+begin_src emacs-lisp :tangle yes
(use-package vc
  :config
  (require 'vc-git)
  ;;; include vc leader key in defaults leader keys
  (spacemacs/declare-prefix "V" "version control")
  (spacemacs/set-leader-keys "V" vc-prefix-map)
  (define-key vc-prefix-map (kbd "C-=") 'vc-ediff)
  (define-key vc-prefix-map "r" 'vc-rename-file)
  (define-key vc-prefix-map "R" 'vc-retrieve-tag)

  ;;; diff files
  ;; (evil-define-key 'normal diff-mode-map
  ;;   (kbd "C-q") 'quit-window)

  ;;; annotations
  (evil-set-initial-state 'vc-annotate-mode 'normal)
  (evil-define-key 'normal vc-annotate-mode-map
    "gr" 'revert-buffer
    "d" 'vc-annotate-show-diff-revision-at-line
    "D" 'vc-annotate-show-changeset-diff-revision-at-line
    "t" 'vc-annotate-toggle-annotation-visibility

    (kbd "C-j") 'vc-annotate-next-revision ;; older revisions
    (kbd "C-k") 'vc-annotate-prev-revision ;; newer revisions
    )
  (spacemacs/set-leader-keys-for-major-mode 'vc-annotate-mode
    ;;; unbound functions
    ;; vc-dir-query-replace-regexp
    ;; vc-dir-search
    ;; vc-dir-isearch
    ;; vc-dir-isearch-regexp
    "m" 'vc-next-action
    "l" 'vc-annotate-show-log-revision-at-line
    "d" 'vc-annotate-show-diff-revision-at-line
    "gg"    'vc-annotate-goto-line
    "gc"    'vc-annotate-revision-at-line
    "gp"    'vc-annotate-revision-previous-to-line
    "g SPC" 'vc-annotate-working-revision)

  ;;; vc-directory
  (evil-set-initial-state 'vc-dir-mode 'normal)
  (evil-define-key 'normal vc-dir-mode-map
    ;;; Unbound Functions
    ;; vc-dir-query-replace-regexp
    ;; vc-dir-search
    ;; vc-dir-isearch
    ;; vc-dir-isearch-regexp
    "a" 'vc-register ;; git add FILE
    "d" 'vc-diff
    "i" 'vc-register
    ;; "q" 'vc-dir-kill-dir-status-process
    "i" 'vc-dir-ignore
    "x"  'vc-dir-kill-line
    "gr" 'revert-buffer

    "A" 'vc-dir-mark-all-files
    "m" 'vc-dir-mark
    "U" 'vc-dir-unmark-all-files
    "u" 'vc-dir-unmark
    "t" 'vc-dir-toggle-mark
    (kbd "<backspace>") 'vc-dir-unmark-file-up

    "p" 'vc-pull
    "P" 'vc-push

    "o" 'vc-dir-display-file
    (kbd "RET") 'vc-dir-find-file

    (kbd "C-j") 'vc-dir-next-line
    (kbd "C-k") 'vc-dir-previous-line
    (kbd "M-j") 'vc-dir-next-directory
    (kbd "M-k") 'vc-dir-previous-directory)

  (spacemacs/set-leader-keys-for-major-mode 'vc-dir-mode
    "i" 'vc-log-incoming
    "o" 'vc-log-incoming
    "l" 'vc-print-log
    "L" 'vc-print-root-log
    "D" 'vc-root-diff
    "d" 'vc-diff
    "h" 'vc-dir-hide-up-to-date
    "u" 'vc-update ;; don't understand
    "m" 'vc-next-action)

  ;;; history + log
  ;; despite being different modes and using different maps, theses both incorporate
  ;; basically the same functions to accomplish the same things, so use the same config
  ;; for both of them.
  (dolist (tuple `((vc-git-region-history-mode . ,vc-git-region-history-mode-map)
                   (vc-git-log-view-mode       . ,vc-git-log-view-mode-map)))
    (let ((mode (car tuple))
          (kmap (cdr tuple)))
      (evil-set-initial-state mode 'normal)
      ;; NOTE have to use * or kmap won't be evaluated
      (evil-define-key* 'normal kmap
        ;;; WARN unknown functions
        ;;    * log-view-modify-change-comment
        "q" 'quit-window
        "d" 'log-view-diff
        "o" 'log-view-find-revision ; open current file at current commit

        (kbd "<return>") 'log-view-toggle-entry-display
        (kbd "<tab>")    'log-view-toggle-entry-display

        ;; move to next message, then reallign to top
        ;; (kbd "C-j") #'(lambda () (interactive) (log-view-msg-next)
        ;;                 (call-interactively 'evil-scroll-line-to-top))
        (kbd "C-j") 'log-view-msg-next
        (kbd "C-k") 'log-view-msg-prev

        (kbd "C-M-j") 'log-view-file-next
        (kbd "C-M-k") 'log-view-file-prev

        (kbd "M-j") 'diff-hunk-next
        ;; TODO reallign diff to propper location on move down without trapping on a single diff
        ;; (kbd "M-j") #'(lambda () (interactive) (diff-hunk-next)
        ;;                 (call-interactively 'evil-scroll-line-to-top)
        ;;                 (evil-previous-line 3))
        (kbd "M-k") #'(lambda () (interactive) (diff-hunk-prev) (evil-previous-line 3)))

      (spacemacs/set-leader-keys-for-major-mode mode
        "r" 'revert-buffer
        "p" 'log-view-diff-changeset
        "a" 'log-view-annotate-version
        "m" 'log-view-toggle-mark-entry
        "s" 'diff-goto-source)))

  ;;; making commits... why name it log :P
  (evil-define-key 'normal log-edit-mode-map
    (kbd "C-q")   'log-edit-kill-buffer
    (kbd "C-n")   'log-edit-next-comment
    (kbd "C-p")   'log-edit-previous-comment
    (kbd "C-M-n") 'log-edit-comment-search-forward
    (kbd "C-M-p") 'log-edit-comment-search-backward
    (kbd "M-0")   'evil-beginning-of-line)
  (evil-redirect-digit-argument log-edit-mode-map "0" 'log-edit-beginning-of-line)

  (dolist (mode '(vc-git-log-edit-mode))
    ;; spacemacs doesn't inherit major leader keys so you'll have to
    ;; allocate the same keys for each vc system you use.
    (spacemacs/declare-prefix-for-mode mode "mi" "insert" "insert shortcuts")
    (spacemacs/set-leader-keys-for-major-mode mode
      "d" 'log-edit-show-diff
      "f" 'log-edit-show-files
      "?" 'log-edit-mode-help
      "SPC" 'log-edit-done
      (kbd "DEL") 'log-edit-kill-buffer

      "ic" 'log-edit-insert-changelog
      "if" 'log-edit-insert-filenames
      "iC" 'log-edit-insert-changelog-entries
      "iT" 'log-edit-insert-cvs-rcstemplate
      "it" 'log-edit-insert-cvs-template
      "iF" 'log-edit-insert-filenames-without-changelog
      "im" 'log-edit-insert-message-template))

  ;; then allocate unique bindings for each individual vc system
  (spacemacs/declare-prefix-for-mode 'vc-git-log-edit-mode "mt" "toggle" "toggle commit status")
  (spacemacs/set-leader-keys-for-major-mode 'vc-git-log-edit-mode
    "ta" 'vc-git-log-edit-toggle-amend
    "ts" 'vc-git-log-edit-toggle-signoff))
#+end_src
** vlc-rc
#+begin_src emacs-lisp :tangle yes
(use-package vlc-rc
  :config
  (spacemacs/set-leader-keys "v" vlc-rc-map)
  (spacemacs/declare-prefix "v" "VLC" "VLC Remote Control")
  (evil-define-key 'normal dired-mode-map
    "v" nil)
  (evil-define-key 'normal dired-mode-map
    "vv" 'vlc/dired-add-file
    "vq" 'vlc/dired-enqueue-file))
#+end_src
** yasnippet
#+begin_src emacs-lisp :tangle yes
(use-package yasnippet
  :bind* (:map yas-minor-mode-map
          ("<C-return>" . yas-next-field)))
#+end_src
** ycmd emacs-lisp 
#+begin_src emacs-lisp :tangle yes
  (use-package ycmd
    :init
    (setq custom-ycmd-map (make-sparse-keymap)
          ycmd-global-config nil
          ycmd-server-command `("python3" "-u" ,(expand-file-name "~/.vim/plugged/YouCompleteMe/third_party/ycmd/ycmd")))

    (define-prefix-command 'jump 'custom-ycmd-jump-map "jumpx")

    (spacemacs/declare-prefix "y" "ycmd")
    (spacemacs/declare-prefix "yg" "jump" "ycmd jump")
    (spacemacs/set-leader-keys "y" custom-ycmd-map)

    :config
    (dolist (mode-hook (list 'c++-mode-hook
                             'c-mode-hook
                             'python-mode-hook))
          (add-hook mode-hook 'ycmd-mode))

    :bind (:map custom-ycmd-map
           ("y"   . ycmd-mode)
           ("Y"   . global-ycmd-mode)
           ("n"   . ycmd-open)
           ("k"   . ycmd-close)
           ("v"   . ycmd-version)
           ("b"   . ycmd-parse-buffer)
           ("c"   . ycmd-load-conf-file)
           ("C"   . ycmd-clear-compilation-flag-cache)
           ("s"   . ycmd-show-debug-info)
           ("d"   . ycmd-show-documentation)
           ("l"   . ycmd-toggle-log-enabled)
           ("r"   . ycmd-restart-semantic-server)
           ("t"   . ycmd-get-type)
           ("."   . ycmd-completer) ; helm all ycmd requests
           ("SPC" . ycmd-toggle-force-semantic-completion)
           ("C-r" . ycmd-refactor-rename)
           ("C-c" . ycmd-display-completions)
           :prefix-map custom-ycmd-jump-map
           :prefix "g"
           ("g" . ycmd-goto)
           ("G" . ycmd-goto-imprecise)
           ("t" . ycmd-goto-type)
           ("d" . ycmd-goto-definition)
           ("D" . ycmd-goto-declaration)
           ("r" . ycmd-goto-references)
           ("i" . ycmd-goto-include)
           ("I" . ycmd-goto-implementation)))
#+end_src
